// Copyright (C) 1997-2011 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Description:
//      Create UI components for Maya Fur plugin
//

/////////////////////////////////////////////////////////////////////////////
//
// Debugging procedures
//
/////////////////////////////////////////////////////////////////////////////


//  The contents of the following files are concatented into this file: 
//	 HairPluginCreateUI_header.mel
//        HairPluginCreateUI_attributes.mel
//        HairPluginCreateUI_misc.mel
//        HairPluginCreateUI_project.mel
//        HairPluginCreateUI_attractors.mel
//        HairPluginCreateUI_menu.mel
//        HairPluginCreateUI_artisan.mel
//        HairPluginCreateUI_hairDescAE.mel
//        HairPluginCreateUI_feedbackAE.mel
//        HairPluginCreateUI_attractorAE.mel
//        HairPluginCreateUI_curveAttractorAE.mel
//        HairPluginCreateUI_hairGlobalAE.mel
//        HairPluginCreateUI_lightAE.mel
//        HairPluginCreateUI_render.mel
//        HairPluginCreateUI_light.mel
//        HairPluginCreateUI_preRender.mel
//        HairPluginCreateUI_hotkeys.mel
//        HairPluginCreateUI_main.mel
//        HairPluginCreateUI_test.mel


proc HfDebug( string	$debug )
{
}

proc HfCDebug( string	$debug,
	int		$title,
	int		$cr
)
{
}


proc int isMELDebuggingEnabled()
{
	return false;
}

						   
proc addDebugTag(
	string	$tag
)
{
}


proc HfTDebug(
	string	$tag,
	string	$debug
)
{
}

proc HfTCDebug(
	string	$tag,
	string	$debug,
	int		$title,
	int		$cr
)
{
}

proc checkNode(
	string	$node
)
{
}



// This contains the list of hair attributes contained in the
// hair feedback node
// - HfFeedbackAttributeType is the typical source for feedback
//   attribute
//   - 0 is hair description node
//   - 1 is attractor set node
//
global string	$HfFeedbackAttributes[];
global int		$HfFeedbackAttributeSource[];

clear( $HfFeedbackAttributes );
clear( $HfFeedbackAttributeSource );

// special map file name indicating that the attribute is mapped but
// hasn't been saved out to a file yet
//
//#define UNNAMED_MAP_FILE	"UNNAMED"

proc addFeedbackAttr(
	string	$attr,
	int		$source
)
{
	global string	$HfFeedbackAttributes[];
	global int		$HfFeedbackAttributeSource[];

	$HfFeedbackAttributes[size($HfFeedbackAttributes)] = $attr;
	$HfFeedbackAttributeSource[size($HfFeedbackAttributeSource)] = $source;
}

// these are lists dealing with all the paintable attributes
//
global string	$HfHairPaintAttr[];			// base names for attributes
global string	$HfHairPaintAttrUiName[];	// names as they appear in UI
global string	$HfHairPaintDirAttr[];		// base names for direction attributes

clear( $HfHairPaintAttr );
clear( $HfHairPaintAttrUiName );
clear( $HfHairPaintDirAttr );

proc addPaintableAttr(
	string	$uiName,
	string	$baseAttrName,
	string	$baseDirAttrName
)
{
	global string	$HfHairPaintAttrUiName[];
	global string	$HfHairPaintAttr[];
	global string	$HfHairPaintDirAttr[];

	$HfHairPaintAttrUiName[size($HfHairPaintAttrUiName)] = $uiName;
	$HfHairPaintAttr[size($HfHairPaintAttr)] = $baseAttrName;
	$HfHairPaintDirAttr[size($HfHairPaintDirAttr)] = $baseDirAttrName;
}

// this is a special paintable attribute
//
addPaintableAttr( (uiRes("m_FurPluginCreateUI.kDirection")), "", "Polar" );

// This contains a list of all hair attributes shown in attribute editor
//
global string $HfHairAttributes[];
global string $HfHairAttrUiNames[];

clear( $HfHairAttributes );
clear( $HfHairAttrUiNames );

proc addHairAttr(
	string	$attrUiName,
	string	$attr,
	int		$feedback,
	int		$paintable
)
{
	global string	$HfHairAttributes[];
	global string	$HfHairAttrUiNames[];

	$HfHairAttributes[size($HfHairAttributes)] = $attr;
	$HfHairAttrUiNames[size($HfHairAttrUiNames)] = $attrUiName;

	if ( $feedback ) {
		addFeedbackAttr( $attr, 0 );
	}
	if ( $paintable ) {
		addPaintableAttr( $attrUiName, $attr, "" );
	}
}

// This contains a list of all attractor set attributes shown in attribute editor
//
global string $HfAttractorAttributes[];
global string $HfAttractorAttrUiNames[];
global string $HfCurveAttractorAttributes[];
global string $HfCurveAttractorAttrUiNames[];


clear( $HfAttractorAttributes );
clear( $HfAttractorAttrUiNames );
clear( $HfCurveAttractorAttributes );
clear( $HfCurveAttractorAttrUiNames );

proc addAttractorAttr(
	string	$attrUiName,
	string	$attr,
	int		$feedback,
	int		$paintable
)
{
	global string	$HfAttractorAttributes[];
	global string	$HfAttractorAttrUiNames[];

	$HfAttractorAttributes[size($HfAttractorAttributes)] = $attr;
	$HfAttractorAttrUiNames[size($HfAttractorAttrUiNames)] = $attrUiName;

	if ( $feedback ) {
		addFeedbackAttr( $attr, 1 );
	}
	if ( $paintable ) {
		addPaintableAttr( ("Attractor " + $attrUiName), $attr, "" );
	}
}

proc addCurveAttractorAttr(
	string	$attrUiName,
	string	$attr,
	int		$feedback,
	int		$paintable
)
{
	global string	$HfCurveAttractorAttributes[];
	global string	$HfCurveAttractorAttrUiNames[];

	$HfCurveAttractorAttributes[size($HfCurveAttractorAttributes)] = $attr;
	$HfCurveAttractorAttrUiNames[size($HfCurveAttractorAttrUiNames)] = $attrUiName;
	
	if ( $feedback ) {
		addFeedbackAttr( $attr, 2 );
	}
	if ( $paintable ) {
		addPaintableAttr( ($attrUiName), $attr, "" );
	}
}

// add all attributes and indicate whether they are in feedback nodes and/or paintable
//
addHairAttr( (uiRes("m_FurPluginCreateUI.kBaseColor")) , "BaseColor",true,false);
addHairAttr( (uiRes("m_FurPluginCreateUI.kTipColor")) , "TipColor",true,false);
addHairAttr( (uiRes("m_FurPluginCreateUI.kBaseAmbientColor")) , "BaseAmbientColor",true,false);
addHairAttr( (uiRes("m_FurPluginCreateUI.kTipAmbientColor")) , "TipAmbientColor",true,false);
addHairAttr( (uiRes("m_FurPluginCreateUI.kSpecularColor")) , "SpecularColor",true,false);
addHairAttr( (uiRes("m_FurPluginCreateUI.kSpecularSharpness")) , "SpecularSharpness",true,false);
addHairAttr( (uiRes("m_FurPluginCreateUI.kLength")) , "Length",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kBaldness")) , "Baldness",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kInclination")) , "Inclination",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kRoll")) , "Roll",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kPolar")) , "Polar",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kBaseOpacity")) , "BaseOpacity",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kTipOpacity")) , "TipOpacity",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kBaseWidth")) , "BaseWidth",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kTipWidth")) , "TipWidth",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kBaseCurl")) , "BaseCurl",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kTipCurl")), "TipCurl",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kScraggle")), "Scraggle",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kScraggleFrequency")) , "ScraggleFrequency",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kScraggleCorrelation")) , "ScraggleCorrelation",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kClumping")) , "Clumping",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kClumpingFrequency")) , "ClumpingFrequency",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kClumpShape")) , "ClumpShape",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kSegments")), "Segments",true,false);
addHairAttr( (uiRes("m_FurPluginCreateUI.kAttraction")), "Attraction",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kOffset")), "Offset",true,true);
addHairAttr( (uiRes("m_FurPluginCreateUI.kCustomEqualizerOption")), "CustomEqualizer",true,true);

string $radius = (uiRes("m_FurPluginCreateUI.kRadius"));
string $power = (uiRes("m_FurPluginCreateUI.kPower"));
string $influence = (uiRes("m_FurPluginCreateUI.kInfluence"));
string $startLength = (uiRes("m_FurPluginCreateUI.kStartLength"));
string $endLength = (uiRes("m_FurPluginCreateUI.kEndLength"));
string $thresholdLength = (uiRes("m_FurPluginCreateUI.kThresholdLength"));

addAttractorAttr($radius,"Radius",true,false);
addAttractorAttr($power,"Power",true,false);
addAttractorAttr($influence,"Influence",true,false);
addAttractorAttr($startLength,"StartLength",true,false);
addAttractorAttr($endLength,"EndLength",true,false);
addAttractorAttr($thresholdLength,"ThresholdLength",true,false);

addCurveAttractorAttr($radius,"CurveRadius",true,true);
addCurveAttractorAttr($power,"CurvePower",true,true);
addCurveAttractorAttr($influence,"CurveInfluence",true,true);
addCurveAttractorAttr($startLength,"CurveStartLength",true,true);
addCurveAttractorAttr($endLength,"CurveEndLength",true,true);
addCurveAttractorAttr($thresholdLength,"CurveThresholdLength",true,true);

// various procedures used to get various attribute names from the
// standard attribute basenames
//
proc string feedbackDefaultAttr(
	string	$baseAttr
)
{
	return $baseAttr;
}

proc string feedbackHairGlobalScaleAttr()
{
	return "furGlobalScale";
}

proc string feedbackHairGlobalScalePlug(
	string	$node
)
{
	return ($node + ".furGlobalScale");
}

proc string feedbackAttractorGlobalScaleAttr()
{
	return "attractorGlobalScale";
}
proc string feedbackCurveAttractorGlobalScaleAttr()
{
	return "curveAttractorGlobalScale";
}
proc string feedbackAttractorGlobalScalePlug(
	string	$node
)
{
	return ($node + ".attractorGlobalScale");
}
proc string feedbackCurveAttractorGlobalScalePlug(
	string	$node
)
{
	return ($node + ".curveAttractorGlobalScale");
}
proc string feedbackUSamplesAttr()
{
	return "uSamples";
}

proc string feedbackUSamplesPlug(
	string	$node
)
{
	return ($node + ".uSamples");
}

proc string feedbackRealUSamplesPlug(
	string	$node
)
{
	return ($node + ".realUSamples");
}

proc string feedbackVSamplesAttr()
{
	return "vSamples";
}

proc string feedbackVSamplesPlug(
	string	$node
)
{
	return ($node + ".vSamples");
}

proc string feedbackRealVSamplesPlug(
	string	$node
)
{
	return ($node + ".realVSamples");
}

proc string feedbackExportWrapThresholdAttr()
{
	return "exportWrapThreshold";
}

proc string feedbackExportWrapThresholdPlug(
	string $node
)
{
	return ($node + ".exportWrapThreshold");
}
proc string feedbackSamplesAttr(
	string	$baseAttr
)
{
	return ($baseAttr + "Samples");
}

proc string feedbackSamplesDirtyAttr(
	string	$baseAttr
)
{
	return ($baseAttr + "SamplesDirty");
}

proc string feedbackMapDirtyAttr(
	string	$baseAttr
)
{
	return ($baseAttr + "MapDirty");
}

proc string feedbackMapAttr(
	string	$baseAttr
)
{
	return ($baseAttr + "Map");
}

proc string hairDefaultAttr(
	string	$baseAttr
)
{
	return $baseAttr;
}

proc string hairMapsAttr(
	string	$baseAttr
)
{
	return ($baseAttr + "Map");
}

proc string hairMapFileAttr(
	string	$baseAttr
)
{
	return ($baseAttr + "MapFile");
}

proc string baseFromHairMapsAttr(
	string	$hairMapsAttr
)
{
	int		$l = size( $hairMapsAttr );

	if ( $l > 3 ) {
		string	$temp = substring( $hairMapsAttr, $l - 2, $l );

		if ( $temp == "Map" ) {
			$temp = substring( $hairMapsAttr, 1, $l - 3 );
			return $temp;
		} else {
			return "";
		} 
	} else {
		return "";
	}
}

proc string hairMapUSamplesAttr(
	string	$baseAttr
)
{
	return ($baseAttr + "MapUSamples");
}

proc string hairMapVSamplesAttr(
	string	$baseAttr
)
{
	return ($baseAttr + "MapVSamples");
}

proc string hairMapOffsetAttr(
	string	$baseAttr
)
{
	return ($baseAttr + "MapOffset");
}

proc string hairMapMultAttr(
	string	$baseAttr
)
{
	return ($baseAttr + "MapMult");
}

proc string hairNoiseAttr(
	string	$baseAttr
)
{
	return ($baseAttr + "Noise");
}

proc string hairNoiseFreqAttr(
	string	$baseAttr
)
{
	return ($baseAttr + "NoiseFreq");
}

proc string hairGlobalScaleAttr()
{
	return "GlobalScale";
}

proc string hairGlobalScalePlug(
	string	$node
)
{
	return ($node + ".GlobalScale");
}

proc string attractorGlobalScaleAttr()
{
	return "GlobalScale";
}

proc string curveAttractorGlobalScaleAttr()
{
	return "CurveGlobalScale";
}

proc string attractorGlobalScalePlug(
	string	$node
)
{
	return ($node + ".GlobalScale");
}
proc string curveAttractorGlobalScalePlug(
	string	$node
)
{
	return ($node + ".CurveGlobalScale");
}

proc string feedbackNurbsInputSurfacePlug(
	string	$feedback
)
{
	return ($feedback + ".inputSurface");
}

proc string feedbackMeshInputSurfacePlug(
	string	$feedback
)
{
	return ($feedback + ".inputMesh");
}

// Fea 130855 Fur cannot be used on Sub-Ds 
proc string feedbackSubdivInputSurfacePlug(
	string	$feedback
)
{
	return ($feedback + ".inputSubdiv");
}

proc string feedbackInputSurfacePlug(
	string	$feedback
)
{
	// There are two possible input surface plugs: Nurbs & Mesh
	// If Nurbs isn't connected return Mesh
	//
	string	$inputPlug = feedbackNurbsInputSurfacePlug( $feedback );
	string	$surfacePlug = `connectionInfo -sfd $inputPlug`;

	if ( $surfacePlug == "" ) {
		$inputPlug = feedbackMeshInputSurfacePlug( $feedback );
		$surfacePlug = `connectionInfo -sfd $inputPlug`;
	}
	// Fea 130855 Fur cannot be used on Sub-Ds 
	if($surfacePlug == ""){
		$inputPlug = feedbackSubdivInputSurfacePlug( $feedback );	
	}

	return $inputPlug;
}

proc connectShapeToFeedbackInputSurface(
	string	$shape,
	string	$feedback
)
{
	string $srcPlug, $dstPlug;

	if ( `nodeType $shape` == "nurbsSurface" ) {
		$srcPlug = $shape + ".ws";
		$dstPlug = feedbackNurbsInputSurfacePlug( $feedback );
	} else if ( `nodeType $shape` == "mesh" ) {
		$srcPlug = $shape + ".w";
		$dstPlug = feedbackMeshInputSurfacePlug( $feedback );
	} else if( `nodeType $shape` == "subdiv" ) {		// Fea 130855 Fur cannot be used on Sub-Ds 
		$srcPlug = $shape + ".ws";
		$dstPlug = feedbackSubdivInputSurfacePlug( $feedback );
	}else {
		string $warningMsg = (uiRes("m_FurPluginCreateUI.kShapeWarning"));
		warning(`format -s $shape -s $feedback $warningMsg`);
		return;
	}
	connectAttr $srcPlug $dstPlug; 
}

// special attributes added to lights for fur shading purposes
//
//#define AUTOSHADE		0
//#define SHADOWMAP		1
//#define AREALIGHT		2

//#define SHADEATTR_INT	0
//#define SHADEATTR_FLOAT	1
//#define SHADEATTR_BOOL	2

global int		$HfShadeType[];			// type: AUTOSHADE, SHADOWMAP, AREALIGHT
global string	$HfShadeNameL[];		// long names
global string	$HfShadeNameS[];		// short names
global float	$HfShadeDefault[];		// defaults
global float	$HfShadeMin[];			// minimum
global float	$HfShadeMax[];			// maximum
global int		$HfShadeAttrType[];		// attr type: SHADEATTR_INT, ...

clear( $HfShadeType );
clear( $HfShadeNameL );
clear( $HfShadeNameS );
clear( $HfShadeDefault );
clear( $HfShadeMin );
clear( $HfShadeMax );
clear( $HfShadeAttrType );

proc addShadeAttr(
	int		$type,
	int		$attrType,
	string	$attrNameL,
	string	$attrNameS,
	string	$attrNameUI,
	float	$dflt,
	float	$min,
	float	$max
)
{
	global int	  $HfShadeType[];
	global int	  $HfShadeAttrType[];
	global string $HfShadeNameL[];
	global string $HfShadeNameS[];
	global float  $HfShadeDefault[];
	global float  $HfShadeMin[];
	global float  $HfShadeMax[];

	$HfShadeType[size($HfShadeType)] = $type;
	$HfShadeAttrType[size($HfShadeAttrType)] = $attrType;
	$HfShadeNameL[size($HfShadeNameL)] = $attrNameL;
	$HfShadeNameS[size($HfShadeNameS)] = $attrNameS;
	$HfShadeDefault[size($HfShadeDefault)] = $dflt;
	$HfShadeMin[size($HfShadeMin)] = $min;
	$HfShadeMax[size($HfShadeMax)] = $max;
}

proc addAutoShadeAttr(
	string	$attrNameL,
	string	$attrNameS,
	string	$attrNameUI,
	float	$dflt,
	float	$min,
	float	$max
)
{
	addShadeAttr(
		0, 1,
		$attrNameL, $attrNameS, $attrNameUI,
		$dflt, $min, $max
	);
}

proc addShadowMapAttr(
	string	$attrNameL,
	string	$attrNameS,
	string	$attrNameUI,
	float	$dflt,
	float	$min,
	float	$max
)
{
	addShadeAttr(
		1, 1,
		$attrNameL, $attrNameS, $attrNameUI,
		$dflt, $min, $max
	);
}

proc addAreaLightAttr(
	string	$attrNameL,
	int		$attrType,
	string	$attrNameS,
	string	$attrNameUI,
	float	$dflt,
	float	$min,
	float	$max
)
{
	addShadeAttr(
		2, $attrType,
		$attrNameL, $attrNameS, $attrNameUI,
		$dflt, $min, $max
	);
}

addAutoShadeAttr( "furSelfShade",				"hss" ,	"Self Shade",				0.5,	0.0,	1.0 );
addAutoShadeAttr( "furSelfShadeDarkness",		"hsd" ,	"Self Shade Darkness",		1.0,	0.0,	1.0 );
addAutoShadeAttr( "furBackShadeFactor",			"hbf" ,	"Back Shade Factor",		2.0,	0.0,	3.0 );
addAutoShadeAttr( "furBackShadeDarkness",		"hbd" ,	"Back Shade Darkness",		1.0,	0.0,	1.0 );

//addShadowMapAttr( "furShadowCone",				"fsc" ,	"Cone Angle",				0.0,	0.0,	-1.0 );
addShadowMapAttr( "furShadowThreshold",			"fst" ,	"Threshold",				0.0,	0.0,	1.0 );
//addShadowMapAttr( "furShadowLightFilterSz",		"fslf",	"Filter Sz near light",		3.0,	1.0,	-1.0 );
//addShadowMapAttr( "furShadowObjFilterSz",		"fsof",	"Filter Sz near object",	3.0,	1.0,	-1.0 );
//addShadowMapAttr( "furShadowLightDarkness",		"fsld",	"Darkenss near light",		1.0,	0.0,	1.0 );
//addShadowMapAttr( "furShadowObjDarkness",		"fsod",	"Darkness near object",		1.0,	0.0,	1.0 );
//addShadowMapAttr( "furShadowLowHairEpsilon",	"fsle",	"Low Fur Dmap Bias",		0.3,	0.0,	-1.0 );
//addShadowMapAttr( "furShadowHighHairEpsilon",	"fshe",	"High Fur Dmap Bias",		2.0,	0.0,	-1.0 );
//addShadowMapAttr( "furShadowGeomEpsilon",		"fsge",	"Geometry Dmap Bias",		0.5,	0.0,	-1.0 );

//addAreaLightAttr( "furAreaLightSpotSublights",	SHADEATTR_BOOL, "fasp",	"Use Spotlights",	0,		1,	-1 );
addAreaLightAttr( "furAreaLightDensity",		1,"fasd", "Sublight Density",	1,		0,	10 );
//addAreaLightAttr( "furAreaLightAngle",		SHADEATTR_FLOAT,"faan", "Spot Angle",		120,	0,	180);
//addAreaLightAttr( "furAreaFadeAngle",			SHADEATTR_FLOAT,"fafa", "Spot Fade Angle",	20,		0,	180 );

addDebugTag( "shadeAttr" );


proc makeShadeAttr(
	string	$lightShape,
	int		$idx
)
{
	string $tag = "shadeAttr";

	global int	  $HfShadeAttrType[];
	global string $HfShadeNameL[];
	global string $HfShadeNameS[];
	global float  $HfShadeDefault[];
	global float  $HfShadeMin[];
	global float  $HfShadeMax[];

	if ( $idx >= 0 && $idx < size( $HfShadeNameL ) ) {
		if ( !`attributeQuery -ex -node $lightShape $HfShadeNameL[$idx]` ) {
			string	$cmd = "addAttr -at ";

			switch ( $HfShadeAttrType[$idx] )
			{
				case 0:
					$cmd += "short";
					break;
				case 1:
					$cmd += "double";
					break;
				case 2:
					$cmd += "bool";
					break;
			}
			$cmd += " -ln " + $HfShadeNameL[$idx]
				  + " -sn " + $HfShadeNameS[$idx]
				  + " -dv " + $HfShadeDefault[$idx];
			if ( $HfShadeMin[$idx] <= $HfShadeDefault[$idx] ) {
				$cmd += " -min " + $HfShadeMin[$idx];
			}
			if ( $HfShadeMax[$idx] >= $HfShadeDefault[$idx] ) {
				$cmd += " -max " + $HfShadeMax[$idx];
			}
			$cmd += " " + $lightShape;
			HfTDebug($tag,"eval " + $cmd);
			eval $cmd;		   
		}
	}
}

proc makeShadeAttributes(
	string	$lightShape,
	int		$shadeType
)
{
	global int $HfShadeType[];
	
	int		$a;
	int		$na = size( $HfShadeType );

	for ( $a = 0; $a < $na; $a++ ) {
		if ( $HfShadeType[$a] == $shadeType ) {
			makeShadeAttr( $lightShape, $a );
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
//
// General Purpose procedures
//
/////////////////////////////////////////////////////////////////////////////

proc int inBatchMode()
{
	global int		$gHfMayaState;

	return $gHfMayaState != 0;
}

addDebugTag( "doSystem" );

proc string doSystem(
	string	$cmd,
	int		$printResults
)
{
	HfTDebug( "doSystem","running \"" + $cmd + "\"");
	string	$results=`system( $cmd )`;

	if ( $printResults && $results != "" ) {
		print $results;
	}
	return $results;
}

proc string replaceCharacterInString(
	string	$srcStr,
	string	$fromChar,
	string	$toChar
)
{
	string	$parts[];
	int		$nParts = tokenize( $srcStr, $fromChar, $parts );
	int		$p;
	string	$dstStr = "";

	$nParts--;
	for ( $p = 0; $p < $nParts; $p++ ) {
		$dstStr += $parts[$p] + $toChar;
	}
	$dstStr += $parts[$p];

	return $dstStr;
}

proc int isAbsolutePath(
	string	$filename
)
{
	int	$abs = false;

	if (`about -win`) {
		if ( ($filename != "" && `substring $filename 1 1` == "/")
		  || (size($filename) > 1 && `substring $filename 2 2` == ":") ) {
			$abs = true;
		}
	} else {
		if ( $filename != "" && `substring $filename 1 1` == "/" ) {
			$abs = true;
		}
	}

	return $abs;
}

proc string	stripTrailingChars(
	string	$str,
	string	$char
)
{
	string	$newStr = $str;
	int		$newStrSize = size( $newStr );

	while ( $newStrSize > 1 && substring( $newStr, $newStrSize, $newStrSize ) == $char ) {
		$newStr = substring( $newStr, 1, $newStrSize - 1 );
		$newStrSize--;
	}

	return $newStr;
}

proc string getProjectDir(
	string	$ruleType,
	string	$refRule
)
{
	int		$foundRule = false;
	string	$rule;
	string	$dir = "";

	string $listOfRulesCmd = "workspace -q -" + $ruleType;
	string $listOfRules[] = `eval($listOfRulesCmd)`;
	
    for ($rule in $listOfRules) 
	{		
		if( $foundRule )
		{
			$dir = $rule;
			break;
		}
		else if( $rule == $refRule )
		{
			$foundRule = true;
		}
	}

	return stripTrailingChars( $dir, "/" );
}

proc string getTheProjectDir()
{
	string $projectDir = `workspace -q -rd`;

	return stripTrailingChars( $projectDir, "/" );
}

proc string getDirPath(
	string	$ruleType,
	string	$refRule
)
{       
	string $dir = getProjectDir( $ruleType, $refRule );
	
	if($dir != "")
		$dir = `file -q -expandName $dir`;

	if ( $dir != "" && !isAbsolutePath( $dir ) ) {
		string $projectDir = getTheProjectDir();

		$dir = $projectDir + "/" + $dir;
	}

	return $dir;
}

//addDebugTag( "makeProjectRelative" );

proc string makeProjectRelative(
	string	$pathname
)
{
	string	$tag = "makeProjectRelative";
	string	$projectPath = $pathname;
	string	$relPath = "";

	if($pathname != "")
		$pathname = `file -q -expandName $pathname`;

	// try to make the path project relative
	//
	if ( isAbsolutePath( $pathname ) ) {
		string	$projectDir = getTheProjectDir();
		string	$re = "^" + $projectDir;
		string	$p = match( $re, $pathname );

		if ( $p != "" ) {
			$relPath = substring( $pathname, size( $p ) + 1, size( $pathname ) ); 

			HfTDebug( $tag, "stripped \"" + $projectDir + "\" from \"" + $pathname + "\"->\"" + $relPath + "\"" );
		}
	} else {
		$relPath = $pathname;
	}

	if ( $relPath != "" ) {
		// get rid of initial slashes and dots
		//
		string	$firstChar = substring( $relPath, 1, 1 );
		int		$dotOK = true;

		HfTDebug($tag, "firstChar = \"" + $firstChar + "\"" );
		while ( $firstChar == "/" || ( $dotOK && $firstChar == "." ) ) {
			int	$relPathSize = size( $relPath );

			$dotOK = $firstChar != ".";
			if ( $relPathSize > 1 ) {
				$relPath = substring( $relPath, 2, $relPathSize );
				HfTDebug($tag, "removed " + $firstChar + " to get \"" + $relPath + "\"" );
				$firstChar = substring( $relPath, 1, 1 );
			} else {
				$relPath = "";
				$firstChar = "";
			}
		}
		if ( $relPath != "" ) {
			$projectPath = $relPath;
		}
	}

	HfTDebug( $tag, "\"" + $pathname + "\"->\"" + $projectPath + "\"" );
	return $projectPath;
}

proc int isNumeric(string $testString)
{
	string $buffer[];
	int $numTokens = `tokenize $testString "." $buffer`;
	$testString = $buffer[0];

	$numTokens = `tokenize $testString "0/1/2/3/4/5/6/7/8/9" $buffer`;
	if(size($buffer[0]) == 0)
	{
		return true;
	}
	else
	{
		return false;
	}
}

proc int frameLoop(string $frameExt, string $currentFrameExt) 
{
	if( size($frameExt) - size($currentFrameExt) >=0 && size($frameExt) - size($currentFrameExt) < 4 )
	{
		return true;
	}

	return false;
}
proc string nextFrameExt(string $frameExt, string $currentFrameExt)
{
	int $status = false;

	switch( size($frameExt) - size($currentFrameExt) )
	{
		case 0:
			$frameExt = ".0";
			$status = true;
			break;
		case 1:
			$frameExt = ".00";
			$status = true;
			break;
		case 2:
			$frameExt = ".000";
			$status = true;
			break;
		case 3:
			$frameExt = ".0000";
			$status = true;
			break;
		default:
			$status = false;
			break;
	}
	  
	if( $status )
	{
		string $buffer[];
		int $numTokens = `tokenize $currentFrameExt "." $buffer`;
		$frameExt += $buffer[0];
	}

	return $frameExt;
}

proc string makeFullPath(
	string	$file
)
{
	string	$fullPath;
	
	if($file != "")
		$file = `file -q -expandName $file`;
	if ( isAbsolutePath( $file ) ) {
		$fullPath = $file;
	} else {
		// any relative paths are assumed to be rooted at the current project
		//
		string $projectDir = getTheProjectDir();

		$fullPath = $projectDir + "/" + $file;
	}
	return $fullPath;
}

global proc string HfGetFullImagePath(
	string	$filename
)
{
	if($filename != "" && $filename != "UNNAMED") {
		$filename = `file -q -expandName $filename`;
		$filename = makeProjectRelative($filename);
	}
	string	$fullPath = $filename;

	if ( isAbsolutePath( $filename ) ) {
		$fullPath = $filename;
	} else {
		$fullPath = getDirPath( "fileRule", "furAttrMap" ) + "/" + $filename;
		if ( ! `filetest -r $fullPath` ) {
			$fullPath = getDirPath( "fileRule", "sourceImages" ) + "/" + $filename;
			if ( ! `filetest -r $fullPath` ) {
				// try rooting it at the project directory
				//
				string	$projectDir = getTheProjectDir();
				
				$fullPath = $projectDir + "/" + $filename;
				if ( ! `filetest -r $fullPath` ) {
					$fullPath = "";
				}
			}
		}
	}

	return $fullPath;
}

global proc string HfGetGlobalsLocation( string $globals )
{
	string $str;
	if ( $globals != "" &&
		 `objExists $globals` &&
		 `attributeQuery -ex -n $globals "projectLocation"` )
	{
		$str = `getAttr ( $globals + ".projectLocation" )`;
		if ( $str != "" &&
			 substring( $str, size($str), size($str) ) != "/" )
		{
			$str += "/";
		}
	}

	return $str;
}

proc string getConnectedFurGlobals( string $node )
{
	string $connected[];
	string $nodeType = `nodeType $node`;

	string $srcPlug = $node + ".message";
	if ( `connectionInfo -isSource $srcPlug` ) {
		$connected = `connectionInfo -dfs $srcPlug`;
	}
	for ( $conn in $connected )
	{
	    string $buffer[];
	    tokenize($conn, ".", $buffer);
		string $connNode = $buffer[0];
		if ( `nodeType $connNode` == "FurGlobals" )
		{
			return $connNode;
		}
	}

	string $def = "defaultFurGlobals";
	if ( `objExists $def` ) {
		return $def;
	}

	return "";
}

global proc string HfGetAttachedGlobalsPath( string $node )
{
	string $globals = getConnectedFurGlobals( $node );
	return HfGetGlobalsLocation( $globals );
}

addDebugTag("getGlobalsPath");

proc string getGlobalsPath( string $plug )
{
	string $buffer[];
	tokenize($plug,".",$buffer);
	string $node = $buffer[0];
	string $nodeType = `nodeType $node`;

	string $tag = "getGlobalsPath";
	HfTDebug($tag, ( "( " + $plug + " )" ) );
	HfTDebug($tag, ( "nodeType is: " + $nodeType ) );

	if ( $nodeType == "FurDescription" ||
		 $nodeType == "FurAttractors" )
	{
		return HfGetAttachedGlobalsPath( $node );
	}
	else if ( $nodeType == "FurFeedback" )
	{
		string $conn = `connectionInfo -sfd $plug`;
		if ( $conn != "" )
		{
			HfTDebug($tag, "found connection: " + $conn );
			tokenize($conn,".",$buffer);
			$node = $buffer[0];
			$nodeType = `nodeType $node`;
			if ( $nodeType == "FurDescription" ||
				 $nodeType == "FurAttractors" )
			{
				HfTDebug($tag, "found desc/attr" );
				return HfGetAttachedGlobalsPath( $node );
			}
		}
	}
	return "";
}

addDebugTag("getMapFile");

proc string getMapFile(
	string	$mapPlug
)
{
	$tag = "getMapFile";

	HfTDebug( $tag, ( "getting map file for " + $mapPlug ) );

	string	$mapFile = `getAttr $mapPlug`;
	if($mapFile !="" && $mapFile != "UNNAMED")
	{
		$mapFile = `file -q -expandName $mapFile`;
		$mapFile = makeProjectRelative($mapFile);
	}
	if ( $mapFile != "UNNAMED" && 
		 $mapFile != "" && 
		 !isAbsolutePath($mapFile) )
	{
		string $buffer[];
		tokenize($mapPlug,".",$buffer);
		string $node = $buffer[0];
		if ( `isFromReferencedFile $node` )
		{
			string $globalsPath = getGlobalsPath( $mapPlug );
			if ( $globalsPath != "" )
			{
				string $fullMap = $globalsPath + $mapFile;			
				if ( `filetest -r $fullMap` )
				{
					HfTDebug( $tag, ( "found path for " + $node + ": " + $fullMap ) );
					$mapFile = $fullMap;
				}
			}
		}
	}

	return $mapFile;
}

global proc string HfGetFullMapPath( string $mapPlug )
{
	string $tag = "getMapFile";
	HfTDebug($tag, $mapPlug);
	string $mapFile = getMapFile( $mapPlug );
	
	if($mapFile != "") {
		$mapFile = `file -q -expandName $mapFile`;
		$mapFile =  makeProjectRelative($mapFile);
	}

	if ( $mapFile != "" &&
		 !isAbsolutePath($mapFile) )
	{
		$mapFile = HfGetFullImagePath( $mapFile );
	}

	HfTDebug($tag, "returning: " + $mapFile);
	return $mapFile;
}

proc string standardName(
	string	$n
)
{
	if ( $n != "" ) {
		string	$temp[];
	
		$temp=`ls $n`;
		if ( size( $temp ) == 1 ) {
			return $temp[0];
		} else {
			return "";
		}
	} else {
		return "";
	}
}

proc string getSrcPlug(
	string	$dstPlug
)
{
	string	$srcPlug = `connectionInfo -sfd $dstPlug`;

	return $srcPlug;
}

proc string[] getDstPlugs(
	string	$srcPlug
)
{
	string	$dstPlugs[];
	
	// work around bug in connectionInfo -dfs where a
	// string is returned instead of a string array
	// if there are no connections
	//
	if ( `connectionInfo -isSource $srcPlug` ) {
		$dstPlugs = `connectionInfo -dfs $srcPlug`;
	}
	
	return $dstPlugs;
}

proc string stripMultiIndex( string $plug )
{
	string	$multiIndex = match( "\\[[0-9]*\\]", $plug );

	if ( $multiIndex == "" ) {
		return $plug;
	}

	string	$stripped = substring( $plug, 1, (size($plug) - size($multiIndex)) );

	return $stripped;
}

proc int getMultiIndex( string $plug )
{
	string	$multiIndexB = match( "\\[[0-9]*\\]", $plug );

	if ( $multiIndexB == "" ) {
		return -1;
	}

	string	$multiIndexStr = substring( $multiIndexB, 2, (size($multiIndexB)-1) );
	int		$multiIndex = $multiIndexStr;

	return $multiIndex;
}

//addDebugTag( "setMapFile" );

proc setMapFile(
	string	$mapPlug,
	string	$mapFile
)
{
	string	$tag = "setMapFile";

	HfTDebug($tag, "setting " + $mapPlug + " to " + $mapFile);
	setAttr -type "string" $mapPlug $mapFile;

	int		$mi = getMultiIndex( $mapPlug );

	if ( $mi >= 0 ) {
		string	$baseAttr = plugAttr( stripMultiIndex( $mapPlug ) );
		
		$baseAttr = baseFromHairMapsAttr( $baseAttr );

		if ( $baseAttr != "" ) {
			string	$hd = plugNode( $mapPlug );
			string	$mapUSamplesPlug = $hd + "." + hairMapUSamplesAttr($baseAttr) + "[" + $mi + "]";
			string	$mapVSamplesPlug = $hd + "." + hairMapVSamplesAttr($baseAttr) + "[" + $mi + "]";

			HfTDebug($tag, "zeroing " + $mapUSamplesPlug + " & " + $mapVSamplesPlug);
			setAttr $mapUSamplesPlug 0;
			setAttr $mapVSamplesPlug 0;

			// if a feedback node is connected to the map plug, clear the map
			// dirty flag
			//
			string	$connections[] = getDstPlugs( $mapPlug );
			string	$c;

			for ( $c in $connections ) {
				if ( `nodeType $c` == "FurFeedback" ) {
					string	$dirtyPlug = plugNode( $c ) + "." + feedbackMapDirtyAttr($baseAttr);

					HfTDebug( $tag, "clearing " + $dirtyPlug );
					setAttr $dirtyPlug 0;
					$dirtyPlug = plugNode( $c ) + "." + feedbackSamplesDirtyAttr($baseAttr);
					HfTDebug( $tag, "clearing " + $dirtyPlug );
					setAttr $dirtyPlug 0;
				}
			}
		}
	}
}

addDebugTag("HFScriptJobs");

proc addAttrChangedScriptJob(
	int		 $id
)
{
	HfTDebug("HFScriptJobs","addAttrChangedScriptJob " + $id);

	global int	 $HfAttrChangedScriptJobs[];

	$HfAttrChangedScriptJobs[size($HfAttrChangedScriptJobs)] = $id;
}

proc addConnChangedScriptJob(
	int		 $id
)
{
	HfTDebug("HFScriptJobs","addConnChangedScriptJob " + $id);

	global int	 $HfConnChangedScriptJobs[];

	$HfConnChangedScriptJobs[size($HfConnChangedScriptJobs)] = $id;
}

//addDebugTag("getShapes");

proc int getShapes(
	string	$items[],		// should be unique path names
	string	$shapeTypes[],
	string	$shapes[],
	int		$index,
	int		$transforms
)
{
	string $tag = "getShapes";
	string $s;

	global int $indent = 0;
	int $i;

	for ( $s in $items ) {
		HfTCDebug($tag,"",1,0);
		for ( $i = 0; $i < $indent; $i++ ) {
			HfTCDebug($tag," ",0,0);
		}
		HfTCDebug($tag, ( "(" + $index + ") \"" + $s + "\"..." ),0,0); 

		if ( `nodeType $s` == "transform" ) {
			string	$relatives[]=`listRelatives -f $s`;

			HfTCDebug($tag, "recursing",0,1);
			$indent++;
			$index = getShapes( $relatives, $shapeTypes, $shapes, $index, $transforms );
			$indent--;
		} else {
			// is it one of the shape types
			//
			int		$matches = 0;
			string	$nodeType = `nodeType $s`;
			string	$st;

			for ( $st in $shapeTypes ) {
				if ( $nodeType == $st ) {
					$matches = 1;
					break;
				}
			}

			if ( $matches ) {
				int	$isIntermediate = getAttr( $s  + ".intermediateObject");
	
				if ( $isIntermediate ) {
					HfTCDebug($tag,($shapes[$index] + " is intermediate - ignoring"),0,1);
					continue;
				}
				if ( $transforms ) {
					// return the parent transform
					//
					string $parent[]=`listRelatives -p -pa $s`;
					if ( size($parent) == 1 ) {
						$shapes[$index] = $parent[0];
					} else {
						$shapes[$index] = $s;
					}
				} else {
					$shapes[$index] = $s;
				}
				HfTCDebug($tag,("added " + $shapes[$index]),0,1);
				$index++;
			} else {
				HfTCDebug($tag,"",0,1);
			}
		}
	}

	return $index;
}

proc int getSurfaceShapes(
	string	$items[],		// should be unique path names
	string	$surfaces[],
	int		$index,
	int		$transforms
)
{
	string	$shapeTypes[];

	$shapeTypes[0] = "nurbsSurface";
	$shapeTypes[1] = "mesh";
	$shapeTypes[2] = "subdiv";
	$index = getShapes(
		$items, $shapeTypes, $surfaces, $index, $transforms
	);

	return $index;
}

proc getSelectedSurfaceShapes(
	string	$selected[]
)
{
	getSurfaceShapes(
		`ls -objectsOnly -sl -transforms -type nurbsSurface -type mesh -type subdiv`,
		$selected, 0, 0
	);
}

proc int getFurShapes(
		string	$items[],		// should be unique path names
		string	$furs[],
		int		$index,
		int		$transforms
)
{
	string	$shapeTypes[];
	
	$shapeTypes[0] = "FurFeedback";
	$index = getShapes(
		$items, $shapeTypes, $furs, $index, $transforms
		);
	
	return $index;
}

proc getSelectedFurShapes(
	string	$selected[]
)
{
	getFurShapes(
		`ls -objectsOnly -sl -transforms -type FurFeedback`,
		$selected, 0, 0
		);
}

proc string getChildShape(
	string	$transform
)
{
	if ( `nodeType $transform` != "transform" ) {
		return $transform;
	}

	string	$childShapes[] = `listRelatives -shapes -pa $transform`;
	string $cs, $s;

	// if there is only one non-intermediate shape, then we
	// will use it
	//
	$s = "";
	for ( $cs in $childShapes ) {
		int	$isIntermediate = getAttr( $cs  + ".intermediateObject");
		if ( ! $isIntermediate ) {
			if ( $s == "" ) {
				$s = $cs;
			} else {
				$s = "";
				break;
			}
		}
	}
	return $s;
}

proc getTransformAndShape(
	string	$dagNode,
	string	$paths[]	// transform in 0, shape in 1
)
{
	if ( `nodeType $dagNode` == "transform" ) {
		$paths[0]=standardName($dagNode);
		$paths[1]=standardName(getChildShape($dagNode));
	} else {
		$paths=`listRelatives -p -pa $dagNode`;
		$paths[1]=standardName($dagNode);
	}
}

//addDebugTag( "selectionStack" );

global int		$HfSavedSelectionLevel; 
global int		$HfSavedSelectionOffsets[];

$HfSavedSelectionLevel = -1;
$HfSavedSelectionOffsets[0] = 0;

proc saveSelectionList()
{
	string	$tag="selectionStack";

	global string	$HfSavedSelectionList[];
	global int		$HfSavedSelectionOffsets[];
	global int		$HfSavedSelectionLevel; 

	string	$selected[] = `ls -sl`;
	string	$s;
	int		$i;

	$HfSavedSelectionLevel++;	// push stack
	$i = $HfSavedSelectionOffsets[$HfSavedSelectionLevel]; 

	// save selection into list
	//
	for ( $s in $selected ) {
		HfTDebug($tag,"save: level=" + $HfSavedSelectionLevel + ",idx=" + $i + ",item=" + $s);
		$HfSavedSelectionList[$i++] = $s;
	}
	$HfSavedSelectionOffsets[$HfSavedSelectionLevel+1] = $i;
}

proc restoreSelectionList()
{
	string	$tag="selectionStack";

	global string	$HfSavedSelectionList[];
	global int		$HfSavedSelectionOffsets[];
	global int		$HfSavedSelectionLevel; 

	if ( $HfSavedSelectionLevel >= 0 ) {
		string	$selected[];
		int		$s = 0;
		int		$lower = $HfSavedSelectionOffsets[$HfSavedSelectionLevel]; 
		int		$upper = $HfSavedSelectionOffsets[$HfSavedSelectionLevel+1];
		int		$i;

		// restore selection into list
		//
		for ( $i = $lower; $i < $upper; $i++ ) {
			HfTDebug(
				$tag,
				"restore: level=" + $HfSavedSelectionLevel + ",idx=" + $i + ",item="
			  + $HfSavedSelectionList[$i]
			);
			$selected[$s++] = $HfSavedSelectionList[$i];
		}
		if ( $s > 0 ) {
			select -replace $selected;
		} else {
			select -clear;
		}

		$HfSavedSelectionLevel--;	// pop stack
	} else {
		// reset stack
		//
		HfTDebug($tag, "stack underflow - resetting");
		$HfSavedSelectionLevel = -1;
		$HfSavedSelectionOffsets[0] = 0;
	}
}

//addDebugTag("hairDescList");

global int $HfHairGlobalsListsBuilt;

$HfHairGlobalsListsBuilt = false;

proc int getHairGlobalsListPlugs(
	string	$listPlugs[],
	int		$forceBuild
)
{
	string	$hairGlobals = HfGetHairGlobal();
	string	$hdListAttrName = "hairDescriptions";
	string	$asListAttrName = "attractorSets";
	string	$protectAttrName = "furNodeList";
	string	$casListAttrName = "curveAttractorSets";

	if ( $hairGlobals == "" && $forceBuild ) {
		$hairGlobals = HfBuildHairGlobal();
	}

	if ( $hairGlobals != "" ) {
		$listPlugs[0] = $hairGlobals + "." + $hdListAttrName;
		$listPlugs[1] = $hairGlobals + "." + $asListAttrName;
		$listPlugs[2] = $hairGlobals + "." + $protectAttrName;
		$listPlugs[3] = $hairGlobals + "." + $casListAttrName;
		return true;
	} else {
		return false;
	}
}

proc addReferencedGlobalsNode(
	string	$referencedNode,
	string	$protectPlug
)
{
	string	$tag = "globals";

	if ( $protectPlug != "" ) {
		string	$hairGlobals = plugNode( $protectPlug );
		string	$rogl = "rogl";

		// if there is no attribute for read only nodes, add one now
		//
		if ( ! `attributeQuery -exists -node $hairGlobals $rogl` ) {
			HfTDebug($tag, "adding " + $rogl + " attribute to " + $hairGlobals);
			addAttr -at message -sn $rogl -ln "referencedFurGlobals" $hairGlobals;
		}

		// get the protect plug for the referencedNode and
		// make sure this node isn't already on some global's list
		//
		string	$protectAttr = plugAttr( $protectPlug );
		string	$roProtectPlug = $referencedNode + "." + $protectAttr;
		string	$dstPlugs[] = `listAttr -m -st $protectAttr $referencedNode`;
		string	$d;

		for ( $d in $dstPlugs ) {
			string	$srcNode = plugNode( getSrcPlug( $referencedNode + "." + $d ) );

			if ( `nodeType $srcNode` == "FurGlobals" ) {
                  		return;
			}
		}

		string	$roglPlug = $hairGlobals + "." + $rogl;

		HfTDebug($tag,"connecting " + $roglPlug + "->" + $roProtectPlug);
		connectAttr -na $roglPlug $roProtectPlug;
	}
}

// disconnectAttr that checks whether the disconnection
// can be done first
//

//addDebugTag( "check" );

proc int checkAndDisconnectAttr(
	string	$srcPlug,
	string	$dstPlug
)
{
	int		$disconnected;
	string	$srcNode = plugNode( $srcPlug );
	string	$dstNode = plugNode( $dstPlug );
	
	HfTDebug(
		"check",
		"disconnectAttr \"" + $srcPlug + "\" \"" + $dstPlug + "\""
	);

	if ( `isFromReferencedFile $srcNode`
	  && `isFromReferencedFile $dstNode` ) {
		$disconnected = false;
		HfTDebug(
			"check",
			"  disconnectAttr failed since both are in referenced file"
		);
	} else {
		$disconnected = !catch( `disconnectAttr $srcPlug $dstPlug` );
		HfTDebug(
			"check",
			"  disconnectAttr " + ($disconnected ? " succeeded" : " failed")
		);
	}

	return $disconnected;
}

proc int checkAndDelete(
	string	$object
)
{
	int	$deleted;
	
	HfTDebug(
		"check", "delete \"" + $object + "\""
	);
	if ( `isFromReferencedFile $object` ) {
		$deleted = false;
		HfTDebug(
			"check",
			"  delete failed, object is from referenced file"
		);
	} else {
		$deleted = !catch( `delete $object` );
		HfTDebug(
			"check",
			"  delete " + ($deleted ? " succeeded" : " failed")
		);
	}

	return $deleted;
}

//addDebugTag("connectToGlobals");

proc connectHairNodeToGlobals(
	string	$hairNode,
	string	$globalsListPlug,
	string	$globalsProtectPlug
)
{
	string	$tag = "connectToGlobals";
	string	$hnPlug;
	int		$makeConnections = true;

	// make a connection from hair globals to this new hair description node
	// - make two bi-directional connections between hair node
	//   and hair globals in an attempt to keep the nodes from
	//   being inadvertantly deleted when nodes connected to them
	//   are deleted
	//
	$hnPlug = $hairNode + ".fgc";
	if ( ! `isConnected $globalsListPlug $hnPlug` ) {
		if ( `connectionInfo -isDestination $hnPlug` ) {
			string	$srcPlug = `connectionInfo -sfd $hnPlug`;

			HfTDebug($tag,$hnPlug + " connected to " + $srcPlug + " - disconnect" );
			if ( ! `checkAndDisconnectAttr $srcPlug $hnPlug` ) {
				// disconnect failed; this must be because
				// srcPlug is a fur globals in a referenced file
				// so add it to list of referenced fur globals
				// in the current fur globals
				//
				addReferencedGlobalsNode(
					plugNode( $srcPlug ), $globalsProtectPlug
				);
				$makeConnections = false;
			}
		}
		if ( $makeConnections ) {
			HfTDebug($tag,"connecting " + $globalsListPlug + "->" + $hnPlug );
			connectAttr $globalsListPlug $hnPlug;
		}
	}

	$hnPlug = $hairNode + ".message";
	if ( $makeConnections ) {
		string	$connected[] = getDstPlugs( $hnPlug );
		string	$c;

		for ( $c in $connected ) {
			// is this the protect plug
			//
			HfTDebug($tag, $hnPlug + " is connected to " + $c);
			if ( $globalsProtectPlug == `stripMultiIndex( $c )` ) {
				HfTDebug($tag, $hnPlug + " already connected to " + $c);
				$makeConnections = false;
				break;
			} else if ( `nodeType $c` == "FurGlobals" ) {
				HfTDebug($tag, $hnPlug + " connected to wrong fur globals " + $c + " - disconnect");
				checkAndDisconnectAttr $hnPlug $c;
			}
		}
	}
	if ( $makeConnections ) {
		HfTDebug($tag," connecting " + $hnPlug + "->" + $globalsProtectPlug);
		connectAttr -na $hnPlug $globalsProtectPlug;
	}
}

proc resetHairGlobalsLists()
{
	global int $HfHairGlobalsListsBuilt;

	string	$tag = "hairDescList";

	HfTDebug($tag,"in resetHairGlobalsLists");

	string	$listPlugs[];
	string	$plugs[];
	string	$p;
	int		$i;

	// this just gets the various list plugs
	// - don't force their creation and return if there
	//   isn't any
	//
	if ( !getHairGlobalsListPlugs( $listPlugs, false ) ) {
		return;
	}

	for ( $i = 0; $i < 2; $i++ ) {
		$plugs=getDstPlugs( $listPlugs[$i] );
		for ( $p in $plugs ) {
			HfTDebug($tag,"disconnecting " + $listPlugs[$i] + " from " + $p);
			if ( ! `checkAndDisconnectAttr $listPlugs[$i] $p` ) {
				HfTDebug($tag,"can't disconnect " + $listPlugs[$i] + " from " + $p);
			}
		}
	}

	string	$parts[];
	tokenize($listPlugs[2], ".", $parts);
	clear( $plugs );
	$plugs=`listAttr -m -st $parts[1] $parts[0]`;
	for ( $p in $plugs ) {
		string	$dstPlug = $parts[0] + "." + $p;
		string	$srcPlug = getSrcPlug( $dstPlug );
		
		if ( $srcPlug != "" ) {
			HfTDebug($tag,"disconnecting " + $srcPlug + " from " + $dstPlug);
			if ( ! `checkAndDisconnectAttr $srcPlug $dstPlug` ) {
				HfTDebug($tag,"can't disconnect " + $srcPlug + " from " + $dstPlug);
			}
		} 
	}

	$HfHairGlobalsListsBuilt = false;
}

proc int buildHairGlobalsLists(
	string	$listPlugs[],
	int		$makeHairGlobals
)
{
	global int $HfHairGlobalsListsBuilt;

	string	$tag = "hairDescList";

	if ( !getHairGlobalsListPlugs( $listPlugs, $makeHairGlobals ) ) {
		return false;
	}

	string	$hdListPlug = $listPlugs[0];
	string	$asListPlug = $listPlugs[1];
	string	$protectPlug = $listPlugs[2];
	string	$casListPlug = $listPlugs[3];

	if ( ! $HfHairGlobalsListsBuilt ) {
		resetHairGlobalsLists();

		// go through entire scene looking for hair descriptions
		// and attractor sets
		//
		string	$allHairObjects[];
		string	$obj;
		string	$fgcPlug;
		
		HfTDebug($tag,"building lists for " + plugNode($protectPlug));

		$allHairObjects = `ls -type FurDescription -type FurAttractors -type FurCurveAttractors`;
		for ( $obj in $allHairObjects ) {
			// make two bi-directional connections between hair node
			// and hair globals in an attempt to keep the nodes from
			// being inadvertantly deleted when nodes connected to them
			// are deleted
			//
			string	$listPlug;

			if ( `nodeType $obj` == "FurDescription" ) {
				$listPlug = $hdListPlug;
			} else if ( `nodeType $obj` == "FurAttractors" ) {
				$listPlug = $asListPlug;
			}else if ( `nodeType $obj` == "FurCurveAttractors" ) {
				$listPlug = $casListPlug;
			} else {
				continue;
			} 

			connectHairNodeToGlobals(
				$obj, $listPlug, $protectPlug
			);
		}

		$HfHairGlobalsListsBuilt = true;
	}

	return true;
}

//addDebugList("getGlobalsList");

proc getHairGlobalsListRecursive(
	string	$listPlug,
	string	$list[]
)
{
	string	$tag = "getGlobalsList";
	string	$dstPlugs[] = getDstPlugs( $listPlug );
	string	$dp;
	int		$l = size( $list );

	HfTDebug($tag,"get list from " + $listPlug); 
	for ( $dp in $dstPlugs ) {
		HfTDebug($tag, "adding " + plugNode( $dp ) + " at idx " + $l);
		$list[$l++] = plugNode( $dp );
	}

	// check if there are any read only hair globals nodes
	// we should check
	//
	string	$plugParts[];

	tokenize( $listPlug, ".", $plugParts );

	if ( `attributeQuery -exists -node $plugParts[0] "rogl"` ) {
		$dstPlugs = getDstPlugs( $plugParts[0] + ".rogl" );

		for ( $dp in $dstPlugs ) {
			getHairGlobalsListRecursive(
				plugNode( $dp ) + "." + $plugParts[1],
				$list
			);
		}
	} 
}

proc getHairGlobalsList(
	string	$listPlug,
	string	$list[]
)
{
	clear( $list );
	getHairGlobalsListRecursive( $listPlug, $list );
}

proc string getHairGlobalsProtectPlug(
	int	$force
)
{
	string	$listPlugs[];

	if ( buildHairGlobalsLists( $listPlugs, $force ) ) {
		return $listPlugs[2];
	} else {
		return "";
	}
}

proc string getHairGlobalsHDListPlug(
	int	$force
)
{
	string	$listPlugs[];

	if ( buildHairGlobalsLists( $listPlugs, $force ) ) {
		return $listPlugs[0];
	} else {
		return "";
	}
}

//addDebugTag("getHairSetMembers");

proc getHairSetMembers(
	string	$hairAttrPlug,
	string	$members[],
	int		$multiIndexes[]
)
{
	string	$tag = "getHairSetMembers";

	HfTDebug( $tag, ("in getHairSetMembers(" + $hairAttrPlug + ")") );

	string	$hairSet = plugNode( $hairAttrPlug );
	string	$dagSetMembers[] = `listAttr -m -st "dagSetMembers" $hairSet`;
	string	$dsm, $m, $s;
	int		$mi = 0;

	clear( $members );
	clear( $multiIndexes );

	for ( $dsm in $dagSetMembers ) {
		HfTDebug( $tag, "checking " + $dsm );

		int		$multiIndex = getMultiIndex( $dsm );
		
		$m = getSrcPlug($hairSet + "." + $dsm);
		if ( $m == "" ) {
			continue;
		}
		$m = plugNode( standardName( $m ) );
		if ( $m == "" ) {
			continue;
		}
		$s = $m;
		if ( `nodeType $s` == "transform" ) {
			$s = getChildShape( $s );
		}

		if (
			$s != ""
		 && ( `nodeType $s` == "nurbsSurface"
		   || `nodeType $s` == "mesh"
		   || `nodeType $s` == "subdiv"  )
		) {
			$members[$mi] = standardName($m);
			$multiIndexes[$mi] = $multiIndex;
			HfTDebug( $tag, ( " " + $members[$mi] + " " + $multiIndexes[$mi]) );
			$mi++;
		}
	}
}

proc getHairSetNurbsPolyMembers(
	string	$hairAttrPlug,
	string	$members[],
	int		$multiIndexes[]
)
{
	string	$tag = "getHairSetMembers";

	HfTDebug( $tag, ("in getHairSetNurbsPolyMembers(" + $hairAttrPlug + ")") );

	string	$hairSet = plugNode( $hairAttrPlug );
	string	$dagSetMembers[] = `listAttr -m -st "dagSetMembers" $hairSet`;
	string	$dsm, $m, $s;
	int		$mi = 0;

	clear( $members );
	clear( $multiIndexes );

	for ( $dsm in $dagSetMembers ) {
		HfTDebug( $tag, "checking " + $dsm );

		int		$multiIndex = getMultiIndex( $dsm );
		
		$m = getSrcPlug($hairSet + "." + $dsm);
		if ( $m == "" ) {
			continue;
		}
		$m = plugNode( standardName( $m ) );
		if ( $m == "" ) {
			continue;
		}
		$s = $m;
		if ( `nodeType $s` == "transform" ) {
			$s = getChildShape( $s );
		}

		if ($s != "")
		{	
			if( `nodeType $s` == "nurbsSurface"   || `nodeType $s` == "mesh"  )
			{
				$members[$mi] = standardName($m);
				$multiIndexes[$mi] = $multiIndex;
				HfTDebug( $tag, ( " " + $members[$mi] + " " + $multiIndexes[$mi]) );
				$mi++;
			}
		}
	}
}

//addDebugTag("getAllDescriptions");

proc getAllDescriptions(
	string	$descListPlug,
	string	$descriptions[],
	string	$assignedToSurfaces[]
)
{
	if ( $descListPlug == "" ) {
		clear( $descriptions );
	} else if ( size( $assignedToSurfaces ) > 0 ) {
		string	$tag="getAllDescriptions";
		string	$allDescriptions[];
		string	$expanded[];
		string	$srfPaths[];
		string	$hd;
		string	$s;
		int		$hdi = 0;
		int		$ei = 0;
		int		$expandedSize;

		getHairGlobalsList(
			$descListPlug, $allDescriptions
		);

		// expand assignedToSurfaces to include
		// transforms and then sort them
		//
		for ( $s in $assignedToSurfaces ) {
			getTransformAndShape( $s, $srfPaths );
			$expanded[$ei++]=$srfPaths[0];
			$expanded[$ei++]=$srfPaths[1];
		}
		$expanded=`sort $expanded`;
		$expandedSize = size( $expanded );

		for ( $hd in $allDescriptions ) {
			HfTDebug($tag,"checking " + $hd);

			string	$members[];
			int		$multiIndexes[];
			string	$m;

			getHairSetMembers( $hd, $members, $multiIndexes );
			$members=`sort $members`;

			// if one of the members is in expanded, add hair description
			// to list
			//
			$ei = 0;
			for ( $m in $members ) {
				HfTDebug($tag," checking member " + $m);

				for ( ; $ei < $expandedSize && strcmp($m,$expanded[$ei]) > 0; $ei++ ) {
					HfTDebug($tag," skipping " + $expanded[$ei] );
				}
				if ( $ei >= $expandedSize ) {
					break;
				}
				HfTDebug($tag," comparing to " + $expanded[$ei]);
				if ( $m == $expanded[$ei] ) {
					HfTDebug($tag," adding " + $hd + " at " + $hdi);
					$descriptions[$hdi++]=$hd;
					break;
				}
			}
		}
	} else {
		getHairGlobalsList(
			$descListPlug, $descriptions
		);
	}
}

proc getAllHairDescriptions(
	string	$hairDescriptions[],
	int		$assignedToSelected
)
{
	string	$selected[];

	if ( $assignedToSelected ) {
		getSelectedSurfaceShapes( $selected );
		if ( size( $selected ) == 0 ) {
			clear( $hairDescriptions );
			return;
		}
	} else {
		clear( $selected );
	}
	getAllDescriptions(
		getHairGlobalsHDListPlug(false), $hairDescriptions,
		$selected
	);
}

proc string createHairDescriptionNode()
{
	string	$hairDescNode = `createNode "FurDescription"`;

	checkNode( $hairDescNode );
	connectHairNodeToGlobals(
		$hairDescNode,
		getHairGlobalsHDListPlug(true),
		getHairGlobalsProtectPlug(true)
	);

	return $hairDescNode;
}

proc string getHairGlobalsASListPlug(
	int	$force
)
{
	string	$listPlugs[];

	if ( buildHairGlobalsLists( $listPlugs, $force ) ) {
		return $listPlugs[1];
	} else {
		return "";
	}
}
proc string getHairGlobalsCASListPlug(
	int	$force
)
{
	string	$listPlugs[];

	if ( buildHairGlobalsLists( $listPlugs, $force ) ) {
		return $listPlugs[3];
	} else {
		return "";
	}
}

proc getAllAttractorSets(
	string	$hairAttractors[],
	int		$assignedToSelected
)
{
	string	$selected[];

	if ( $assignedToSelected ) {
		getSelectedSurfaceShapes( $selected );
		if ( size( $selected ) == 0 ) {
			clear( $hairAttractors );
			return;
		}
	} else {
		clear( $selected );
	}
	getAllDescriptions(
		getHairGlobalsASListPlug(false), $hairAttractors,
		$selected
	);
}

proc getAllCurveAttractorSets(
	string	$hairAttractors[],
	int		$assignedToSelected
)
{
	string	$selected[];

	if ( $assignedToSelected ) {
		getSelectedSurfaceShapes( $selected );
		if ( size( $selected ) == 0 ) {
			clear( $hairAttractors );
			return;
		}
	} else {
		clear( $selected );
	}
	getAllDescriptions(
		getHairGlobalsCASListPlug(false), $hairAttractors,
		$selected
	);
}
proc string createHairAttractorsNode()
{
	string	$attractorsNode = `createNode "FurAttractors"`;

	checkNode( $attractorsNode );
	connectHairNodeToGlobals(
		$attractorsNode,
		getHairGlobalsASListPlug(true),
		getHairGlobalsProtectPlug(true)
	);

	return $attractorsNode;
}

proc string createHairCurveAttractorsNode()
{
	string	$attractorsNode = `createNode "FurCurveAttractors"`;

	checkNode( $attractorsNode );
	connectHairNodeToGlobals(
		$attractorsNode,
		getHairGlobalsCASListPlug(true),
		getHairGlobalsProtectPlug(true)
	);

	return $attractorsNode;
}

//addDebugTag("getMapped");
	
proc getMapped(
	string	$hairAttrMapPlug,
	string	$mappedSurface[],
	string	$mapFiles[],
	int		$mapIndexes[]
)
{
	string	$tag = "getMapped";

	HfTDebug( $tag, ("in getMapped(" + $hairAttrMapPlug + ")") );

	string	$plugParts[];
	string  $node;

	tokenize($hairAttrMapPlug, ".", $plugParts);
	$node = $plugParts[0];
	
	string	$mapped[] = `listAttr -m -st $plugParts[1] $plugParts[0]`;

	clear( $mappedSurface );
	clear( $mapFiles );
	clear( $mapIndexes );
	if ( size( $mapped ) == 0 ) {
		return;
	}

	string	$hairSetMembers[];
	int		$hairSetIndexes[];
	string	$member;
	string	$mapFile;
	int		$memberIdx = 0;
	int		$mappedIdx = 0;
	int		$outIdx = 0;
	int		$mappedMultiIdx = getMultiIndex( $mapped[$mappedIdx] );

	HfTCDebug( $tag, (" " + size( $mapped ) + " map entries:"),1,0);
	for ( $member in $mapped ) {
		HfTCDebug( $tag, ($member + " "),0,0);
	}
	HfTCDebug( $tag, "",0,1);

	// the following loops only work if the multi indexes for
	// $hairSetMembers and $mapped are in ascending order
	//
	getHairSetMembers( $hairAttrMapPlug, $hairSetMembers, $hairSetIndexes );
	for ( $member in $hairSetMembers ) {
		int		$memberMultiIdx = $hairSetIndexes[$memberIdx];

		HfTDebug( $tag, (" checking against:" + $member + " " + $memberMultiIdx) );

		while ( $mappedMultiIdx < $memberMultiIdx ) {
			HfTDebug( $tag, (" skipping map:" + $mapped[$mappedIdx] + " " + $mappedMultiIdx) );
			$mappedIdx++;
			if ( $mappedIdx < size( $mapped ) ) {
				$mappedMultiIdx = getMultiIndex( $mapped[$mappedIdx] );
			} else {
				break;
			}
		}
		if ( $mappedIdx == size( $mapped ) ) {
			break;
		}

		if ( $mappedMultiIdx == $memberMultiIdx ) {
			HfTDebug( $tag, ( $mapped[$mappedIdx] + " " + $mappedMultiIdx + " matches " + $member + " " + $memberMultiIdx) );
			$mapFile = getMapFile($hairAttrMapPlug + "[" + $mappedMultiIdx + "]");
			if($mapFile !="")
			{
				$mapFile = `file -q -expandName $mapFile`;
				$mapFile = makeProjectRelative($mapFile);
			}
			if ( size( $mapFile ) > 0 ) {
				$mappedSurface[$outIdx] = $member;

				$mapFiles[$outIdx] = $mapFile;
				if ( !isAbsolutePath($mapFile) && `isFromReferencedFile $node` )
				{
					string $refMapFile = HfGetAttachedGlobalsPath( $node );
					string $newMap = $refMapFile + $mapFile;
					if ( $refMapFile != "" &&
						 `filetest -r $newMap` )
					{
						$mapFiles[$outIdx] = $newMap;
					}
				}

				$mapIndexes[$outIdx] = $mappedMultiIdx;
				HfTDebug( $tag, ( " " + $member + " " + $mapFile + " " + $mappedMultiIdx) );
				$outIdx++;
			}
		}
		$memberIdx++;
	}
}

proc string feedbackInputSurface(
	string	$feedback
)
{
	if ( $feedback != "" ) {
		string	$hfPlug = feedbackInputSurfacePlug( $feedback );
		string	$inputSurfacePlug = `connectionInfo -sfd $hfPlug`;

		return plugNode( $inputSurfacePlug );
	} else {
		return "";
	}
}

proc string getHairFeedbackNode(
	string	$surface
)
{
	string	$feedback = "";
	string	$srcPlug = "";

	// determine if the shape is already connected to a hairfeedback node
	// 
	if ( `nodeType $surface` == "nurbsSurface" ) {
		$srcPlug = $surface + ".ws";
	} else if ( `nodeType $surface` == "mesh" ) {
		$srcPlug = $surface + ".w";
	} else if ( `nodeType $surface` == "subdiv" ) {
		$srcPlug = $surface + ".ws";
	}

	if ( $srcPlug != "" ) {
		string $connected[] = getDstPlugs( $srcPlug );
		string $c;

		for ( $c in $connected ) {
			string $node = plugNode($c);
			if ( `nodeType $node` == "FurFeedback" ) {
				$feedback = $node;
				break;
			}
		}
	}

	return $feedback;
}

proc string[] getFurFeedbackNodes(
	string	$surface
)
{
	string $feedback[];
	string	$srcPlug = "";
	
	// determine if the shape is already connected to a furfeedback node
	// 
	if ( `nodeType $surface` == "nurbsSurface" ) {
		$srcPlug = $surface + ".ws";
	} else if ( `nodeType $surface` == "mesh" ) {
		$srcPlug = $surface + ".w";
	} else if ( `nodeType $surface` == "subdiv" ) {
		$srcPlug = $surface + ".ws";
	}
	
	if ( $srcPlug != "" ) {
		string $connected[] = getDstPlugs( $srcPlug );
		string $c;

		int $count = 0;
		for ( $c in $connected ) {
			string $node = plugNode($c);
			if ( `nodeType $node` == "FurFeedback" ) {
				$feedback[$count] = $node;
				$count++;
			}
		}
	}
	
	return $feedback;
}

proc string getFurFeedbackNode(
	string	$surface,
	string  $furDescription
)
{
	string $feedback = "";
	string $srcPlug = "";
	
	// determine if the shape is already connected to a furfeedback node
	// 
	if ( `nodeType $surface` == "nurbsSurface" ) {
		$srcPlug = $surface + ".ws";
	} else if ( `nodeType $surface` == "mesh" ) {
		$srcPlug = $surface + ".w";
	} else if ( `nodeType $surface` == "subdiv" ) {
		$srcPlug = $surface + ".ws";
	}
	
	if ( $srcPlug != "" ) {
		string $connected[] = getDstPlugs( $srcPlug );
		string $c;
		
		for ( $c in $connected ) {
			string $node = plugNode($c);
			if ( `nodeType $node` == "FurFeedback" ) {
				string	$thisDesc = HfGetHairDescFromFeedback( $node );
				if ( size( $furDescription ) > 0 ) {
					if ( $thisDesc != $furDescription ) {
						continue;
					}
				}
				$feedback = $node;
			}
		}
	}
	
	return $feedback;
}

global proc string HfGetFurFeedbackNode(
   string	$surface,
   string  $furDescription
   )
{
	return getFurFeedbackNode ($surface, $furDescription);
}

//addDebugTag( "saveFeedbackAttr" );

proc setFeedbackAttr(
	string	$node,
	string	$attr,
	float	$value
)
{
	setAttr ($node + "." + $attr) $value;
	HfTDebug("saveFeedbackAttr","setting " + $node + "." + $attr + " to " + $value);
}

proc setHDFeedbackAttr(
	string	$node,
	string	$attr,
	int		$mi,
	float	$value
)
{
	setAttr ($node + "." + $attr + "[" + $mi + "]") $value;
	HfTDebug("saveFeedbackAttr","setting " + $node + "." + $attr + "[" + $mi + "]" + " to " + $value);
}

proc saveFeedbackInfo(
	string	$feedback,
	string	$hairDesc,
	string	$mi
)
{
	HfTDebug( "saveFeedbackAttr", "in saveFeedbackInfo(" + $feedback + "," + $hairDesc + "," + $mi + ")" );

	int		$us, $vs, $ew, $eh, $cf, $da;
	float	$fa;
	string	$plug;

	// get them from fur feedback
	//
	$plug = $feedback + "." + `feedbackUSamplesAttr`;
	$us = `getAttr $plug`;
	$plug = $feedback + "." + `feedbackVSamplesAttr`;
	$vs = `getAttr $plug`;
	$ew = `getAttr ($feedback + ".exportWidth")`;
	$eh = `getAttr ($feedback + ".exportHeight")`;
	$cf = `getAttr ($feedback + ".colorFeedbackEnabled")`;
	$da = `getAttr ($feedback + ".drawAttractors")`;
	$fa = `getAttr ($feedback + ".furAccuracy")`;

	// save them to fur description
	//
	setHDFeedbackAttr( $hairDesc, "feedbackUSamples", $mi, $us );
	setHDFeedbackAttr( $hairDesc, "feedbackVSamples", $mi, $vs );
	setHDFeedbackAttr( $hairDesc, "feedbackExportWidth", $mi, $ew );
	setHDFeedbackAttr( $hairDesc, "feedbackExportHeight", $mi, $eh );
	setHDFeedbackAttr( $hairDesc, "feedbackColorEnabled", $mi, $cf );
	setHDFeedbackAttr( $hairDesc, "feedbackDrawAttractors", $mi, $da );
	setHDFeedbackAttr( $hairDesc, "feedbackFurAccuracy", $mi, $fa );
}

proc resetFeedbackInfo(
	string	$descNode,
	string	$mi
)
{
	HfTDebug( "saveFeedbackAttr", "in resetFeedbackInfo(" + $descNode + "," + $mi + ")" );

	// this can be used for attractor set nodes as well
	//
	if ( `attributeQuery -ex -node $descNode "feedbackUSamples"` ) {
		// reset feedback info for this slot
		//
		setHDFeedbackAttr( $descNode, "feedbackUSamples", $mi, 0 );
		setHDFeedbackAttr( $descNode, "feedbackVSamples", $mi, 0 );
		setHDFeedbackAttr( $descNode, "feedbackExportWidth", $mi, 0 );
		setHDFeedbackAttr( $descNode, "feedbackExportHeight", $mi, 0 );
		setHDFeedbackAttr( $descNode, "feedbackColorEnabled", $mi, 0 );
		setHDFeedbackAttr( $descNode, "feedbackDrawAttractors", $mi, 0 );
		setHDFeedbackAttr( $descNode, "feedbackFurAccuracy", $mi, 0 );
	}
}

proc restoreFeedbackInfo(
	string	$feedback,
	string	$hairDesc,
	string	$mi
)
{
	int		$us, $vs, $ew, $eh, $cf, $da;
	float	$fa;

	if ( ($us = `getAttr ($hairDesc + ".feedbackUSamples[" + $mi + "]")`) == 0 ) {
		// initialize values
		//
		$us = $vs = 32;
		$ew = $eh = 256;
		$cf = true;
		$da = false;
		$fa = 1.0;
	} else {
		// get them from fur description
		//
		$vs = `getAttr ($hairDesc + ".feedbackVSamples[" + $mi + "]")`;
		$ew = `getAttr ($hairDesc + ".feedbackExportWidth[" + $mi + "]")`;
		$eh = `getAttr ($hairDesc + ".feedbackExportHeight[" + $mi + "]")`;
		$cf = `getAttr ($hairDesc + ".feedbackColorEnabled[" + $mi + "]")`;
		$da = `getAttr ($hairDesc + ".feedbackDrawAttractors[" + $mi + "]")`;
		$fa = `getAttr ($hairDesc + ".feedbackFurAccuracy[" + $mi + "]")`;
	}
	setFeedbackAttr($feedback,`feedbackUSamplesAttr`,$us);
	setFeedbackAttr($feedback,`feedbackVSamplesAttr`,$vs);
	setFeedbackAttr($feedback,"exportWidth",$ew);
	setFeedbackAttr($feedback,"exportHeight",$eh);
	setFeedbackAttr($feedback,"furAccuracy",$fa);
	setFeedbackAttr($feedback,"colorFeedbackEnabled",$cf);
	setFeedbackAttr($feedback,"drawAttractors",$da);
}

proc string feedbackHairDescPlug(
	string	$feedback
)
{
	if ( $feedback != "" ) {
		return ($feedback + "." + feedbackDefaultAttr("Inclination"));
	} else {
		return "";
	}
}

proc string getHairDescFromFeedback(
	string	$feedback
)
{
	string	$hfPlug = feedbackHairDescPlug( $feedback );

	if ( $hfPlug != "" ) {
		return plugNode( getSrcPlug( $hfPlug ) );
	} else {
		return "";
	}
}

proc string feedbackAttractorSetPlug(
	string	$feedback
)
{
	if ( $feedback != "" ) {
		return ($feedback + "." + feedbackDefaultAttr("Influence"));
	} else {
		return "";
	}
}

proc string feedbackCurveAttractorSetPlug(
	string	$feedback
)
{
	if ( $feedback != "" ) {
		return ($feedback + "." + feedbackDefaultAttr("CurveInfluence"));
	} else {
		return "";
	}
}

proc string getAttractorSetFromFeedback(
	string	$feedback
)
{
	string	$asPlug = feedbackAttractorSetPlug( $feedback );

	if ( $asPlug != "" ) {
		return plugNode( getSrcPlug( $asPlug ) );
	} else {
		return "";
	}
}

proc string getCurveAttractorSetFromFeedback(
	string	$feedback
)
{
	string	$asPlug = feedbackCurveAttractorSetPlug( $feedback );

	if ( $asPlug != "" ) {
		return plugNode( getSrcPlug( $asPlug ) );
	} else {
		return "";
	}
}

proc int removeHairFeedbackFromSurfaces(
	string	$surfaces[],
	string	$hairDesc		// hair feedback for this hair description
)
{
	string	$tag = "removeHairFeedback";
	string	$feedbackNodes[];
	int		$fbi = 0;
	string	$s;
	string	$members[], $m;
	int		$multiIndexes[], $mi;

	for ( $s in $surfaces ) {
		HfTDebug($tag,"processing " + $s);

		string	$srfPaths[2];
		string	$feedback;

		getTransformAndShape( $s, $srfPaths );		
		if ( $srfPaths[1] != "" ) {
			string $attachedFeedbacks[];
			$attachedFeedbacks = getFurFeedbackNodes( $srfPaths[1] );
			for ($feedback in $attachedFeedbacks) {
				string	$hd = getHairDescFromFeedback( $feedback );
				
				if ( size( $hairDesc ) > 0 ) {
					if ( $hd != $hairDesc ) {
						continue;
					}
				}
				$feedbackNodes[$fbi++]=$feedback;
				
				// store various aspects of feedback node with the hair description
				// so they will be used the next time a feedback node is attached
				//
				getHairSetMembers( $hd, $members, $multiIndexes );
				$mi = 0;
				for ( $m in $members ) {
					if ( $m == $srfPaths[0] || $m == $srfPaths[1] ) {
						saveFeedbackInfo($feedback, $hd, $multiIndexes[$mi] );
						break;
					}
					$mi++;
				}
			}
		}
	}

	// delete all the feedback nodes found
	//
	int	 $succeeded = true;

	for ( $s in $feedbackNodes ) {
		if ( ! `HfDeleteHairFeedbackNode( $s )` ) {
			$succeeded = false;
		}
	}

	return $succeeded;
}

proc int removeHairFeedbackFromSurface(
	string	$surface,
	string	$hairDesc
)
{
	string	$surfaces[];

	$surfaces[0] = $surface;
	return removeHairFeedbackFromSurfaces( $surfaces, $hairDesc );
}

proc string getSurfaceShapeFromFeedback(string $feedback)
{
	string $retName = "";
	
	// Check if Fur is connected to Nurbs surface.
	//
	string $srcPlug = getSrcPlug ($feedback+".inputSurface");
	if ( $srcPlug == "" ) {
		// Check if Fur is connected to poly surface.
		//
		$srcPlug = getSrcPlug ($feedback+".inputMesh");
		if ( $srcPlug == "" ) {
			// Check if Fur is connected to SubD surface.
			//
			$srcPlug = getSrcPlug ($feedback+".inputSubdiv");
		}
	}
	
	if ( $srcPlug != "" ) {
		string $node;
		$node = plugNode($srcPlug);
		if ( `nodeType $node` == "nurbsSurface" ||
			 `nodeType $node` == "mesh" ||
			 `nodeType $node` == "subdiv" ) {
			$retName = $node;
		}
	} 
	return $retName;
}

proc getAllFurFeedback(
	string	$hairDescriptions[],
	int		$assignedToSelected
)
{
	string	$selected[];
	if ( $assignedToSelected ) {
		getSelectedFurShapes( $selected );
		if ( size( $selected ) == 0 ) {
			clear( $hairDescriptions );
			return;
		}
	} else {
		clear( $selected );
	}

	string $selectedSurfaces[];
	for($furFeedback in $selected)
	{
		string $surface = getSurfaceShapeFromFeedback($furFeedback);
		$selectedSurfaces[size($selectedSurfaces)]= $surface;				 
	}

	select -replace $selectedSurfaces;

	getAllDescriptions(
		getHairGlobalsHDListPlug(false), $hairDescriptions,
		$selectedSurfaces
	);
}

proc startHFScriptJobs(
	string	$hf
)
{
	string	$tag = "HFScriptJobs";

	HfTDebug($tag,"start script jobs for " + $hf);

	// connect a script job to one of the feedback attributes so that
	// hair description deletion can be detected
	//
	string	$watchPlug = feedbackHairDescPlug( $hf );
	string	$script = "HfFeedbackInputChanged " + $watchPlug;

	HfTDebug($tag,"adding scriptJob:" + $script);
	addAttrChangedScriptJob( `scriptJob -ac $watchPlug $script` );

	// connect a script job to one of the feedback attributes so that
	// attractor set deletion can be detected
	//
	$watchPlug = feedbackAttractorSetPlug( $hf );
	$script = "HfFeedbackInputChanged " + $watchPlug;

	HfTDebug($tag,"adding scriptJob:" + $script);
	addAttrChangedScriptJob( `scriptJob -ac $watchPlug $script` );

	// attach a script job to the inputSurface attribute of the feedback
	// node which is used to determine if the surface to which it is connected
	// is deleted
	//
	$watchPlug = feedbackInputSurfacePlug( $hf );
	$script = "HfFeedbackInputChanged " + $watchPlug;

	HfTDebug($tag,"adding scriptJob:" + $script);
	addAttrChangedScriptJob( `scriptJob -cu true -ac $watchPlug $script` );

	// attach script jobs to sample size attributes so that we can detect when they change
	//
	$watchPlug = feedbackUSamplesPlug($hf);
	$script = "HfFeedbackSampleSizeChanged " + $watchPlug;
	HfTDebug($tag,"adding scriptJob:" + $script);
	addAttrChangedScriptJob( `scriptJob -ac $watchPlug $script` );

	$watchPlug = feedbackVSamplesPlug($hf);
	$script = "HfFeedbackSampleSizeChanged " + $watchPlug;
	HfTDebug($tag,"adding scriptJob:" + $script);
	addAttrChangedScriptJob( `scriptJob -ac $watchPlug $script` );

	// attach script jobs to exportWrapThreshold so that we can detect when they change
	//
	$watchPlug = feedbackExportWrapThresholdPlug($hf);
	$script = "HfExportThreshold " + $watchPlug;
	HfTDebug($tag,"adding scriptJob:" + $script);
	addAttrChangedScriptJob( `scriptJob -ac $watchPlug $script` );
}

proc addPolarOffsetToFeedback(
	string	$feedbackNode,
	string	$offsetPlug
)
{
	string	$tag = "offsetHairAngle";
	string	$polarDstPlug=$feedbackNode + "." + feedbackDefaultAttr("Polar");
	string	$polarSrcPlug=`connectionInfo -sfd $polarDstPlug`;

	if ( $polarSrcPlug != "" ) {
		HfTDebug( $tag, "disconnecting " + $polarSrcPlug + " from " + $polarDstPlug);
		if ( `checkAndDisconnectAttr $polarSrcPlug $polarDstPlug` ) {
			string	$expressionStr
				= $polarDstPlug
				+ "=fmod(" + $polarSrcPlug + "+" + $offsetPlug
				+ ",1.0);";
			HfTDebug( $tag, "creating expression " + $expressionStr);
			expression -string $expressionStr;
		} else {
			string $plugNodeValue =  plugNode( $polarSrcPlug );
			string $warnMsg = (uiRes("m_FurPluginCreateUI.kFurPolarWarn"));
			warning(`format -s $plugNodeValue $warnMsg`);
		}
	}
}

//addDebugTag( "connectToHF" );

proc connectToHFAttrs(
	string	$hairDesc,
	int		$multiIndex,
	string	$hairFeedback,
	string	$baseAttrName
)
{
	string	$tag = "connectToHF";

	// check if the attribute has been added
	int $found = false;
	string $attr = hairDefaultAttr($baseAttrName);
	string $attrList[];
	$attrList = `listAttr $hairDesc`;
	for( $a in $attrList )
	{
		if( $a == $attr )
		{
			$found = true;
			break;
		}
	}

	if( $found )
	{
		// connect default and map attributes
		//
		connectAttr 
			($hairDesc + "." + hairDefaultAttr($baseAttrName))
			($hairFeedback + "." + feedbackDefaultAttr($baseAttrName));
		HfTDebug($tag," " + hairDefaultAttr($baseAttrName)); 
		connectAttr(
			($hairDesc + "." + hairMapsAttr($baseAttrName) + "[" + $multiIndex + "]"),
			($hairFeedback + "." + feedbackMapAttr( $baseAttrName ))
			);
		HfTDebug($tag," " + hairMapsAttr($baseAttrName) + "[" + $multiIndex + "]"); 
		
		// if the mapOffset attribute exists, connect mapOffset and mapMult
		//
		string	$attr = hairMapOffsetAttr($baseAttrName);
		
		if ( `attributeQuery -exists -n $hairDesc $attr` ) {
			connectAttr 
				($hairDesc + "." + $attr)
				($hairFeedback + "." + $attr);
			HfTDebug($tag," " + $attr);
			$attr = hairMapMultAttr($baseAttrName);
			connectAttr 
				($hairDesc + "." + $attr)
				($hairFeedback + "." + $attr);
			HfTDebug($tag," " + $attr);
		}
		
		$attr = hairNoiseAttr($baseAttrName);
		if ( `attributeQuery -exists -n $hairDesc $attr` ) {
			connectAttr 
				($hairDesc + "." + $attr)
			($hairFeedback + "." + $attr);
			HfTDebug($tag," " + $attr);
			$attr = hairNoiseFreqAttr($baseAttrName);
			connectAttr 
				($hairDesc + "." + $attr)
				($hairFeedback + "." + $attr);
			HfTDebug($tag," " + $attr);
		}
	}
}

proc disconnectHFAttr(
	string	$sourceNode,	// empty if don't care
	string	$feedback,
	string	$attr
)
{

	if ( `attributeQuery -exists -n $feedback $attr` ) {
		string	$source, $dest;

		// disconnect default and map attributes
		//
		$dest=$feedback + "." + $attr;
		$source=`connectionInfo -sfd $dest`;
		if ( $source != "" && ( $sourceNode == "" || $sourceNode == plugNode( $source ) ) ) {
			checkAndDisconnectAttr($source,$dest);
		}
	}
}

proc disconnectHFAttrs(
	string	$sourceNode,	// empty if don't care
	string	$hairFeedback,
	string	$baseAttrName
)
{
	// check if the attribute has been added
	int $found = false;
	string $attr = hairDefaultAttr($baseAttrName);
	string $attrList[];
	$attrList = `listAttr $hairFeedback`;
	for( $a in $attrList )
	{
		if( $a == $attr )
		{
			$found = true;
			break;
		}
	}

	if( $found )
	{
		disconnectHFAttr ( $sourceNode,  $hairFeedback, feedbackDefaultAttr($baseAttrName) ); 

		disconnectHFAttr ( $sourceNode,  $hairFeedback, feedbackMapAttr($baseAttrName) ); 
		disconnectHFAttr ( $sourceNode,  $hairFeedback, hairMapOffsetAttr($baseAttrName) ); 
		disconnectHFAttr ( $sourceNode,  $hairFeedback, hairMapMultAttr($baseAttrName) ); 

		disconnectHFAttr ( $sourceNode,  $hairFeedback, hairNoiseAttr($baseAttrName) ); 
		disconnectHFAttr ( $sourceNode,  $hairFeedback, hairNoiseFreqAttr($baseAttrName) ); 
	}
}

proc connectToHF(
	string	$node,			// node to connect from
	int		$source,		// source type to connect
	int		$mi,			// multi index in hair description maps
	string	$hf				// hair feedback
)
{
	global string	$HfFeedbackAttributes[];
	global int		$HfFeedbackAttributeSource[];
	
	int		$numFeedbackAttrs=size($HfFeedbackAttributes);
	int		$n;

	HfTDebug("connectToHF","Connecting " + $node + "[" + $mi + "] to " + $hf);

	for ( $n = 0; $n < $numFeedbackAttrs; $n++ ) {
		// if the source for this feedback attribute matches the passed
		// source, then connect it up
		//
		if ( $HfFeedbackAttributeSource[$n] == $source ) {
			connectToHFAttrs( $node, $mi, $hf, $HfFeedbackAttributes[$n] );
		}
	}
}

proc disconnectFromHF(
	string	$sourceNode,	// source node to disconnect, empty if don't care
	int		$sourceType,	// source type to disconnect
	string	$hf				// hair feedback
)
{
	global string	$HfFeedbackAttributes[];
	global int		$HfFeedbackAttributeSource[];
	
	int		$numFeedbackAttrs=size($HfFeedbackAttributes);
	int		$n;

	for ( $n = 0; $n < $numFeedbackAttrs; $n++ ) {
		// if the source for this feedback attribute matches the passed
		// source, then connect it up
		//
		if ( $HfFeedbackAttributeSource[$n] == $sourceType ) {
			disconnectHFAttrs( $sourceNode, $hf, $HfFeedbackAttributes[$n] );
		}
	}
}

proc connectHDToHF(
	string	$hd,			// hair description
	int		$mi,			// multi index in hair description maps
	string	$hf				// hair feedback
)
{
	string	$hdScalePlug = hairGlobalScalePlug( $hd );
	string	$hfScalePlug = feedbackHairGlobalScalePlug( $hf );

	HfTDebug("connectToHF","Connecting " + $hdScalePlug + " to " + $hfScalePlug);
	connectAttr $hdScalePlug $hfScalePlug;
	connectToHF( $hd, 0, $mi, $hf );
}

proc connectASToHF(
	string	$as,			// attractor set
	int		$mi,			// multi index in hair description maps
	string	$hf				// hair feedback
)
{
	string	$asScalePlug = attractorGlobalScalePlug( $as );
	string	$hfScalePlug = feedbackAttractorGlobalScalePlug( $hf );

	HfTDebug("connectToHF","Connecting " + $asScalePlug + " to " + $hfScalePlug);
	connectAttr $asScalePlug $hfScalePlug;

	connectToHF( $as, 1, $mi, $hf );
}

proc connectCASToHF(
	string	$as,			// attractor set
	int	$mi,			// multi index in hair description maps
	string	$hf			// hair feedback
)
{
	string	$asScalePlug = curveAttractorGlobalScalePlug( $as );
	string	$hfScalePlug = feedbackCurveAttractorGlobalScalePlug( $hf );

	HfTDebug("connectToHF","Connecting " + $asScalePlug + " to " + $hfScalePlug);
	connectAttr $asScalePlug $hfScalePlug;

	connectToHF( $as, 2, $mi, $hf );
}


proc disconnectASFromHF(
	string	$as,			// attractor set, empty string if don't care
	string	$hf				// hair feedback
)
{
	string	$hfScalePlug = feedbackAttractorGlobalScalePlug( $hf );
	string	$asScalePlug = getSrcPlug( $hfScalePlug );

	if ( $asScalePlug != "" && ( $as == "" || $as == plugNode( $asScalePlug ) ) ) {
		checkAndDisconnectAttr($asScalePlug,$hfScalePlug);
	}

	disconnectFromHF( $as, 1, $hf );
}

proc disconnectCASFromHF(
	string	$as,			// attractor set, empty string if don't care
	string	$hf				// hair feedback
)
{
	string	$hfScalePlug = feedbackCurveAttractorGlobalScalePlug( $hf );
	string	$asScalePlug = getSrcPlug( $hfScalePlug );
	if ( $asScalePlug != "" && ( $as == "" || $as == plugNode( $asScalePlug ) ) ) {
		checkAndDisconnectAttr($asScalePlug,$hfScalePlug);
	}
	disconnectFromHF( $as, 2, $hf );
}
proc connectSrfToHF( 
	string $shape, 
	string $feedbackNodeName 
)
{
	int $rc = HFcheckEqualizerAttr($shape);
	if( $rc == 0 )
	{
		return;
	}
	else if( $rc == 1 )
	{
		addAttr -dt "string" -ln "equalizerMap" -sn "emp" $shape;
	}

	string $srcPlug = $shape + ".emp";
	string $dstPlug = $feedbackNodeName + ".EqualizerMap";
	connectAttr $srcPlug $dstPlug; 
	return;
}

proc string getFlipNormalsPlug(
	string	$shape,
	int		$makeOne
)
{
	string	$tag = "flipHairNormals";
	string	$flipAttr=`buildFurFiles -fna`;
	string	$attr[]=`listAttr -st $flipAttr $shape`;
	string	$flipPlug = $shape + "." + $flipAttr;

	if ( size( $attr ) == 0 ) {
		if ( $makeOne ) {
			HfTDebug( $tag, "adding attribute " + $flipAttr + " to " + $shape);
			addAttr -at bool -ln $flipAttr -dv false $shape;

			// if this shape is connected to a feedback node we have to connect
			// this attribute to it
			//
			string  $feedbackNodes[];
			string	$feedbackNode;
			$feedbackNodes = getFurFeedbackNodes( $shape );

			for ($feedbackNode in $feedbackNodes) {
				if ( $feedbackNode != "" ) {
					HfTDebug( $tag, "connecting " + $flipPlug + " to " + $feedbackNode);
					connectAttr	$flipPlug ($feedbackNode + ".flipNormals");
				}
			}
		} else {
			$flipPlug = "";
		}
	}

	return $flipPlug;
}

//addDebugTag("maps");

proc resetMapBaseName()
{
	global string	$HfCurMapBaseName;

	$HfCurMapBaseName = "";
}

resetMapBaseName();

proc string getMapBaseName( int $enableAsking )
{
	string	$tag = "maps";

	string	$basename = HfGetSceneName();
	string	$temp;
	int		$base_len;
	int		$gotBasename = false;

	global string	$HfCurMapBaseName;

	// strip off directories and suffix
	//
	if ( $basename != "" ) {
		HfTDebug( $tag, "basename = " + $basename );
		$basename = match( "[^/]*[^/]$", $basename );
		HfTDebug( $tag, "basename after directory strip = " + $basename );
		$temp = match( "\\.[^.]*[^.]$", $basename );
		HfTDebug( $tag, "suffix = " + $temp );
		$base_len = size($basename) - size($temp);
		if ( $base_len > 0 ) {
			$gotBasename = true;
		}
	}

	if ( $gotBasename && size($temp) > 0 ) {
		$basename = substring( $basename, 1, $base_len );
	}
	if ( $gotBasename && size( $basename ) == 0 ) {
		$gotBasename = false;
	}
	string $ok     = (uiRes("m_FurPluginCreateUI.kOk"));
	string $cancel = (uiRes("m_FurPluginCreateUI.kCancel"));
	if ( ! $gotBasename ) { 
		if ( $HfCurMapBaseName != "" ) {
			// use any previous base name
			//
			$basename = $HfCurMapBaseName;
		} else if ( $enableAsking && ! `inBatchMode` ) {
			string  $msg = (uiRes("m_FurPluginCreateUI.kBaseNameMessage"));
			string	$response=`promptDialog -title (uiRes("m_FurPluginCreateUI.kEnterMapBasename"))
				-message $msg
				-button $ok -defaultButton $ok -button $cancel -cancelButton $cancel`;
			if ( $response == $ok ) {
				$basename=`promptDialog -q -text`;
			}
		}
	}

	$HfCurMapBaseName = $basename;
	return $basename;
}

proc string getMapNameForAttr(
	string	$surfaceName,
	string	$attrNode,
	string	$attrName,
	int		$ask,
        string $frame
)
{
	string	$tag = "maps";

	HfTDebug($tag,"in getMapNameForAttr(" + $surfaceName + "," + $attrNode + "," + $attrName + ")");

	// setup the project
	HfCheckProjectDir();

	string	$dir = getProjectDir( "fileRule", "furAttrMap" );
	string	$temp;
	string	$mapName;
	string	$basename = getMapBaseName( $ask );

	if ( $basename == "" ) {
		string $warningMsg = (uiRes("m_FurPluginCreateUI.kBaseNameWarn")); 
		warning( `format -s $attrName  $warningMsg` );
		return "";
	}

	$surfaceName=standardName($surfaceName);
	if ( size( $surfaceName ) == 0 ) {
		string $warningMsg = (uiRes("m_FurPluginCreateUI.kMapWarning"));
		warning( `format -s $attrName -s $surfaceName $warningMsg`);
		return "";
	}

	// massage the surface name if a path was required to resolve ambiguity
	//
	$surfaceName=replaceCharacterInString( $surfaceName, "|", "_" );

	// Also take out all of the ':'s from all of the names
	$surfaceName=replaceCharacterInString( $surfaceName, ":", "_" );
	$attrNode=replaceCharacterInString( $attrNode, ":", "_" );
	$attrName=replaceCharacterInString( $attrName, ":", "_" );

	$mapName = $dir;
	$temp = substring( $dir, size($dir), size($dir) );
	if ( $temp != "/" ) {
		$mapName += "/";
	}
	if($frame == "")	     
		$mapName += $basename
			 + "_" + $surfaceName
			 + "_" + $attrNode
			 + "_" + $attrName
			 + ".iff"; 
	else
		$mapName += $basename
			 + "_" + $attrNode
			 + "_" + $attrName
			 + "." + $frame
			 + ".iff"; 

	return $mapName;
}

proc setMapNamesForSurfaces(
	string	$surfaces[],
	string	$attrName
)
{
	string	$tag = "maps";
	string	$s;
	string	$feedbackMapAttr = feedbackMapAttr( $attrName );

	for ( $s in $surfaces ) {
		HfTDebug($tag, "setMapNamesForSurfaces checking surface " + $s);

		string $furDesc;
		string $feedback;
		if(`optionMenuGrp -q -ex hairDescMenu` && `optionMenuGrp -q -numberOfItems hairDescMenu` != 0)
			$furDesc = `optionMenuGrp -q -value hairDescMenu`;

		if( size($furDesc) != 0 && $furDesc != "None" )
			$feedback = getFurFeedbackNode( $s,$furDesc);
		
		if(size($feedback) == 0)
			$feedback = getHairFeedbackNode( $s );		
		
		if ( $feedback != "" ) {
			string $mapAttrPlug = $feedback + "." + $feedbackMapAttr;
			string $mapName = getMapFile( $mapAttrPlug );

			if ( size( $mapName ) == 0 ) {
				string	$hdMapAttrPlug = `connectionInfo -sfd $mapAttrPlug`;

				if ( $hdMapAttrPlug != "" ) {
					HfTDebug($tag, "setting " + $hdMapAttrPlug + " to " + "UNNAMED");
					setMapFile( $hdMapAttrPlug, "UNNAMED" );
				}

				string	$dirtyPlug = $feedback + "."
								   + feedbackSamplesDirtyAttr($attrName);
				int		$dirty = `getAttr $dirtyPlug`;

				setAttr $dirtyPlug 0;
				HfTDebug($tag, $dirtyPlug + " was " + $dirty + ", set to 0");
				$dirtyPlug = $feedback + "." + feedbackMapDirtyAttr($attrName);
				$dirty = `getAttr $dirtyPlug`;
				setAttr $dirtyPlug 0;
				HfTDebug($tag, $dirtyPlug + " was " + $dirty + ", set to 0");
			}
		}
	}
}

proc updateDirtyMapsForSurface(
	string	$surface
)
{
	string	$tag = "maps"; 
	string $furDesc;
	string $feedbacks[];

	if(`optionMenuGrp -q -ex hairDescMenu` && `optionMenuGrp -q -numberOfItems hairDescMenu` != 0)
		$furDesc = `optionMenuGrp -q -value hairDescMenu`;

	if( size($furDesc) != 0 && $furDesc != "None" )
		$feedbacks[0] = getFurFeedbackNode( $surface,$furDesc);
	
	if(size($feedbacks) == 0)
		$feedbacks  = getFurFeedbackNodes( $surface );

	if ( $feedbacks[0] == "" ) {
		return;
	}


	global string $HfFeedbackAttributes[];

	int	$numFeedbackAttrs = size($HfFeedbackAttributes);
	int	$n;
    for ( $feedback in $feedbacks ) {
	HfTDebug($tag, "updateDirtyMapsFor " + $surface + " with feedback " + $feedback);
	for ( $n = 0; $n < $numFeedbackAttrs; $n++ ) {
		string	$attrName = $HfFeedbackAttributes[$n];
		string	$samplesDirtyPlug = $feedback + "." + feedbackSamplesDirtyAttr( $attrName );
		string	$mapDirtyPlug = $feedback + "." + feedbackMapDirtyAttr( $attrName );

		if ( `getAttr $samplesDirtyPlug` ) {
			// move the dirty'ness to the map dirty plug
			//
			HfTDebug($tag, $samplesDirtyPlug + " is set");
			setAttr $mapDirtyPlug 1;
			setAttr $samplesDirtyPlug 0;
		} else if ( ! `getAttr $mapDirtyPlug` ) { 
			string	$mapAttrPlug = $feedback + "." + feedbackMapAttr( $attrName );
			string	$mapName = getMapFile( $mapAttrPlug );
		
			if ( $mapName == "UNNAMED" ) {
				// if it isn't dirty and the map was unnamed, clear it out
				//
				string	$hdMapAttrPlug = `connectionInfo -sfd $mapAttrPlug`;

				if ( $hdMapAttrPlug != "" ) {
					HfTDebug($tag,"clearing " + $hdMapAttrPlug);
					setMapFile( $hdMapAttrPlug, "" );
				}
			}
		}
	}
	}
}

proc int getDirtyMapsForSurface(
	string	$surface,
	int		$index,
	string	$surfaces[],
	string	$feedbackNodes[],
	string	$attrNames[],
	string	$mapAttrPlugs[]
)
{
	string	$tag = "maps";
	string $furDesc;
	string $feedbacks[];
	$feedbacks = getFurFeedbackNodes( $surface );

	if ( $feedbacks[0] == "" ) {
		return $index;
	}

	global string $HfFeedbackAttributes[];

	int	$numFeedbackAttrs = size($HfFeedbackAttributes);
	int	$n;

    for ( $feedback in $feedbacks ) {
	HfTDebug($tag, "getDirtyMapsFor " + $surface + " with feedback " + $feedback);
	for ( $n = 0; $n < $numFeedbackAttrs; $n++ ) {
		string	$attrName = $HfFeedbackAttributes[$n];
		string	$mapAttrPlug = $feedback + "." + feedbackMapAttr( $attrName );
		string	$hdMapAttrPlug = `connectionInfo -sfd $mapAttrPlug`;
		string	$mapDirtyPlug = $feedback + "." + feedbackMapDirtyAttr( $attrName );
		string	$samplesDirtyPlug = $feedback + "." + feedbackSamplesDirtyAttr( $attrName );
		string	$mapName = getMapFile( $mapAttrPlug );

		global string	$HfPossiblyPaintedSurfaces[];

		// the map is dirty if the mapDirty flag is set or if we are in the middle of
		// painting hair attributes and the samplesDirty flag is set
		//
		int		$mapDirty =`getAttr $mapDirtyPlug`
						|| ( size($HfPossiblyPaintedSurfaces) > 0 && `getAttr $samplesDirtyPlug` );

		// if the map isn't dirty, check if the map file itself is missing or inaccessible
		//
		if ( !$mapDirty && $mapName != "UNNAMED" ) {
			string	$mapPath = HfGetFullImagePath( $mapName );
			if ( $mapPath == "" ) {
				int	$issueWarning = true;

				// don't issue warning if this is an equalizer map and equalizer
				// maps aren't being read
				//
				if ( $attrName == "Equalizer" )
				{ 
					string $hairGlobal = HfGetHairGlobal();

					if ( $hairGlobal != "" )
					{
						int	$em = `getAttr ($hairGlobal + ".equalMap")`;

						if ( $em != 2 )
						{
							$issueWarning = false;
						}
					}
				}

				if ( $issueWarning )
				{
					string $warningMsg = (uiRes("m_FurPluginCreateUI.kMapNameNotFoundWarn"));
					warning(`format -s $attrName -s $surface -s $mapName -s $feedback $warningMsg`);
				}
				$mapDirty = true;
			}
		}
		
		if ( $mapDirty ) {
			$surfaces[$index] = $surface;
			$feedbackNodes[$index] = $feedback;
			$attrNames[$index] = $attrName;
			$mapAttrPlugs[$index] = $hdMapAttrPlug;
			$index++;
		} else {
			// if it isn't dirty and the map was unnamed, clear it out
			//
			if ( $mapName == "UNNAMED"  && $hdMapAttrPlug != "" ) {
				HfTDebug($tag,"clearing " + $hdMapAttrPlug);
				setMapFile( $hdMapAttrPlug, "" );
			}
		}
	}
	}
	return $index;
}

proc string[] exportDirtyMapsName(
	string	$surfaces[]
)
{
	string	$s;
	string	$exportSurfaces[];
	string	$exportFeedbackNodes[];
	string	$exportAttrNames[];
	string	$exportMapAttrPlugs[];
	int		$numExports = 0;

	for ( $s in $surfaces ) {
		$numExports = getDirtyMapsForSurface(
			$s, $numExports,
			$exportSurfaces, $exportFeedbackNodes,
			$exportAttrNames, $exportMapAttrPlugs
		);
	}

	string $statements[];
	for ( $ne = 0; $ne < $numExports; $ne++ ) 
	{
		$statements[$ne] = $exportAttrNames[$ne] + " Map for "
			+ $exportSurfaces[$ne];
	}

	return $statements;
}

proc exportMaps(
	int		$numExports,
	string	$surfaces[],
	string	$feedbackNodes[],
	string	$attrNames[],
	string	$mapAttrPlugs[]
)
{
	string	$tag = "maps"; 

	HfTDebug($tag, "exportMaps(" + $numExports + ") called");

	for ( $ne = 0; $ne < $numExports; $ne++ ) {
		string	$attrName = $attrNames[$ne];
		string	$mapAttrPlug = $mapAttrPlugs[$ne];
		string	$feedback = $feedbackNodes[$ne];
		string	$surface = $surfaces[$ne];
		string	$mapDirtyPlug = $feedback + "." + feedbackMapDirtyAttr( $attrName );
		string	$samplesDirtyPlug = $feedback + "." + feedbackSamplesDirtyAttr( $attrName );
		string	$mapName = getMapFile( $mapAttrPlug );
		string	$exportFile = "";
		string	$exportFilePath = "";
		int		$newName = $mapName == "" || $mapName == "UNNAMED";
		
		// get the expected export file name for this attribute map
		// - equalizer maps are different, we never generate names
		//   for them, we just use whatever name they have
		//
		if ( $attrName != "Equalizer" && $newName) {
			$exportFile = getMapNameForAttr(
				$surface, plugNode( $mapAttrPlug ), $attrName, $newName, ""
			);
		}

		if ( $newName && $exportFile == "" ) {
			if ( $mapName == "UNNAMED" && $mapAttrPlug != "" ) {
				setMapFile( $mapAttrPlug, "" );
			}
			setAttr $mapDirtyPlug 0;
			setAttr $samplesDirtyPlug 0;
			continue;
		} else if ( $exportFile != "" ) {
			$exportFilePath = makeFullPath( $exportFile );
		} else {
			// use existing name
			//
			$exportFile = $mapName;
			$exportFilePath = HfGetFullImagePath( $exportFile );
		}

		if ( $exportFilePath == "" ) {
			continue;
		}
		
		string	$samplesAttr = feedbackSamplesAttr( $attrName );
		
		if($attrName == "Radius" ||
		   $attrName == "Power" ||
		   $attrName == "Influence" ||
		   $attrName == "StartLength" ||
		   $attrName == "EndLength" ||
		   $attrName == "ThresholdLength" ) 
		{
			float $setFeedbackSample[] =`getAttr ($feedback + "." + $samplesAttr)`;
		}
		
		HfTDebug($tag, " exporting " + $feedback + "." + $samplesAttr
			+ " to " + $exportFilePath);
		
		int		$mi = getMultiIndex( $mapAttrPlug );
		string	$mapUSamplesPlug, $mapVSamplesPlug;
		string	$fbUSamplesPlug, $fbVSamplesPlug;
		string $yes = (uiRes("m_FurPluginCreateUI.kYes"));
        string $cancel = (uiRes("m_FurPluginCreateUI.kCancel"));

		if ( $mi >= 0 ) {
			string	$hd = plugNode( $mapAttrPlug );

			$mapUSamplesPlug = $hd + "." + hairMapUSamplesAttr($attrName) + "[" + $mi + "]";
			$mapVSamplesPlug = $hd + "." + hairMapVSamplesAttr($attrName) + "[" + $mi + "]";
			$fbUSamplesPlug = feedbackRealUSamplesPlug($feedback);
			$fbVSamplesPlug = feedbackRealVSamplesPlug($feedback);

			// ask user before going ahead if:
			// 1) this file exists and wasn't generated by this plugin
			// 2) this file exists and it was previously generated from this
			//    plugin at a higher sampling frequency
			//
			string $confirm = (uiRes("m_FurPluginCreateUI.kConfirm"));
			if ( `filetest -r $exportFilePath` ) {
				int	 $mapUSamples = `getAttr $mapUSamplesPlug`;
				int	 $mapVSamples = `getAttr $mapVSamplesPlug`;
				string	$response = $yes;

				if ( $mapUSamples == 0 || $mapVSamples == 0 ) {
					HfTDebug(
						$tag,
						$surface + "'s " + $attrName + " attribute map file:\n" + $exportFilePath
					  + " has uninitialized sample size"
					);
					$response = $yes;
				} else {
					int	$fbUSamples = `getAttr $fbUSamplesPlug`;
					int	$fbVSamples = `getAttr $fbVSamplesPlug`;

					if ( $mapUSamples > $fbUSamples || $mapVSamples > $fbVSamples ) {
						if ( `inBatchMode` ) {
							$response = $cancel;	// take the safe approach
						} else {
								string $cancel = (uiRes("m_FurPluginCreateUI.kCancel"));
								string $msg = (uiRes("m_FurPluginCreateUI.kAttributeMapMsg"));
								$msg = `format -s $surface -s $attrName -s $exportFilePath -s $mapUSamples -s $mapVSamples -s $fbUSamples -s $fbVSamples $msg`;
								$response = `confirmDialog -title $confirm -ma "left"
								-button $yes -button $cancel -defaultButton $cancel
								-cancelButton $cancel -dismissString $cancel
								-message $msg`;
						}
					}
				}

				if ( $response != $yes ) {
					continue;
				}
			}
		}

		// Exporting is done by setting the ExportAttr attribute of the feedback node
		// to the attribute we want to export. The export is then triggered
		// by getting the ExportStatus attribute
		//
		setAttr -type "string" ($feedback + ".exportFile") $exportFilePath;
		setAttr -type "string" ($feedback + ".exportAttr") $samplesAttr;
		int $success=`getAttr ($feedback + ".exportStatus")`;
		HfTDebug($tag, $feedback + ".exportStatus=" + $success);
		
		// if the export file is different from saved name, set the name now
		//
		if ( $mapName != $exportFile ) {
			setMapFile( $mapAttrPlug, $exportFile );
		}
		
		if ( $success ) {
			setAttr $mapDirtyPlug 0;
			setAttr $samplesDirtyPlug 0;
			if ( $mapUSamplesPlug != "" && $fbUSamplesPlug != "" ) {
				int		 $uSamples = `getAttr $fbUSamplesPlug`;

				HfTDebug($tag, "setting " + $mapUSamplesPlug + " to " + $uSamples);
				setAttr $mapUSamplesPlug $uSamples;
			}
			if ( $mapVSamplesPlug != "" && $fbVSamplesPlug != "" ) {
				int		 $vSamples = `getAttr $fbVSamplesPlug`;

				HfTDebug($tag, "setting " + $mapVSamplesPlug + " to " + $vSamples);
				setAttr $mapVSamplesPlug $vSamples;
			}
		} else {
			string $warningMsg = (uiRes("m_FurPluginCreateUI.kExportFailureWarn"));
			warning( `format -s $attrName -s $surface $warningMsg`);
		} 
	}
}

proc exportDirtyMaps(
	string	$surfaces[]
)
{
	string	$tag="maps";
	string	$s;
	string	$exportSurfaces[];
	string	$exportFeedbackNodes[];
	string	$exportAttrNames[];
	string	$exportMapAttrPlugs[];
	int		$numExports = 0;

	for ( $s in $surfaces ) {
		$numExports = getDirtyMapsForSurface(
			$s, $numExports,
			$exportSurfaces, $exportFeedbackNodes,
			$exportAttrNames, $exportMapAttrPlugs
		);
		HfTDebug($tag, "getDirtyMapsForSurface(" + $s + "): numExports = " + $numExports);
	}

	exportMaps(
		$numExports,
		$exportSurfaces, $exportFeedbackNodes,
		$exportAttrNames, $exportMapAttrPlugs
	);
}

proc int getCopyAttrMapsVal( string $globalsNode )
{
	int $retVal = 0;

	if ( $globalsNode != "" &&
		 `objExists $globalsNode` &&
		 `attributeQuery -exists -node $globalsNode "copyAttrMaps"` )
	{
		$retVal = `getAttr ( $globalsNode + ".copyAttrMaps" )`;
	}

	return $retVal;
}

proc int getCopyAttrMapsValFromNode( string $node )
{
	string $globals = getConnectedFurGlobals( $node );
	return getCopyAttrMapsVal( $globals );
}

//addDebugTag("copyMaps");

proc copySharedDescriptionAttributeMaps(
	string	$d,
	string	$attributes[],
	int		$checkOnly
)
{
	string	$tag = "copyMaps";
	string	$a;
	string	$mappedSurfaces[];
	string	$mapFiles[], $mf;
	int		$mapIndexes[], $mi;
	string	$mapUSamplesPlug, $mapVSamplesPlug;
	int		$nMaps, $m, $mapUSamples, $mapVSamples;

	int $copyAttrMaps = getCopyAttrMapsVal( "defaultFurGlobals" );
	switch( $copyAttrMaps )
	{
	case 0:
		// 0 means if the node is referenced we don't worry about it
		if ( `isFromReferencedFile $d` ) {
			return;
		}
		break;
	case 1:
		// 1 means do as we used to - copy maps to new name, set attr to reflect this
		break;
	case 2:
		// 2 means never copy the attr maps.
		return;
	}

	for ( $a in $attributes ) {
		$mapPlug = $d + "." + hairMapsAttr($a);
		HfTDebug($tag, " check map plug " + $mapPlug );
		getMapped(
			$mapPlug, $mappedSurfaces, $mapFiles, $mapIndexes
		);
		$nMaps = size( $mapIndexes );
		for ( $m = 0; $m < $nMaps; $m++ ) {
			$mi = $mapIndexes[$m];
			$mapUSamplesPlug = $d + "." + hairMapUSamplesAttr($a) + "[" + $mi + "]";
			$mapVSamplesPlug = $d + "." + hairMapVSamplesAttr($a) + "[" + $mi + "]";
			$mapUSamples = `getAttr $mapUSamplesPlug`;
			$mapVSamples = `getAttr $mapVSamplesPlug`;

			HfTDebug($tag, "  check " + $a + " map for " + $mappedSurfaces[$m]);

			// check maps which were generated by us
			// - baked maps have sample sizes set to -1
			// - painted maps have smaple sizes > 0
			//
			if ( $mapUSamples != 0 && $mapVSamples != 0 ) {
				HfTDebug($tag, "   current map file is " + $mapFiles[$m]);

				string	$fromPath = HfGetFullImagePath( $mapFiles[$m] );

				if ( $fromPath != "" ) {
					if ( $checkOnly ) {
						continue;
					}

					string	$expectedMapFile = getMapNameForAttr(
						$mappedSurfaces[$m], $d, $a, false, ""
					);
					
					HfTDebug($tag, "   expected map file is " + $expectedMapFile);
					if ( $expectedMapFile != $mapFiles[$m] ) {
						string	$toPath = makeFullPath( $expectedMapFile );
												
						HfTDebug(
							$tag,
							"   possible sharing\n    copy: " + $fromPath
							+ "\n    to: " + $toPath
							);
						
						string	$copyCmd;
						
						if ( `about -win` ) {
							string	$dosFromPath = replaceCharacterInString( $fromPath, "/", "\\" );
							string	$dosToPath = replaceCharacterInString( $toPath, "/", "\\" );
							
							$copyCmd = "copy \"" + $dosFromPath + "\" \"" + $dosToPath + "\"";
						} else {
							$copyCmd = "/bin/cp \"" + $fromPath + "\" \"" + $toPath + "\"";
						}
						doSystem( $copyCmd, true );
						
						// change the map file
						// - don't use setMapFile since it resets all kinds of other
						//   stuff
						//
						HfTDebug($tag, "   setting " + $mapPlug + "[" + $mi + "] to " + $expectedMapFile );
						setAttr -type "string" ($mapPlug + "[" + $mi + "]") $expectedMapFile;
					}
				} else {
					string $warningMsg = (uiRes("m_FurPluginCreateUI.kMapNotFoundWarn"));
					warning( `format -s $d -s $a -s $mappedSurfaces[$m] -s $mapFiles[$m] $warningMsg` );
				}
			}
		}
	}
}

// this procedure goes through all the hair descriptions and attractors
// and copies any attribute map files that may be shared with another
// scene file
//
proc copySharedAttributeMaps(
	int		$checkOnly		// only check maps, don't copy
)
{
	string	$tag = "copyMaps";
	string	$descriptions[], $d;

	global string	$HfHairAttributes[];

	getAllHairDescriptions( $descriptions, false );
	for ( $d in $descriptions ) {
		HfTDebug($tag, "check hair description " + $d );
		copySharedDescriptionAttributeMaps( $d, $HfHairAttributes, $checkOnly ); 
	}

	global string	$HfAttractorAttributes[];

	getAllAttractorSets( $descriptions, false );
	for ( $d in $descriptions ) {
		HfTDebug($tag, "check attractor set " + $d );
		copySharedDescriptionAttributeMaps( $d, $HfAttractorAttributes, $checkOnly ); 
	}
}

//addDebugTag( "removeHairFeedback" );
//addDebugTag( "removeHFDisconnects" );

global proc int HfDeleteHairFeedbackNode(
	string	$feedbackNode
)
{
	string	$tag = "removeHairFeedback";

	if ( `isFromReferencedFile $feedbackNode` ) {
		string $warningMsg = (uiRes("m_FurPluginCreateUI.kRefenceFileDeletionWarn"));
		warning( `format -s $feedbackNode $warningMsg` );
		return false;
	}

	// Is there a surface and hair description attached? If so, check if any maps need to be saved
	//
	string	$inputSurface = feedbackInputSurface( $feedbackNode );
	string	$hairDesc = getHairDescFromFeedback( $feedbackNode );

	HfTDebug(
		$tag,
		"deleting feedback \"" + $feedbackNode + "\" with input surface \""
	  + $inputSurface + "\" and fur description \"" + $hairDesc + "\""
	);
	if ( $inputSurface != "" && $hairDesc != "" ) {
		string	$surfaces[];

		$surfaces[0] = $inputSurface;
		exportDirtyMaps( $surfaces );
	}
	
	// delete the node
	// 
	string	$parents[]=`listRelatives -allParents -pa $feedbackNode`;
	string	$p;
	int		$nparents = size( $parents );

	HfTDebug($tag,"Deleting feedback node " + $feedbackNode);
	if ( `checkAndDelete $feedbackNode` ) {
		// find all parent's parents
		//
		for ( $c = 0; $c < $nparents; $c++ ) {
			string	$pparents[]=`listRelatives -allParents -pa $parents[$c]`;

			for ( $p in $pparents ) {
				$parents[size($parents)]=$p;
			}
		}
		for ( $p in $parents ) {
			string	$children[]=`listRelatives -children $p`;

			if ( size( $children ) == 0 ) {
				HfTDebug($tag,"Deleting child-less parent " + $p);
				checkAndDelete $p;
			}
		}
		//Update Fur/UV Linking Relationship Editor.
		HfUpdateFurUVEditor;
		return true;
	} else {
		return false;
	}
}

addDebugTag("feedbackNodeChanged");

global proc HfFeedbackInputChanged(
	string	$feedbackPlug
)
{
	string	$tag="feedbackNodeChanged";

	HfTDebug($tag,$feedbackPlug + " has changed");

	// check if node is still called the same thing
	// - if there is no node of this name anymore, reset the attribute
	//   changed script jobs
	//
	string	$node;
	$node = plugNode( $feedbackPlug );
	
	if ( ! `objExists $node` ) {
		evalDeferred( "HfResetAttrChangedScriptJobs" );
		return;
	}

	// check if it still has something connected to it
	//
	string	$srcPlug = "";
	$srcPlug =`connectionInfo -sfd $feedbackPlug`;

	if ( $srcPlug == "" ) {
		string	$feedback=plugNode( $feedbackPlug );
		string	$attractorFeedbackPlug=feedbackAttractorSetPlug( $feedback );

		if ( $feedbackPlug == $attractorFeedbackPlug ) {
			HfTDebug($tag,$feedbackPlug + " is unconnected, disconnect attractor set connections");
			HfDisconnectASFromFeedback( "", $feedback );
		} else {
			HfTDebug($tag,$feedbackPlug + " is unconnected, delete " + $feedback);
			catch (`HfDeleteHairFeedbackNode ($feedback)`);
		}
	}
	HfHairPaintFeedbackCB();
}

global proc HfFeedbackSampleSizeChanged(
	string	$feedbackPlug
)
{
	string	$tag="feedbackNodeChanged";
	string	$hf = plugNode( $feedbackPlug );

	HfTDebug($tag,$feedbackPlug + " has changed");

	string	$uSamplesPlug = feedbackUSamplesPlug( $hf );
	string	$vSamplesPlug = feedbackVSamplesPlug( $hf );
	string	$realUSamplesPlug = feedbackRealUSamplesPlug( $hf );
	string	$realVSamplesPlug = feedbackRealVSamplesPlug( $hf );
	int		$uSamples = `getAttr $uSamplesPlug`;
	int		$vSamples = `getAttr $vSamplesPlug`;
	int		$realUSamples = `getAttr $realUSamplesPlug`;
	int		$realVSamples = `getAttr $realVSamplesPlug`;

	HfTDebug($tag,$uSamplesPlug + "=" + $uSamples + "," + $realUSamplesPlug + "=" + $realUSamples);
	HfTDebug($tag,$vSamplesPlug + "=" + $vSamples + "," + $realVSamplesPlug + "=" + $realVSamples);

	if ( $uSamples != $realUSamples || $vSamples != $realVSamples ) {
		string	$inputSurface = feedbackInputSurface( $hf );
		string	$hairDesc = getHairDescFromFeedback( $hf );

		if ( $inputSurface != "" && $hairDesc != "" ) {
			string	$surfaces[];

			$surfaces[0] = $inputSurface;
			HfTDebug( $tag,"exporting dirty maps for " + $inputSurface );
			exportDirtyMaps( $surfaces );
		}

		// now set the real sample size attribute
		//
		string	$changedAttr = plugAttr( $feedbackPlug );

		if ( $changedAttr == `feedbackUSamplesAttr` ) {
			HfTDebug( $tag,"setting " + $realUSamplesPlug + " to " + $uSamples);
			setAttr $realUSamplesPlug $uSamples;
			string $members[];
                        int $multiIndexes[];
                        getHairSetMembers( $hairDesc,$members,$multiIndexes);
    
			int $i;
			for( $i=0; $i< size($members); $i++ )
			{
				if($inputSurface == $members[$i] )
				{
					saveFeedbackInfo($hf,$hairDesc, $multiIndexes[$i]);
					break;
				}
			}

		} else {
			HfTDebug( $tag,"setting " + $realVSamplesPlug + " to " + $vSamples);
			setAttr $realVSamplesPlug $vSamples;
			string $members[];
                        int $multiIndexes[];
                        getHairSetMembers( $hairDesc,$members,$multiIndexes);
    
			int $i;
			for( $i=0; $i< size($members); $i++ )
			{
				if($inputSurface == $members[$i] )
				{
					saveFeedbackInfo($hf,$hairDesc, $multiIndexes[$i]);
					break;
				}
			}
		}
	}
}

proc getHairSetMembersUVSet(
	string	$hairAttrPlug,
	string	$members[],
	int		$multiIndexes[]
)
{
	string	$tag = "getHairSetMembers";

	HfTDebug( $tag, ("in getHairSetMembersUVSet(" + $hairAttrPlug + ")") );

	string	$hairSet = plugNode( $hairAttrPlug );
	string	$uvSetNames[] = `listAttr -m -st "uvSetName" $hairSet`;
	string	$usn, $m, $s;
	int		$mi = 0;

	clear( $members );
	clear( $multiIndexes );

	for ( $usn in $uvSetNames ) {
		HfTDebug( $tag, "checking " + $usn );

		int		$multiIndex = getMultiIndex( $usn );
		
		$m = getSrcPlug($hairSet + "." + $usn);
		if ( $m == "" ) {
			continue;
		}
		$m = plugNode( standardName( $m ) );
		if ( $m == "" ) {
			continue;
		}
		$s = $m;
		if ( `nodeType $s` == "transform" ) {
			$s = getChildShape( $s );
		}

		if (
			$s != ""
		 && ( `nodeType $s` == "nurbsSurface"
		   || `nodeType $s` == "mesh"
		   || `nodeType $s` == "subdiv" )
		) {
			$members[$mi] = standardName($m);
			$multiIndexes[$mi] = $multiIndex;
			HfTDebug( $tag, ( " " + $members[$mi] + " " + $multiIndexes[$mi]) );
			$mi++;
		}
	}
}

//addDebugTag("assignHDToSurface");

proc assignHDToSurface(
	string	$hairDescNode,
	string	$surface
)
{
	string	$tag = "assignHDToSurface";
	string	$members[];
	string	$m;
	int		$memberIndexs[];
	int		$lastMemberIndex = -1;
	int		$mi;
	string	$srfPaths[];

	getTransformAndShape( $surface, $srfPaths );
	HfTDebug($tag,"assign " + $hairDescNode + " to " + $srfPaths[0] + "(" + $srfPaths[1] + ")");
	
	// don't allow hair descriptions to be assigned to mesh's that have no UVs
	//
	if ( `nodeType $srfPaths[1]` == "mesh" ) {
		string	$uvAttr = $srfPaths[1] + ".uvpt";

		if ( `getAttr -s $uvAttr` <= 0 ) {
			string $warningMsg = (uiRes("m_FurPluginCreateUI.kNoUVWarning"));
			warning( `format -s $srfPaths[0] $warningMsg` );
			return;
		}

		// Fur description is attached to Fur UV set when Fur is linked to non-current UV.
		
		//get "uvSetName" attributes of $surface
		string $allAttr[] = `listAttr -m -st "uvSetName" $surface`;
		//get current UV set ID
		int $nCurrIndex = HfGetCurrentUVsetNumber($surface);

		//Check the connection between Fur Descriptions and non current UV.
		for( $nCount =0; $nCount < size($allAttr); $nCount++ )
		{
			if($nCurrIndex != $nCount)
			{
				string $strName = $surface +"."+$allAttr[$nCount] ;
				string $allConnection[];
				int $setFurUV = false;
	
				if(size(`connectionInfo -dfs $strName`) > 0 )
				{
					$allConnection = `connectionInfo -dfs $strName`;
				}
				else
				{
					continue;
				}
		
				for($nIndex =0; $nIndex < size($allConnection); $nIndex++)
				{
					if(`nodeType $allConnection[$nIndex]` == "FurDescription")
					{
						if(`isConnected $strName $allConnection[$nIndex]`)
						{
							string $strWar = `getAttr $strName`;
							string $currUVSet[] = `polyUVSet -currentUVSet -uvSet $strWar $surface`;
							$setFurUV = true;
 							break;
						}
					}
				}

				if( $setFurUV == true )
 				{
 					break;
				}
			}
		}
             
		//pop-up warning message if UVs are out of 0 to 1 space
		string $currUVSet[] = `polyUVSet -q -cuv $surface`;
		float $UVbbox[] =`polyEvaluate -b2 -uvSetName $currUVSet[0] $surface`;
		if($UVbbox[0] < -1e-5 || $UVbbox[1] > 1.0+1e-5 || $UVbbox[2] < -1e-5 || $UVbbox[3] > 1.0+1e-5 )
			warning (uiRes("m_FurPluginCreateUI.kFurRequisitionWarn")) ;
                
	}

	getHairSetMembers( $hairDescNode, $members, $memberIndexs );
	for ( $m in $members ) {
		HfTDebug($tag,"checking if " + $hairDescNode + " is already assigned to " + $m );

		if ( $m == $srfPaths[0] || $m == $srfPaths[1] ) {
			// already assigned
			//
			HfTDebug($tag,$hairDescNode + " is already assigned to " + $surface );
			return;
		}
	}

	for ( $mi in $memberIndexs ) {
		if ( ($mi - $lastMemberIndex) > 1 ) {
			// there is a gap in the indexs so stick
			// the surface there
			//
			break;
		}
		$lastMemberIndex = $mi;
	}

	$lastMemberIndex++;
	HfTDebug($tag,
			 ( "connecting " + $surface + " to "
			 + $hairDescNode + ".dsm[" + $lastMemberIndex + "]" ) );
	connectAttr ($surface + ".iog")
				($hairDescNode + ".dsm[" + $lastMemberIndex + "]");

	
	//Connecting UVSet and uvsn.
	if ( `nodeType $srfPaths[1]` == "mesh" && `nodeType $hairDescNode` == "FurDescription"  ) {

		$lastMemberIndex = -1;
		getHairSetMembersUVSet( $hairDescNode, $members, $memberIndexs );

		for ( $mi in $memberIndexs ) {
			if ( ($mi - $lastMemberIndex) > 1 ) {
				// there is a gap in the indexs so stick
				// the surface there
				//
				break;
			}
			$lastMemberIndex = $mi;
		}

		$lastMemberIndex++;

		int $nIndex = HfGetCurrentUVsetNumber($surface);

		if( $nIndex != -1 )
		{
			connectAttr ($surface +".uvSet["+$nIndex+"].uvSetName")
					($hairDescNode + ".uvsn[" + $lastMemberIndex + "]");
		}
	}
}

global proc int HfGetCurrentUVsetNumber(string $surface)
{
	//get all uv set for given surface
	string $allUVSet[]  = `polyUVSet -q -allUVSets $surface`;

	//get current uv set
	string $currUVSet[] = `polyUVSet -q -cuv $surface`;
	int $nIndex = -1;
	int $nCount;
	
	//get current uv set ID from all the uv sets
	for($nCount = 0; $nCount < size($allUVSet); $nCount++)
	{
		if( !strcmp($currUVSet[0],$allUVSet[$nCount]) )
		{
			$nIndex = $nCount;
			break;
		}
	}
	
	//infinite loop to match dependency node name and current UV set.
	if( $nIndex != -1 )
	{
		int $n;
		for($n=0; ; $n++)
		{
			string $depName;
			string $actualName;
			// get the dependency name for uv set.
			$depName = $surface + ".uvSet[" +$n+ "].uvSetName";
			// get an attribute for dependency node
			$actualName = `getAttr $depName`;
			
			if( !strcmp($currUVSet[0], $actualName ) )
			{
				$nIndex = $n;
				break;
			}
		}
	}

	return $nIndex;
}

proc unassignHDFromSurface(
	string	$hairDescNode,
	string	$surface,
	int		$deleteFeedback
)
{
	string	$tag = "assignHDToSurface";
	string	$members[];
	int		$memberIndexs[];
	int		$nMembers;
	int		$n;
	string	$srfPaths[];

	getTransformAndShape( $surface, $srfPaths );

	HfTDebug($tag,"unassign " + $hairDescNode + " from " + $srfPaths[0] + "(" + $srfPaths[1] + ")");

	//remove connection between uv set and fur description
	if(`nodeType $surface` == "mesh" )
	{
		//get "uvSetName" attributes of $polygonShapeNode
		string $allAttr[] = `listAttr -m -st "uvSetName" $surface`;
		
		//Check the availability of connection between UV set and Fur Descriptions
		for( $nCount =0; $nCount < size($allAttr); $nCount++ )
		{
			string $strName = $surface +"."+$allAttr[$nCount] ;
			string $allConnection[];

			if(size(`connectionInfo -dfs $strName`) > 0 )
			{
				$allConnection = `connectionInfo -dfs $strName`;
			}
			else
			{
				continue;
			}

			for($nIndex =0; $nIndex < size($allConnection); $nIndex++)
			{
				if(`nodeType $allConnection[$nIndex] ` == "FurDescription")
				{
					if( plugNode($allConnection[$nIndex]) != $hairDescNode )
					{
						continue;
					}
					if(`isConnected $strName $allConnection[$nIndex]`)
					{
						int $uvDisconnected;
						$uvDisconnected = checkAndDisconnectAttr($strName,$allConnection[$nIndex]);
						if(!$uvDisconnected)
						{
							string $warningMsg = (uiRes("m_FurPluginCreateUI.kStringAssignWarn"));
							warning( `format -s $strName -s $allConnection[$nIndex] $warningMsg` );
						}
					}
				}
			}
		}
	}
	getHairSetMembers( $hairDescNode, $members, $memberIndexs );
	$nMembers = size( $members );
	int $isFileTextureDeleted = false;
	for ( $n = 0; $n < $nMembers; $n++ ) {
		string	$sm = $members[$n];
		string	$assigned;

		HfTDebug($tag," checking against:" + $sm);

		if ( $srfPaths[0] == $sm || $srfPaths[1] == $sm ) {
			$assigned = $sm;
		} else {
			$assigned = "";
		}
		if ( $assigned != "" ) {
			int	$mi = $memberIndexs[$n];

			HfTDebug($tag,
					 ( "disconnecting " + $assigned + " from "
					 + $hairDescNode + ".dsm[" + $mi + "]" ) );
			int	$disconnected = checkAndDisconnectAttr(
									($assigned + ".iog"),
									($hairDescNode + ".dsm[" + $mi + "]")
								);
			if ( $disconnected ) {
				if ( $deleteFeedback ) {
					removeHairFeedbackFromSurface( $assigned, $hairDescNode );
					resetFeedbackInfo( $hairDescNode, $mi );
				}

				// make sure all the map entries are clear for this surface
				//
				string	$attrs[] = `listAttr -m $hairDescNode`;
				string	$a;

				for ( $a in $attrs ) {
					// does it have map in its name and if so is it a multi
					//
					int		$mmi;

					if ( gmatch( $a, "*Map*" ) && ($mmi = getMultiIndex( $a )) >= 0 && $mmi == $mi ) {
						string	$plug = $hairDescNode + "." + $a;
						string	$type = `getAttr -type $plug`;

						HfTDebug($tag,"plug " + $plug + " is of type " + $type);
						if ( $type == "string" ) {
							HfTDebug($tag,"clearing " + $plug + " to empty string");
							setAttr -type "string" $plug "";
						} else if ( $type == "long" ) {
							HfTDebug($tag,"clearing " + $plug + " to 0");
							setAttr $plug 0;
						}
					}
				}
				if($isFileTextureDeleted == false)
				{
					// Deleting expressions
					$attrs = `listAttr $hairDescNode`;
					string	$attr;
					for ( $attr in $attrs ) 
					{
						string	$defaultAttrPlug = $hairDescNode + "." + hairDefaultAttr($attr);
						if ( `objExists $defaultAttrPlug` ) {
						
							string	$shadePlug = getSrcPlug( $defaultAttrPlug );	
							if($shadePlug !="")
							{
								string $plugs[];
								int $count;
								$count = `tokenize $shadePlug "." $plugs`;
								string $frameExtn = $plugs[0]+".frameExtension";
							
													
								if (`nodeType $plugs[0]` == "file" && `objExists $frameExtn` )
								{
									//Delete existing expressions
									string $expNodes[] = `listConnections ($plugs[0]+".frameExtension")`;
									for ($exp in $expNodes)
									{ 
										if( `nodeType $exp` == "expression" )
										{
											int $found = false;
											string $attrList[];
											$attrList = `listAttr -ud $exp`;
											for( $userAttr in $attrList )
											{
												if( $userAttr == "furAnimTexture" )
												{
													$found = true;
													break;
												}
											}
							
											if($found)
											{
												string $sourcePlugs[];
												int $sourceCount = `tokenize $exp "." $sourcePlugs`;
												delete $sourcePlugs[0];
											}
										}
									}
								}				
							}
						}
					}
					$isFileTextureDeleted = true;
				}				
			} else {
				string $warningMsg = (uiRes("m_FurPluginCreateUI.kUnAssignementWarn"));
				warning(`format -s $hairDescNode -s $surface $warningMsg`);
			}
		}
	}
	if ( $deleteFeedback ) {
	
		//If more than one node is connected to surfaceShape node in Dag, 
		//equal map attribute of surfaceShape will not be deleted.
		string $objects[] = `ls -ap $surface`;
		if(size($objects) == 1)
		{
			//Delete Equalizer map attribute
			HfDeleteEqualAttr($surface);
		}
	}
}

//addDebugTag("copyHD");

proc copyHairDescription(
	string	$hairDesc
)
{
	string	$tag = "copyHD";
	string	$copiedHD[] = `duplicate $hairDesc`;

	if ( size( $copiedHD ) == 1 ) {

		//make duplicate of attribute maps from original fur description and
		//added to the duplicate fur description
		int $count;
		string $furAttr[] = `listAttr -m $hairDesc`;
		string $firstDescription;

		for($count=0; $count < size ( $furAttr ); $count++)
		{
			$firstDescription = $hairDesc+"."+$furAttr[$count];
			string $tmpAttr = $furAttr[$count];
			
			if(!( strcmp( $tmpAttr, "BaseColor" ) == 0 || strcmp( $tmpAttr, "TipColor" )== 0 ||
				  strcmp( $tmpAttr, "BaseAmbientColor" )== 0 || strcmp( $tmpAttr, "TipAmbientColor" )== 0 ||
				  strcmp( $tmpAttr, "SpecularColor" )== 0 ) )
			{
				continue;
			}

			string $testName = `connectionInfo -sfd $firstDescription`;
			if(size ( $testName ) == 0)
			{
				continue;
			}

			string $textureName[];
			int $numOfTokens = `tokenize $testName "." $textureName`;

			if( size($textureName) == 2 )
			{
				string $attrName = $textureName[1];
				
				//make duplicate of connected attribute maps
				string $NewTextureName[] = `duplicate -un $textureName[0]`;

				if(size($NewTextureName) == 0)
				{
					continue;
				}

				$NewTextureName[0] = $NewTextureName[0] + "." + $textureName[1];
				string $dupFurDes = $copiedHD[0] +"." +$furAttr[$count];
				
				//connect duplicate attribute maps to original fur description
				connectAttr -f $NewTextureName $dupFurDes;
			}
		}

		// go through and make sure all map names are clear
		//
		string	$attrs[] = `listAttr -m $copiedHD[0]`;
		string	$a;

		for ( $a in $attrs ) {
			// does it have map in its name and if so
			// is it a multi
			//
			if ( gmatch( $a, "*Map*" ) && getMultiIndex( $a ) >= 0 ) {
				string	$plug = $copiedHD[0] + "." + $a;
				string	$type = `getAttr -type $plug`;

				HfTDebug($tag,"plug " + $plug + " is of type " + $type);
				if ( $type == "string" ) {
					HfTDebug($tag,"clearing " + $plug + " to empty string");
					setAttr -type "string" $plug "";
				} else if ( $type == "long" ) {
					HfTDebug($tag,"clearing " + $plug + " to 0");
					setAttr $plug 0;
				}
			}
		}
		connectHairNodeToGlobals(
			$copiedHD[0],
			getHairGlobalsHDListPlug(true),
			getHairGlobalsProtectPlug(true)
		);
	}
}

// membership for attractor sets is the same as for hair descriptions
// so we can just call the same routines
//
//addDebugTag("attractors");

proc string getAttractorObject(
	string	$node,
	string	$attr
)
{
	string	$tag = "attractors";
	string	$object = "";

	HfTDebug( $tag, "checking if " + $attr + " attribute exists on " + $node);
	if ( `attributeQuery -n $node -ex $attr` ) {
		string	$plug = ($node + "." + $attr);
		string	$dstPlugs[] = getDstPlugs( $plug );

		if ( size( $dstPlugs ) == 1 ) {
			$object = $dstPlugs[0];
		} else {
			$object = `connectionInfo -sfd $plug`;
		}
		if ( $object != "" ) {
			$object = plugNode( $object );
			HfTDebug($tag,"getAttractorObject(" + $node + "," + $attr + ") = " + $object);
		}
	}
	return $object;
}

proc buildAttractorGrpConnection(
	string	$attractorGrp,
	string	$attractorEnd
)
{
	string	$tag = "attractors";

	HfTDebug($tag,"adding attractorGroup attribute to " + $attractorEnd);
	addAttr -ln "attractorGroup" -sn "agrp" -at message $attractorEnd;
	HfTDebug($tag,"adding attractorEnd attribute to " + $attractorGrp);
	addAttr -ln "attractorEnd" -sn "aend" -at message $attractorGrp;
	HfTDebug($tag,"connecting " + $attractorGrp + ".aend to " + $attractorEnd + ".agrp");
	connectAttr ($attractorGrp + ".aend") ($attractorEnd + ".agrp"); 
}

proc string getAttractorGrp(
	string	$node
)
{
	string	$tag = "attractors";
	string	$agrp, $aend;
	string	$parents[];

	HfTDebug( $tag, "in getAttractorGrp(" + $node + ")" );

	// check if this node points to attractor group
	//
	$agrp = getAttractorObject( $node, "agrp" );
	if ( $agrp == "" ) {
		// look up path for a node containing attractorEnd attribute
		// this would be the attractor group
		//
		while ( $node != "" ) {
			$aend = getAttractorObject( $node, "aend" );
			if ( $aend != "" ) {
				$agrp = $node;
				break;
			}
			$parents = `listRelatives -pa -ap $node`;
			if ( size( $parents ) == 1 ) {
				$node = $parents[0];
			} else {
				break;
			}
		}
	}

	return $agrp;
}

proc string getAttractorEnd(
	string	$node
)
{
	string	$tag = "attractors";
	string	$aend, $agrp;

	HfTDebug( $tag, "in getAttractorEnd(" + $node + ")" );

	// first check if this node refers to end node
	//
	$aend = getAttractorObject( $node, "aend" );
	if ( $aend == "" ) {
		// look for attractor group
		//
		$agrp = getAttractorGrp( $node );
		if ( $agrp != "" ) {
			$aend = getAttractorObject( $agrp, "aend" );
		}
	}
	return $aend;
}

proc getAttrSetMembers(
	string	$plug,
	string	$members[],
	int		$multiIndexes[]
)
{
	getHairSetMembers( $plug, $members, $multiIndexes );
}

proc getAttractorsFromAS(
	string	$attractors[],
	string	$attrSet,
	int		$subPaths	// include sub-paths
)
{
	string	$tag = "getAttractorsFromAS";
	string	$dstPlugs[] = `listAttr -m -st "attractors" $attrSet`;
	string	$d;
	int		$a = 0;
	
	for ( $d in $dstPlugs ) {
		string	$attr = plugNode( getSrcPlug( $attrSet + "." + $d ) );
		
		if ( $attr != "" ) {
			if ( $subPaths ) {
				string	$fullPaths[] = `ls -long $attr`;
				string	$fullPath = $fullPaths[0];
				string	$parts[];
				int		$nParts = `tokenize $fullPath "|" $parts`;
				
				HfTDebug( $tag, "processing " + $fullPath + " with " + $nParts + " parts");
				
				if ( $nParts >= 3 ) {
					string	$chain = "";
					int		$n;
					
					for ( $n = 0; $n < $nParts; $n++ ) {
						$chain += "|" + $parts[$n];
						
						if ( $n >= ($nParts - 3) ) {
							$attractors[$a++]=standardName( $chain );
						}
					}
				}
			} else {
				$attractors[$a++]=$attr;
			}
		}
	}
}

//addDebugTag("connectASToHF");

proc connectASToFeedback(
	string	$attractorSet,
	string	$feedback
)
{
	string	$tag = "connectASToHF";
	string	$attractors[];
	string	$a;
	string	$members[], $m;
	int		$multiIndexes[];
	int		$hfIndex = 0;
	string	$srf = feedbackInputSurface( $feedback );

	if ( $srf == "" ) {
		return;
	}

	getAttrSetMembers( $attractorSet, $members, $multiIndexes );
	
	// determine if passed hair description assigned to it
	//
	int		$connect = 0;
	int		$mi = 0;
	string	$srfPaths[];

	getTransformAndShape( $srf, $srfPaths );
	HfTDebug($tag,"surface: " + $srfPaths[0] + "(" + $srfPaths[1] + ")");

	for ( $m in $members ) {
		HfTDebug($tag," " + $m);
		if ( $m == $srfPaths[0] || $m == $srfPaths[1] ) {
			$connect = 1;
			break;
		}
		$mi++;
	}

	if ( !$connect ) {
		return;
	}

	// connect various global attractor set attributes to feedback
	//
	connectAttr
		($attractorSet + ".AttractorModel")
		($feedback + ".AttractorModel");
	connectAttr
		($attractorSet + ".AttractorsPerHair")
		($feedback + ".AttractorsPerHair");

	// connect attractor set attributes to hair feedback node
	//
	connectASToHF( $attractorSet, $multiIndexes[$mi], $feedback );

	// connect the actual attractors to feedback
	//
	getAttractorsFromAS( $attractors, $attractorSet, 1 );
	for ( $a in $attractors ) {
		string	$from = $a + ".wm";
		string	$to = $feedback + ".attractors[" + $hfIndex++ + "]";
		
		HfTDebug( $tag, "connecting " + $from + " -> " + $to );
		connectAttr $from $to;
	}
}

proc connectCASToFeedback(
	string	$attractorSet,
	string	$feedback,
	string  $hairSystem
)
{
	string	$tag = "connectCASToFeedback";
	string	$attractors[];
	string	$curve;
	string	$members[], $m;
	int		$multiIndexes[];
	int		$hfIndex = 0;
	string	$srf = feedbackInputSurface( $feedback );

	if ( $srf == "" ) {
		return;
	}

	getAttrSetMembers( $attractorSet, $members, $multiIndexes );
	
	// determine if passed hair description assigned to it
	//
	int		$connect = 0;
	int		$mi = 0;
	string	$srfPaths[];

	getTransformAndShape( $srf, $srfPaths );
	HfTDebug($tag,"surface: " + $srfPaths[0] + "(" + $srfPaths[1] + ")");

	for ( $m in $members ) {
		HfTDebug($tag," " + $m);
		if ( $m == $srfPaths[0] || $m == $srfPaths[1] ) {
			$connect = 1;
			break;
		}
		$mi++;
	}

	if ( !$connect ) {
		return;
	}

	// connect various global attractor set attributes to feedback
	//
	connectAttr
		($attractorSet + ".CurveAttractorModel")
		($feedback + ".CurveAttractorModel");
	connectAttr
		($attractorSet + ".CurveAttractorsPerHair")
		($feedback + ".CurveAttractorsPerHair");

	string $attr = "furAttrSystem";
	if ( !`attributeQuery -ex -node $hairSystem $attr` )
	{
		addAttr -at message -hidden true -longName "furAttrSystem" -shortName "fas" $hairSystem;
	}

	$attr = "curveAttractors";
	if ( `attributeQuery -exists -n $attractorSet $attr` ) {
		string	$source, $dest;
		// disconnect default and map attributes
		//
		$dest=$attractorSet + "." + $attr;
		$source=`connectionInfo -sfd $dest`;
		if ( $source != "" && ( $hairSystem == "" || $hairSystem == plugNode( $source ) ) ) {
			checkAndDisconnectAttr($source,$dest);
		}
	}
	connectAttr
		($hairSystem + ".furAttrSystem")
		($attractorSet + ".curveAttractors");
	
	// connect attractor set attributes to hair feedback node
	//
	connectCASToHF( $attractorSet, $multiIndexes[$mi], $feedback );

	string $curveShapes[];
	if(`nodeType $hairSystem` == "hairSystem")
		$curveShapes = HfGetCurvesFromHairSystem($hairSystem);

	for ( $curve in $curveShapes ) {
		string	$from = $curve + ".ws";
		string	$to = $feedback + ".inputCurve[" + $hfIndex++ + "]";
		
		HfTDebug( $tag, "connecting " + $from + " -> " + $to );
		connectAttr $from $to;
	}
}

//addDebugTag("disconnectASFromHF");

global proc HfDisconnectASFromFeedback(
	string	$attractorSet,	// empty string if don't care
	string	$feedback
)
{
	string	$tag = "disconnectASFromHF";

	// Is there a surface and attractor set attached? If so, check if any maps need to be saved
	//
	string	$inputSurface = feedbackInputSurface( $feedback );
	string	$attrSet = getAttractorSetFromFeedback( $feedback );

	if ( $inputSurface != "" && $attrSet != "" ) {
		string	$surfaces[];

		$surfaces[0] = $inputSurface;
		exportDirtyMaps( $surfaces );
	}

	// disconnect various global attractor set attributes
	//
	disconnectHFAttr( $attractorSet, $feedback, "AttractorModel" );
	disconnectHFAttr( $attractorSet, $feedback, "AttractorsPerHair" );

	// disconnect attractor set attributes from hair feedback node
	//
	disconnectASFromHF( $attractorSet, $feedback );

	// disconnect the actual attractors to feedback
	//
	string	$dstPlugs[] = `listAttr -m -st "attractors" $feedback`;
	string	$d;
	string	$attractors[];
	int		$checkAttractors = false;

	if ( $attractorSet != "" ) {
		getAttractorsFromAS( $attractors, $attractorSet, 1 );
		$checkAttractors = true;
	}
	
	for ( $d in $dstPlugs ) {
		string	$dstPlug = $feedback + "." + $d;
		string	$srcPlug = getSrcPlug( $dstPlug );
		int		$disconnect;

		if ( $srcPlug == "" ) {
			continue;
		}

		if ( $checkAttractors ) {
			string	$srcNode = standardName( plugNode( $srcPlug ) );
			string	$a;
	
			$disconnect = false;
			for ( $a in $attractors ) {
				if ( $a == $srcNode ) {
					$disconnect = true;
					break;
				}
			}
		} else {
			$disconnect = true;
		}

		if ( $disconnect ) {
			int	$success = checkAndDisconnectAttr($srcPlug,$dstPlug);
			HfTDebug(
				$tag,
				"disconnect " + $srcPlug + " from " + $dstPlug
				+ ($success ? "succeeded" : "failed")
			);
		}
	}
}

global proc HfDisconnectCASFromFeedback(
	string	$attractorSet,	// empty string if don't care
	string	$feedback,
	string  $hairSystem
)
{
	string	$tag = "disconnectASFromHF";

	// Is there a surface and attractor set attached? If so, check if any maps need to be saved
	//
	string	$inputSurface = feedbackInputSurface( $feedback );
	string	$attrSet = getCurveAttractorSetFromFeedback( $feedback );

	if ( $inputSurface != "" && $attrSet != "" ) {
		string	$surfaces[];

		$surfaces[0] = $inputSurface;
		exportDirtyMaps( $surfaces );
	}

	// disconnect various global attractor set attributes
	//
	disconnectHFAttr( $attractorSet, $feedback, "CurveAttractorModel" );
	disconnectHFAttr( $attractorSet, $feedback, "CurveAttractorsPerHair" );

	// disconnect attractor set attributes from hair feedback node
	//
	disconnectCASFromHF( $attractorSet, $feedback );


	// disconnect the actual attractors to feedback
	//
	string	$dstPlugs[] = `listAttr -m -st "inputCurve" $feedback`;
	string	$d;
	string	$attractors[];
	int		$checkAttractors = false;

	if ( $attractorSet != "" ) {
		if(`nodeType $hairSystem` == "hairSystem")
			$attractors= HfGetCurvesFromHairSystem($hairSystem);		
		$checkAttractors = true;
	}
	
	for ( $d in $dstPlugs ) {
		string	$dstPlug = $feedback + "." + $d;
		string	$srcPlug = getSrcPlug( $dstPlug );
		int		$disconnect;

		if ( $srcPlug == "" ) {
			continue;
		}

		if ( $checkAttractors ) {
			string	$srcNode = standardName( plugNode( $srcPlug ) );
			string	$a;
	
			$disconnect = false;
			for ( $a in $attractors ) {
				if ( $a == $srcNode ) {
					$disconnect = true;
					break;
				}
			}
		} else {
			$disconnect = true;
		}
		if ( $disconnect ) {
			int	$success = checkAndDisconnectAttr($srcPlug,$dstPlug);
			HfTDebug(
				$tag,
				"disconnect " + $srcPlug + " from " + $dstPlug
				+ ($success ? "succeeded" : "failed")
			);
		}
	}
}
proc controlASToHFConnections(
	string	$surfaces[],
	int		$makeConnections,
	string	$attractorSet	
)
{
	string	$s;

	for ( $s in $surfaces ) {
		string	$shape = getChildShape( $s );
		if ( $shape != "" ) {
			string $feedbacks[];
			string $feedback;
			
			$feedbacks = getFurFeedbackNodes( $shape );
			for ($feedback in $feedbacks) {
				if ( $makeConnections ) {
					connectASToFeedback( $attractorSet, $feedback );
				} else {
					HfDisconnectASFromFeedback( $attractorSet, $feedback );
				}
			}
		}
	}
}

proc controlCASToHFConnections(
	string	$surfaces[],
	int		$makeConnections,
	string	$attractorSet,
	string  $hairSystem,
	string  $furDescription	
)
{
	string	$s;
	for ( $s in $surfaces ) {
		string	$shape = getChildShape( $s );
		if ( $shape != "" ) {
			string $feedbacks[];
			string $feedback;
			$feedback = getFurFeedbackNode( $shape,$furDescription );

			if ( $makeConnections ) {
				connectCASToFeedback( $attractorSet, $feedback,$hairSystem );
			} else {
				HfDisconnectCASFromFeedback( $attractorSet, $feedback,$hairSystem );
			}
		}
	}
}

proc detachASFromSurfacesHF(
	string	$surfaces[],
	string	$attractorSet
)
{
	controlASToHFConnections( $surfaces, false, $attractorSet );
}

proc detachCASFromSurfacesHF(
	string	$surfaces[],
	string	$attractorSet,
	string  $hairSystem,
	string  $furDescription
)
{
	controlCASToHFConnections( $surfaces, false, $attractorSet, $hairSystem, $furDescription );
}

proc detachASFromSurfaceHF(
	string	$surface,
	string	$attractorSet
)
{
	string	$oneSurface[];

	$oneSurface[0] = $surface;
	detachASFromSurfacesHF( $oneSurface, $attractorSet ); 
}

proc detachCASFromSurfaceHF(
	string	$surface,
	string	$attractorSet,
	string  $hairSystem,
	string $furDescription
)
{
	string	$oneSurface[];

	$oneSurface[0] = $surface;
	detachCASFromSurfacesHF( $oneSurface, $attractorSet, $hairSystem, $furDescription ); 
}

proc attachASToSurfacesHF(
	string	$surfaces[],
	string	$attractorSet
)
{
	controlASToHFConnections( $surfaces, false, "" );
	controlASToHFConnections( $surfaces, true, $attractorSet );
}

proc attachCASToSurfacesHF(
	string	$surfaces[],
	string	$attractorSet,
	string  $hairSystem,
	string  $furDescription
)
{
	controlCASToHFConnections( $surfaces, false, "",$hairSystem,$furDescription );
	controlCASToHFConnections( $surfaces, true, $attractorSet,$hairSystem,$furDescription );
}

proc attachASToSurfaceHF(
	string	$surface,
	string	$attractorSet
)
{
	string	$oneSurface[];

	$oneSurface[0] = $surface;
	attachASToSurfacesHF( $oneSurface, $attractorSet ); 
}
proc attachCASToSurfaceHF(
	string	$surface,
	string	$attractorSet,
	string $hairSystem,
	string $furDescription
)
{
	string	$oneSurface[];

	$oneSurface[0] = $surface;
	attachCASToSurfacesHF( $oneSurface, $attractorSet,$hairSystem,$furDescription ); 
}

//addDebugTag("attachHairFeedback");

proc attachHairFeedbackToSurfaces(
	string	$surfaces[],
	string	$hairDesc		// hair feedback for this hair description
)
{
	string	$tag = "attachHairFeedback";
	string	$members[];
	int		$multiIndexes[];
	string	$s, $m;

	saveSelectionList;
	getHairSetMembers( $hairDesc, $members, $multiIndexes );

	for ($s in $surfaces ) {
		// determine if passed hair description assigned to it
		//
		int		$attach = false;
		int		$mi = 0;
		string	$srfPaths[];

		getTransformAndShape( $s, $srfPaths );
		HfTDebug($tag,"selected: " + $srfPaths[0] + "(" + $srfPaths[1] + ")");

		// only attach if surface is visible
		//
		if ( $srfPaths[0] != "" && `getAttr ($srfPaths[0] + ".visibility")`
		  && $srfPaths[1] != "" && `getAttr ($srfPaths[1] + ".visibility")` ) {
			for ( $m in $members ) {
				HfTDebug($tag," " + $m);
				if ( $m == $srfPaths[0] || $m == $srfPaths[1] ) {
					$attach = true;
					break;
				}
				$mi++;
			}
		}

		string $shape=$srfPaths[1];

		if ( $shape != ""
		  && ( `nodeType $shape` == "nurbsSurface"
		    || `nodeType $shape` == "mesh" || `nodeType $shape` == "subdiv" ) ) {
			string	$feedbackNodeName;
			string	$feedbackNodeParent = "FurFeedback";

			// determine if the shape is already connected to a hairfeedback node
			//
			$feedbackNodeName = getFurFeedbackNode( $shape, $hairDesc );
			if ( $feedbackNodeName != "" ) {
				HfTDebug($tag,"found " + $shape + " connected to " + $feedbackNodeName);

				string $feedbackHairDesc = getHairDescFromFeedback($feedbackNodeName);
				HfTDebug($tag,"found " + $feedbackHairDesc + " connected to " + $feedbackNodeName);
				
				if ( $feedbackHairDesc == $hairDesc ) {
					// this surface is already connected to an appropriate
					// hair feedback node
					//
					$attach = false;
				} else {
					// this surface is connected to a hair feedback node
					// associated with a different hair description. 
					//
					int	$removed = true ; //removeHairFeedbackFromSurface( $shape, "" );
					if ( ! $removed ) {
						string $warningMsg = (uiRes("m_FurPluginCreateUI.kExistingFurWarn"));
						warning(`format -s $shape $warningMsg`);
						$attach = false;
					}
				}
			}

			if ( !$attach ) {
				continue;
			}

			if ( !`objExists $feedbackNodeParent` ) {
				group -w -em -name $feedbackNodeParent;
			}

			// create a transform node parented to the $feedbackNodeParent and
			// then create the feedback node parented to the group we just created
			//
			string	$pathParts[];
			string	$base;

			tokenize($srfPaths[0],"|",$pathParts);
			$base=$pathParts[size($pathParts)-1];
			$feedbackNodeName=($base + "_FurFeedback");
			$feedbackNodeParent=`group -p $feedbackNodeParent -em -name $feedbackNodeName`;
			$feedbackNodeName+="Shape";
			$feedbackNodeName=
				`createNode -p $feedbackNodeParent -n $feedbackNodeName FurFeedback`;
			HfTDebug($tag,"created " + $feedbackNodeName + " for " + $base + "," + $hairDesc);
			checkNode( $feedbackNodeName );

			// restore various aspects of feedback node 
			//
			restoreFeedbackInfo($feedbackNodeName, $hairDesc, $multiIndexes[$mi] );
			saveFeedbackInfo($feedbackNodeName, $hairDesc, $multiIndexes[$mi] );

			connectShapeToFeedbackInputSurface( $shape, $feedbackNodeName );
			connectSrfToHF( $shape, $feedbackNodeName );
			
			// check if the shape has the flip hair normals attribute and connect it to
			// the feedback shape if it does
			//
			string	$flipPlug = getFlipNormalsPlug( $shape, false );

			if ( $flipPlug != "" ) {
				HfTDebug($tag,"found " + $flipPlug + " - connect to " + $feedbackNodeName);
				connectAttr	$flipPlug ($feedbackNodeName + ".flipNormals");
			}

			// connect hair description node to hair feedback node
			//
			connectHDToHF( $hairDesc, $multiIndexes[$mi], $feedbackNodeName );

			// check if the shape has the offset hair angle attribute and modify
			// the connections if it does
			//
			string	$offsetAttr=`buildFurFiles -opa`;
			
			$attr=`listAttr -st $offsetAttr $shape`;
			if ( size($attr) == 1 ) {
				HfTDebug($tag,"found attribute " + $attr[0] + " on " + $shape);
				addPolarOffsetToFeedback(
					$feedbackNodeName, ($shape + "." + $offsetAttr)
				);
			}

			// check how many attractor sets are assigned to this surface and
			// if there are any attach one to the feeedback node
			//
			string	$attractorSets[];
			string	$oneSurface[];

			$oneSurface[0] = $s;
			getAllDescriptions(
				getHairGlobalsASListPlug(false), $attractorSets, $oneSurface
			);
			if ( size( $attractorSets ) > 0 ) {
				HfTDebug($tag,"attaching " + $attractorSets[0] + " to " + $feedbackNodeName);
				connectASToFeedback( $attractorSets[0], $feedbackNodeName );
			}

			// start up script jobs to watch various parts of feedback node
			//
			string	$fullname[] = `ls -l $feedbackNodeName`;

			if ( size( $fullname ) == 1 ) {
				startHFScriptJobs( $fullname[0] );
			}
			// Attach a script job to monitor Surface/Feedback deletetion.
			string $watchPlug;
			$watchPlug = $shape + ".equalizerMap";
			$script = "HfSurfaceChanged " + $watchPlug;
			addConnChangedScriptJob( `scriptJob -cu true -con $watchPlug $script` );
		}
	}

	restoreSelectionList;
}

proc attachHairFeedbackToAssignedSurfaces(
	string	$hairDesc
)
{
	string	$members[];
	int		$multiIndexes[];

	getHairSetMembers( $hairDesc, $members, $multiIndexes );
	attachHairFeedbackToSurfaces( $members, $hairDesc );
}

proc assignASToSurface(
	string	$hairAttrNode,
	string	$surface
)
{
	assignHDToSurface( $hairAttrNode, $surface );
	attachASToSurfaceHF( $surface, $hairAttrNode );
}

proc assignCASToSurface(
	string	$hairAttrNode,
	string	$surface,
	string  $hairSystem,
	string  $furDescription
)
{
	assignHDToSurface( $hairAttrNode, $surface );
	attachCASToSurfaceHF( $surface, $hairAttrNode,$hairSystem,$furDescription);
}

proc unassignASFromSurface(
	string	$hairAttrNode,
	string	$surface
)
{
	unassignHDFromSurface( $hairAttrNode, $surface, false );
	detachASFromSurfaceHF( $surface, $hairAttrNode );
}

proc unassignCASFromSurface(
	string	$hairAttrNode,
	string	$surface,
	string  $hairSystem,
	string  $furDescription
)
{
	detachCASFromSurfaceHF( $surface, $hairAttrNode, $hairSystem,$furDescription );
	string $a[] = `listConnections -shapes true -type "FurFeedback" ($hairAttrNode+".CurveAttractorModel")`;
	if(size($a) ==0)
		unassignHDFromSurface( $hairAttrNode, $surface, false );
}

proc updateASToHFConnections(
	string	$attrSet
)
{
	string	$members[], $m;
	int		$multiIndexes[];
	string	$updateSurfaces[];
	int		$usi = 0;

	getAttrSetMembers( $attrSet, $members, $multiIndexes );
	for ( $m in $members ) {
		string  $feedbacks[];
		$feedbacks = getFurFeedbackNodes( $m );
		
		string $feedback;
		for ($feedback in $feedbacks) {
			if ( $feedback != "" ) {
				string	$as = getAttractorSetFromFeedback( $feedback );

				if ( $as == $attrSet ) {
					$updateSurfaces[$usi++] = $m;
				}
			}
		}
	}

	attachASToSurfacesHF( $updateSurfaces, $attrSet );
}

proc addAttractorsToAS(
	string	$attractors[],
	string	$attrSet
)
{
	string	$tag = "attractors";
	string	$attr;

	for ( $attr in $attractors ) {
		string	$dstPlugs[] = `listAttr -m -st "attractors" $attrSet`;
		string	$d;
		int		$connect = true;

		$attr = getAttractorEnd( $attr );

		for ( $d in $dstPlugs ) {
			string	$a = plugNode( getSrcPlug( $attrSet + "." + $d ) );

			if ( $a == $attr ) {
				HfTDebug( $tag, $attr + " is already in the attractor set " + $attrSet );

				// is already in attractor set
				//
				$connect = false;
				break;
			}
		}

		if ( $connect ) {
			HfTDebug( $tag, "connecting " + $attr + ".iog to " + $attrSet + ".attractors");
			connectAttr -na ($attr + ".iog") ($attrSet + ".attractors");
		}
	}
	
	updateASToHFConnections( $attrSet );
}

proc removeAttractorFromAS(
	string	$attr,
	string	$attrSet
)
{
	string	$dstAttrs[] = `listAttr -m -st "attractors" $attrSet`;
	string	$da;
	int		$removed = false;
	string	$attrEnd = getAttractorEnd( $attr );

	for ( $da in $dstAttrs ) {
		string	$dstPlug = $attrSet + "." + $da;
		string	$srcPlug = getSrcPlug( $dstPlug );
		string	$a = plugNode( $srcPlug );

		if ( $a == $attrEnd ) {
			if ( `checkAndDisconnectAttr $srcPlug $dstPlug` ) {
				$removed = true;
			}
		}
	}
	
	if ( $removed ) {
		updateASToHFConnections( $attrSet );

		// if it is an attractor group then MayaFur created
		// it, so we can delete it
		//
		//string	$attrGrp = getAttractorGrp( $attr );
		
		//if ( $attrGrp != "" ) {
		//	checkAndDelete $attrGrp;
		//}
	}
}

proc addAttractorToAS(
	string	$attr,
	string	$attrSet
)
{
	string	$oneAttractor[];

	// We need to delete the connection if this attractor
	// is already attached to some attarctor set before
	// adding it to attractor set.
	string	$descriptions[], $d;
	getAllAttractorSets( $descriptions, false );
	for ( $d in $descriptions ) {
		removeAttractorFromAS ($attr, $d);
	}

	$oneAttractor[0] = $attr;
	addAttractorsToAS( $oneAttractor, $attrSet );
}

//addDebugTag("bakeMappedAttr");

proc string decodeSwitchNode(
	string	$switchNode,
	string	$surface,
	string	$switchShadeAttr
)
{
	string	$tag = "bakeMappedAttr";
	string	$srfPaths[];
	string	$switchShapeAttrs[] = `listAttr -m -st "inShape" $switchNode`;
	string	$ssa;
	string	$shadePlug = "";

	getTransformAndShape( $surface, $srfPaths );
	HfTDebug($tag,"decoding " + $switchNode + " for " + $srfPaths[0] + "(" + $srfPaths[1] + ")");

	// check if this surface has an input on the switch
	//
	for ( $ssa in $switchShapeAttrs ) {
		string	$switchShapePlug = getSrcPlug( $switchNode + "." + $ssa );

		if ( $switchShapePlug != "" ) {
			string $switchShape = plugNode( standardName( $switchShapePlug ) );

			HfTDebug($tag,"found switch shape " + $switchShape);
			if ( $switchShape == $srfPaths[1] ) {
				// now we need to get multiIndex out of the original
				// switch node attribute so we can construct the shade plug
				//
				int	$mi = getMultiIndex( $ssa );

				if ( $mi >= 0 ) {
					$shadePlug=getSrcPlug(
						$switchNode+".input["+$mi+"]."+$switchShadeAttr
					);
					HfTDebug($tag,"matched: returning " + $shadePlug);
				}
				break;
			}
		}
	}

	return $shadePlug;
}


proc string  getTextureFile(string $currentFrameExt, string $dirname, string $baseFileName, string $fileFormatExt) 
{
	string $frameExt;
	int	$contFrameLoop;

	for( $frameExt= $currentFrameExt, $contFrameLoop = true; $contFrameLoop; $contFrameLoop = frameLoop($frameExt, $currentFrameExt) )
	{	
		//Frame Extension at the end
		string $exactFileName = $dirname +"/"+$baseFileName+$fileFormatExt+$frameExt;
		if(`filetest -r $exactFileName`)
		{
			return $exactFileName;
		}
   
		//file format extension at the end
		$exactFileName = $dirname +"/"+$baseFileName+$frameExt+$fileFormatExt;
		if(`filetest -r $exactFileName`)
		{
			return $exactFileName;
		}

		$frameExt = nextFrameExt($frameExt, $currentFrameExt);
	}
	
	return "";
}

global proc HfSetAnimatedTexture( string $attrName, string $dirname,string $baseFileName, string $fileFormatExt, int $frameExt)
{
	string $currentFrameExt = "."+$frameExt;
	string $textureFile = getTextureFile($currentFrameExt, $dirname,$baseFileName,$fileFormatExt);
	setAttr $attrName -type "string" $textureFile;	
	if($textureFile=="") {
		string $list[] = `ls -sl`;
		select -r $list;
	}
}
proc string bakeAttribute(
	string	$node,
	string	$attr,
	string  $frame
)
{
        string	$defaultAttrPlug = $node + "." + hairDefaultAttr($attr);
	if ( !`objExists $defaultAttrPlug` )	return "";
	string	$shadePlug = getSrcPlug( $defaultAttrPlug );

	string $plugs[];
	int $count;
	$count = `tokenize $shadePlug "." $plugs`;
	string	$shadeNode = plugNode( $shadePlug );
	string	$shadeNodeType = `nodeType $shadeNode`;

	// don't bake if this is an anim curve	
	if ( gmatch( $shadeNodeType, "animCurve*" ) ) 	return "";

	string	$surfaces[];
	int		$indexes[];
	int		$numSurfaces;
	int		$s;
	string	$switchShadeAttr = "";

	if ( $shadeNodeType == "tripleShadingSwitch" ) {
		$switchShadeAttr = "inTriple";
	} else if ( $shadeNodeType == "singleShadingSwitch" ) {
		$switchShadeAttr = "inSingle";
	} else if ( $shadeNodeType == "doubleShadingSwitch" ) {
		$switchShadeAttr = "inDouble";
	}

	getHairSetMembers( $defaultAttrPlug, $surfaces, $indexes );
	$numSurfaces = size($surfaces);
	if($numSurfaces == 0) 
		return "";

	string	$convertNode, $convertAttr;
	string	$fileNode = "";

	if ( $switchShadeAttr != "" ) {
		string	$switchPlug = decodeSwitchNode( 
			$shadeNode, $surfaces[0], $switchShadeAttr
		);
		
		if ( $switchPlug == "" ) {
			return "";
		} 
		$convertNode = plugNode( $switchPlug );
		$convertAttr = plugAttr( $switchPlug );
	} else {
		$convertNode = $shadeNode;
		$convertAttr = plugAttr( $shadePlug );
	}

	string	$converted[];
	string	$convertPlug = $convertNode + "." + $convertAttr;
	int		$antiAlias = false;
	
	string	$exportWidthPlug = $node + ".exportWidth";
	string	$exportHeightPlug = $node + ".exportHeight";
	int		$resX = 256;
	int		$resY = 256;

	if ( `objExists $exportWidthPlug` )
		$resX =`getAttr $exportWidthPlug`;
	if ( `objExists $exportHeightPlug` )
		$resY =`getAttr $exportHeightPlug`;

	// use the settings from the otions dialog for convert solid textures
	//
	if ( `optionVar -exists convertSolidTxAntiA` ) {
		$antiAlias=`optionVar -query convertSolidTxAntiA`;
	}
	if ( `optionVar -exists convertSolidTxResX` ) {
		$resX=`optionVar -query convertSolidTxResX`;
	}
	if ( `optionVar -exists convertSolidTxResY` ) {
		$resY=`optionVar -query convertSolidTxResY`;
	}
	// determine where we want to put the baked texture map
	//
	string	$bakeFile = getMapNameForAttr($surfaces[0], $node, $attr, true, $frame);
	string	$fullBakePath = makeFullPath( $bakeFile );

	if(`nodeType $surfaces[$s]` == "mesh")
	{
		string  $furUVSet = HfGetFurUVSet($surfaces[$s],0);
		$converted =
		`convertSolidTx -antiAlias $antiAlias
						-resolutionX $resX -resolutionY $resY
						-fileImageName $fullBakePath
						-uvSetName $furUVSet 
						$convertPlug $surfaces[0]`;
	}
	else
	{
		$converted =
		`convertSolidTx -antiAlias $antiAlias
						-resolutionX $resX -resolutionY $resY
						-fileImageName $fullBakePath
						$convertPlug $surfaces[0]`;
	}

	if ( size($converted) == 1 ) {
		$fileNode = $converted[0];
	}

	string	$c;
	for ( $c in $converted )		
		checkAndDelete $c;
	
	return $fullBakePath;
}

proc bakeMappedAttribute(
	string	$node,
	string	$attr,
	int     $isDetailOperation,
	int     $surfaceIndices[],
	string  $mapFiles[],
	string  $previousMapFiles[]
)
{
    string	$tag = "bakeMappedAttr";
	string	$defaultAttrPlug = $node + "." + hairDefaultAttr($attr);

	if ( !`objExists $defaultAttrPlug` ) {
		HfTDebug($tag,$defaultAttrPlug + " does not exist - ignore");
		return;
	}

	string	$shadePlug = getSrcPlug( $defaultAttrPlug );
	if ( $shadePlug == "")
	{
		string $surfaces[];
		int $indices[];
		getHairSetMembers( $defaultAttrPlug, $surfaces, $indices );

		for ( $surfaceCount = 0; $surfaceCount < size($surfaces); $surfaceCount++ ) 
		{
			int	$mi = $indices[$surfaceCount];
			int	$mapValue = `getAttr ($node + "." + hairMapFileAttr($attr) + "[" + $mi + "]")`;
			
			string $furAnimExpress[];
			if( size(`connectionInfo -dfs ($node + "." + hairMapFileAttr($attr) + "[" + $mi + "]")`) != 0 )
			{
				$furAnimExpress = `connectionInfo -dfs ($node + "." + hairMapFileAttr($attr) + "[" + $mi + "]")`;
			}
			
			//Check if it is a procedural texture or animated file texture
			if(size($furAnimExpress) == 0)
			{
				if($mapValue == true )
				{
					// make sure all dirty maps are saved
					HfExportMaps();
						
					string $mapUSamplesPlug = $node + "." + hairMapUSamplesAttr($attr) + "[" + $mi + "]";
					string $mapVSamplesPlug = $node + "." + hairMapVSamplesAttr($attr) + "[" + $mi + "]";
					if(`getAttr $mapUSamplesPlug` == -1 && `getAttr $mapVSamplesPlug` == -1 )
					{
					   setMapFile($node + "." + hairMapsAttr($attr) + "[" + $mi + "]","");
					   setAttr ($node + "." + hairMapFileAttr($attr) + "[" + $mi + "]") false;
					}
				}
			}
			else
			{
				if($mapValue == true )
				{	
					string $buffer[];
					int $numTokens = `tokenize $furAnimExpress[0] "." $buffer`;

					if( `objExists $buffer[0]`)
					{
						delete $buffer[0];
						for ( $srfCount = 0; $srfCount < size($surfaces); $srfCount++)
						{
							int $index = $indices[$srfCount];
							setMapFile($node + "." + hairMapsAttr($attr) + "[" + $index + "]","");
							setAttr ($node + "." + hairMapFileAttr($attr) + "[" + $index + "]") false;
						}
					}
				}
			}
		 
		}

		return;
	}
	string $plugs[];
	int $count;
	$count = `tokenize $shadePlug "." $plugs`;

	HfTDebug($tag,"(" + $node + "," + $attr + ")");

	if (`nodeType $plugs[0]` != "file" ) {
		string	$shadeNode = plugNode( $shadePlug );
		string	$shadeNodeType = `nodeType $shadeNode`;

		HfTDebug($tag,"found " + $shadePlug + "(" + $shadeNodeType + ") attached to " + $defaultAttrPlug);

		// don't bake if this is an anim curve
		//
		if ( gmatch( $shadeNodeType, "animCurve*" ) ) {
			HfTDebug($tag,$shadeNode + " is an animCurve - ignore");
			return;
		}

		string	$surfaces[];
		int		$indexes[];
		int		$numSurfaces;
		int		$s;
		string	$switchShadeAttr = "";

		if ( $shadeNodeType == "tripleShadingSwitch" ) {
			$switchShadeAttr = "inTriple";
		} else if ( $shadeNodeType == "singleShadingSwitch" ) {
			$switchShadeAttr = "inSingle";
		} else if ( $shadeNodeType == "doubleShadingSwitch" ) {
			$switchShadeAttr = "inDouble";
		}

		getHairSetMembers( $defaultAttrPlug, $surfaces, $indexes );

		for ( $s = 0, $numSurfaces = size($surfaces); $s < $numSurfaces; $s++ ) {
			string	$convertNode, $convertAttr;
			string	$fileNode = "";

			if ( $switchShadeAttr != "" ) {
				// since this is a switch node determine which switch
				// plug corresponds to this surface if any
				//
				string	$switchPlug = decodeSwitchNode( 
					$shadeNode, $surfaces[$s], $switchShadeAttr
				);
				
				if ( $switchPlug == "" ) {
					continue;
				} 
				$convertNode = plugNode( $switchPlug );
				$convertAttr = plugAttr( $switchPlug );
			} else {
				$convertNode = $shadeNode;
				$convertAttr = plugAttr( $shadePlug );
			}

			string	$converted[];
			string	$convertPlug = $convertNode + "." + $convertAttr;
			int		$antiAlias = false;
			
			// bug 178401 Make baking Fur's attribute map(s) more user friendly 
			
			string	$exportWidthPlug = $node + ".exportWidth";
			string	$exportHeightPlug = $node + ".exportHeight";
			int		$resX = 256;
			int		$resY = 256;

			if ( `objExists $exportWidthPlug` )
			{
				$resX =`getAttr $exportWidthPlug`;
			}
			if ( `objExists $exportHeightPlug` )
			{
				$resY =`getAttr $exportHeightPlug`;
			}

			// use the settings from the otions dialog for convert solid textures
			//
			if ( `optionVar -exists convertSolidTxAntiA` ) {
				$antiAlias=`optionVar -query convertSolidTxAntiA`;
			}
			if ( `optionVar -exists convertSolidTxResX` ) {
				$resX=`optionVar -query convertSolidTxResX`;
			}
			if ( `optionVar -exists convertSolidTxResY` ) {
				$resY=`optionVar -query convertSolidTxResY`;
			}

			// determine where we want to put the baked texture map
			//
			string	$bakeFile = getMapNameForAttr(
				$surfaces[$s], $node, $attr, true, ""
			);
			string	$fullBakePath = makeFullPath( $bakeFile );
			

			HfTDebug( $tag, "bake filename = \"" + $bakeFile + "\"");
			HfTDebug( $tag, "full bake filename = \"" + $fullBakePath + "\"" );
			HfTDebug($tag,
				"convertSolidTx -antiAlias " + $antiAlias
			  + " -resolutionX " + $resX + " -resolutionY " + $resY
			  + " -fileImageName " + $fullBakePath
			  + " " + $convertPlug + " " + $surfaces[$s]);
			
			// bug #174996."furUVSet" is passed with "convertSolidTx" command for polygon object.
			if(`nodeType $surfaces[$s]` == "mesh")
			{
				string  $furUVSet = HfGetFurUVSet($surfaces[$s],0);
				$converted =
				`convertSolidTx -antiAlias $antiAlias
						        -resolutionX $resX -resolutionY $resY
								-fileImageName $fullBakePath
								-uvSetName $furUVSet 
								$convertPlug $surfaces[$s]`;
			}
			else
			{
				$converted =
				`convertSolidTx -antiAlias $antiAlias
						        -resolutionX $resX -resolutionY $resY
								-fileImageName $fullBakePath
								$convertPlug $surfaces[$s]`;
			}

			if ( size($converted) == 1 ) {
				$fileNode = $converted[0];
				HfTDebug($tag, "convertSolidTx -> " + $fileNode);
			}

			if ( $fileNode != "" && `nodeType $fileNode` == "file" ) {
				string	$filename=`getAttr ($fileNode + ".fileTextureName")`;

				if ( $filename != "" ) {
					int	$mi = $indexes[$s];

					$filename = makeProjectRelative( $filename );

					HfTDebug(
						$tag,
						"setting " + $node + "." + hairMapsAttr($attr) + "[" + $mi + "] to " + $filename
					);
					setMapFile( 
						($node + "." + hairMapsAttr($attr) + "[" + $mi + "]"),
						$filename
					);
					
					setAttr ($node + "." + hairMapFileAttr($attr) + "[" + $mi + "]") true;			
					// set the sample size to (-1,-1) to indicate that we generated this file but it wasn't
					// painted
					//
					string $mapUSamplesPlug = $node + "." + hairMapUSamplesAttr($attr) + "[" + $mi + "]";
					string $mapVSamplesPlug = $node + "." + hairMapVSamplesAttr($attr) + "[" + $mi + "]";

					setAttr $mapUSamplesPlug -1;
					setAttr $mapVSamplesPlug -1;
				}
			}

			string	$c;

			for ( $c in $converted ) {
				HfTDebug( $tag, "deleting " + $c );
				checkAndDelete $c;
			}
		}
	}
	else if (`nodeType $plugs[0]` == "file" )
	{
		//Delete existing expressions
		string $destConnection = `connectionInfo -sfd $defaultAttrPlug`;
		string $destPlugs[];
		int $destCount = `tokenize $destConnection "." $destPlugs`;

		if( `nodeType $destPlugs[0]` == "file" )
		{
			string $expNodes[] = `listConnections ($destPlugs[0]+".frameExtension")`;

			for ($exp in $expNodes)
			{ 
				if( `nodeType $exp` == "expression" )
				{
					int $found = false;
					string $attrList[];
					$attrList = `listAttr -ud $exp`;
					for( $userAttr in $attrList )
					{
						if( $userAttr == "furAnimTexture" )
						{
							$found = true;
							break;
						}
					}
					
					if($found)
					{
						string $sourcePlugs[];
						int $sourceCount = `tokenize $exp "." $sourcePlugs`;
						
						string $surfaces[];
						int    $indices[];
						getHairSetMembers( $defaultAttrPlug, $surfaces, $indices );
						for ( $surfaceCount = 0; $surfaceCount < size($surfaces); $surfaceCount++ ) 
						{
							int	$mi = $indices[$surfaceCount];
							string $cmd = "connectionInfo -dfs "+ $node + "." + hairMapFileAttr($attr) + "[" + $mi + "]";
							string $mapFileAttr[]= `eval $cmd`;
							string $animTexture = $sourcePlugs[0]+".furAnimTexture["+ $mi + "]";
							if($mapFileAttr[0] == $animTexture)
							{
								delete $sourcePlugs[0];
								break;							
							}
						}
					}
				}
			}
		}
		//find-out the number of attribute maps
		string $surfaces[];
		int    $indices[];
		getHairSetMembers( $defaultAttrPlug, $surfaces, $indices );
		string	$expressionName = $node + hairDefaultAttr($attr);

		int $maxIndex=-1;
		for($index in $indices)
		{
			if( $index > $maxIndex )
			{
				$maxIndex = $index;
			}
		}
		
		//Create expression.

		if($maxIndex != -1)
		{
			$maxIndex++;
			string $exp;

			string $nodeName = $node + "." + hairMapsAttr($attr);
			if(!`getAttr ($plugs[0]+".useFrameExtension")`)
			{
			       	string $file = bakeAttribute($node, $attr, "");
				if( $file == "")
					return;
				
				if(`about -win`)
					$file = replaceCharacterInString($file,"\\","/");
	
				string $mapName = "\""+$file+"\"";			
					
				if($isDetailOperation){
					clear($indices);
					$indices = $surfaceIndices;
				}
		
				$exp = "string $frmaeExtn = "+$plugs[0]+".frameExtension;\n";
				int $count;
				for($count =0; $count< size($indices); $count++)
				{
					if($isDetailOperation){
						$file = $mapFiles[$count];
						if(`about -win`)
							$file = replaceCharacterInString($file,"\\","/");					
						$mapName = "\""+$file+"\"";
					}
						
					$exp += "setAttr \""+$nodeName+"[" +$indices[$count]+"]\" -type \"string\" "+$mapName+" ;\n";
				}

			}
			else
			{
				string $file;
				if(!$isDetailOperation){
					int $sf = `playbackOptions -q -minTime`;
					int $ef = `playbackOptions -q -maxTime`;
					int $i=0;
					for( $i = $sf; $i <=$ef; $i++) {				    
						currentTime -e $i;
						$file = bakeAttribute($node,$attr, $i);
					}
					currentTime -e $sf;
				}

				string $result[];
				if($isDetailOperation){
					clear($indices);
					$indices = $surfaceIndices;
				}
				else {
					$result=HfgetAnimatedFileFormat($file);
				}				
				
				$exp = "string $frmaeExtn = "+$plugs[0]+".frameExtension;\n";
				int $count;
				for($count =0; $count<size($indices); $count++)
				{
					if($isDetailOperation){					
						$file = $mapFiles[$count];
						if(`about -win`)
							$file = replaceCharacterInString($file,"\\","/");
						$result = HfgetAnimatedFileFormat($file);
						
						int $frame = `getAttr ($plugs[0]+".frameExtension")`;						
						string $currentFrameExt = "."+$frame;
						string $textureFile = getTextureFile($currentFrameExt, $result[0],$result[1],$result[2]);
						if($textureFile=="")
						{
							warning (uiRes("m_FurPluginCreateUI.kImageSelectionWarn"));
							$file = $previousMapFiles[$count];
							if(`about -win`)
								$file = replaceCharacterInString($file,"\\","/");
							$result = HfgetAnimatedFileFormat($file);
							string $list[] = `ls -sl`;
							select -r $list;
						}						
					}					
					$exp += "HfSetAnimatedTexture( \""+$nodeName+"["+$indices[$count]+"]\",\""+$result[0]+"\",\""+$result[1]+"\",\""+$result[2]+"\",$frmaeExtn );\n";
				}
					 
			}
			
			expression -s $exp -ae on -n $expressionName;

			// check if the attribute "furAnimTexture" has been added			
			int $found = false;
			string $attrList[];
			$attrList = `listAttr -ud $expressionName`;
			for( $userAttr in $attrList )
			{
				if( $userAttr == "furAnimTexture" )
				{
					$found = true;
					break;
				}
			}
			
			if(!$found)
			{
				addAttr -attributeType bool -multi -hidden true -longName "furAnimTexture" -shortName "fat" $expressionName;
			}

			string $surfaces[];
			int $indices[];
			getHairSetMembers( $defaultAttrPlug, $surfaces, $indices );

			for ( $surfaceCount = 0; $surfaceCount < size($surfaces); $surfaceCount++ ) 
			{
				int	$mi = $indices[$surfaceCount];
				string $connection1 = $node + "." + hairMapFileAttr($attr) + "[" + $mi + "]";
				string $connection2 = $expressionName + ".furAnimTexture" + "[" + $mi + "]";
				if(!`isConnected $connection1 $connection2`)
				{
					setAttr ($node + "." + hairMapFileAttr($attr) + "[" + $mi + "]") true;
					setAttr ($expressionName + ".furAnimTexture" + "[" + $mi + "]") true;
					connectAttr ($node + "." + hairMapFileAttr($attr) + "[" + $mi + "]") ($expressionName + ".furAnimTexture" + "[" + $mi + "]");

					string $mapUSamplesPlug = $node + "." + hairMapUSamplesAttr($attr) + "[" + $mi + "]";
					string $mapVSamplesPlug = $node + "." + hairMapVSamplesAttr($attr) + "[" + $mi + "]";

					setAttr $mapUSamplesPlug -1;
					setAttr $mapVSamplesPlug -1;
				}
			}
		}
	}
}

global proc HfResetAllScriptJobs()
{
	HfResetAttrChangedScriptJobs();
	HfResetConnChangedScriptJobs();
}

global proc HfResetAttrChangedScriptJobs()
{
	string	$tag = "HFScriptJobs";

	global int	 $HfAttrChangedScriptJobs[];

	int		 $id;

	// first kill off any running script jobs
	//
	for ( $id in $HfAttrChangedScriptJobs ) {
		if (`scriptJob -exists $id`) {
			HfTDebug($tag,"killing job " + $id);
			scriptJob -kill $id;
		}
	}
	clear( $HfAttrChangedScriptJobs );

	string	$allFBObjects[];
	string	$obj;
	
	// start script jobs to watch various inputs of fur
	// feedback nodes
	//
	$allFBObjects = `ls -l -type FurFeedback`;
	for ( $obj in $allFBObjects ) {
		startHFScriptJobs( $obj );
	}
}

global proc HfResetConnChangedScriptJobs()
{
	string	$tag = "HFScriptJobs";

	global int	 $HfConnChangedScriptJobs[];

	int		 $id;

	// first kill off any running script jobs
	//
	for ( $id in $HfConnChangedScriptJobs ) {
		if (`scriptJob -exists $id`) {
			HfTDebug($tag,"killing job " + $id);
			scriptJob -kill $id;
		}
	}
	clear( $HfConnChangedScriptJobs );

	string	$allSurfaceObjects[];
	string	$obj;
	
	// start script jobs to watch various inputs of fur
	// feedback nodes
	//
	$allFBObjects = `ls -l -type FurFeedback`;
	for ( $obj in $allFBObjects ) {
		string $surface = "";
		$surface = getSurfaceShapeFromFeedback( $obj );
		if ($surface != "") {
			// Attach a script job to monitor Surface/Feedback deletetion.
			string $watchPlug = $surface + ".equalizerMap";
			$script = "HfSurfaceChanged " + $watchPlug;
			addConnChangedScriptJob( `scriptJob -cu true -con $watchPlug $script` );
		}
	}
}

// This procedure goes through all FurDescriptions and tries to
// create a FurFeedback if it is not created already.
proc attachFurFeebacks ()
{
	string	$descriptions[], $hairDesc;

	getAllHairDescriptions( $descriptions, false );
	for ( $hairDesc in $descriptions ) {
		attachHairFeedbackToAssignedSurfaces( $hairDesc );
	}
}

addDebugTag("openSceneCB");

//#define kNewScene		0
//#define kOpenScene		1
//#define kImportScene	2
//#define kReferenceScene	3

global string	$HfLastSceneName;
global int		$HfPluginCBWorking = false;
global int		$HfResetFurDefered = false;

$HfLastSceneName = "";

global proc HfResetScriptJobs()
{
	string $feedbackNodes[] = `ls -type "FurFeedback"`;
	if( size($feedbackNodes) != 0 )
	{
		string $selected[];
		HfGetSelectedSurfaceShapes ( $selected );
		if ( size($selected) != 0 ) {
			evalDeferred( "HfResetAllScriptJobs" );
		}
	}
}

global proc HfStartSelectionChangedJob ()
{
	global int	$HfSelectionChangedJobId;
	$HfSelectionChangedJobId = `scriptJob -protected -event 
					"SelectionChanged" "HfResetScriptJobs"`;
}

global proc HfStopSelectionChangedJob ()
{
	global int	 $HfAttrChangedScriptJobs[];
	global int	 $HfConnChangedScriptJobs[];
	global int	$HfSelectionChangedJobId;
	int		 $id;

	// first kill off any running fur feedback script jobs
	//
	for ( $id in $HfAttrChangedScriptJobs ) {
		if (`scriptJob -exists $id`) {
			scriptJob -kill $id;
		}
	}
	clear( $HfAttrChangedScriptJobs );

	// then kill off any running surface script jobs
	//
	for ( $id in $HfConnChangedScriptJobs ) {
		if (`scriptJob -exists $id`) {
			scriptJob -kill $id;
		}
	}
	clear( $HfConnChangedScriptJobs );

	if (`scriptJob -exists $HfSelectionChangedJobId`) {
		scriptJob -force -kill $HfSelectionChangedJobId ;
	}
}

global proc HfResetFur()
{
	global string $gHfHairMenu;
 	if(!(`menu -exists $gHfHairMenu` || `inBatchMode`))
 		return;
	
	global int		$HfResetFurDefered;

	string	$tag="openSceneCB";

	HfTDebug($tag,"In HfResetFur()");

	global string	$HfLastSceneName;
	
	$HfLastSceneName = `file -q -sn`;
	
	// mark hair globals lists as dirty  so they get rebuilt next time
	// they are needed
	//
	global int $HfHairGlobalsListsBuilt;

	$HfHairGlobalsListsBuilt = false;

	resetMapBaseName();
	HfResetAttrChangedScriptJobs();

	// go through all hair descriptions and attractor sets
	// and check if all the attribute maps are accessible
	//
	copySharedAttributeMaps( true );

	// go through all fur descriptions and create FurFeedback
	// nodes if they are not created already.
	//
	attachFurFeebacks();
	
	string	$allFBObjects[];
	string	$obj;
	
	// make sure that the new global scale attributes
	// and roll attributes introduced in 3.0 are connected as well
	//
	$allFBObjects = `ls -type FurFeedback`;
	for ( $obj in $allFBObjects ) {
		string	$hfScalePlug = feedbackHairGlobalScalePlug( $obj );
		string	$srcPlug = getSrcPlug( $hfScalePlug );

		if ( $srcPlug == "" ) {
			string	$hd = getHairDescFromFeedback( $obj );

			if ( $hd != "" ) {
				string	$hdScalePlug = hairGlobalScalePlug( $hd );

				HfTDebug($tag,"connecting " + $hdScalePlug + " to " + $hfScalePlug);
				connectAttr $hdScalePlug $hfScalePlug;
			}
		}

		$hfScalePlug = feedbackAttractorGlobalScalePlug( $obj );
		$srcPlug = getSrcPlug( $hfScalePlug );

		if ( $srcPlug == "" ) {
			string	$as = getAttractorSetFromFeedback( $obj );

			if ( $as != "" ) {
				string	$asScalePlug = attractorGlobalScalePlug( $as );

				HfTDebug($tag,"connecting " + $asScalePlug + " to " + $hfScalePlug);
				connectAttr $asScalePlug $hfScalePlug;
			}
		}

		// check if roll attributes are hooked up
		//
		string	$rollDstPlug = $obj + "." + feedbackDefaultAttr("Roll");
		
		$srcPlug = getSrcPlug( $rollDstPlug );
		if ( $srcPlug == "" ) {
			// have to find out multi-index so check one of the other attributes
			string	$incMapPlug = $obj + "." + feedbackMapAttr("Inclination");

			$srcPlug = getSrcPlug( $incMapPlug );
			if ( $srcPlug != "" ) {
				int		$multiIdx = getMultiIndex( $srcPlug );
				string	$hd = getHairDescFromFeedback( $obj );

				if ( $hd != "" && $multiIdx >= 0 ) {
					HfTDebug($tag,"connecting roll attributes from " + $hd + " to " + $obj);
					connectToHFAttrs(
						$hd, $multiIdx, $obj, "Roll"
					);
				}
			}
		}

		// check if Offset attributes are hooked up
		//
		string $offsetDstPlug = $obj + "." + feedbackDefaultAttr("Offset");
		
		$srcPlug = getSrcPlug( $offsetDstPlug );
		if ( $srcPlug == "" ) {
			// have to find out multi-index so check one of the other attributes
			string	$incMapPlug = $obj + "." + feedbackMapAttr("Inclination");

			$srcPlug = getSrcPlug( $incMapPlug );
			if ( $srcPlug != "" ) {
				int		$multiIdx = getMultiIndex( $srcPlug );
				string	$hd = getHairDescFromFeedback( $obj );

				if ( $hd != "" && $multiIdx >= 0 ) {
					HfTDebug($tag,"connecting offset attributes from " + $hd + " to " + $obj);
					connectToHFAttrs(
						$hd, $multiIdx, $obj, "Offset"
					);
				}
			}
		}

		// check if Base Ambient color attributes are hooked up
		//
		string $baseAmbientDstPlug = $obj + "." + feedbackDefaultAttr("BaseAmbientColor");
		
		$srcPlug = getSrcPlug( $baseAmbientDstPlug );
		if ( $srcPlug == "" ) {
			// have to find out multi-index so check one of the other attributes
			string	$incMapPlug = $obj + "." + feedbackMapAttr("Inclination");

			$srcPlug = getSrcPlug( $incMapPlug );
			if ( $srcPlug != "" ) {
				int		$multiIdx = getMultiIndex( $srcPlug );
				string	$hd = getHairDescFromFeedback( $obj );

				if ( $hd != "" && $multiIdx >= 0 ) {
					HfTDebug($tag,"connecting BaseAmbientColor attributes from " + $hd + " to " + $obj);
					connectToHFAttrs(
						$hd, $multiIdx, $obj, "BaseAmbientColor"
					);
				}
			}
		}
				
		// check if TipAmbient color attributes are hooked up
		//
		string $tipAmbientDstPlug = $obj + "." + feedbackDefaultAttr("TipAmbientColor");
		
		$srcPlug = getSrcPlug( $tipAmbientDstPlug );
		if ( $srcPlug == "" ) {
			// have to find out multi-index so check one of the other attributes
			string	$incMapPlug = $obj + "." + feedbackMapAttr("Inclination");

			$srcPlug = getSrcPlug( $incMapPlug );
			if ( $srcPlug != "" ) {
				int		$multiIdx = getMultiIndex( $srcPlug );
				string	$hd = getHairDescFromFeedback( $obj );

				if ( $hd != "" && $multiIdx >= 0 ) {
					HfTDebug($tag,"connecting TipAmbient Color attributes from " + $hd + " to " + $obj);
					connectToHFAttrs(
						$hd, $multiIdx, $obj, "TipAmbientColor"
					);
				}
			}
		}
		
		// check if Specular Color attributes are hooked up
		//
		string $specularDstPlug = $obj + "." + feedbackDefaultAttr("SpecularColor");
		
		$srcPlug = getSrcPlug( $specularDstPlug );
		if ( $srcPlug == "" ) {
			// have to find out multi-index so check one of the other attributes
			string	$incMapPlug = $obj + "." + feedbackMapAttr("Inclination");

			$srcPlug = getSrcPlug( $incMapPlug );
			if ( $srcPlug != "" ) {
				int		$multiIdx = getMultiIndex( $srcPlug );
				string	$hd = getHairDescFromFeedback( $obj );

				if ( $hd != "" && $multiIdx >= 0 ) {
					HfTDebug($tag,"connecting Specular Color attributes from " + $hd + " to " + $obj);
					connectToHFAttrs(
						$hd, $multiIdx, $obj, "SpecularColor"
					);
				}
			}
		}

		// check if Specular Sharpness attributes are hooked up
		//
		string $specularSharpDstPlug = $obj + "." + feedbackDefaultAttr("SpecularSharpness");
		
		$srcPlug = getSrcPlug( $specularSharpDstPlug );
		if ( $srcPlug == "" ) {
			// have to find out multi-index so check one of the other attributes
			string	$incMapPlug = $obj + "." + feedbackMapAttr("Inclination");

			$srcPlug = getSrcPlug( $incMapPlug );
			if ( $srcPlug != "" ) {
				int		$multiIdx = getMultiIndex( $srcPlug );
				string	$hd = getHairDescFromFeedback( $obj );

				if ( $hd != "" && $multiIdx >= 0 ) {
					HfTDebug($tag,"connecting Specular Sharpness attributes from " + $hd + " to " + $obj);
					connectToHFAttrs(
						$hd, $multiIdx, $obj, "SpecularSharpness"
					);
				}
			}
		}

		// check if Custom Equalizer attribute are hooked up
		//
		string $customDstPlug = $obj + "." + feedbackDefaultAttr("CustomEqualizer");
		
		$srcPlug = getSrcPlug( $customDstPlug );
		if ( $srcPlug == "" ) {
			// have to find out multi-index so check one of the other attributes
			string	$incMapPlug = $obj + "." + feedbackMapAttr("Inclination");

			$srcPlug = getSrcPlug( $incMapPlug );
			if ( $srcPlug != "" ) {
				int		$multiIdx = getMultiIndex( $srcPlug );
				string	$hd = getHairDescFromFeedback( $obj );

				if ( $hd != "" && $multiIdx >= 0 ) {
					HfTDebug($tag,"connecting customEqualizer attributes from " + $hd + " to " + $obj);
					connectToHFAttrs(
						$hd, $multiIdx, $obj, "CustomEqualizer"
					);
				}
			}
		}

		// check if Clumping attributes are hooked up.
		//
		string $clumpingDstPlug = $obj + "." + feedbackDefaultAttr("Clumping");
		
		$srcPlug = getSrcPlug( $clumpingDstPlug );
		if ( $srcPlug == "" ) {
			// have to find out multi-index so check one of the other attributes
			string	$incMapPlug = $obj + "." + feedbackMapAttr("Inclination");

			$srcPlug = getSrcPlug( $incMapPlug );
			if ( $srcPlug != "" ) {
				int		$multiIdx = getMultiIndex( $srcPlug );
				string	$hd = getHairDescFromFeedback( $obj );

				if ( $hd != "" && $multiIdx >= 0 ) {
					HfTDebug($tag,"connecting clumping attributes from " + $hd + " to " + $obj);
					connectToHFAttrs(
						$hd, $multiIdx, $obj, "Clumping"
					);
				}
			}
		}

		// check if Clumping Frequency attributes are hooked up.
		//
		string $clumpingFrqDstPlug = $obj + "." + feedbackDefaultAttr("ClumpingFrequency");
		
		$srcPlug = getSrcPlug( $clumpingFrqDstPlug );
		if ( $srcPlug == "" ) {
			// have to find out multi-index so check one of the other attributes
			string	$incMapPlug = $obj + "." + feedbackMapAttr("Inclination");

			$srcPlug = getSrcPlug( $incMapPlug );
			if ( $srcPlug != "" ) {
				int		$multiIdx = getMultiIndex( $srcPlug );
				string	$hd = getHairDescFromFeedback( $obj );

				if ( $hd != "" && $multiIdx >= 0 ) {
					HfTDebug($tag,"connecting clumping frequency attributes from " + $hd + " to " + $obj);
					connectToHFAttrs(
						$hd, $multiIdx, $obj, "ClumpingFrequency"
					);
				}
			}
		}

		// check if Clump Shape attributes are hooked up.
		//
		string $clumpShapeDstPlug = $obj + "." + feedbackDefaultAttr("ClumpShape");
		
		$srcPlug = getSrcPlug( $clumpShapeDstPlug );
		if ( $srcPlug == "" ) {
			// have to find out multi-index so check one of the other attributes
			string	$incMapPlug = $obj + "." + feedbackMapAttr("Inclination");

			$srcPlug = getSrcPlug( $incMapPlug );
			if ( $srcPlug != "" ) {
				int		$multiIdx = getMultiIndex( $srcPlug );
				string	$hd = getHairDescFromFeedback( $obj );

				if ( $hd != "" && $multiIdx >= 0 ) {
					HfTDebug($tag,"connecting clump shape attributes from " + $hd + " to " + $obj);
					connectToHFAttrs(
						$hd, $multiIdx, $obj, "ClumpShape"
					);
				}
			}
		}
	}

	// make sure that the new shadow map dynamic attributes added in 3.0,
	// are added to spot lights that have fur shading attributes
	//
	string	$allSpotLights[];
	string	$obj;
	
	$allSpotLights = `ls -type spotLight`;
	for ( $obj in $allSpotLights ) {
		if ( `attributeQuery -ex -node $obj "furShadingType"` ) {
			HfTDebug($tag,"making shadow map attributes for " + $obj);
			makeShadeAttributes( $obj, 1 );
		}
	}

	$HfResetFurDefered = false;

	//Update advanced Fur Render Dialog Box on New/Open Scene operation
	if ( `window -exists AdvancedFurWnd` )
	{
		HfAdvanceRenderUpdate();
	}

	//Added new attribute "uvSetName" to Fur Description node in 4.5 version
	//Make connection between uvSet of the the polygon Shape node and attached Fur Description node.

	string	$descriptions[];
	$descriptions = `ls -type FurDescription`;
	if (size($descriptions) > 0) {
		HfUpdateUVSetConnection();
	}
	HfUpdateAnimTexture();
}

global proc HfUpdateAnimTexture()
{
	// Find all file textures
	string $fileTextures[] = `ls -type "file" `;
	string $texture;
	
	for($texture in $fileTextures)
	{
		//List all file texture attributes
		string $textureAttrList[];
		$textureAttrList = `listAttr $texture`;
		
		// get a list of all attributes that are the source of a connection
		// the return value is of the format [ source plug, dest plug, source plug, dest plug, ...]
		// so when we iterate over it we need to skip every other entry.
		string $connections[] = `listConnections -source false -destination true -connections true $texture`;

		int $i = 0;
		for ($i = 0; $i < size( $connections ); $i += 2 ) {
			string $sourcePlug = $connections[$i];

			string $defaultAttrPlug[];
			string $expressionName[];

			if(  size (`connectionInfo -dfs ($sourcePlug)`) !=0 &&  size (`connectionInfo -dfs ($texture+".frameExtension")`) !=0)
			{
				$defaultAttrPlug = `connectionInfo -dfs ($sourcePlug)`;
				$expressionName = `connectionInfo -dfs ($texture+".frameExtension")` ;
				
				if( `nodeType $defaultAttrPlug[0]` == "FurDescription" )
				{
					$expressionName[0] = plugNode($expressionName[0]);

					// check if the attribute "furAnimTexture" has been added
					int $found = false;
					string $expAttrList[];
					string $expAttr;

					$expAttrList = `listAttr -ud $expressionName[0]`;
					for( $expAttr in $expAttrList )
					{
						if($expAttr == "furAnimTexture")
						{
							return;
						}
					}	
					
					// Adding "furAnimTexture" attribute
					addAttr -attributeType bool -multi -hidden true -longName "furAnimTexture" -shortName "fat" $expressionName[0];
					
					// Make connection between fur description and expression nodes.
					for ( $attrPlug in $defaultAttrPlug )
					{
						//Get surface multi indices
						string $surfaces[];
						int $indices[];
						getHairSetMembers( $attrPlug, $surfaces, $indices );
						
						string $attr = plugAttr($attrPlug);
						string $node = plugNode($attrPlug);
						for($count=0; $count<size($surfaces); $count++)
						{
							int $mi = $indices[$count];

							setAttr ($node + "." + hairMapFileAttr($attr) + "[" + $mi + "]") true;
							setAttr ($expressionName[0] + ".furAnimTexture" + "[" + $mi + "]") true;

							connectAttr ($node + "." + hairMapFileAttr($attr) + "[" + $mi + "]") ($expressionName[0] + ".furAnimTexture" + "[" + $mi + "]");

							string $mapUSamplesPlug = $node + "." + hairMapUSamplesAttr($attr) + "[" + $mi + "]";
							string $mapVSamplesPlug = $node + "." + hairMapVSamplesAttr($attr) + "[" + $mi + "]";

							setAttr $mapUSamplesPlug -1;
							setAttr $mapVSamplesPlug -1;	
						}
					}
				}
			}
		}
	}
}

global proc HfUpdateUVSetConnection()
{
	//Find all mesh nodes that are available in the scene. 
	string $allMeshObj[] = `ls -type mesh`;
	string $polygonShapeNode;

	for($polygonShapeNode in $allMeshObj)
	{
		//Get "Attached Fur Descriptions" to the polygon shape Node.
		string $furDescription[];
		string $furObj;
		$furDescription = HfGetFurDescription($polygonShapeNode);

		for($furObj in $furDescription )
		{					
			string $allAttr[] = `listAttr -m -st "uvSetName" $polygonShapeNode`;
			int $isConnected = false;
		
			//Check the availability of connection between UV set and Fur Descriptions
			for( $nCount =0; $nCount < size($allAttr); $nCount++ )
			{
				string $strName = $polygonShapeNode +"."+$allAttr[$nCount] ;
				string $allConnection[];
			
				if(size(`connectionInfo -dfs $strName`) > 0 )
				{
					$allConnection = `connectionInfo -dfs $strName`;
				}
				else
				{
					continue;
				}
				
				for($nIndex =0; $nIndex < size($allConnection); $nIndex++)
				{
					if(`nodeType $allConnection[$nIndex]` == "FurDescription")
					{
						if(`isConnected $strName $allConnection[$nIndex]`)
						{
							$isConnected =	true;
							break;
						}
					}
				}
			}

			if( $isConnected == false )
			{
				//Make the connection between FurDescription.uvsn and polygon.uvSetName
				HfConnectFurPolygonUVSetName($polygonShapeNode,$furObj);
			}
		}
	}
}

proc openSceneCallback(
	int	$openType
)
{
	string	$tag="openSceneCB";

	HfTDebug($tag,"openType=" + $openType);

	global int		$HfResetFurDefered;

	// if there is already a reset deferred, don't do another one
	//
	if ( !$HfResetFurDefered ) {
		HfTDebug($tag,"evalDeferred HfResetFur");
		evalDeferred HfResetFur;
		$HfResetFurDefered = true;
	}
}

// this one is called by plugin if built using
// Maya 1.5 API or later
//
global proc HfOpenSceneCallback(
	int	$openType
)
{
	global int	$HfPluginCBWorking;

	$HfPluginCBWorking = true;
	if ( $openType >= 0 ) {
		openSceneCallback( $openType );
	}
}

addDebugTag("saveSceneCB");

//#define kSaveScene				0
//#define kExportScene			1
//#define kExportSceneReference	2

proc saveProjectLocationOnGlobals()
{
	string $tag = "saveSceneCB";

	string $globals[] = `ls -type "FurGlobals"`;
	for ( $node in $globals )
	{
		// This won't really work for references, since we don't know
		// what file the node came from
		if ( !`isFromReferencedFile $node` )
		{
			string $attr = "projectLocation";
			string $plug = $node + "." + $attr;
			if ( !`attributeQuery -ex -node $node $attr` )
			{
				addAttr -dt "string" -ln $attr $node;
			}

			string $ws = `workspace -q -fn`;
			if ( $ws != "" )
			{
				string $currProjLoc = `getAttr $plug`;
				if ( $ws != $currProjLoc )
				{
					HfTDebug($tag, "setting " + $plug + " to be " + $ws );
					setAttr $plug -type "string" $ws;
				}
			}

			// For pre-3.0.1, we also check and add copyAttrMaps if it's not there
			if ( !`attributeQuery -ex -node $node "copyAttrMaps"` )
			{
				addAttr -at "short" -ln "copyAttrMaps" $node;
			}
		}
	}
}

proc saveSceneCallback(
	int	$beforeSave,
	int $saveType
)
{
	string	$tag="saveSceneCB";

	HfTDebug($tag,"before=" + $beforeSave + " saveType=" + $saveType);

	global string	$HfLastSceneName;

	if ( $beforeSave ) {
		string	$sceneName = `file -q -sn`;

		if ( $HfLastSceneName != $sceneName ) {
			HfTDebug($tag,
				"scene name changed\n from: " + $HfLastSceneName
			  + "\n to: " + $sceneName);
	
			$HfLastSceneName = $sceneName;
		}

		// make sure all dirty maps are saved
		//
		HfExportMaps();

		// go through all hair descriptions and copy all
		// painted attribute map files that may be refered
		// to by other scene files
		//
		copySharedAttributeMaps( false );

		saveProjectLocationOnGlobals();
	}

	//If fur description doesn't exist in the scene,
	//export before save callback should not be executed 
	string $furDescs[] = `ls -type FurDescription`;

	if($beforeSave && $saveType == 1 && size($furDescs) != 0 )
	{ 
		//Surface reference
		string $surfaceNames[] = `ls -type nurbsSurface -type mesh -type subdiv`;
		for($surface in $surfaceNames)
		{
			int $isSurfaceFound = false;
			int $isReferenceFileFound = false;
			int $nameSpaceFound = false;
			string $userDefinedAttrList[] = `listAttr -ud $surface`;
			for( $userDefinedAttr in $userDefinedAttrList )
			{
				if($userDefinedAttr == "surfaceReference")
				{
					$isSurfaceFound = true;
				}
				else if($userDefinedAttr == "referenceFile")
				{
					$isReferenceFileFound = true;
				}
				else if($userDefinedAttr == "furNameSpace")
				{
					$nameSpaceFound = true;
				}
			}
			if( $isSurfaceFound == false )
			{
				addAttr -attributeType bool -hidden true -longName "surfaceReference" -shortName "sref" $surface;
			}			
			if(	$isReferenceFileFound == false )
			{
				addAttr -dataType "string" -hidden true -longName "referenceFile" -shortName "reff" $surface;
			}
			if(	$nameSpaceFound == false )
			{
				addAttr -dataType "string" -hidden true -longName "furNameSpace" -shortName "fns" $surface;
			}

			if(`reference -q -inr $surface`)
			{
				$fileName = `reference -q -f $surface`;
				setAttr -type "string" ($surface+".referenceFile") $fileName;

				$nameSpace = `file -q -ns $fileName`;
				setAttr -type "string" ($surface+".furNameSpace") $nameSpace;
				
				setAttr ($surface+".surfaceReference") true;
			}
			else
			{
				setAttr ($surface+".surfaceReference") false;
			}
		}
		//Fur Description reference
		for($furDesc in $furDescs)
		{
			int $isFurDescFound = false;
			string $userDefinedAttrList[] = `listAttr -ud $furDesc`;

			for( $userDefinedAttr in $userDefinedAttrList )
			{
				if($userDefinedAttr == "furReference")
				{
					$isFurDescFound = true;
				}
			}	
	
			if( $isFurDescFound == false )
			{
				addAttr -attributeType bool -hidden true -longName "furReference" -shortName "fref" $furDesc;
			}

			if(`reference -q -inr $furDesc`)
			{
				setAttr ($furDesc+".furReference") true;
			}
			else
			{
				setAttr ($furDesc+".furReference") false;
			}
		}
		//Fur Global reference
		string	$hairGlobals = HfBuildHairGlobal();
		string $furGlobals[] = `ls -type FurGlobals`;
		for($furGlobal in $furGlobals)
		{
			int $isFurGlobalFound = false;
			string $userDefinedAttrList[] = `listAttr -ud $furGlobal`;
						
			for( $userDefinedAttr in $userDefinedAttrList )
			{
				if($userDefinedAttr == "furGlobalReference")
				{
					$isFurGlobalFound = true;
				}
			}	
	
			if( $isFurGlobalFound == false )
			{
				addAttr -attributeType bool -hidden true -longName "furGlobalReference" -shortName "fgrf" $furGlobal;
			}
			if(`reference -q -inr $furGlobal`)
			{
				setAttr ($furGlobal+".furGlobalReference") true;
			}
			else
			{
				setAttr ($furGlobal+".furGlobalReference") false;
			}
		}		
		$hairGlobals +=".readEqualMapPath";
		if(size(`getAttr $hairGlobals`)==0)
		{
			string $sceneName = HfGetSceneName();
			string $eqMapPath = getProjectDir("fileRule", "furEqualMap")  + "/" + $sceneName;
			setAttr -type "string" ($hairGlobals) $eqMapPath;			
		}
	}
	if($beforeSave == false && $saveType == 0 && size($furDescs) != 0)
	{
		string	$hairGlobals = HfBuildHairGlobal();
		$hairGlobals +=".readEqualMapPath";
		string $sceneName = HfGetSceneName();
		string $eqMapPath = getProjectDir("fileRule", "furEqualMap")  + "/" + $sceneName;
		setAttr -type "string" ($hairGlobals) $eqMapPath;			
	}
}

// this one is called by plugin if built using
// Maya 1.5 API or later
//
global proc HfSaveSceneCallback(
	int	$beforeSave,
	int	$saveType
)
{
	global int	$HfPluginCBWorking;

	$HfPluginCBWorking = true;
	if ( $saveType >= 0 ) {
		saveSceneCallback( $beforeSave, $saveType );
		//Update advanced Fur Render Dialog Box on File Save/SaveAs operation
		if ( `window -exists AdvancedFurWnd` )
		{
			HfAdvanceRenderUpdate();
		}
	}
}

global proc int HfLightShadingType(
	string $name
)
{
	int $shadType = 0;
	
	if( `attributeQuery -exists -n $name furShadingType` )
	{
		string $plug = $name + ".furShadingType";
		$shadType = `getAttr $plug`;
	}

	return $shadType;
}

global proc string[] HfGetFurDesFromShape(string $polygonShapeNode)
{
	string $furDescription[];
	string $iogNodes[];
	string $result[];

	//get current uv index id
	int $nCurrIndex = HfGetCurrentUVsetNumber($polygonShapeNode);

	//get "uvSetName" attributes of $polygonShapeNode
	string $allAttr[] = `listAttr -m -st "uvSetName" $polygonShapeNode`;

	//Check the availability of connection between non current UV set and Fur Descriptions
	for( $nCount =0; $nCount < size($allAttr); $nCount++ )
	{
		if($nCurrIndex != $nCount)
		{
			string $strName = $polygonShapeNode +"."+$allAttr[$nCount] ;
			string $allConnection[];

			if(size(`connectionInfo -dfs $strName`) > 0 )
			{
				$allConnection = `connectionInfo -dfs $strName`;
			}
			else
			{
				continue;
			}
	
			for($nIndex =0; $nIndex < size($allConnection); $nIndex++)
			{
				if(`nodeType $allConnection[$nIndex] ` == "FurDescription")
				{
					if(`isConnected $strName $allConnection[$nIndex]`)
					{
						return $result;
					}
				}
			}
		}
	}
							
	string $iog = $polygonShapeNode+".iog";
	string $testIog[];

	//Check the availability of "instObjGroups" node from given polygon shape node.
	//
	$testIog = `listAttr -m -st "instObjGroups" $polygonShapeNode`;
	if(size($testIog) != 0)
	{
		//Get the distination nodes from source node
		//
		if(size(`connectionInfo -dfs $iog`) > 0)
			$iogNodes  = `connectionInfo -dfs $iog`;
	}

	int $nCount;
	for($nCount=0; $nCount < size($iogNodes); $nCount++)
	{
		//Get the Fur description node from iogNodes.
		//
		if(`nodeType $iogNodes[$nCount]` == "FurDescription")
		{
			$furDescription[size($furDescription)] = $iogNodes[$nCount];
		}
	}
	
	for($nCount=0; $nCount < size($furDescription); $nCount++)
	{
		// Get the fur description node without attribute name.
		//
		string $furBuffer[];
		int $numTokens;
		$numTokens = `tokenize $furDescription[$nCount] "." $furBuffer`;
		
		$result[size($result)] = $furBuffer[0];
	}

	return $result;
}

global proc string HfGetFurUVSet(string $polygonShapeNode, int $isFeedback)
{
	string $furUVSet;

	//get shape node of given polygon node
	string	$selected[];
	string  $items[];
	$items[0] = $polygonShapeNode;
	getSurfaceShapes($items,$selected, 0, 0);
	$polygonShapeNode = $selected[0];
	
	//get "uvSetName" attributes of $polygonShapeNode
	string $allAttr[] = `listAttr -m -st "uvSetName" $polygonShapeNode`;

	//Check the availability of connection between UV set and Fur Descriptions
	for( $nCount =0; $nCount < size($allAttr); $nCount++ )
	{
		string $strName = $polygonShapeNode +"."+$allAttr[$nCount] ;
		string $allConnection[];
	
		if(size(`connectionInfo -dfs $strName`) > 0 )
		{
			$allConnection = `connectionInfo -dfs $strName`;
		}
		else
		{
			continue;
		}
		
		for($nIndex =0; $nIndex < size($allConnection); $nIndex++)
		{
			if(`nodeType $allConnection[$nIndex] ` == "FurDescription")
			{
				if(`isConnected $strName $allConnection[$nIndex]`)
				{
					$furUVSet = `getAttr $strName`;
					return $furUVSet;
				}
			}
		}
	}

	//Connect uvSetName attribute of Fur Description to default uv set of 
	//polygon shape node when fur uv set is deleted.
	if($isFeedback)
	{
		string $allFurDes[];
		$allFurDes = HfGetFurDescription($polygonShapeNode);
		
		int $nCount;
		for($nCount=0; $nCount < size($allFurDes); $nCount++)
		{
			string $members[];
			int $memberIndexs[];
			$lastMemberIndex = -1;

			getHairSetMembersUVSet( $allFurDes[$nCount], $members, $memberIndexs );

			for ( $mi in $memberIndexs ) {
				if ( ($mi - $lastMemberIndex) > 1 ) {
					break;
				}
				$lastMemberIndex = $mi;
			}

			$lastMemberIndex++;
			connectAttr ($polygonShapeNode +".uvSet[0].uvSetName")
						($allFurDes[$nCount] + ".uvsn[" + $lastMemberIndex + "]");

		}

	}

	string $defaultUVSet = $polygonShapeNode +"."+$allAttr[0]; 
	$furUVSet =`getAttr $defaultUVSet`;
	return $furUVSet;
}

global proc string[] HfGetFurDescription(string $polygonShapeNode )
{
	string $furDescription[];
	string $iogNodes[];
	string $result[];

	string $iog = $polygonShapeNode+".iog";
	string $testIog[];

	//Check the availability of "instObjGroups" node from given polygon shape node.
	//
	$testIog = `listAttr -m -st "instObjGroups" $polygonShapeNode`;
	if(size($testIog) != 0)
	{
		//Get the distination nodes from source node
		//
		if(size(`connectionInfo -dfs $iog`) > 0)
			$iogNodes  = `connectionInfo -dfs $iog`;
	}

	int $nCount;
	for($nCount=0; $nCount < size($iogNodes); $nCount++)
	{
		//Get the Fur description node from iogNodes.
		//
		if(`nodeType $iogNodes[$nCount]` == "FurDescription")
		{
			$furDescription[size($furDescription)] = $iogNodes[$nCount];
		}
	}
	
	for($nCount=0; $nCount < size($furDescription); $nCount++)
	{
		// Get the fur description node without attribute name.
		//
		string $furBuffer[];
		int $numTokens;
		$numTokens = `tokenize $furDescription[$nCount] "." $furBuffer`;
		
		$result[size($result)] = $furBuffer[0];
	}
	return $result;
}

global proc HfConnectFurPolygonUVSetName( string $polygonShapeNode, string $furBuffer )
{
	//Connecting polygon uvSetName and  Fur Description uvsn.
	int $lastMemberIndex = -1;
	string $members[];
	int $memberIndexs[];

	getHairSetMembersUVSet( $furBuffer, $members, $memberIndexs );

	for ( $mi in $memberIndexs ) {
	if ( ($mi - $lastMemberIndex) > 1 ) {
	// there is a gap in the indexs so stick
	// the surface there
	//
			break;
		}
		$lastMemberIndex = $mi;
	}

	$lastMemberIndex++;

	string  $uvName;
	int $nIndex = -1;
	$uvName = `getAttr ($polygonShapeNode +".uvSet[0].uvSetName")`;

	if( size($uvName) == 0 )
	{
		$nIndex = HfGetCurrentUVsetNumber($polygonShapeNode);
	}
	else
	{
		$nIndex = 0;
	}

	if( $nIndex != -1 )
	{
		connectAttr ($polygonShapeNode +".uvSet["+$nIndex+"].uvSetName")
					($furBuffer + ".uvsn[" + $lastMemberIndex + "]");
	}
}

global proc string HfGetFurUVSetAttribute(string $polygonShapeNode)
{
	//get shape node of given polygon node
	string	$selected[];
	string  $items[];
	$items[0] = $polygonShapeNode;
	getSurfaceShapes($items,$selected, 0, 0);
	$polygonShapeNode = $selected[0];
	
	//get "uvSetName" attributes of $polygonShapeNode
	string $allAttr[] = `listAttr -m -st "uvSetName" $polygonShapeNode`;

	//Check the availability of connection between UV set and Fur Descriptions
	for( $nCount =0; $nCount < size($allAttr); $nCount++ )
	{
		string $strName = $polygonShapeNode +"."+$allAttr[$nCount] ;
		string $allConnection[];
	
		if(size(`connectionInfo -dfs $strName`) > 0 )
		{
			$allConnection = `connectionInfo -dfs $strName`;
		}
		else
		{
			continue;
		}
		
		for($nIndex =0; $nIndex < size($allConnection); $nIndex++)
		{
			if(`nodeType $allConnection[$nIndex] ` == "FurDescription")
			{
				if(`isConnected $strName $allConnection[$nIndex]`)
				{					
					return $strName;
				}
			}
		}
	}
	
	string $defaultUVSet = $polygonShapeNode +"."+$allAttr[0]; 
	return $defaultUVSet;
}

global proc string[] HfGetFurSurfaces()
{
	string $allObj[];
	$allObj = `ls -type nurbsSurface -type mesh -type subdiv`;
	string $furObj[];
	int $count;

	for($count=0; $count < size($allObj); $count++)
	{
		string	$hairDescriptions[];
		string $selectedObj[];

		$selectedObj[0] = $allObj[$count];

		getAllDescriptions(
			getHairGlobalsHDListPlug(false), $hairDescriptions,
			$selectedObj);

		if( size($hairDescriptions) > 0 )
		{
			$furObj[size($furObj)] = $allObj[$count];
		}
		clear($hairDescriptions);
	}
	return $furObj;
}

global proc HfUpdateFurUVEditor()
{
	//Get Relationship Editor panel
	string $relationshipEditorPanel = `getPanel -wl (localizedPanelLabel("Relationship Editor"))`;
	//Get All Visible Panels
	string $visiblePanels[]   = `getPanel -vis`;

	int $existRelatinshipPanel = false;
	string $taskName;

	//Check whether Relationship Editor is visible or not.
	for( $thisPanel in $visiblePanels )
	{
		if( $relationshipEditorPanel == $thisPanel )
		{
			$existRelatinshipPanel = true;
			break;
		}
	}

	//Update Relationship Editor if current task is Fur/UV Linking
	if( $existRelatinshipPanel == true )
	{
		if (`optionVar -exists relationshipEditorTask`)
		{
			$taskName = `optionVar -query relationshipEditorTask`;
    
			if( $taskName == "furUVLinking" )
			{
				relationshipEditorRelationshipsChanged $relationshipEditorPanel $taskName;
			}
		}
	}	
}

global proc string HfGetMeshNodeFromFeedback(string $feedback)
{
	string $shapeNode;
	$shapeNode = `connectionInfo -sfd ($feedback+".inputMesh")`;

	string $shapeName;
	string $tokenizedNames[];
	int $numTokens = `tokenize $shapeNode "." $tokenizedNames`;

	if( `nodeType $tokenizedNames[0]` == "mesh")
	{
		$shapeName = $tokenizedNames[0];
	}

	return $shapeName;
}

global proc string HfGetSubdShapeFromFeedback(string $feedback)
{
	string $shapeNode;
	string $strName = $feedback+".inputSubdiv";
	
	$shapeNode = `connectionInfo -sfd $strName`;

	string $retName;
	string $shapeName[];
	int $numTokens = `tokenize $shapeNode "." $shapeName`;
	if( `nodeType $shapeName[0]` == "subdiv")
	{
		$retName = $shapeName[0];
	}

	return $retName;
}

global proc string HfGetSurfaceShapeFromFeedback(string $feedback)
{
	string $retName = "";
	
	$retName = getSurfaceShapeFromFeedback ($feedback);
	if ($retName == "") {
		// This Fur is not connected to any Surface !!
		//
		error ((uiRes("m_FurPluginCreateUI.kFurFeedbackShapeError")));
		return "";
	}
	return $retName;
}

//bug 177108 Apply Fur Preset doesn't work on groups 
global proc HfGetSelectedSurfaceShapes(
	string	$selected[]
)
{
	getSurfaceShapes(
		`ls -objectsOnly -sl -transforms -type nurbsSurface -type mesh -type subdiv`,
		$selected, 0, 0
	);
}

global proc string HfGetHairDescFromFeedback( string $feedback )
{
    string $hairDesc;
    $hairDesc = getHairDescFromFeedback($feedback);
    return $hairDesc;
}

global proc string[] HfGetUVSample(string $furDesc, string $surface)
{
	string $members[];
	int $multiIndexes[];
	string $uvSample[];
	getHairSetMembers( $furDesc,$members,$multiIndexes);
	
	int $i;
	for( $i=0; $i< size($members); $i++ )
	{
		if($surface == $members[$i] )
		{
			int $value;
			if ( ($value = `getAttr ($furDesc+".feedbackUSamples["+$i+"]")`) == 0 )
			{
				string $feedbackShapeName[] = `connectionInfo -dfs ($surface + ".equalizerMap")`;
				if (size($feedbackShapeName) == 1)
				{
					string $buffer[];
					tokenize($feedbackShapeName[0], ".", $buffer);
					string $connNode = $buffer[0];
					if ( `nodeType $connNode` == "FurFeedback" )
					{
						string $furDescriptionName = `connectionInfo -sfd ($connNode + ".Length")`;
						tokenize($furDescriptionName, ".", $buffer);
						if ($buffer[0] == $furDesc)
						{
							$value = `getAttr ($connNode+".uSamples")`;
						}
					}
				}
			}
			$uvSample[0] = $value;

			if ( ($value = `getAttr ($furDesc+".feedbackVSamples["+$i+"]")`) == 0 )
			{
				string $feedbackShapeName[] = `connectionInfo -dfs ($surface + ".equalizerMap")`;
				if (size($feedbackShapeName) == 1)
				{
					string $buffer[];
					tokenize($feedbackShapeName[0], ".", $buffer);
					string $connNode = $buffer[0];
					if ( `nodeType $connNode` == "FurFeedback" )
					{
						string $furDescriptionName = `connectionInfo -sfd ($connNode + ".Length")`;
						tokenize($furDescriptionName, ".", $buffer);
						if ($buffer[0] == $furDesc)
						{
							$value = `getAttr ($connNode+".vSamples")`;
						}
					}
				}
			}
			$uvSample[1] = $value;
			
			return $uvSample;
		}
	}
}

global proc HfDeleteEqualAttr(string $surface)
{
	string	$hairDescriptions[];
	string $surfaces[];
	$surfaces[0] = $surface;

	getAllDescriptions(getHairGlobalsHDListPlug(false), $hairDescriptions, $surfaces);

	// Delete equalizer map attribute if surface doesn't have any furdescription
	if( size($hairDescriptions) == 0 )
	{
		if (`attributeQuery -ex -node $surface "equalizerMap"`)
		{
			deleteAttr -at "equalizerMap" $surface;
		}
	}	
}

global proc int HfCheckCustomMaps(string $shapeName, int $oldMethod)
{
	string $furDes[] = `ls -type FurDescription`;
	string $sceneName = HfGetSceneName();

	int $furCount;
	int $frameNum = HfGetUseFrame();
	for ($furCount=0; $furCount < size($furDes); $furCount++)
	{
		string $defaultAttrPlug = $furDes[$furCount] + ".CustomEqualizerMap";
		string $surfaces[];
		int    $indices[];
		getHairSetMembers( $defaultAttrPlug, $surfaces, $indices );
		
		int $s;
		for ( $s = 0, $numSurfaces = size($surfaces); $s < $numSurfaces; $s++ )
		{
			if(size(`getAttr ($defaultAttrPlug+"["+$indices[$s]+"]")`) == 0 )
			{
				//Get equalizer map path					
				string $reference_equalmap = HfGetReferenceEqualMap($surfaces[$s]);
				string $eqMapPath;
				if($reference_equalmap==" ")
				{					
					if(!$oldMethod)
						$eqMapPath = $sceneName+"_"+$surfaces[$s] +"_eqMap_"+$frameNum+".iff";
					else
						$eqMapPath = $sceneName+"_"+$surfaces[$s] +"_eqMap.iff";
				}
				else
				{
					if(!$oldMethod)
						$eqMapPath = $reference_equalmap+"_eqMap_"+$frameNum+".iff";				
					else
						$eqMapPath = $reference_equalmap+"_eqMap.iff";
				}
				if(!$oldMethod)
				{				
					$eqMapPath  = replaceCharacterInString($eqMapPath, ":","_");	
					$eqMapPath  = replaceCharacterInString($eqMapPath, "|","_");				
					$eqMapPath  = getDirPath("fileRule", "furEqualMap") + "/" + $eqMapPath;
				}
				else
				{
					string $mapPath = `getAttr ($surfaces[$s]+".equalizerMap")`;
					if( $mapPath !="" )
					{
						$eqMapPath = $mapPath;
					}
					if(!isAbsolutePath($eqMapPath))
					{
						// any relative paths are assumed to be rooted at the current project
						//
						string $projectDir = getTheProjectDir();

						$eqMapPath = $projectDir + "/" + $eqMapPath;
					}
				}
				
				//Get attribute map path
				string $attrPath = $sceneName+"_"+$surfaces[$s] +"_"+ $furDes[$furCount] +"_CustomEqualizer.iff";				
				$attrPath =	replaceCharacterInString($attrPath, ":","_");	
				$attrPath =	replaceCharacterInString($attrPath, "|","_");
				$attrPath = getDirPath( "fileRule", "furAttrMap" ) + "/" + $attrPath;

				if(`filetest -f $eqMapPath`)
				{
					sysFile -copy $attrPath $eqMapPath;
					setMapFile( ($defaultAttrPlug+"["+$indices[$s]+"]"), makeProjectRelative( $attrPath ) );
					
					// set the sample size to (-1,-1) to indicate that we generated this file but it wasn't
					// painted
					//
					string $mapUSamplesPlug = $furDes[$furCount] + "." + hairMapUSamplesAttr("CustomEqualizer") + "[" + $indices[$s] + "]";
					string $mapVSamplesPlug = $furDes[$furCount] + "." + hairMapVSamplesAttr("CustomEqualizer") + "[" + $indices[$s] + "]";
		
					setAttr $mapUSamplesPlug -1;
					setAttr $mapVSamplesPlug -1;	
				}
				else
				{
					if ($shapeName == $surfaces[$s])
					{
						if(!$oldMethod || `inBatchMode`)
						{	
							return 0;
						}
						else
						{
							int $rc = HfGenerateCusEqualizer($eqMapPath,$defaultAttrPlug+"["+$indices[$s]+"]");
							return $rc;
						}
					}
				}
			}
		}
	}
	
	return 1;
}

global proc StartProgress(string $statusMessage)
{
	global string $gMainProgressBar;
	progressBar -edit
				-beginProgress
				-status $statusMessage
				-maxValue 100
				$gMainProgressBar;
}

global proc CompleteProgress()
{
	global string $gMainProgressBar;
	progressBar -edit
				-endProgress
				$gMainProgressBar;
}

global proc ProcessStatus(int $statusPercentage)
{
	global string $gMainProgressBar;
	progressBar -edit -step $statusPercentage $gMainProgressBar;
}

global proc string HfGetEqualizerPath()
{
	string $hairGlobal = HfBuildHairGlobal();
	string $eqMapPath = getTheProjectDir()+"/";
	$eqMapPath += getProjectDir("fileRule", "furEqualMap");
	return $eqMapPath;
}

global proc string HfGetAttrMapPath()
{
	string $hairGlobal = HfBuildHairGlobal();
	string $attrMapPath = getTheProjectDir()+"/";
	$attrMapPath += getProjectDir("fileRule", "furAttrMap");
	return $attrMapPath;
}

global proc HFdetachHDFromSurface(string $furDescNode, string $surface)
{
	unassignHDFromSurface($furDescNode, $surface, false);
}

global proc HfSurfaceChanged(
	string	$surfacePlug
)
{
	// check if node is still called the same thing
	// - if there is no node of this name anymore, reset the attribute
	//   changed script jobs
	//
	string	$node;
	$node = plugNode( $surfacePlug );
	
	if ( ! `objExists $node` ) {
		// Surface got deleted, i.e. Delete all the Fur feedback nodes
		// associated with NULL surface.
		//
		string	$allFBObjects[];
		string	$obj;
	
		$allFBObjects = `ls -l -type FurFeedback`;
		for ($obj in $allFBObjects) {
			// Find the surface from this feedback.
			string $surface = "";
			$surface = getSurfaceShapeFromFeedback( $obj );
			if ($surface == "") {
				catch (`HfDeleteHairFeedbackNode( $obj )`);
			}
		}
		evalDeferred( "HfResetAllScriptJobs" );
		return;
	}
	
	// FurFeedback node is deleted hence detach FurDescription from this surface.
	//
	string $furDescription[];
	string $furObj;
	$furDescription = HfGetFurDescription($node);
	for($furObj in $furDescription ) {
		string $furFeedbackNode = "";
		$furFeedbackNode = getFurFeedbackNode ($node, $furObj);
		// If we are not able to find the furFeedback that means this furFeedback
		// is under deletion process.
		//
		if ($furFeedbackNode == "") {
			if (`attributeQuery -ex -node $node "equalizerMap"`) {
				unassignHDFromSurface($furObj, $node, false);
			}
			else {
				unassignHDFromSurface($furObj, $node, true);
			}
		}
	}

	evalDeferred( "HfResetAttrChangedScriptJobs" );
	return;
}

global proc string HfGetBaseName()
{
	
	// The equalizer maps that get created are named
	// according to the scene name that's already in effect.
        // If the user hasn't saved the scene yet, prompt
	// him to now.
	//
	
	string $namingPrefix = `file -q -sn`;
	
	if( $namingPrefix == "" ) {
		string $title = (uiRes("m_FurPluginCreateUI.kSaveSceneWarning"));
		string $msg = (uiRes("m_FurPluginCreateUI.kContinueMessage"));
		string $saveScene = (uiRes("m_FurPluginCreateUI.kSaveSceneButton")); 
		string $cancel = (uiRes("m_FurPluginCreateUI.kCancel"));
		
		string $lastChance = `confirmDialog 
			-title $title
			-message $msg
			-messageAlign "left"
			-button $saveScene 
			-button $cancel 
			-defaultButton $saveScene
			-cancelButton $cancel -dismissString $cancel`;	
		
		int $goAhead = ( $lastChance == $saveScene );
		if( $goAhead ) {
			SaveScene;
			string $scene = `file -q -sceneName`;
			$namingPrefix = `basename $scene ""`;
			if( size( $namingPrefix ) == 0 ) {
				$namingPrefix = untitledFileName();
			}
		}

		if(( size( $namingPrefix ) == 0 )
		|| ( $namingPrefix == (untitledFileName()) ) )	
		{
			return "";
		}
	}
	return $namingPrefix;
}

global proc string HfCheckRefEqualizerMaps(string $shapeName)
{
	string $hairGlobal = HfBuildHairGlobal();
	string $readEqualPath = `getAttr ($hairGlobal + ".readEqualMapPath")`;
	string $prefixName;
	global int $gHfMayaState;
		
	//Find default Equalizer map directory 
	string $strEqualMap = HfGetSceneName();
	
	//Since there is no way to findout the original scene name during interactive batch rendering,
	//tokenize function is used to avoid "__pid".
	if($gHfMayaState == 1)
	{
		string $buffer[];
		int $numTokens = `tokenize $strEqualMap "__" $buffer`;
		int $i;
		string $sceneName ="";
		
		for($i=0; $i<size($buffer); $i++)
		{
			if($i == 0)
			{	
				$sceneName =$buffer[0];
			}
			else if($i != size($buffer)-1)
			{
				$sceneName +=$buffer[$i];			
			}			
		}
		$strEqualMap = $sceneName;
	}
	
	string $eqMapPath = getTheProjectDir()+"/";
	$eqMapPath += getProjectDir("fileRule", "furEqualMap")	+ "/" + $strEqualMap;			

	// Find furry objects
	string $furryObjects[] = HfGetFurSurfaces();
	
	string	$fullPath = $readEqualPath;

	if($fullPath == "")
	{
		$fullPath = $eqMapPath; 
	}
		
	if ( !isAbsolutePath( $fullPath ) )
	{
		// any relative paths are assumed to be rooted at the current project
		
		string $projectDir = getTheProjectDir();

		$fullPath = $projectDir + "/" + $readEqualPath;
	}
	
	if($fullPath != $eqMapPath)
	{
		for($obj in $furryObjects)
		{
			if($obj == $shapeName)
			{
				$prefixName = `basename $fullPath ""`;
			}
		}
	}
	return $prefixName;
}

global proc string HfGetRefSurface(string $shapeName, string $prefix)
{
	string $refFile = `reference -q -f $shapeName`;
	string $refName = HfGetReferenceFile($shapeName);
	string $result; 
	
	//Get name space
	string $nameSpace;
	$nameSpace = `file -q -ns $refFile`;

	if($prefix != "")
	{
		$refName = $prefix;
	}
	
	//Get proper surface name
	$shapeName= `substitute $nameSpace $shapeName $refName`;
	string $plug[]; 
	$numTokens = `tokenize $shapeName ":" $plug`;	

	if(size($plug) > 1)
	{
		int $isNameSpace = false;
		int $count = 0;
		for($count = 0; $count <size($plug); $count++)
		{
			if($plug[$count] == $refName)
			{
				$isNameSpace = true;
				$result = $plug[$count];					
			}
			else if($isNameSpace == true)
			{
				$result += $plug[$count];
			}
			if($count != size($plug)-1)
			{
				$result +="_";
			}
		}
	}
	else
	{
		$result = $shapeName;
	}

	$result= replaceCharacterInString($result, "|","_");			
	return $result; 
}

global proc string HfGetRefSurfaceBatch(string $shapeName, string $prefix)
{
	string $result;
	int $isReferenced = false;
	global int $gHfMayaState;

	int $isSurfaceFound = false;
	int $isNameSpaceFound = false;
	string $userDefinedAttrList[] = `listAttr -ud $shapeName`;
	for( $userDefinedAttr in $userDefinedAttrList )
	{
		if($userDefinedAttr == "surfaceReference")
		{
			 $isSurfaceFound = true;
		}
		if($userDefinedAttr == "furNameSpace")
		{
			 $isNameSpaceFound = true;
		}

	} 

	if( $gHfMayaState == 1 && $isSurfaceFound)
	{
		if(`getAttr ($shapeName+".surfaceReference")` == true )
		{
			$isReferenced = true;
		}
		else
		{
			$result = $shapeName;
		}
	}
	else
	{
		$result = $shapeName;
	}

	if($isReferenced == true)
	{
		//Get referenced file
		string $refFile;
		string $refName;
		$refFile = `getAttr ($shapeName+".referenceFile")`;
		$refName = HfGetFileName($refFile);
		
		if($prefix != "")
		{
			$refName =$prefix;
		}

		//Get name space
		string $nameSpace;
		if($isNameSpaceFound)
		{
			$nameSpace = `getAttr ($shapeName+".furNameSpace")`;
		}
		else
		{
			string $refFile = `reference -q -f $shapeName`;
		        $nameSpace = `file -q -ns $refFile`;
		}		

		//Get proper surface name
		$shapeName= `substitute $nameSpace $shapeName $refName`;
		string $plug[]; 
		$numTokens = `tokenize $shapeName ":" $plug`;	

		if(size($plug) > 1)
		{
			int $isNameSpace = false;
			int $count = 0;
			for($count = 0; $count <size($plug); $count++)
			{
				if($plug[$count] == $refName)
				{
					$isNameSpace = true;
					$result = $plug[$count];					
				}
				else if($isNameSpace == true)
				{
					$result += $plug[$count];
				}
				if($count != size($plug)-1)
				{
					$result +="_";
				}
			}
		}
		else
		{
			$result = $shapeName;
		}
	}

	$result= replaceCharacterInString($result, "|","_");			
	return $result; 
}

proc setAreaValues(float $furUseFrame)
{
	string $hairGlobal = HfBuildHairGlobal();
	string $cmd = $hairGlobal + ".areaValue"; 

	// Calc.Area Values : OFF
	if(`getAttr $cmd` == 0)
	{
		string $feedbackNodes[] = `ls -type "FurFeedback"`;
		for($feedback in $feedbackNodes)
		{
			setAttr ($feedback +".furCalcArea") 1.0;
		}
		
	}
	// Calc.Area Values : Global
	else if(`getAttr $cmd` == 1)
	{
		//Find out the area of all furry surfaces
		string $surfaces[] = HfGetFurSurfaces();
		
		for( $surface in $surfaces)
		{
			// check if the attribute has been added
			int $found = false;
			string $attrList[];
			$attrList = `listAttr -ud $surface`;
			for( $a in $attrList )
			{
				if( $a == "furMeshArea" )
				{
					$found = true;
					break;
				}
			}
			if(!$found)
			{	
				addAttr -at "float" -hidden true -ln "furMeshArea" -sn "fma" -dv 0 -min 0 $surface;
		    }
		    
		    float $area;
		    if(`nodeType $surface` == "mesh")
				$area =`furMeshArea $surface $furUseFrame`;
		    else if(`nodeType $surface` == "nurbsSurface")
				$area =`furNurbsArea $surface $furUseFrame`;
		    else if(`nodeType $surface` == "subdiv")
		     		$area =`furSubdArea $surface $furUseFrame`;
				
		    setAttr ($surface +".furMeshArea") $area;
		}

		//Find out the maximum area		
		float $maxArea = 0.0;
		for( $surface in $surfaces)
		{
		   float $tmpArea = `getAttr ($surface +".furMeshArea")`;
		   if($maxArea < $tmpArea)
				$maxArea = $tmpArea;			
		}
		
		//Find out the FurFeedback Nodes that are attached to the surface
		for( $surface in $surfaces)
		{
			string $feedbackNodes[]= getFurFeedbackNodes($surface);
						
			for($feedback in $feedbackNodes)
			{
			    float $tmpArea = `getAttr ($surface +".furMeshArea")`;			    
			    float $factor = $tmpArea / $maxArea ;
				setAttr ($feedback +".furCalcArea") $factor;
			}
		}
	}
	// Calc.Area Values : Per Fur Description
	
	else if(`getAttr $cmd` == 2)
	{
		//Find out all FurDescription
		string $furDescs[] = `ls -type "FurDescription"`;
		
		for($furDesc in $furDescs)
		{
			string $members[];
			int $memberIndexs[];
			// Find out surfaces that are attached with FurDescription
			getHairSetMembers( $furDesc, $members, $memberIndexs );
			
			for($member in $members)
			{
				// check if the attribute has been added
				int $found = false;
				string $attrList[];
				$attrList = `listAttr -ud $member`;
				for( $a in $attrList )
				{
					if( $a == "furMeshArea" )
					{
						$found = true;
						break;
					}
				}
				if(!$found)
				{	
					addAttr -at "float" -hidden true -ln "furMeshArea" -sn "fma" -dv 0 -min 0 $member;
				}
			    
			    	float $area;
				if(`nodeType $member` == "mesh")
					$area =`furMeshArea $member $furUseFrame`;
				else if(`nodeType $member` == "nurbsSurface")
					$area =`furNurbsArea $member $furUseFrame`;
				else if(`nodeType $member` == "subdiv")
					$area =`furSubdArea $member $furUseFrame`;
				
				setAttr ($member +".furMeshArea") $area;				
			}
			
			//Find out the maximum area		
			float $maxArea = 0.0;
			for($member in $members)
			{
				float $tmpArea = `getAttr ($member +".furMeshArea")`;
				if($maxArea < $tmpArea)
					$maxArea = $tmpArea;			
			}
			for($member in $members)
			{
				string $feedback = getFurFeedbackNode($member,$furDesc);
			    float $tmpArea = `getAttr ($member +".furMeshArea")`;			    
			    float $factor = $tmpArea / $maxArea ;
				setAttr ($feedback +".furCalcArea") $factor;		
			}
		}		
	}	
}
global proc HfSetCalAreaValues()
{
    string $hairGlobal = HfBuildHairGlobal();
    float $furUseFrame = `getAttr ($hairGlobal+".useFrame")`;
    setAreaValues($furUseFrame);
}

global proc HfChangeDynamicAttr()
{
	string $surfaces[] = `ls -type "subdiv" -type "nurbsSurface"`;
	for($surface in $surfaces)
	{
		if(`attributeQuery -ex -node $surface "ns"`)
		{
			string $val = `getAttr ($surface+".ns")`;
			deleteAttr -at "ns" $surface;
			addAttr -dataType "string" -hidden true -longName "furNameSpace" -shortName "fns" $surface;
			setAttr -type "string" ($surface+".furNameSpace") $val;
		}		
	}		
}

global proc string[] HfGetFurryNurbsPoly()
{
	string $allObj[];
	$allObj = `ls -type nurbsSurface -type mesh`;
	string $furObj[];
	int $count;

	for($count=0; $count < size($allObj); $count++)
	{
		string	$hairDescriptions[];
		string $selectedObj[];

		$selectedObj[0] = $allObj[$count];

		getAllDescriptions(
			getHairGlobalsHDListPlug(false), $hairDescriptions,
			$selectedObj);

		if( size($hairDescriptions) > 0 )
		{
			$furObj[size($furObj)] = $allObj[$count];
		}
		clear($hairDescriptions);
	}
	return $furObj;
}
global proc HfCopyDeleteCustomEqualizer()
{
	string $equalizerMapPaths[];
	string $furDes[] = `ls -type FurDescription`;
	string $sceneName = HfGetSceneName();

	// Copy Custom equalizer maps
	int $furCount;
	int $frameNum = HfGetUseFrame();
	for ($furCount=0; $furCount < size($furDes); $furCount++)
	{
		string $defaultAttrPlug = $furDes[$furCount] + ".CustomEqualizerMap";
		string $surfaces[];
		int    $indices[];

		getHairSetMembers( $defaultAttrPlug, $surfaces, $indices );
		int $s;
		for ( $s = 0, $numSurfaces = size($surfaces); $s < $numSurfaces; $s++ )
		{
			string $a= `getAttr ($defaultAttrPlug+"["+$indices[$s]+"]")`;
			if(size(`getAttr ($defaultAttrPlug+"["+$indices[$s]+"]")`) == 0 )
			{
			
				//Get equalizer map path					
				string $reference_equalmap = HfGetReferenceEqualMap($surfaces[$s]);
				string $eqMapPath;
				if($reference_equalmap==" ")
				{					
					$eqMapPath = $sceneName+"_"+$surfaces[$s] +"_eqMap_"+$frameNum+".iff";
				}
				else
				{
					$eqMapPath = $reference_equalmap+"_eqMap_"+$frameNum+".iff";				
				}				
				$eqMapPath  = replaceCharacterInString($eqMapPath, ":","_");	
				$eqMapPath  = replaceCharacterInString($eqMapPath, "|","_");				
				$eqMapPath  = getDirPath("fileRule", "furEqualMap") + "/" + $eqMapPath;
				
				//Get attribute map path
				string $attrPath = $sceneName+"_"+$surfaces[$s] +"_"+ $furDes[$furCount] +"_CustomEqualizer.iff";				
				$attrPath =	replaceCharacterInString($attrPath, ":","_");	
				$attrPath =	replaceCharacterInString($attrPath, "|","_");
				$attrPath = getDirPath( "fileRule", "furAttrMap" ) + "/" + $attrPath;
				
				if(`filetest -f $eqMapPath`)
				{
					sysFile -copy $attrPath $eqMapPath;
					setMapFile( ($defaultAttrPlug+"["+$indices[$s]+"]"), makeProjectRelative( $attrPath ) );
					
					// set the sample size to (-1,-1) to indicate that we generated this file but it wasn't
					// painted
					//
					string $mapUSamplesPlug = $furDes[$furCount] + "." + hairMapUSamplesAttr("CustomEqualizer") + "[" + $indices[$s] + "]";
					string $mapVSamplesPlug = $furDes[$furCount] + "." + hairMapVSamplesAttr("CustomEqualizer") + "[" + $indices[$s] + "]";
		
					setAttr $mapUSamplesPlug -1;
					setAttr $mapVSamplesPlug -1;
					
					furAppendUniqueEntry($eqMapPath, $equalizerMapPaths);
				}
			}
		}
	}
	
	// Delete Equalizer after copying
	for ($equalizerMap in $equalizerMapPaths)
	{
		if(`filetest -f $equalizerMap`)
		{
			sysFile -delete $equalizerMap;
		}
	}
}

global proc float HfGetUseFrame()
{
    string $hairGlobal = HfBuildHairGlobal();
    float $furUseFrame = `getAttr ($hairGlobal+".useFrame")`;
    return $furUseFrame;
}

global proc HfSelectEqualizer_OldScene()
{
	string $msg = (uiRes("m_FurPluginCreateUI.kSceneMessage"));
	string $defaultEqualizer = (uiRes("m_FurPluginCreateUI.kDefaultEqualizerMapsButton"));
	string $rc = `confirmDialog -title (uiRes("m_FurPluginCreateUI.kEqualizerMapTitle"))
		-message $msg
		-button (uiRes("m_FurPluginCreateUI.kCustomEqualizerMapsButton")) -button $defaultEqualizer -defaultButton $defaultEqualizer
		-cancelButton $defaultEqualizer -dismissString $defaultEqualizer`;
	
	if( $rc == $defaultEqualizer )
	{
		string $hairGlobal = HfBuildHairGlobal();
	    $cmd = "setAttr " + $hairGlobal + ".equalMap 1";
	    eval $cmd;
	    AEFurGlobalsCheckReadEqualMap($hairGlobal);
	}	
}

global proc int HfGenerateCusEqualizer(string $equalMap, string $surfaceName)
{
	string $msg = (uiRes("m_FurPluginCreateUI.kEqualizerMapMessage"));
	$msg = `format -s $equalMap $msg`;
	string $default = (uiRes("m_FurPluginCreateUI.kDefault")); 
	string $rc = `confirmDialog -title (uiRes("m_FurPluginCreateUI.kCustomEqualizerMap"))
		-message $msg
		-messageAlign "center"
		-button $default -button (uiRes("m_FurPluginCreateUI.kBrowseButton")) -defaultButton $default
		-cancelButton $default -dismissString $default`;
 
	if( $rc == $default )
	{
		return 0;
	}
	else
	{
		int $rc = AEequalizerMapBrowser("AEassignEqualMapCB dummy "+$surfaceName);
		return $rc;
	}
}

global proc int AEassignEqualMapCB( string $dummy,
                                  string $fileAttribute,
                                  string $filename,
                                  string $fileType )
{

	global int $isSelected;
	$isSelected  = true;
		
	setMapFile( $fileAttribute, makeProjectRelative( $filename ) );
	string $currentDir = `workspace -q -dir`;
	retainWorkingDirectory ($currentDir);
	return true;	
 }
 
global proc int AEequalizerMapBrowser( string $cmd )
{
	
    	global int $isSelected;
	$isSelected = false;	

	string  $workspace = `workspace -q -fn`;
	setWorkingDirectory $workspace "furEqualMap" "sourceImages";
	
	string $open = (uiRes("m_FurPluginCreateUI.kOpen"));
	fileBrowser ($cmd, $open, "image", 0);

	// Since fileBrowser is a modeless dialog on Linux, it is not possible to control.
	// So this function always return 1.
	if(`about -win` || `about -mac`)
	{
		if(!$isSelected )
		{
			warning (uiRes("m_FurPluginCreateUI.kEqualizerValidityWarning"));
			return 0;
		}
		else
		{
			return 1;
		}
	}
	return 1;
}

global proc string HfGetSelectedHairSystem()
{
	// Get all selected hair systems from follicles/pfxHair/hairSystems
	string $hairDescriptions[] = getSelectedHairSystems();
	if(size($hairDescriptions) <=0 ) 
	{
		return "";
	}
	return $hairDescriptions[0];	
}

global proc string[] HfGetSurfacesFromHairSystem(string $hairSystem)
{
	string $out[];
	
	string $follicles[] = `listConnections -shapes true -type "follicle" ($hairSystem+".inputHair")`;
	for ($foll in $follicles)
	{
		string $surfaces[] = `listConnections -shapes true -type nurbsSurface $foll`;
		if(size($surfaces)== 0)
		{
			$surfaces = `listConnections -shapes true -type mesh $foll`;
		}
		for($surface in $surfaces)
			furAppendUniqueEntry($surface, $out);
	}
	return $out;
}


global proc string[] HfGetCurvesFromHairSystemAndSurface(string $hairSystem, string $surface)
{
	string $fList[];
	string $cList[];
	
	// Get unique follicles list from hair system and the surface
	string $follicles[] = `listConnections -shapes true -type "follicle" ($hairSystem+".inputHair")`;
	for ($foll in $follicles)
	{
		string $surfaces[] = `listConnections -shapes true -type nurbsSurface $foll`;
		if(size($surfaces)== 0)
		{
			$surfaces = `listConnections -shapes true -type mesh $foll`;
		}
		for($s in $surfaces)
		{
			if($surface == $s)
				furAppendUniqueEntry($foll, $fList);
		}
	}
	for ($f in $fList)
	{
		string $curves[] = `listConnections -shapes true -type "nurbsCurve" ($f +".outCurve")`;
		
		for($c in $curves)
		{
			furAppendUniqueEntry($c, $cList);
		}
	}
	if(size($cList) == 0)
	{
		warning((uiRes("m_FurPluginCreateUI.kOutputCurvesWarning")) );
	}
	return $cList;
}

global proc string[] HfGetCurvesFromHairSystem(string $hairSystem)
{
	string $fList[];
	string $cList[];
	
	// Get unique follicles list from hair system and the surface
	string $follicles[] = `listConnections -shapes true -type "follicle" ($hairSystem+".inputHair")`;
	for ($foll in $follicles)
	{
		string $surfaces[] = `listConnections -shapes true -type nurbsSurface $foll`;
		if(size($surfaces)== 0)
		{
			$surfaces = `listConnections -shapes true -type mesh $foll`;
		}
		for($s in $surfaces)
		{
			furAppendUniqueEntry($foll, $fList);
		}
	}
	for ($f in $fList)
	{
		string $curves[] = `listConnections -shapes true -type "nurbsCurve" ($f +".outCurve")`;
		
		for($c in $curves)
		{
			furAppendUniqueEntry($c, $cList);
		}
	}
	if(size($cList) == 0)
	{
		warning(uiRes("m_FurPluginCreateUI.kOutputCurvesWarning"));
	}
	return $cList;
}

global proc string[] HfGetCurvesFromCurveSystem(string $curveSystem)
{
	string $cList[];
	
	string $curves[] = `listConnections -shapes true -type "nurbsCurve" ($curveSystem)`;
			
	for($c in $curves)
	{
		furAppendUniqueEntry($c, $cList);
	}
	if(size($cList) == 0)
	{
		warning((uiRes("m_FurPluginCreateUI.kCurveWarning")) );
	}
	return $cList;
}
global proc string HfGetSurfaceFromHairSystem(string $hairDescriptions[])
{
	// Get all selected hair systems from follicles/pfxHair/hairSystems
	string $outHairSystems[] = getSelectedHairSystems();
	if(size($outHairSystems) <=0 ) 
	{
		warning((uiRes("m_FurPluginCreateUI.kSelectionWarning")) );
		return "";
	}
	
	//find follicle from first hair system
	string $hairSys = $outHairSystems[0];
	string $con = `connectionInfo -sfd ($hairSys + ".inputHair[0]")`;
	string $foll;
	if( $con != "" ){
		string $buffer[];
		int $numTokens = `tokenize $con "." $buffer`;
		if( $numTokens > 1 ){
			string $nType = `nodeType $buffer[0]`;
			if( $nType == "follicle"){
					$foll = $buffer[0];
				}
		}
	}
	
	//Find Surface from follicle
	$con = `connectionInfo -sfd ($foll + ".inputWorldMatrix")`;
	string $surface[];
	if( $con != "" ){
		string $buffer[];
		int $numTokens = `tokenize $con "." $buffer`;
		if( $numTokens > 1 ){
			string $nType = `nodeType $buffer[0]`;
			if( $nType == "mesh" || $nType == "nurbsSurface" ){
					$surface[0] = $buffer[0];
				}
		}
	}
	
	getAllDescriptions(
		getHairGlobalsHDListPlug(false), $hairDescriptions,	$surface);
	return $outHairSystems[0];
}

global proc string[] HfgetAnimatedFileFormat(string $file )
{
	if(!isAbsolutePath($file))
	{
		string $projectDir = getTheProjectDir();
		$file = $projectDir + "/" + $file;
	}	
	string $result[];
	// The exact filename is constructed from the following format 
	// "dirName + baseFileName + outFormatExt + frmaeExtn" 
	// Reference: TimageFileSearchPath::expandImageName() function
	
	string $exactFileName;
	string $rawFileName = $file;
	
	// Find out dir name.
	string $dirname;
	$dirname = dirname( $rawFileName );
	$result[0] = $dirname;

	// Find out base file name.
	string $baseFileName;
	string $rawFileNameBuffer[];
	string $rawFileNameExtn;
	int    $numTokens;
	$numTokens = `tokenize $rawFileName "." $rawFileNameBuffer`;
	if($numTokens > 1)
	{
		$rawFileNameExtn = ".";
	}
	int $count;
	for($count = 1; $count < $numTokens; $count++)
	{
			$rawFileNameExtn += $rawFileNameBuffer[$count];
			if($count != $numTokens -1 )
			{
			$rawFileNameExtn += ".";
			}
	}
	$baseFileName = basename($rawFileName,$rawFileNameExtn);
	$result[1]= $baseFileName;

	// Find out file format extension
	string	$fileFormatExt;
	string	$ptrStart;
	string	$ptrEnd;
	if(size($rawFileNameExtn) > 0)
	{
		$ptrStart = $rawFileNameExtn;
	}

	if(size($rawFileNameBuffer) > 2)
	{
		$ptrEnd = ".";
	}
	for($count = 2; $count < $numTokens; $count++)
	{
		$ptrEnd += $rawFileNameBuffer[$count];
		if($count != $numTokens -1)
		{
			$ptrEnd += ".";
		}
	}

	if(size($ptrStart) !=0)
	{
		if(size($ptrEnd) !=0)
		{
			int $ptrLength = size($ptrStart)-size($ptrEnd);
			if( !isNumeric($ptrStart) && $ptrLength >=3 && $ptrLength<10)
			{
				string $ptrStartBuffer[];
				int $tokens = `tokenize $ptrStart "." $ptrStartBuffer`;
				$fileFormatExt = "."+ $ptrStartBuffer[0];
			}
			else if( !isNumeric($ptrEnd) && size ($ptrEnd ) >=3 && size($ptrEnd)<10 && $numTokens <= 3)
			{
				$fileFormatExt = $ptrEnd;
			}
		}
		else
		{
			if(!isNumeric($ptrStart) && size ($ptrStart ) >=3 && size($ptrStart)<10)
			{
				$fileFormatExt = $ptrStart;
			}
		}
	}
	$result[2]= $fileFormatExt;
	return $result;
}

// ==================================
//  Hair and Fur Project Directories
// ==================================
global proc string HfGetDirPath(
	string $refRule
)
{   
	string $dir = getDirPath( "fileRule", $refRule );

	return $dir;
}

global proc string HfGetFullProjectPath(
	string	$filename
)
{
	if($filename != "")
		$filename = `file -q -expandName $filename`;
	
	string	$fullPath = $filename;

	if ( isAbsolutePath( $filename ) ) {
		$fullPath = $filename;
	} else {
		// root it at the project directory
		//
		string	$projectDir = `workspace -q -rd`;
		
		$fullPath = $projectDir + "/" + $filename;
	}

	return $fullPath;
}

proc hfCheckDirExist(
	string $refRule
)
{
	string $dir = HfGetDirPath( $refRule );
	
	if($dir != "")
		$dir = `file -q -expandName $dir`;

	string $curDir = `pwd`;
	
	int $dirExist = chdir( $dir );
	if( $dirExist == -1 )
	{
		// Create directory
		//
		string $msg = (uiRes("m_FurPluginCreateUI.kCreatingDirectoryMsg"));
		print(`format -s $dir $msg`);
		$directoryExists = `workspace -create $dir`;
	}

	chdir $curDir;
}


proc hfCreateFileRules(
	string $listOfFileRules[],
	string $hfRuleList[],
	string $hfDirList[] 
)
{
	string $root = `workspace -q -rd`;

	for ( $i = 0; $i < size( $hfRuleList ); $i++ )
	{
        //  search to see if file rule exists.
		//
        int $found = false;
        for ($rule in $listOfFileRules) 
		{
			if ( $rule == $hfRuleList[$i] ) 
			{
                $found = true;
                break;
            }
        }
        
		// map the rule to the directory
		if ( !$found ) 
		{
			workspace -fileRule $hfRuleList[$i] $hfDirList[$i];
		}
		
		// create the directory if necessary
		hfCheckDirExist( $hfRuleList[$i] );             
	}
	
    // Save the changes to the workspace in workspace.mel
    //
    workspace -saveWorkspace;

    // Refresh in the UI
    //
    workspace -update;
}

global proc HfCheckProjectDir()
{
    $listOfFileRules=`workspace -q -fr`;
    int $foundFiles, $foundShad, $foundEqual, $foundImage, $foundAttrMap;
	$foundFiles = $foundShad = $foundEqual = $foundImage = $foundAttrMap = false;
    for ($rule in $listOfFileRules) 
	{
		if( $rule == "furFiles" )
		{
			$foundFiles = true;
		}
		else if( $rule == "furShadowMap" )
		{
			$foundShad = true;
		}
		else if( $rule == "furEqualMap" )
		{
			$foundEqual = true;
		}
		else if( $rule == "furImages" )
		{
			$foundImage = true;
		}
		else if( $rule == "furAttrMap" )
		{
			$foundAttrMap = true;
		}
    }
	
	string $hfRuleList[5] = { "furFiles", "furShadowMap", "furEqualMap", "furImages",
	                          "furAttrMap" };

    if ( !$foundFiles || !$foundShad || !$foundEqual || !$foundImage || !$foundAttrMap )
	{
		// Create directories
		//
		string $hfDirList[4] =  { "furFiles", "furShadowMap", 
								  "furEqualMap", "furImages", "furAttrMap" };
		hfCreateFileRules( $listOfFileRules, $hfRuleList, $hfDirList );
	}
	else
	{
		for ( $i = 0; $i < size( $hfRuleList ); $i++ )
		{
			hfCheckDirExist( $hfRuleList[$i] );             
		}
	}
}

global proc HfCreateDir(
	string $dir
)
{
	string $curDir = `pwd`;
	
	if($dir != "")
		$dir = `file -q -expandName $dir`;
		
	int $dirExist = chdir( $dir );
	if( $dirExist == -1 )
	{
		// Create directory
		//
		string $msg = (uiRes("m_FurPluginCreateUI.kCreatingDirectoryMsg"));
		print(`format -s $dir $msg`);
		$directoryExists = `workspace -create $dir`;
	}

	chdir $curDir;
}

global proc string HfCreateTempDir()
{
	// Create a local directory for storing temporary fur files
	// Use to avoid storing them on network shares which can seriously hurt
	// performance (see bug 249667)
	// Returns directory name on success or empty string on failure
	string $tmpdir = `getenv TMPDIR`;
	string $hairFileDir = "";
	$hairFileDir = $tmpdir + "/maya_furTempFiles";
	int $grist = 1;
	int $maxGrist = 1000;
	while (($grist < $maxGrist) &&
				`filetest -f $hairFileDir` || `filetest -d $hairFileDir`) {
		$hairFileDir = $tmpdir + "/maya_furTempFiles" + $grist;
		$grist++;
	}

	if ($grist >= $maxGrist || !`sysFile -makeDir $hairFileDir`) {
		$hairFileDir = "";
	}
	return $hairFileDir;
}

addDebugTag("createAttractor");

// types of attractors we can create
//
//#define ATTRACTOR_JOINTS	0
//#define ATTRACTOR_DYNAMICS	1
//#define ATTRACTOR_IKCHAIN	2
//#define ATTRACTOR_FOLLOW	3

proc string attract(
	float	$length,
	int		$type,
	int     $attType,
	int     $faceId,
	float   $uParam,
	float   $vParam     
)
{
	string	$tag = "createAttractor";
	string	$paths[], $p;

	// save the selection list for later
	//
	string	$selected[] = `ls -sl`;
	float	$middle = $length / 2.0;
	float	$kink = 0.0;

	if ( $type == 2 ) {
		// for some odd reason a kink is required so that the chain
		// will behave nicely when manipulated using the ik handle
		//
		$kink = 0.1;
	}

	select -cl;  // to prevent joints from parenting to the surface

	// First, build the attractor chain.  It consists of
	// an ik chain, each link of which is one unit long,
	// pointing straight up from the origin.
	//
	string $joint1 = `joint -name attractorBase -p 0.0 0.0 0.0`;
	string $joint2 = `joint -name attractorMid -p 0.0 $middle $kink`;
	joint -e -zso -oj xyz $joint1;
	string $joint3 = `joint -name attractorEnd -p 0.0 $length 0.0`;
	$joint3 = longNameOf($joint3);
	joint -e -zso -oj xyz $joint2;

	HfTDebug($tag,"j1="+$joint1+",j2="+$joint2+",j3="+$joint3);

	string $ikHandle[];
	string $ikCurve;
	string $pointInfoNode;
	string $angleNode;
	int $ikCurveParented = false;

	if ( $type == 1 ) {
		select $joint1 $joint3;
		$ikHandle = `ikHandle -sol ikSplineSolver -parentCurve on -rootOnCurve on -createCurve on -simplifyCurve on -numSpans 1`;

		// Get the name of the curve which is controling the ikHandle
		//
		$ikCurve = `ikHandle -q -curve $ikHandle[0]`;
		$paths = `listRelatives -f -parent $ikCurve`;
		$ikCurve = $paths[0];
	} else if ( $type == 2 ) {
		// set the joint limits so it will try not to pass through the
		// surface below it.
		//
		transformLimits -rz -90 90 -erz 1 1 -ry -90 90 -ery 1 1 $joint1;
		transformLimits -rz -90 90 -erz 1 1 -ry -90 90 -ery 1 1 $joint2;
		select ($joint1+".rotatePivot") ($joint3+".rotatePivot");
		$ikHandle = `ikHandle`;

	}

	HfTDebug($tag, "ikCurve=" + $ikCurve);

	string	$root = $joint1;

	//---------------------------------------------------
	// The attractor chain is complete.  If there is a point-on-nurbs-surface
	// selected, then we will constrain the attractor to sit on the
	// point, initially normal to the surface at that point.
	//
	// Check initial conditions:  There must be exactly one selected
	// item; it must be a point-on-surface.
	//
	if ( size($selected) == 1 ){
		string $parts[];
		tokenize($selected[0],".[]",$parts);

		string $transform = "";
		string $surface = "";

		if ( `nodeType $parts[0]` == "transform" ){
			$transform = $parts[0];
			string $children[] = `listRelatives -f -children $transform`;
			int $i;
			for ( $i=0; $i<size($children) && $surface == ""; $i++ ){
				if ( `nodeType $children[$i]` == "nurbsSurface" || `nodeType $children[$i]` == "mesh" || `nodeType $children[$i]` == "subdiv" ){
					// Avoid internal surfaces.
					if(!(`getAttr ($children[$i]+".io")`) )
					{
						$surface = $children[$i];
					}
				}
			}
		} else if ( `nodeType $parts[0]` == "nurbsSurface" ){
			$surface = $parts[0];
			string $parents[] = `listRelatives -f -parent $surface`;
			if ( `nodeType $parents[0]` == "transform" ){
				$transform = $parents[0];
			}
		} else 	if( `nodeType $parts[0]` == "mesh" ) {
			$surface = $parts[0];
			string $parents[] = `listRelatives -f -parent $surface`;
			if ( `nodeType $parents[0]` == "transform" ){
				$transform = $parents[0];
			}
		} else 	if( `nodeType $parts[0]` == "subdiv" ) {
			$surface = $parts[0];
			string $parents[] = `listRelatives -f -parent $surface`;
			if ( `nodeType $parents[0]` == "transform" ){
				$transform = $parents[0];
			}
		}

		if ( $transform != "" && $surface != "" && ($parts[1] == "uv" || $parts[1] == "f" || $attType || $parts[1] == "smf" ) )
		{

		if(`nodeType $surface` == "nurbsSurface")
		{

			// Retokenize the string to get the UV parameters.
			//
			tokenize($selected[0],"[]",$parts);

			float $u = $parts[1];
			float $v = $parts[2];

			// Okay, we have a selected surface point.  We will need to
			// create some new nodes.  First, create a pointOnSurfaceInfo
			// node, to return information about the position and normal
			// of the point on the surface.
			//

			$pointInfoNode = `pointOnSurface -ch on -u $u -v $v $surface`;

			// Create an "angleBetween" node, to calculate the rotation required
			// to rotate the (verticle) attractor to point parallel to the 
			// object normal.
			//
			$angleNode = `createNode angleBetween`;

			// Create a root transform for the joints to sit on.  This transform
			// will be constrained to lie on the surface, and the joints will
			// freely move against that.
			//
			$root = `group -em -w -n attractorRoot`;
			$root = "|" + $root;

			if ( $type == 1 ) {
				parent $joint1 $ikCurve $root;
				$ikCurve = $root+$ikCurve;
				$ikCurveParented = true;
			} else {
				parent $joint1 $root;
			}
			$joint3 = $root + $joint3;

			// Now, attach everything together.
			// The position of the surface point drive the transform position.
			//
			if ( ($type == 0) || ($type == 1) || ($type == 3)) {
				connectAttr ($pointInfoNode+".position") ($root+".translate");
			}

			// The normal of the surface point drives one of the inputs of
			// angleBetween node;  the other is set permanently to 0 1 0 or
			// 0 -1 0 depending on flip normals
			//
			string $flipNormalsPlug = getFlipNormalsPlug( $surface, false );
			float $vector1Y = 1.0;

			if ( $flipNormalsPlug != "" && `getAttr $flipNormalsPlug` ) {
				$vector1Y = -1.0;
			}
			setAttr -lock true ($angleNode+".vector1") 0.0 $vector1Y 0.0;
			connectAttr ($pointInfoNode+".nn") ($angleNode+".vector2");

			// Finally, the euler output of the angleBetween node drives
			// the rotation of the root tranform.
			//
			if ( ($type == 0) || ($type == 1) || ($type == 3)) {
				connectAttr ($angleNode+".euler") ($root+".rotate");
			}

			// Now the attractor will remain properly fixed, no matter
			// how the geometry of the surface changes.
		}
		else if(`nodeType $surface` == "mesh")
		{
			string $part[];
			int $numToken = `tokenize $parts[2] ":" $part`;

			int $face;
			if($attType == false)
			{

			  $face= $part[0];
			}
			else
			{
			  $face = $faceId;
			}

			if($uParam <0.0)
			{
				$uParam=0.0;
			}
			if($vParam <0.0)
			{
				$vParam=0.0;
			}
			
			$pointInfoNode = `furPointOnMesh -faceIndex $face -u $uParam -v $vParam $surface`;

			// Create an "angleBetween" node, to calculate the rotation required
			// to rotate the (verticle) attractor to point parallel to the 
			// object normal.
			//
			$angleNode = `createNode angleBetween`;

			// Create a root transform for the joints to sit on.  This transform
			// will be constrained to lie on the surface, and the joints will
			// freely move against that.
			//
			$root = `group -em -w -n attractorRoot`;
			$root = "|" + $root;

			if ( $type == 1 ) {
				parent $joint1 $ikCurve $root;
				$ikCurve = $root+$ikCurve;
				$ikCurveParented = true;
			} else {
				parent $joint1 $root;
			}
			$joint3 = $root + $joint3;

			// Now, attach everything together.
			// The position of the surface point drive the transform position.
			//
			if ( ($type == 0) || ($type == 1) || ($type == 3)) {
				connectAttr ($pointInfoNode+".position") ($root+".translate");
			}
			// The normal of the surface point drives one of the inputs of
			// angleBetween node;  the other is set permanently to 0 1 0 or
			// 0 -1 0 depending on flip normals
			//
			string $flipNormalsPlug = getFlipNormalsPlug( $surface, false );
			float $vector1Y = 1.0;

			if ( $flipNormalsPlug != "" && `getAttr $flipNormalsPlug` ) {
				$vector1Y = -1.0;
			}
			setAttr -lock true ($angleNode+".vector1") 0.0 $vector1Y 0.0;
			connectAttr ($pointInfoNode+".normal") ($angleNode+".vector2");
			
			// Finally, the euler output of the angleBetween node drives
			// the rotation of the root tranform.
			//
			if ( ($type == 0) || ($type == 1) || ($type == 3)) {
				connectAttr ($angleNode+".euler") ($root+".rotate");
			}

		}
		else if(`nodeType $surface` == "subdiv")
		{

			select $selected;
			$pointInfoNode = `PointOnSubdFace`;
			select -cl;

			// Create an "angleBetween" node, to calculate the rotation required
			// to rotate the (verticle) attractor to point parallel to the 
			// object normal.
			//
			$angleNode = `createNode angleBetween`;

			// Create a root transform for the joints to sit on.  This transform
			// will be constrained to lie on the surface, and the joints will
			// freely move against that.
			//
			$root = `group -em -w -n attractorRoot`;
			$root = "|" + $root;

			if ( $type == 1 ) {
				parent $joint1 $ikCurve $root;
				$ikCurve = $root+$ikCurve;
				$ikCurveParented = true;
			} else {
				parent $joint1 $root;
			}
			$joint3 = $root + $joint3;

			// Now, attach everything together.
			// The position of the surface point drive the transform position.
			//
			if ( ($type == 0) || ($type == 1) || ($type == 3)) {
				connectAttr ($pointInfoNode+".position") ($root+".translate");
			}
			// The normal of the surface point drives one of the inputs of
			// angleBetween node;  the other is set permanently to 0 1 0 or
			// 0 -1 0 depending on flip normals
			//
			string $flipNormalsPlug = getFlipNormalsPlug( $surface, false );
			float $vector1Y = 1.0;

			if ( $flipNormalsPlug != "" && `getAttr $flipNormalsPlug` ) {
				$vector1Y = -1.0;
			}
			setAttr -lock true ($angleNode+".vector1") 0.0 $vector1Y 0.0;
			connectAttr ($pointInfoNode+".normal") ($angleNode+".vector2");
			
			// Finally, the euler output of the angleBetween node drives
			// the rotation of the root tranform.
			//
			if ( ($type == 0) || ($type == 1) || ($type == 3)) {
				connectAttr ($angleNode+".euler") ($root+".rotate");
			}
		}	 // Now the attractor will remain properly fixed, no matter
			// how the geometry of the surface changes.
		} // end if-a-surface-point-is-selected
	} // end if-there-is-one-selected-item

	HfTDebug($tag,"root=" + $root);

	// - finish things off
	// - if there are multiple pieces group them all up
	// - add an attribute to the end joint so that we know what should be selected
	//   when we want to select the attractor and what should be deleted when the attractor
	//   is removed from the attractor set
	//
	string	$attractorGrp;

	switch ( $type ) {
	case 1:
		// If Dynamics were specified, then we create the appropriate
		// objects now.
		//

		// group up existing stuff
		//
		$attractorGrp = `group -name "DynamicFurAttractor"
							$ikHandle[0] $root`;
		if ( ! $ikCurveParented ) {
			parent $ikCurve $attractorGrp;
		}
		$ikCurve=$attractorGrp+$ikCurve;

		// Turn the curve into a soft body
		//
		$paths = `soft -convert -hideOriginal on -goal 1 $ikCurve`;


		// soft -convert returns the particle transform node
		// it's parent is the soft curve
		//
		string	$softBodyCurveParticles = $paths[0];
		$paths=`listRelatives -p -pa $softBodyCurveParticles`;
		string	$softBodyCurve = $paths[0];

		HfTDebug($tag, "softBodyCurve=" + $softBodyCurve );

		// Create springs for the curve. Change the max distance attribute
		// to work for mutliple units.
		//
		string $cu = `currentUnit -q -l`;
		float $minDist = 0;
		string $unitCmd =("convertUnit -fromUnit \"")+ $cu +("\" -toUnit \"cm\" \""+$length+"\"");
                string $dist = eval($unitCmd);
                string $buffer[];
                int $numTokens = `tokenize $dist "cm" $buffer`;
		float $maxDist = $buffer[0];

		$paths = `spring -exclusive false -mm true -mnd $minDist -mxd $maxDist -s 20 -d 0.20000003 -sfw 1 -efw 1 $softBodyCurve`;


		string	$fullPaths[] = `ls -l $paths[0]`;
		string	$springName = $fullPaths[0];
	
		// Add the appropriate goal weights for the particles.
		//
		particle -e -or 1 -at goalPP -fv 0.05 $softBodyCurveParticles;
		particle -e -or 2 -at goalPP -fv 0.02 $softBodyCurveParticles;
		particle -e -or 3 -at goalPP -fv 0.005 $softBodyCurveParticles;
		
		$paths = `listRelatives -f -children $softBodyCurve`;
		$paths = `saveInitialState -attribute goalPP $paths`;

		parent $softBodyCurve $springName $attractorGrp;

		break;
	case 2:
		$attractorGrp = `group -name "IKFurAttractor" $ikHandle[0] $root`;
		// The position of the surface point drive the transform position.
		//
		if ($pointInfoNode != "") {
			connectAttr ($pointInfoNode+".position") ($attractorGrp+".translate");
		}
		// The euler output of the angleBetween node drives the rotation of tranform.
		//
		if ($angleNode != "") {
			connectAttr ($angleNode+".euler") ($attractorGrp+".rotate");
		}

		break;
	case 0:
	case 3:
		$attractorGrp = `group -name "FurAttractor" $root`;
		break;
	}

	if ( $attractorGrp != "" ) {
		$paths = `ls -l $attractorGrp`;
		if ( size( $paths ) == 1 ) {
			$attractorGrp = $paths[0];
			$joint3 = $attractorGrp + $joint3;

			buildAttractorGrpConnection( $attractorGrp, $joint3 );
		} else {
			string $error = (uiRes("m_FurPluginCreateUI.kMultipleOccurencesError"));
			error( `format -s $attractorGrp $error`);
		}
	}

	return $joint3;
} // end script.

// where we can create
//
//#define ATTRACTOR_PT_ON_SRF	0
//#define ATTRACTOR_SRF_GRID	1
//#define ATTRACTOR_ORIGIN	2
//#define ATTRACTOR_PT_ON_POLYSRF	3
//#define ATTRACTOR_PT_ON_SUBDSRF	4

proc setAttractorOptionVars()
{
	if ( !`optionVar -exists HfAttractorWhere`) {
        optionVar -intValue HfAttractorWhere 1;
	}
	if ( !`optionVar -exists HfAttractorSrfGridU`) {
        optionVar -intValue HfAttractorSrfGridU 3;
	}
	if ( !`optionVar -exists HfAttractorSrfGridV`) {
        optionVar -intValue HfAttractorSrfGridV 3;
	}

	// get rid of any old HfAttractorLength which was mistakenly set as
	// an integer value
	if ( `optionVar -exists HfAttractorLength`) {
        optionVar -remove HfAttractorLength;
	}
	if ( !`optionVar -exists HfAttractorLgth`) {
        optionVar -floatValue HfAttractorLgth 5;
	}

	if ( !`optionVar -exists HfAttractorType`) {
        optionVar -intValue HfAttractorType 1;
	}
	if ( !`optionVar -exists HfAttractorFollowDelay`) {
        optionVar -intValue HfAttractorFollowDelay 5;
	}
	if ( !`optionVar -exists HfAttractorSetAttach`) {
        optionVar -intValue HfAttractorSetAttach 1;
	}
}

global string	$HfLastUsedAttractorSet;

$HfLastUsedAttractorSet = "";

global proc HfCreateAttractorCheck(
	int	$create
)
{
	string	$tag="createAttractor";

	// check what's selected, so we know what can be
	// enabled in the createAttractor window.
	//
	int $surfaceSelected = 0;
	int $posSelected = 0;
	string $surface = "";

	string $selection[] = `ls -sl`;
	string $parts[];

	if ( size($selection)>0 ){
		tokenize( $selection[0],".[]",$parts );
		if ( `nodeType $parts[0]` == "nurbsSurface" ){
			$surface = $parts[0];
			$surfaceSelected = 1;
		} else if ( `nodeType $parts[0]` == "transform" ){
			string $kids[] = `listRelatives -f -children $parts[0]`;
			int $i;
			for ( $i=0; $i<size($kids) && $surfaceSelected == 0; $i++ ){
				if ( `nodeType $kids[$i]` == "nurbsSurface" || `nodeType $kids[$i]` == "mesh" || `nodeType $kids[$i]` == "subdiv" ){
					$surface = $kids[$i];
					$surfaceSelected = 1;
				}
			}
		} else if ( `nodeType $parts[0]` == "mesh" ){
			$surface = $parts[0];
			$surfaceSelected = 1;
		} else if ( `nodeType $parts[0]` == "subdiv" ){
			$surface = $parts[0];
			$surfaceSelected = 1;
		}
	}

	if ( $surfaceSelected ){

		// see if a point-on surface was selected.
		//
		if ( $parts[1] == "uv" ){
			$posSelected = 1;
		} else if ( `nodeType $surface` == "mesh" && $parts[1] == "f" ) {
			$posSelected = 1;
		} else if ( `nodeType $surface` == "subdiv" && $parts[1] == "smf" ) {
			$posSelected = 1;
		}
	}

	// Now, set up the dimming.
	//
	setParent createAttractorWnd;
	setParent caForm;

	string $hold = `radioCollection -query -select createChoice`;

	disable -v (!$surfaceSelected) gridBtn;
	disable -v (!$posSelected) oneBtn;
	disable -v (!$surfaceSelected) attachCheck;

	if ( $hold == "oneBtn" && !$posSelected ){
		radioCollection -edit -select originBtn createChoice;
	}
	if ( $hold == "gridBtn" && !$surfaceSelected ){
		radioCollection -edit -select originBtn createChoice;
		disable -v 1 gridGrp;
	}

	$hold = `radioCollection -query -select attractorTypeChoice`;
	if ( $hold == "followRadioBtn" ) {
		disable -v 0 followDelayGrp;
	}

	// add any existing attractor sets to the place into menu
	//
	int		$placeItems = `optionMenuGrp -q -ni placeMenu`;
	int		$i;
	string	$placeMenuItemName="placeMenuItem";
	string	$placeItemSelected;
	int		$selectIndex = `optionMenuGrp -q -sl placeMenu`;
	
	global string	$HfLastUsedAttractorSet;

	if ( $selectIndex == 1 && $HfLastUsedAttractorSet != "" ) {
		$placeItemSelected = $HfLastUsedAttractorSet;
	} else {
		$placeItemSelected = `optionMenuGrp -q -v placeMenu`;
	}

	HfTDebug($tag,"rebuilding placeMenu: " + $placeItemSelected + " selected");

	// get rid of any that are there
	//
	for ( $i = 1; $i < $placeItems; $i++ ) {
		HfTDebug($tag, " deleting " + $placeMenuItemName+$i);
		deleteUI ($placeMenuItemName+$i);
	}

	string	$attractorSets[];

	// and add all existing attractor sets
	//
	$selectIndex = 1;
	getAllAttractorSets( $attractorSets, false );
	if ( size( $attractorSets ) > 0 ) {
		string	$savedParent = `setParent -q`;
		string	$fullName = `setParent placeMenu`;
		string	$a;

		setParent -menu ($fullName + "|OptionMenu");
		$i = 1;
		for ( $a in $attractorSets ) {
			if ( $a == $placeItemSelected ) {
				$selectIndex = $i + 1;
				HfTDebug($tag," setting $selectIndex to " + $selectIndex);
			}
			HfTDebug($tag, " adding " + $a + ":" + $placeMenuItemName+$i);
			menuItem -l $a ($placeMenuItemName+$i);
			$i++;
		}
		setParent $savedParent;

		if ( $selectIndex == 1 && $i == 2 && $create ) {
			$selectIndex = 2;
		}

		// the following if-else is a workaround for a refresh problem
		// that occurred with the option menu
		//
		if ( $selectIndex > 1 ) {
			optionMenuGrp -e -sl ($selectIndex - 1) placeMenu;
		} else {
			optionMenuGrp -e -sl ($selectIndex + 1) placeMenu;
		}
		optionMenuGrp -e -sl $selectIndex placeMenu;
	}
}


global proc HfCreateAttractor()
{
	// create the 'create Attractor' window
	//
	if ( !`window -exists createAttractorWnd` ){
		setAttractorOptionVars();

		window -w 400 -h 500 -title (uiRes("m_FurPluginCreateUI.kCreateAttractor")) createAttractorWnd;

		formLayout -nd 100 caForm;

		text -label (uiRes("m_FurPluginCreateUI.kFurCreate")) txt1;

		radioCollection createChoice;

		radioButton -label (uiRes("m_FurPluginCreateUI.kOneAttractor")) oneBtn;
		
		radioButton -label (uiRes("m_FurPluginCreateUI.kGridAttractor")) 
			-onc "disable -v 0 gridGrp"
			-ofc "disable -v 1 gridGrp"
			gridBtn;

		radioButton -label (uiRes("m_FurPluginCreateUI.kOrignAttractor")) originBtn;

		intFieldGrp -label (uiRes("m_FurPluginCreateUI.kGridSize")) -en 0 -nf 2
			-v1 `optionVar -q HfAttractorSrfGridU`
			-v2 `optionVar -q HfAttractorSrfGridV`
			gridGrp;

		floatSliderGrp -label (uiRes("m_FurPluginCreateUI.kAttractorLen")) -f true
			-min 0 -max 10 -fmn -10000.0 -fmx 10000.0 -pre 2 -step 0.1
			-v `optionVar -q HfAttractorLgth`
			lengthGrp;

		// create a set of radio buttons used to specify attractor type
		//
		text -label (uiRes("m_FurPluginCreateUI.kAttractorType")) attractorTypeTxt;
		radioCollection attractorTypeChoice;
		radioButton -label (uiRes("m_FurPluginCreateUI.kIKChain"))  ikchainRadioBtn;
		radioButton -label (uiRes("m_FurPluginCreateUI.kDynChain"))  dynRadioBtn;
		radioButton -label (uiRes("m_FurPluginCreateUI.kSimpleChain")) 
			-onc "disable -v 0 followDelayGrp"
			-ofc "disable -v 1 followDelayGrp"
			followRadioBtn;
		intFieldGrp 	-label (uiRes("m_FurPluginCreateUI.kDelay")) 
				-en 0
				-v1 `optionVar -q HfAttractorFollowDelay`
				followDelayGrp;

		// If Dynamics is not loaded, this should be dimmed
		//
		disable -v (!`isTrue "DynamicsExists"`) dynRadioBtn;

		checkBoxGrp -label (uiRes("m_FurPluginCreateUI.kAttachAttrSet")) 
					-label1 (uiRes("m_FurPluginCreateUI.kToSelection")) 
			-v1 `optionVar -q HfAttractorSetAttach`
			attachCheck;

		optionMenuGrp -label (uiRes("m_FurPluginCreateUI.kPlaceAttrInto")) placeMenu;
			menuItem -label (uiRes("m_FurPluginCreateUI.kNewAttrSet")) ;

		button -label (uiRes("m_FurPluginCreateUI.kBtnClose")) -c "evalDeferred \"deleteUI createAttractorWnd\"" cancelBtn;
		button -label (uiRes("m_FurPluginCreateUI.kBtnCreate")) -c "HfDoCreateAttractor" createBtn;

		formLayout -edit

			-af txt1 top 10
			-af txt1 left 10
			-an txt1 bottom
			-an txt1 right

			-af oneBtn top 10
			-ac oneBtn left 10 txt1
			-an oneBtn bottom
			-an oneBtn right

			-ac gridBtn top 5 oneBtn
			-ac gridBtn left 10 txt1
			-an gridBtn bottom
			-an gridBtn right

			-ac gridGrp top 5 gridBtn
			-ac gridGrp left 30 txt1
			-an gridGrp bottom
			-an gridGrp right

			-ac originBtn top 5 gridGrp
			-ac originBtn left 10 txt1
			-an originBtn bottom
			-an originBtn right

			-ac attractorTypeTxt top 10 originBtn
			-af attractorTypeTxt left 10
			-an attractorTypeTxt bottom
			-an attractorTypeTxt right

			-ac followRadioBtn top 10 originBtn
			-ac followRadioBtn left 10 attractorTypeTxt
			-an followRadioBtn bottom
			-an followRadioBtn right

			-ac followDelayGrp top 5 followRadioBtn
			-af followDelayGrp left 10
			-an followDelayGrp bottom
			-an followDelayGrp right

			-ac dynRadioBtn top 5 followDelayGrp
			-ac dynRadioBtn left 10 attractorTypeTxt
			-an dynRadioBtn bottom
			-an dynRadioBtn right

			-ac ikchainRadioBtn top 5 dynRadioBtn
			-ac ikchainRadioBtn left 10 attractorTypeTxt
			-an ikchainRadioBtn bottom
			-an ikchainRadioBtn right

			-ac lengthGrp top 10 ikchainRadioBtn
			-af lengthGrp left 10
			-an lengthGrp bottom
			-an lengthGrp right

			-ac placeMenu top 10 lengthGrp
			-af placeMenu left 10
			-an placeMenu bottom
			-an placeMenu right

			-ac attachCheck top 10 placeMenu
			-af attachCheck left 10
			-an attachCheck bottom
			-an attachCheck right

			-an createBtn top
			-af createBtn left 10
			-af createBtn bottom 10
			-ap createBtn right 5 50

			-an cancelBtn top
			-af cancelBtn right 10
			-af cancelBtn bottom 10
			-ap cancelBtn left 5 50

			caForm;

		string	$radioSelect;
		int		$s = `optionVar -q HfAttractorWhere`;

		switch (  $s ) {
		case 0:
			$radioSelect = "oneBtn"; 
			break;
		case 3:
			$radioSelect = "oneBtn"; 
			break;
		case 4:
			$radioSelect = "oneBtn"; 
			break;
		case 1:
			$radioSelect = "gridBtn"; 
			break;
		case 2:
		default:
			$radioSelect = "originBtn"; 
			break;
		}
		radioCollection -edit -select $radioSelect createChoice;

		$s = `optionVar -q HfAttractorType`;
		switch ( $s ) {
		case 0:
		case 2:
		default:
			$radioSelect = "ikchainRadioBtn"; 
			break;
		case 1:
			$radioSelect = "dynRadioBtn"; 
			break;
		case 3:
			$radioSelect = "followRadioBtn"; 
			break;
		}
		radioCollection -edit -select $radioSelect attractorTypeChoice;

		HfCreateAttractorCheck( true );  //set the dimming

		// attach some script jobs to keep the dialog up to date
		//
		scriptJob -p createAttractorWnd -e "SelectionChanged" "HfCreateAttractorCheck false";
		scriptJob -p createAttractorWnd -dri -ac (getHairGlobalsProtectPlug(true)) "HfCreateAttractorCheck false";
	}

	showWindow createAttractorWnd;
}

global proc HfDoCreateAttractor()
{
	setAttractorOptionVars();

	saveSelectionList;

	// Create attractors for the selected surface
	//
	setParent createAttractorWnd;

	// what kind of attractors do we want
	//
	string $atStr = `radioCollection -q -select attractorTypeChoice`;
	int $attractorType;

	if ( $atStr == "jointsRadioBtn" ) {
		$attractorType = 0;
	} else if ( $atStr == "ikchainRadioBtn" ) {
		$attractorType = 2;
	} else if ( $atStr == "dynRadioBtn" ) {
		$attractorType = 1;
	} else {
		$attractorType = 3;
	}

	// do we attach attractor set to selection
	//
	int	$attach = `checkBoxGrp -q -v1 attachCheck`;

	// length of attractor(s)
	//
	float $length = `floatSliderGrp -q -v lengthGrp`;

	// what are we creating?
	//
	string $what = `radioCollection -q -select createChoice`;

	string $attractors[];
	int $attractorWhere;
	int $ai = 0;

	if ( $what == "oneBtn" ){

		string $allObjects[] = `ls -sl`;
		select -cl;

		for($obj in $allObjects)
		{
			select $obj;
			string $parts[];
			tokenize( $obj,".[]",$parts );

			if ( `nodeType $parts[0]` == "transform" )
			{
				string $kids[] = `listRelatives -f -children $parts[0]`;
				int $i;
				for ( $i=0; $i<size($kids); $i++ )
				{
					if ( `nodeType $kids[$i]` == "nurbsSurface" )
					{
						if(!`getAttr ($kids[$i]+".io")`)
						{
							$attractorWhere = 0;
													
							//Sug #124021 Creating attractors in fur should work for multiple points and surfaces.
							
							string $selected[] = `ls -sl`;
							select -cl;
							for($sel in $selected)
							{
								select $sel;
								$attractors[$ai++]=attract( $length, $attractorType,0,0,0.0, 0.0 );			
							}
						}
					}
					else if ( `nodeType $kids[$i]` == "mesh" )
					{
						if(!`getAttr ($kids[$i]+".io")`)
						{
							$attractorWhere = 3;
													
							//Sug #124021 Creating attractors in fur should work for multiple points and surfaces.
							string $newSelectedItems[];
							int $index	= 0;
							string $selected[] = `ls -sl`;
							for($polyObj in $selected)
							{
								string $polyParts[];
								tokenize( $polyObj,":[]",$polyParts );
								if( size($polyParts) == 3 )
								{
									int $count;
									for($count = int($polyParts[1]); $count<=int($polyParts[2]); $count++)
									{
										$newSelectedItems[$index] = $polyParts[0] + "[" + $count + "]" ;
										$index++;
									}
								}
								if( size($polyParts) == 2 )
								{
									$newSelectedItems[$index] = $polyObj;
									$index++;
									
								}
							}						
							select -cl;
							for($sel in $newSelectedItems)
							{
								select $sel;
								$attractors[$ai++]=attract( $length, $attractorType,0,0, 0.5, 0.5 );
							}
						}
					}
					else if ( `nodeType $kids[$i]` == "subdiv" )
					{
						if(!`getAttr ($kids[$i]+".io")`)
						{
							$attractorWhere = 4;
							
							//Sug #124021 Creating attractors in fur should work for multiple points and surfaces.
							string $newSelectedItems[];
							int $index	= 0;
							string $selected[] = `ls -sl`;
							for($obj in $selected)
							{
								string $subdparts[];
								tokenize( $obj,":[]",$subdparts );
								if( size($subdparts) == 4 )
								{
									int $count;
									for($count = int($subdparts[1]); $count<=int($subdparts[2]); $count++)
									{
										$newSelectedItems[$index] = $subdparts[0] + "[" + $count + "]["+$subdparts[3]+"]" ;
										$index++;
									}
								}
								if( size($subdparts) == 3 )
								{
									$newSelectedItems[$index] = $obj;
									$index++;
									
								}
							}
							select -cl;
							for($sel in $newSelectedItems)
							{
								select $sel;
								$attractors[$ai++]=attract( $length, $attractorType,0,0, 0.5, 0.5 );
							}
						}
					}
				}
			}
			else
			{
				if ( `nodeType $parts[0]` == "nurbsSurface" )
				{
					if(!`getAttr ($parts[0]+".io")`)
					{
						$attractorWhere = 0;
												
						string $selected[] = `ls -sl`;
						select -cl;
						for($sel in $selected)
						{
							select $sel;
							$attractors[$ai++]=attract( $length, $attractorType,0,0,0.0, 0.0 );			
						}
					}
				}
				else if ( `nodeType $parts[0]` == "mesh" )
				{
					if(!`getAttr ($parts[0]+".io")`)
					{
						$attractorWhere = 3;
												
						string $newSelectedItems[];
						int $index	= 0;
						string $selected[] = `ls -sl`;
						for($polyObj in $selected)
						{
							string $polyParts[];
							tokenize( $polyObj,":[]",$polyParts );
							if( size($polyParts) == 3 )
							{
								int $count;
								for($count = int($polyParts[1]); $count<=int($polyParts[2]); $count++)
								{
									$newSelectedItems[$index] = $polyParts[0] + "[" + $count + "]" ;
									$index++;
								}
							}
							if( size($polyParts) == 2 )
							{
								$newSelectedItems[$index] = $polyObj;
								$index++;
								
							}
						}						
						select -cl;
						for($sel in $newSelectedItems)
						{
							select $sel;
							$attractors[$ai++]=attract( $length, $attractorType,0,0, 0.5, 0.5 );
						}
					}
				}
				else if ( `nodeType $parts[0]` == "subdiv" )
				{
					if(!`getAttr ($parts[0]+".io")`)
					{
						$attractorWhere = 4;
						
						string $newSelectedItems[];
						int $index	= 0;
						string $selected[] = `ls -sl`;
						for($obj in $selected)
						{
							string $subdparts[];
							tokenize( $obj,":[]",$subdparts );
							if( size($subdparts) == 4 )
							{
								int $count;
								for($count = int($subdparts[1]); $count<=int($subdparts[2]); $count++)
								{
									$newSelectedItems[$index] = $subdparts[0] + "[" + $count + "]["+$subdparts[3]+"]" ;
									$index++;
								}
							}
							if( size($subdparts) == 3 )
							{
								$newSelectedItems[$index] = $obj;
								$index++;
								
							}
						}
						select -cl;
						for($sel in $newSelectedItems)
						{
							select $sel;
							$attractors[$ai++]=attract( $length, $attractorType,0,0, 0.5, 0.5 );
						}
					}
				}
			} 
		} 
	} else if ( $what == "originBtn" ){
		$attractorWhere = 2;
		select -cl;
		$attractors[$ai++]=attract( $length, $attractorType,0,0,0.0, 0.0 );

	} else {
		
		$attractorWhere = 1;

		// Get grid size
		//
		int $gridU = `intFieldGrp -q -v1 gridGrp`;
		int $gridV = `intFieldGrp -q -v2 gridGrp`;

		if ( $gridU <= 0 ) {
			intFieldGrp -e -v1 1 gridGrp;
			$gridU = 1;
		}
		if ( $gridV <= 0 ) {
			intFieldGrp -e -v2 1 gridGrp;
			$gridU = 1;
		}
		optionVar -intValue HfAttractorSrfGridU $gridU;
		optionVar -intValue HfAttractorSrfGridV $gridV;

		// Get the surface max and min UV
		//
		string $selected[] = `ls -sl`;
		string $parts[];
				
		int $displaySubdivWarning = false;
				
		for( $sel in $selected)
		{
			tokenize( $sel,".[]",$parts);
			string $surface = "";

			if ( `nodeType $parts[0]` == "nurbsSurface" || `nodeType $parts[0]` == "mesh" || `nodeType $parts[0]` == "subdiv" ){
				$surface = $parts[0];
			} else if ( `nodeType $parts[0]` == "transform" ){
				string $selectedOne[];
				$selectedOne = `listRelatives -f -children $parts[0]`;
				int $i;
				for ( $i=0; $i<size($selectedOne) && $surface == ""; $i++ ){
					if ( `nodeType $selectedOne[$i]` == "nurbsSurface" || `nodeType $selectedOne[$i]` == "mesh" || `nodeType $selectedOne[$i]` == "subdiv" ){
						if(!`getAttr ($selectedOne[$i]+".io")`){
							$surface = $selectedOne[$i];
						}
					}
				}
			}

			if ( $surface != "" && `nodeType $surface` == "nurbsSurface" )
			{
				float $minU = `getAttr ($surface+".mnu")`;
				float $maxU = `getAttr ($surface+".mxu")`;
				float $minV = `getAttr ($surface+".mnv")`;
				float $maxV = `getAttr ($surface+".mxv")`;

				float $stepU = ($maxU-$minU)/$gridU;
				float $stepV = ($maxV-$minV)/$gridV;

				float $startU = $minU + ($stepU/2.0);
				float $startV = $minV + ($stepV/2.0);

				float $j;
				float $k;
				string $command;

				for ( $j=$startU; $j<$maxU; $j+=$stepU ){
					for ( $k=$startV; $k<$maxV; $k+=$stepV ){
						$command = ("select "+$surface+".uv["+$j+"]["+$k+"];");
						eval $command;
						$attractors[$ai++]=attract($length,$attractorType,0,0, 0.0, 0.0);
					}
				}
			}
			else if ( $surface != "" && `nodeType $surface` == "mesh" )
			{
				string $selObject = $surface+".f[*]";
				string $projName[] = `polyAutoProjection -cm 0 $selObject`;
				string $uvSetName;
				$uvSetName = `getAttr ($projName[0]+".uvSetName")`;

				float $faceUVArray[];
				$faceUVArray = `furClosestFace -u $gridU -v $gridV -uvSetName $uvSetName $surface`;

				int $count;
				for($count=0; $count<size($faceUVArray);$count+=3)
				{	
					$command = ("select "+$surface+".f["+$faceUVArray[$count]+"];");
					eval $command;
					$attractors[$ai++]=attract($length,$attractorType,1,$faceUVArray[$count], $faceUVArray[$count+1], $faceUVArray[$count+2]);
						
				}

			}
			else if ( $displaySubdivWarning == false && $surface != "" && `nodeType $surface` == "subdiv" )
			{	
				warning (uiRes("m_FurPluginCreateUI.kGridWarning")); 
				$displaySubdivWarning = true;
			}		
		}
	}


	// determine what to do with the attractors
	//
	string	$attractorSet;
	int		$placeIn = `optionMenuGrp -q -select placeMenu`;

	if ( $placeIn == 1 ) {
		// create new attractor set 
		//
		$attractorSet = createHairAttractorsNode();
	} else {
		$attractorSet = `optionMenuGrp -q -value placeMenu`;
	}

	global string	$HfLastUsedAttractorSet;

	$HfLastUsedAttractorSet = $attractorSet;

	// restore selection list and optionally attach
	// attractor set to selected surfaces
	//
	string	$s;

	restoreSelectionList;
	if ( $attach ) {
		string	$selected[];

		getSelectedSurfaceShapes( $selected );
		for ( $s in $selected ) {
			assignASToSurface( $attractorSet, $s );
		}
	}

	if ( $attractorType == 3 ) {
		int	$delay = `intFieldGrp -q -v1 followDelayGrp`;

		for ( $s in $attractors ) {	
			// Create an expression so $joint3 follows $joint1 by a certain
			// amount.  Also, create an attribute on $joint1 which controls the
			// how many frames behind the joint will follow.
			//
			
			// get the names of the first and second joints in the chain
			// $s is the last joint in the chain
			//
			string	$parents[];
			string	$joint1, $joint2;
			
			$parents = `listRelatives -f -p $s`;
			$joint2 = $parents[0];
			$parents = `listRelatives -f -p $joint2`;
			$joint1 = $parents[0];
			addAttr -ln "jointRotationDelay" -sn "dly" -at double $joint1;
			setAttr -k true ($joint1 + ".dly");
			
			string $exp =
				( "float $offset = " + $joint1 + ".dly;\n"
				+ $joint2 + ".rx = `getAttr -t (frame - $offset) " + $joint1 + ".rx`;\n"
				+ $joint2 + ".ry = `getAttr -t (frame - $offset) " + $joint1 + ".ry`;\n"
				+ $joint2 + ".rz = `getAttr -t (frame - $offset) " + $joint1 + ".rz`;\n" );
			expression -s $exp -ae on -n "FollowExp";
			setAttr ($joint1 + ".dly") $delay;
		}
		optionVar -intValue HfAttractorFollowDelay $delay;
	}

	// now add the created attractors to the attractor set
	//
	addAttractorsToAS( $attractors, $attractorSet );

	// save various settings
	//
	optionVar -intValue HfAttractorWhere $attractorWhere;
	optionVar -intValue HfAttractorType $attractorType;
	optionVar -floatValue HfAttractorLgth $length;
	optionVar -intValue HfAttractorSetAttach $attach;
}

global proc string PointOnSubdFace()
{
	  string $pointOnSubd;
	  string $sel[] = `ls -sl`;
	  if(size($sel) != 1) 
	  {
		error((uiRes("m_FurPluginCreateUI.kCreationNode1Error")));
		return "";
	  }
	 
	  string $subds[] = `filterExpand -ex true -sm 38`;
	   
	  if(size($subds) != 1) 
	  {
		error((uiRes("m_FurPluginCreateUI.kCreationNode2Error")));
		return "";
	  }

	  string $face = $subds[0];
	  
	  int $firstIndex = -1;
	  int $secondIndex = -1;
	  string $subd = "";

	  string $tok[];
	  int $nf = `tokenize $face "[" $tok`;

	  string $tok1[];
	  int $nf1 = `tokenize $face "." $tok1`;

	  
	  if( $nf > 2 ) {
		string $tmpS;
		$subd = substring( $tok1[0], 1, size($tok1[0]) );

		$tmpS = substring($tok[1], 1, size($tok[1])-1 );
		$firstIndex = (int)$tmpS;

		$tmpS = substring($tok[2], 1, size($tok[2])-1 );
		$secondIndex = (int)$tmpS;
	 }

	if( "" != $subd ) {
		$pointOnSubd = `createNode furPointOnSubd`;

		// Put it in the middle of the face
		setAttr ($pointOnSubd + ".faceFirst") $firstIndex;
		setAttr ($pointOnSubd + ".faceSecond") $secondIndex;

		setAttr ($pointOnSubd + ".uValue") 0.5;
		setAttr ($pointOnSubd + ".vValue") 0.5;
		setAttr ($pointOnSubd + ".relative") 1;

		connectAttr ($subd + ".worldSubdiv") ($pointOnSubd + ".subd");
	}

	return $pointOnSubd;
}

global proc string HfGetMeshNodeFromPointOnPoly(string $pointOnPolyNodeName )
{
	string $parts[];
	int $numTok = `tokenize $pointOnPolyNodeName "." $parts`;

	$pointOnPolyNodeName = $parts[0];
	string $shapeNode;
	$shapeNode = `connectionInfo -sfd ($pointOnPolyNodeName+".inMesh")`;

	string $shapeName;
	string $tokenizedNames[];
	int $numTokens = `tokenize $shapeNode "." $tokenizedNames`;

	if( `nodeType $tokenizedNames[0]` == "mesh")
	{
		$shapeName = $tokenizedNames[0];
	}

	return $shapeName;
}
proc customizeOptionBoxButtons(
	string	$parent,
	string	$callback,
	string	$setup
)
{
	//	'Apply' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit -label (uiRes("m_FurPluginCreateUI.kOptBoxApply")) 
		-command ($callback + " " + $parent + " " + 1)
		$applyBtn;

	//	'Save' button.
	//
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 0 + "; hideOptionBox")
		$saveBtn;

	//	'Reset' button.
	//
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " " + 1)
		$resetBtn;
}

// this procedure assumes that the parent has been set properly
//
proc addHDSubMenu(
	string	$command,
	string	$annotation,
	int		$assignedToSelected,
	string	$optionBoxCommand,
	string	$optionBoxAnnotation,
	int		$noneNeeded,
	string	$labelSuffix
)
{
	string	$hairDescriptions[];
	string	$hd;
	int		$optionBox = $optionBoxCommand != "";

	getAllHairDescriptions( $hairDescriptions, $assignedToSelected );
	if ( size( $hairDescriptions ) > 0 ) {
		for ( $hd in $hairDescriptions ) {
			menuItem -label ($hd + $labelSuffix) -annotation $annotation -c ($command + " " + $hd);
			if ( $optionBox ) {
				menuItem -optionBox true
					-annotation $optionBoxAnnotation
					-l $optionBoxAnnotation
					-c ($optionBoxCommand + " " + $hd);
			}
		}
	} else if ( $noneNeeded ) {
		menuItem -label (uiRes("m_FurPluginCreateUI.kHDSubMenuNone")) ;
		if ( $optionBox ) {
			menuItem -optionBox true
				-annotation $optionBoxAnnotation
				-l $optionBoxAnnotation
				-c ($optionBoxCommand + " None");
		}
	}
}

proc createHDSubMenu(
	string	$mi,
	string	$command,
	string	$annotation,
	int		$assignedToSelected,
	string	$optionBoxCommand,
	string	$optionBoxAnnotation,
	string	$labelSuffix
)
{
	menu -e -deleteAllItems -enable true $mi;
	setParent -menu $mi;
	addHDSubMenu(
		$command, $annotation, $assignedToSelected,
		$optionBoxCommand, $optionBoxAnnotation,
		true, $labelSuffix
	);
	setParent -menu ..;
}

proc checkHDSubMenu(
	string	$menuItems[],
	int		$assignedToSelected
)
{
	// Just enable all menu items and use error messages
	// if the operation is not appropriate (Bug 163391)
	
	string	$mi;
	for ( $mi in $menuItems ) {
		menuItem -e -enable true $mi;
	}
}

global proc HfCheckHDSubMenu1(
	string	$mi,
	int		$assignedToSelected
)
{
	string	$items[];

	$items[0] = $mi;
	checkHDSubMenu( $items, $assignedToSelected );
}

global proc HfCheckHDSubMenu2(
	string	$mi1,
	string	$mi2,
	int		$assignedToSelected
)
{
	string	$items[];

	$items[0] = $mi1; $items[1] = $mi2;
	checkHDSubMenu( $items, $assignedToSelected );
}

global proc HfCheckHDSubMenu3(
	string	$mi1,
	string	$mi2,
	string	$mi3,
	int		$assignedToSelected
)
{
	string	$items[];

	$items[0] = $mi1; $items[1] = $mi2; $items[2] = $mi3;
	checkHDSubMenu( $items, $assignedToSelected );
}

// this procedure assumes that the parent has been set properly
//
proc addASSubMenu(
	string	$command,
	string	$annotation,
	int		$assignedToSelected,
	int		$noneNeeded,
	string	$labelSuffix
)
{
	string	$hairAttractors[];
	string	$hd;

	getAllAttractorSets( $hairAttractors, $assignedToSelected );
	if ( size( $hairAttractors ) > 0 ) {
		for ( $hd in $hairAttractors ) {
			menuItem -label ($hd + $labelSuffix) -annotation $annotation
				-c ($command + " " + $hd);
		}
	} else if ( $noneNeeded ) {
		menuItem -label (uiRes("m_FurPluginCreateUI.kAddASSubMenuNone"));
	}
}

proc createASSubMenu(
	string	$mi,
	string	$command,
	string	$annotation,
	int		$assignedToSelected,
	string	$labelSuffix
)
{
	menu -e -deleteAllItems -enable true $mi;
	setParent -menu $mi;
	addASSubMenu(
		$command, $annotation, $assignedToSelected,
		true, $labelSuffix
	);
	setParent -menu ..;
}

proc checkASSubMenu(
	string	$menuItems[],
	int		$assignedToSelected
)
{
	// Just enable all menu items and use error messages
	// if the operation is not appropriate (Bug 163391)

	string	$mi;
	for ( $mi in $menuItems ) {
		menuItem -e -enable true $mi;
	}
}

global proc HfCheckASSubMenu1(
	string	$mi,
	int		$assignedToSelected
)
{
	string	$items[];

	$items[0] = $mi;
	checkASSubMenu( $items, $assignedToSelected );
}

global proc HfCheckASSubMenu6(
	string	$mi0,
	string	$mi1,
	string	$mi2,
	string	$mi3,
	string	$mi4,
	string	$mi5,
	int		$assignedToSelected
)
{
	string	$items[];

	$items[0] = $mi0;
	$items[1] = $mi1;
	$items[2] = $mi2;
	$items[3] = $mi3;
	$items[4] = $mi4;
	$items[5] = $mi5;
	checkASSubMenu( $items, $assignedToSelected );
}

global proc HfEnableIfSelectedSurfaces(
	string	$menuItems[]
)
{
	// Just enable all menu items and use error messages
	// if the operation is not appropriate (Bug 163391)

	string	$mi;
	for ( $mi in $menuItems ) {
		menuItem -e -enable true $mi;
	}
}

global proc HfCheckHairPaintMenu(
	string	$hairPaintItem,
	string	$hairPaintDialogItem
)
{
	// Just enable all menu items and use error messages
	// if the operation is not appropriate (Bug 163391)

	menuItem -e -enable true $hairPaintItem;
	menuItem -e -enable true $hairPaintDialogItem;
}

/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Create Hair Description menu
//
/////////////////////////////////////////////////////////////////////////////

proc setAssignHDOptionVars (int $forceFactorySettings)
{
	if ($forceFactorySettings || !`optionVar -exists HfAssignHDAttach`) {
        optionVar -intValue HfAssignHDAttach 1;
	}
}

proc setCreateHDOptionVars (int $forceFactorySettings)
{
	if ($forceFactorySettings || !`optionVar -exists HfCreateHDAssign`) {
        optionVar -intValue HfCreateHDAssign 1;
	}
	setAssignHDOptionVars( 0 );
}

global proc HfCreateHDSetup (string $parent, int $forceFactorySettings)
{
	// Retrieve the option settings
	//
	setCreateHDOptionVars ($forceFactorySettings);

	setParent $parent;

	// Query the optionVar's and set the values into the controls
	//
	int $assign = `optionVar -q HfCreateHDAssign`;

	// Set the controls
	//
	checkBoxGrp -edit -value1 $assign assignBox;
}

global proc HfCreateHDCallback (string $parent, int $doIt)
{
    setParent $parent;

	// Set the optionVar's from the control values, and then perform 
	// the command
	//
	int $assign = `checkBoxGrp -q -value1 assignBox`;
	optionVar -intValue HfCreateHDAssign $assign;

	if ($doIt) {
		HfPerformCreateHD 0;
	}
}

proc createHDOptions ()
{
	//	Name of the command for this option box.
	//
	string $commandName = "HfCreateHD";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");

	//	Step 1:  Get the option box.
	//	============================
	string $layout = getOptionBox();
	setParent $layout;
	
	//	Step 2:  Pass the command name to the option box.
	//	=================================================
	// setOptionBoxCommandName($commandName);
	
	//	Step 3:  Activate the default UI template.
	//	==========================================
	setUITemplate -pushTemplate DefaultTemplate;

	//	Step 4: Create option box contents.
	//	===================================
	
	//	Turn on the wait cursor.
	//
	waitCursor -state 1;

	tabLayout -scr true -tv false;
	
	string $parent = `columnLayout -adjustableColumn 1`;
	
	checkBoxGrp -ncb 1
		-label1 (uiRes("m_FurPluginCreateUI.kHDAssignSelSurf")) 
		assignBox;

	//	Turn off the wait cursor.
	//
	waitCursor -state 0;
	
	//	Step 5: Deactivate the default UI template.
	//  ===========================================
	//
	setUITemplate -popTemplate;

	//	Step 6: Customize the buttons.  
	//	==============================
	//
	customizeOptionBoxButtons( $parent, $callback, $setup );

	//	Step 7: Set the option box title.
	//	=================================
	//
	setOptionBoxTitle("Create Fur Description Options");

	//	Step 8: Customize the 'Help' menu item text.
	//	============================================
	//
	//	By default, the 'Help' menu item is set up when the command name
	//	is passed to the option box.  Normally, you do not need to
	//	customize the 'Help' menu item.
	//  
	//	To customize the 'Help' menu item use the following example.
	//
	// string $helpItem = getOptionBoxHelpItem();
	// menuItem -edit
	//     -label _L10N(kFurNewLabel,"New Label") 
	//     -command "CustomCommand"
	//     $helpItem;

	//	Step 8: Set the current values of the option box.
	//	=================================================
	//
	eval (($setup + " " + $parent + " " + 0));	
	
	//	Step 9: Show the option box.
	//	=============================
	//
	showOptionBox();
}

proc createHairDescription(
	int	$assign
)
{
	saveSelectionList;

	string	$surfaces[];

	if ( $assign ) {
		getSelectedSurfaceShapes( $surfaces );
	}

	string	$hairDescNode = createHairDescriptionNode();

	if ( $assign ) {
		for ( $s in $surfaces ) {
			assignHDToSurface( $hairDescNode, $s );
		}
	}

	restoreSelectionList;

	if ( $assign ) {
		HfAttachFeedbackNode( $hairDescNode );
	}
}


// The action variable means
//      0 - do the command
//      1 - show the option box
//      2 - return the drag command
//
global proc HfPerformCreateHD(int $action)
{
	
    switch ($action) {
        case 0: // Execute the command
            // Retrieve the option settings
            //
            setCreateHDOptionVars(false);
			createHairDescription(
				// `optionVar -q HfCreateHDAssign`
				false	// always create unattached
			);
            break;
        case 1:  // Do the option box
            createHDOptions;
            break;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Delete Hair Description menu
//
/////////////////////////////////////////////////////////////////////////////

global proc HfDeleteHD(
	string	$hd
)
{
	if ( `isFromReferencedFile $hd` ) {
		string $warningMsg = (uiRes("m_FurPluginCreateUI.kDeletionWarning"));
		warning(`format -s $hd $warningMsg`);
	} else {
		string	$members[];
		string	$m;
		int		$multiIndexes[];
	
		getHairSetMembers( $hd, $members, $multiIndexes );
		for ( $m in $members ) {
			unassignHDFromSurface( $hd, $m, true );
		}
		checkAndDelete $hd;
	}
}

global proc HfDeleteHDSubMenu(
	string	$mi
)
{
	string $ann = (uiRes("m_FurPluginCreateUI.kDeleteFurDesc"));
	createHDSubMenu(
		$mi, "HfDeleteHD", $ann, 
		false, "", "", ""
	);
}

/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Copy Hair Description menu
//
/////////////////////////////////////////////////////////////////////////////

global proc HfCopyHD(
	string	$hd
)
{
	copyHairDescription( $hd );
}

global proc HfCopyHDSubMenu(
	string	$mi
)
{
	string $ann = (uiRes("m_FurPluginCreateUI.kDuplicateFurDesc"));
	createHDSubMenu(
		$mi, "HfCopyHD", $ann,
		false, "", "", ""
	);
}
 
/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Assign Hair Description menu
//
/////////////////////////////////////////////////////////////////////////////

global proc HfAssignHDSetup (string $parent, int $forceFactorySettings)
{
	// Retrieve the option settings
	//
	setAssignHDOptionVars ($forceFactorySettings);

	setParent $parent;

	// Query the optionVar's and set the values into the controls
	//
	int $attach = `optionVar -q HfAssignHDAttach`;

	// Set the controls
	//
	checkBoxGrp -edit -value1 $attach attachBox;
}

global proc HfAssignHDCallback (
	string	$hairDesc,
	string	$parent,
	int		$doIt
)
{
    setParent $parent;

	// Set the optionVar's from the control values, and then perform 
	// the command
	//
	int $attach = `checkBoxGrp -q -value1 attachBox`;
	optionVar -intValue HfAssignHDAttach $attach;

	if ($doIt) {
		HfPerformAssignHD(0, $hairDesc);
	}
}

proc AssignHDOptions (
	string	$hairDesc
)
{
	//	Name of the command for this option box.
	//
	string $commandName = "HfAssignHD";

	//	Build the option box actions.
	//
	string $callback = $commandName + "Callback ";
	string $setup = ($commandName + "Setup");

	if ( $hairDesc != "" ) {
		$callback += $hairDesc;
	} else {
		$callback += "\"\"";
	}

	string $layout = getOptionBox();
	setParent $layout;
	
	setUITemplate -pushTemplate DefaultTemplate;

	waitCursor -state 1;

	tabLayout -scr true -tv false;
	
	string $parent = `columnLayout -adjustableColumn 1`;
	
	checkBoxGrp -ncb 1
		-label1 (uiRes("m_FurPluginCreateUI.kAttachFeedback")) 
		attachBox;

	waitCursor -state 0;
	
	setUITemplate -popTemplate;

	customizeOptionBoxButtons( $parent, $callback, $setup );

	string $title = (uiRes("m_FurPluginCreateUI.kFurDescOptTitle"));
	setOptionBoxTitle($title);

	eval (($setup + " " + $parent + " " + 0));	

	showOptionBox();
}

proc assignHairDescription(
	string	$hairDesc
)
{
	// if hairDesc is empty, create a new one
	//
	if ( $hairDesc == "" ) {
		saveSelectionList;
		$hairDesc = createHairDescriptionNode();
		restoreSelectionList;
	}

	if ( !`objExists $hairDesc` ) {
		// reset menu and return
		//
		return;
	}

	// int		$attach = `optionVar -q HfAssignHDAttach`;
	int		$attach = true;		// we always attach feedback now
	string	$surfaces[];

	getSelectedSurfaceShapes( $surfaces );

	for ( $s in $surfaces ) {
		assignHDToSurface( $hairDesc, $s );
	}
	if ( $attach ) {
		HfAttachFeedbackNode( $hairDesc );
	}
	// Create Custom Equalizer Maps if equalMap attribute value of FurGlobal is 2.
	string $hairGlobal = HfBuildHairGlobal();
	if( `getAttr ($hairGlobal+".equalMap")` == 2 )
	{
		string $cmd ="AEFurGlobalsCheckReadEqualMap defaultFurGlobals";
		evalDeferred $cmd;
	}
}


// The action variable means
//      0 - do the command
//      1 - show the option box
//      2 - return the drag command
//
global proc HfPerformAssignHD(
	int		$action,
	string	$hairDesc
)
{
    switch ($action) {
        case 0: // Execute the command
            // Retrieve the option settings
            //
            setAssignHDOptionVars(false);
			assignHairDescription($hairDesc);
            break;
        case 1:  // Do the option box
            AssignHDOptions( $hairDesc );
            break;
    }
}

global proc HfCreateAndAssignHD(
	int		$action
)
{
	// Pop error message if the operation is not appropriate 
	// (Bug 163391)

	string	$selected[];
	getSelectedSurfaceShapes( $selected );
	
	if (size( $selected ) <= 0){
		error ((uiRes("m_FurPluginCreateUI.kSelectionError")));
		return;
	}

	HfPerformAssignHD( $action, "" );
}

global proc HfAssignHDSubMenu(
	string	$mi
)
{
	menu -e -deleteAllItems -enable true $mi;
	setParent -menu $mi;

	string	$optAnnotation="Attach Fur Description Option Box";

	// create special entry which creates and assigns new
	// hair description
	//
	menuItem -label (uiRes("m_FurPluginCreateUI.kHDSubMenuNew"))  
		-annotation (uiRes("m_FurPluginCreateUI.kHDSubMenuNewAnnot")) 
		-c "HfCreateAndAssignHD 0";

	// add all the existing hair descriptions
	//
	string $annot = (uiRes("m_FurPluginCreateUI.kHDSubMenuAttachFurDesc"));
	addHDSubMenu(
		"HfPerformAssignHD 0", $annot,
		false,
		"", "",
		false, ""
	);
	setParent -menu ..;
}

/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Unassign Hair Description menu
//
/////////////////////////////////////////////////////////////////////////////

global proc HfUnassignHD(
	string	$hd
)
{
	string	$surfaces[];

	getSelectedSurfaceShapes( $surfaces );

	for ( $s in $surfaces ) {
		unassignHDFromSurface( $hd, $s, true );
	}
}

global proc HfUnassignHDSubMenu(
	string	$mi
)
{
	string $ann = (uiRes("m_FurPluginCreateUI.kDetachFurDesc"));
	createHDSubMenu(
		$mi, "HfUnassignHD", $ann,
		true, "", "", ""
	);
}

proc string findCurveAttractorSet(string $hairSystem)
{
	string $attrFromHair[] = `listConnections -shapes true -type "FurCurveAttractors" $hairSystem`;
		
	if(size($attrFromHair) == 1)
	{
		return $attrFromHair[0];
	}
	return "";
}

global proc assignHStoFD(string $furDescription, string $hairSystem)
{	
	if($hairSystem =="")
		return;
	
	string $curveAttractorSet;	
	string	$surfaces[];
	string	$m;
	int		$multiIndexes[];	
	getHairSetMembers( $furDescription, $surfaces, $multiIndexes );
	for( $surface in $surfaces)
	{
		$curveAttractorSet = findCurveAttractorSet($hairSystem);
		if($curveAttractorSet == "")
			$curveAttractorSet = createHairCurveAttractorsNode();
		assignCASToSurface( $curveAttractorSet, $surface, $hairSystem, $furDescription );
	}
}

global proc setStartPosition(string $furDesc)
{
	string	$surfaces[];
	string	$m;
	int		$multiIndexes[];	
	getHairSetMembers( $furDesc, $surfaces, $multiIndexes );
	for( $surface in $surfaces)
	{
		string $feedback = getFurFeedbackNode( $surface,$furDesc);
		if($feedback !="")
		{
			setAttr ($feedback+".fsp") true;
			setAttr ($feedback+".fusp") true;
		}
	}
}

global proc HfAddCurvesToFur(string $hairsys)
{
	if($hairsys=="")
		return;
		
	string $furDescriptions[];
	string $curveAttrs[] = `listConnections -shapes true -type "FurCurveAttractors" $hairsys`;
	if( size($curveAttrs) == 1 )
	{
		string $furFeedback[] = `listConnections -shapes true -type "FurFeedback" ($curveAttrs[0]+".CurveAttractorModel")`;				
		for($feedback in $furFeedback)
		{
			string $furDes[] = `listConnections -shapes true -type "FurDescription" ($feedback+".Length")`;
			$furDescriptions[size($furDescriptions)] = $furDes[0];
		}
	    if( size($furDescriptions) > 0 )
		{
			for ($i = 0; $i < size($furDescriptions); $i++)
	                {
				string $command = "assignHStoFD ";
		                $command = ($command 
			                + $furDescriptions[$i] 
			                + " "
			                + $hairsys
			                + " ;");
				catch( eval($command) );
	                }	                
		}
	}	

}

global proc HfSetStartPositionMenu(
	string	$mi
)
{
	menu -e -deleteAllItems -enable true $mi;
	setParent -menu $mi;
	string $annotation = (uiRes("m_FurPluginCreateUI.kSetStartPosMenuAnnot")) ;
	string $optionBoxAnnotation = "";
	string $optionBoxCommand = "";
	string $command = "setStartPosition";
	
	string	$hairDescriptions[];
	string	$hd;
	int		$optionBox = $optionBoxCommand != "";
	
	string $hairSys = HfGetSelectedHairSystem();
	string $surfaces[];
	
	if($hairSys !="")
	{
		string $attractor[] = `listConnections -shapes true -type "FurCurveAttractors" $hairSys`;
		if($attractor[0]!="")
		{
			string $feedbacks[] = `listConnections -shapes true -type "FurFeedback" ($attractor[0]+".CurveRadius")`;
			for($feedback in $feedbacks)
			{
				string $furDescs[] =`listConnections -shapes true -type "FurDescription" ($feedback+".Length")`;
				for($furDes in $furDescs)
					furAppendUniqueEntry($furDes,$hairDescriptions);
			}
		}
	}
	
	
	if ( size( $hairDescriptions ) > 0 ) {
		for ( $hd in $hairDescriptions ) {
			$command = "setStartPosition " + $hd ;
			print $command;
			menuItem -label ($hd) -annotation $annotation -c ($command);
			if ( $optionBox ) {
				menuItem -optionBox true
					-annotation $optionBoxAnnotation
					-l $optionBoxAnnotation
					-c ($optionBoxCommand + " " + $hd);
			}
		}
	} else {
		menuItem -label (uiRes("m_FurPluginCreateUI.kSetStartPosMenuNone")) ;
		if ( $optionBox ) {
			menuItem -optionBox true
				-annotation $optionBoxAnnotation
				-l $optionBoxAnnotation
				-c ($optionBoxCommand + " None");
		}
	}

	setParent -menu ..;
}

global proc HfAssignHSFDSubMenu(
	string	$mi
)
{
	menu -e -deleteAllItems -enable true $mi;
	setParent -menu $mi;
	string $annotation = (uiRes("m_FurPluginCreateUI.kHSFDSubMenuAttHairSystemAnnot")) ;
	string $optionBoxAnnotation = "";
	string $optionBoxCommand = "";
	string $command = "assignHStoFD";
	
	string	$hairDescriptions[];	
	int	$optionBox = $optionBoxCommand != "";

	string $hairSys = HfGetSelectedHairSystem();
	string $surfaces[];
	
	// Get All Furdescriptions that are attached to the surface.
	if($hairSys !="")	
	{
		string $furDes[] = `ls -type FurDescription`;
		for($fur in $furDes)
		{
			string $a[] = `listConnections -shapes true -type mesh ($fur+".dsm")`;
			string $b[] = `listConnections -shapes true -type nurbsSurface ($fur+".dsm")`;
			string $c[] = `listConnections -shapes true -type subdiv ($fur+".dsm")`;
			if( !(size($a)==0 && size($b)==0 && size($c)==0 ))
			{
				$hairDescriptions[size($hairDescriptions)] = $fur;
			}
		}
	}
			
	if ( size( $hairDescriptions ) > 0 ) {
		for ( $hd in $hairDescriptions ) {
			$command = "assignHStoFD " + $hd + " " + $hairSys;
			menuItem -label ($hd) -annotation $annotation -c ($command);
			if ( $optionBox ) {
				menuItem -optionBox true
					-annotation $optionBoxAnnotation
					-l $optionBoxAnnotation
					-c ($optionBoxCommand + " " + $hd);
			}
		}
	} else {
		menuItem -label (uiRes("m_FurPluginCreateUI.kHSFDSubMenuNone")) ;
		if ( $optionBox ) {
			menuItem -optionBox true
				-annotation $optionBoxAnnotation
				-l $optionBoxAnnotation
				-c ($optionBoxCommand + " None");
		}
	}

	setParent -menu ..;
}
global proc HfEditCASSubMenu(
	string	$mi
)
{
	menu -e -deleteAllItems -enable true $mi;
	setParent -menu $mi;
	string $annotation = (uiRes("m_FurPluginCreateUI.kEditCurveAttrAnnot")) ;
	string $command = "HfEditCAS";
	string $optionBoxCommand = "";	
	int    $optionBox = $optionBoxCommand != "";

	string	$hairAttractors[] =`ls -type "FurCurveAttractors"`;
	
	if ( size( $hairAttractors ) > 0 ) {
		for ( $hd in $hairAttractors ) {
			menuItem -label ($hd ) -annotation $annotation
				-c ($command + " " + $hd);
		}
	} else {
		menuItem -label (uiRes("m_FurPluginCreateUI.kEditCASSubMenuNone")) ;
	}
	setParent -menu ..;
}

global proc HfDeleteCASSubMenu(
	string	$mi
)
{
	menu -e -deleteAllItems -enable true $mi;
	setParent -menu $mi;
	string $annotation = (uiRes("m_FurPluginCreateUI.kDelCrvAttrAnnot")) ;
	string $command = "HfDeleteCAS";
	string $optionBoxCommand = "";	
	int    $optionBox = $optionBoxCommand != "";

	string	$hairAttractors[] =`ls -type "FurCurveAttractors"`;
	
	if ( size( $hairAttractors ) > 0 ) {
		for ( $hd in $hairAttractors ) {
			menuItem -label ($hd ) -annotation $annotation
				-c ($command + " " + $hd);
		}
	} else {
		menuItem -label (uiRes("m_FurPluginCreateUI.kDelCASSubMenuNone")) ;
	}
	setParent -menu ..;
}


global proc detachHStoFD(string $furDescription, string $hairSystem)
{
	if($hairSystem =="")
	    return;

	string	$surfaces[];
	string	$m;
	int		$multiIndexes[];	
	getHairSetMembers( $furDescription, $surfaces, $multiIndexes );
	for( $surface in $surfaces)
	{
		string $curveAttractorSet = findCurveAttractorSet($hairSystem);		
		if( $curveAttractorSet != "" )
			unassignCASFromSurface( $curveAttractorSet, $surface, $hairSystem,$furDescription );
	}
}

global proc detachCStoFD(string $furDescription, string $curveSystem)
{
	if($curveSystem =="")
	    return;

	string	$surfaces[];
	string	$m;
	int		$multiIndexes[];	
	getHairSetMembers( $furDescription, $surfaces, $multiIndexes );
	for( $surface in $surfaces)
	{
		string $curveAttractorSet = findCurveAttractorSet($curveSystem);		
		if( $curveAttractorSet != "" )
			unassignCASFromSurface( $curveAttractorSet, $surface, $curveSystem,$furDescription );
	}
}

global proc HfDetachHSSubMenu(
	string	$mi
)
{
	menu -e -deleteAllItems -enable true $mi;
	setParent -menu $mi;
	string $annotation = (uiRes("m_FurPluginCreateUI.kHSSubMenuDetachHairSystemAnnot")) ;
	string $optionBoxAnnotation = "";
	string $optionBoxCommand = "";
	string $command = "detachHStoFD";
	
	string	$hairDescriptions[];
	string	$hd;
	int	$optionBox = $optionBoxCommand != "";
	string $hairSys = HfGetSelectedHairSystem();
	
	if($hairSys !="")
	{
		string $attractor[] = `listConnections -shapes true -type "FurCurveAttractors" $hairSys`;
		if($attractor[0]!="")
		{
			string $feedbacks[] = `listConnections -shapes true -type "FurFeedback" ($attractor[0]+".CurveRadius")`;
			for($feedback in $feedbacks)
			{
				string $furDescs[] =`listConnections -shapes true -type "FurDescription" ($feedback+".Length")`;
				for($furDes in $furDescs)
					furAppendUniqueEntry($furDes,$hairDescriptions);
			}
		}
	}		

	if ( size( $hairDescriptions ) > 0 ) {
		for ( $hd in $hairDescriptions ) {
			$command = "detachHStoFD " + $hd + " " + $hairSys;
			menuItem -label ($hd) -annotation $annotation -c ($command);
			if ( $optionBox ) {
				menuItem -optionBox true
					-annotation $optionBoxAnnotation
					-l $optionBoxAnnotation
					-c ($optionBoxCommand + " " + $hd);
			}
		}
	} else {
		menuItem -label (uiRes("m_FurPluginCreateUI.kDetachHSSubMenuNone")) ;
		if ( $optionBox ) {
			menuItem -optionBox true
				-annotation $optionBoxAnnotation
				-l $optionBoxAnnotation
				-c ($optionBoxCommand + " None");
		}
	}

	setParent -menu ..;
}

/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Edit Hair Description menu
//
/////////////////////////////////////////////////////////////////////////////

global proc HfEditHD(
	string	$hd
)
{
	attachHairFeedbackToAssignedSurfaces( $hd );
	select $hd;
	editSelected;
}

global proc HfEditHDSubMenu(
	string	$mi
)
{
	string $annot = (uiRes("m_FurPluginCreateUI.kEditHDSubMenuFurDesc"));
	createHDSubMenu(
		$mi, "HfEditHD", $annot,
		false, "", "", "..."
	);
}

/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Create Attractor Set menu
//
/////////////////////////////////////////////////////////////////////////////

proc setCreateASOptionVars (int $forceFactorySettings)
{
	if ($forceFactorySettings || !`optionVar -exists HfCreateASAssign`) {
        optionVar -intValue HfCreateASAssign 1;
	}
}

global proc HfCreateASSetup (string $parent, int $forceFactorySettings)
{
	// Retrieve the option settings
	//
	setCreateASOptionVars ($forceFactorySettings);

	setParent $parent;

	// Query the optionVar's and set the values into the controls
	//
	int $assign = `optionVar -q HfCreateASAssign`;

	// Set the controls
	//
	checkBoxGrp -edit -value1 $assign assignBox;
}

global proc HfCreateASCallback (string $parent, int $doIt)
{
    setParent $parent;

	// Set the optionVar's from the control values, and then perform 
	// the command
	//
	int $assign = `checkBoxGrp -q -value1 assignBox`;
	optionVar -intValue HfCreateASAssign $assign;

	if ($doIt) {
		HfPerformCreateAS 0;
	}
}

proc createASOptions ()
{
	//	Name of the command for this option box.
	//
	string $commandName = "HfCreateAS";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");

	string $layout = getOptionBox();
	setParent $layout;
	
	setUITemplate -pushTemplate DefaultTemplate;

	waitCursor -state 1;

	tabLayout -scr true -tv false;
	
	string $parent = `columnLayout -adjustableColumn 1`;
	
	checkBoxGrp -ncb 1
		-label1 (uiRes("m_FurPluginCreateUI.kASAssignSelSurf")) 
		assignBox;

	waitCursor -state 0;
	
	setUITemplate -popTemplate;

	customizeOptionBoxButtons( $parent, $callback, $setup );

	string $title = (uiRes("m_FurPluginCreateUI.kCreateAttrSetOpt"));
	setOptionBoxTitle( $title );

	eval (($setup + " " + $parent + " " + 0));	
	
	showOptionBox();
}

proc createAttractorSet()
{
	saveSelectionList;

	int		$assign = `optionVar -q HfCreateASAssign`;
	string	$surfaces[];

	if ( $assign ) {
		getSelectedSurfaceShapes( $surfaces );
	}

	string	$attrSetNode = createHairAttractorsNode();

	if ( $assign ) {
		for ( $s in $surfaces ) {
			assignASToSurface( $attrSetNode, $s );
		}
	}

	restoreSelectionList;
}


// The action variable means
//      0 - do the command
//      1 - show the option box
//      2 - return the drag command
//
global proc HfPerformCreateAS(int $action)
{
    switch ($action) {
        case 0: // Execute the command
            // Retrieve the option settings
            //
            setCreateASOptionVars(false);
			createAttractorSet;
            break;
        case 1:  // Do the option box
            createASOptions;
            break;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Delete Attractor Set menu
//
/////////////////////////////////////////////////////////////////////////////

global proc HfDeleteAS(
	string	$as
)
{
	string	$members[];
	string	$m;
	int		$multiIndexes[];

	if ( `isFromReferencedFile $as` ) {
		string $warningMsg = (uiRes("m_FurPluginCreateUI.kRefenceFileDeletionWarn"));
		warning( `format -s $as $warningMsg ` );
		return;
	}

	// unassign attractor set from all assigned surfaces
	//
	getAttrSetMembers( $as, $members, $multiIndexes );
	for ( $m in $members ) {
		unassignASFromSurface( $as, $m );
	}

	// delete any attractors that we created
	//
	string	$dstAttrs[] = `listAttr -m -st "attractors" $as`;
	string	$da;

	for ( $da in $dstAttrs ) {
		string	$dstPlug = $as + "." + $da;
		string	$srcPlug = getSrcPlug( $dstPlug );
		if ( $srcPlug != "" ) {
			string	$attr = plugNode( $srcPlug );
			string	$attrGrp = getAttractorGrp( $attr );

			// if it is an attractor group then MayaFur created
			// it, so we can delete it
			//
			if ( $attrGrp != "" ) {
				checkAndDelete $attrGrp;
			}
		}
	}

	// finally delete the attractor set
	//
	checkAndDelete $as;
}

global proc HfDeleteCAS(
	string	$attractorSet
)
{
	string	$members[];
	string	$m;
	int		$multiIndexes[];

	if ( `isFromReferencedFile $attractorSet` ) {
		string $warningMsg = (uiRes("m_FurPluginCreateUI.kRefenceFileDeletionWarn"));
		warning(`format -s $attractorSet $warningMsg` );
		return;
	}
	string $hairDescriptions[];
	string $hairSys[];
	string $hairSystem;
	if($attractorSet !="")
	{
		$hairSys= `listConnections -shapes true -type "hairSystem" $attractorSet`;
		if($hairSys[0]!="")
		{
			string $feedbacks[] = `listConnections -shapes true -type "FurFeedback" ($attractorSet+".CurveRadius")`;
			for($feedback in $feedbacks)
			{
				string $furDescs[] =`listConnections -shapes true -type "FurDescription" ($feedback+".Length")`;
				for($furDes in $furDescs)
					furAppendUniqueEntry($furDes,$hairDescriptions);
			}
			$hairSystem = $hairSys[0];
			//Detach hairsystem from fur description.
			for($fur in $hairDescriptions)
			{
				detachHStoFD($fur,$hairSys[0]);
			}
			
			string $attr = "furAttrSystem";
			if ( !`attributeQuery -ex -node $hairSystem $attr`)
			{
				addAttr -at message -hidden true -longName "furAttrSystem" -shortName "fas" $hairSystem;
			}
		}
		string $a[] = `listConnections -shapes true -type "FurFeedback" ($attractorSet+".CurveAttractorModel")`;
		$attr = "curveAttractors";
		if ( `attributeQuery -exists -n $attractorSet $attr` && size($a) == 0 ) {
			string	$source, $dest;

			// disconnect default and map attributes
			//
			$dest=$attractorSet + "." + $attr;
			$source=`connectionInfo -sfd $dest`;			
			if ( $source != "" && ( $hairSystem == "" || $hairSystem == plugNode( $source ) ) ) {			
				checkAndDisconnectAttr($source,$dest);
			}
			
		}
	
	}
	
	// finally delete the attractor set
	//
	checkAndDelete $attractorSet;
}

global proc HfDeleteASSubMenu(
	string	$mi
)
{
	string $ann = (uiRes("m_FurPluginCreateUI.kDelAttrSet"));
	createASSubMenu( $mi, "HfDeleteAS", $ann, false, "" );
}
 
/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->{Assign,Unassign} Attractor Set menus
//
/////////////////////////////////////////////////////////////////////////////

global proc HfAssignAS(
	string	$as
)
{
	string	$surfaces[];
	string	$s;

	getSelectedSurfaceShapes( $surfaces );

	for ( $s in $surfaces ) {
		assignASToSurface( $as, $s );
	}
}

global proc HfAssignASSubMenu(
	string	$mi
)
{
	string $ann = (uiRes("m_FurPluginCreateUI.kAttachAttrSetToSelSurf"));
	createASSubMenu(
		$mi, "HfAssignAS", $ann,
		false, ""
	);
}

global proc HfUnassignAS(
	string	$as
)
{
	string	$surfaces[];
	string	$s;

	getSelectedSurfaceShapes( $surfaces );

	for ( $s in $surfaces ) {
		unassignASFromSurface( $as, $s );
	}
}

global proc HfUnassignASSubMenu(
	string	$mi
)
{
	string $ann = (uiRes("m_FurPluginCreateUI.kDetachAttrSet"));
	createASSubMenu(
		$mi, "HfUnassignAS", $ann,
		true, ""
	);
}

/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Edit Attractor Set menu
//
/////////////////////////////////////////////////////////////////////////////

global proc HfEditAS(
	string	$as
)
{
	select $as;
	editSelected;
}
global proc HfEditCAS(
	string	$as
)
{
	select $as;
	editSelected;
}

global proc HfEditASSubMenu(
	string	$mi
)
{
	string $ann = (uiRes("m_FurPluginCreateUI.kEditAttrSet"));
	createASSubMenu( $mi, "HfEditAS", $ann, false, "..." );
}
 
/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->{Add,Remove} Attractor menus
//
/////////////////////////////////////////////////////////////////////////////

global proc HfAddAttractorToAS(
	string	$as
)
{
	string	$selected[];
	string	$s;

	$selected = `ls -sl`;

	for ( $s in $selected ) {
		addAttractorToAS( $s, $as );
	}
}

global proc HfAddAttractorSubMenu(
	string	$mi
)
{
	string $ann = (uiRes("m_FurPluginCreateUI.kAddSelGeomAttrSet"));
	createASSubMenu(
		$mi, "HfAddAttractorToAS", $ann,
		false, ""
	);
}

global proc HfRemoveAttractorFromAS(
	string	$as
)
{
	string	$selected[];
	string	$s;

	$selected = `ls -sl`;

	for ( $s in $selected ) {
		removeAttractorFromAS( $s, $as );
	}
}

global proc HfRemoveAttractorSubMenu(
	string	$mi
)
{
	string $ann = (uiRes("m_FurPluginCreateUI.kRemoveSelAttrSet"));
	createASSubMenu(
		$mi, "HfRemoveAttractorFromAS", $ann,
		false, ""
	);
}

/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the equalizer map attribute
//
/////////////////////////////////////////////////////////////////////////////

addDebugTag( "equalizer" );

// return 0 if $shape isn't an valid shape
// return 1 if equalizerMap attr can't find
// return 2 if equalizerMap isn't set
// return 3 if equalizerMap is set properly
global proc int HFcheckEqualizerAttr(
	string $shape
)
{
	string	$tag="equalizer";

	HfTDebug($tag, "checking " + $shape);

	string $type = `nodeType $shape`;
	if( $type != "nurbsSurface" && $type != "mesh" && $type != "subdiv" ) 
	{
		HfTDebug($tag, "  not valid shape (0)" );
		return 0;
	}

	// check if the attribute has been added
	int $found = false;
	string $attrList[];
	$attrList = `listAttr -ud $shape`;
	for( $a in $attrList )
	{
		if( $a == "equalizerMap" )
		{
			$found = true;
			break;
		}
	}

	if( !$found )
	{
		HfTDebug($tag, "  attribute not found (1)" );
		return 1;
	}

	string $plug = $shape + ".equalizerMap";
	string $rc = `getAttr $plug`;
	if( $rc == "" )
	{
		HfTDebug($tag, "  attribute not set properly (2)" );
		return 2;
	}
	else
	{
		// is it a valid file
		//
		string	$eqFile = HfGetFullImagePath( $rc );
		string	$shapeName = match( "[^|]*[^|]$", $shape );

		global int $gHfMayaState;
		if($gHfMayaState != 1)
		{
			if(`reference -q -inr $shapeName`)
			{
				$shapeName =	HfGetReferenceSurface($shapeName);
			}
		}
		else
		{
			int	$isReferenceFileFound = false;
			string	$userDefinedAttrList[] = `listAttr -ud $shapeName`;
			for( $userDefinedAttr in $userDefinedAttrList	)
			{
				if($userDefinedAttr == "referenceFile")
				{
					$isReferenceFileFound = true;
				}
			}
			if($isReferenceFileFound)
			{
				$shapeName =	HfGetReferenceSurfaceBatch($shapeName);
			}
			else if(`reference -q -inr $shapeName`)
			{
				$shapeName =	HfGetReferenceSurface($shapeName);
			}
		}

		// replace reference separator ':' with an underscore since
		// map file names are generated from shape Name
		string $fileShapeTokens[];
		string $refShapeName;
		int $numTokens = `tokenize $shapeName ":" $fileShapeTokens`;
		if($numTokens > 1)
		{
		    int $count;
			for($count=0; $count < $numTokens; $count++)
			{
				if($count > 0)
				{
					$refShapeName +="_";
				}
				$refShapeName +=$fileShapeTokens[$count];
			}
			$shapeName = $refShapeName;
		}

		HfTDebug($tag,"shape name = " + $shapeName);
	
		if ( $eqFile != ""
		  && `filetest -r $eqFile`
		  && gmatch( $rc, "*" + $shapeName + "*")) {
		  
			string $sceneName = `file -q -sn`;
			if($sceneName != "" && `furCompareFileTime $eqFile $sceneName`== 1)
			{
				string $hairGlobal = HfBuildHairGlobal();
				if(`attributeQuery -ex -node $hairGlobal "createEqualMap"`) {
					if(`getAttr ($hairGlobal+ ".createEqualMap")`){				
						return 2;
					}
				}	
				HfTDebug($tag, "  attribute set properly (3)" );
				return 3;
			}
			else
			{
				HfTDebug($tag, "  attribute set properly (2)" );
				return 2;
			}
		} else {
			HfTDebug($tag, "  attribute not set properly (2)" );

			// Work around a bug in the attribute editor code for
			// text fields. The attribute editor starts a script job
			// to update text fields. We added a string attribute to
			// the shape for the equalizer map. If the name of the
			// shape is changed, the script job now refers to a non
			// existent plug which can generate an error if the script
			// fires. To avoid this error find the scipt job and
			// replace it with a new one.
			//
			string	$jobs[] = `scriptJob -lj`;
			string	$j;

			for ( $j in $jobs ) {
				string	$matchRE = "*\.equalizerMap*";

				if ( gmatch( $j, $matchRE ) ) {
					string	$parts[];
					string	$replaceRE = "[^\"]*\.equalizerMap";
					int		$jobId;
					string	$altered;
					string	$p;

					tokenize( $j, ":", $parts );
					$jobId = $parts[0];
					$altered = $parts[1];
					int $partSize = size($parts);					
					for($count = 2; $count<$partSize; $count++) {
						$altered += ":" + $parts[$count];
					}
					HfTDebug( $tag,"  scriptjob " + $jobId + " looks at equalizerMap attribute - killing");
					scriptJob -kill $jobId;

					HfTDebug( $tag,"  before: " + $altered ); 
					tokenize( $altered, $parts );
					$altered = "";
					for ( $p in $parts ) {
						if  ( gmatch( $p, $matchRE ) ) {
							HfTDebug( $tag,"  before replace " + $p);
							string	$modP = substitute( $replaceRE, $p, $plug );
							HfTDebug( $tag,"  after replace " + $modP);
							$altered += $modP + " "; 
						} else {
							$altered += $p + " ";
						}
					}
					HfTDebug( $tag,"  running: scriptJob" + $altered ); 
					eval( "scriptJob " + $altered );
				}
			}

			setAttr -type "string" $plug "";
			return 2;
		}
	}
}

global proc HfSetEqualToSrf(
	string $shape,
	string $equalPath
)
{
	int $rc = HFcheckEqualizerAttr($shape);
	
	if( $rc == 0 )
	{
		return;
	}
	else if( $rc == 1 )
	{
		addAttr -dt "string" -ln "equalizerMap" -sn "emp" $shape;
	}

	string $plug = $shape + ".emp";

	// To make equal project absolute:   $equalPath = makeFullPath( $equalPath );
	// try to make the equal path project relative
	//	
	$equalPath = makeProjectRelative( $equalPath );

	setAttr -type "string" $plug $equalPath;
}



/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Attach Hair Feedback and
// Hair->Remove Hair Feedback menu
//
/////////////////////////////////////////////////////////////////////////////

global proc HfRemoveHairFeedback()
{
	string	$selected[];

	getSelectedSurfaceShapes( $selected );
	removeHairFeedbackFromSurfaces( $selected, "" );
}

global proc HfAttachFeedbackNode(
	string	$hairDesc
)
{
	string	$hairDescriptions[];
	string	$mi;

	getAllHairDescriptions( $hairDescriptions, true );
	if( size( $hairDescriptions ) <= 0){
		return;
	}

	string	$selected[];

	getSelectedSurfaceShapes( $selected );
	attachHairFeedbackToSurfaces( $selected, $hairDesc );
}

global proc HfAttachHFSubMenu(
	string	$mi
)
{
	menu -e -deleteAllItems -enable true $mi;
	setParent -menu $mi;

	// add special menu item to remove all feedback
	//
	menuItem -label (uiRes("m_FurPluginCreateUI.kAttachHFSubMenuNone"))
		-annotation (uiRes("m_FurPluginCreateUI.kAttachHFSubMenuNoneAnnot")) 
		-c "HfRemoveHairFeedback";

	// and add menu items for all hair descriptions assigned
	// to selected surfaces
	//
	string $ann = (uiRes("m_FurPluginCreateUI.kFurFeedbackSelSurfAnnot"));
	addHDSubMenu(
		"HfAttachFeedbackNode", $ann,
		true, "", "" , false, ""
	);
	setParent -menu ..;
}

global proc HfDisconnectASFromHF()
{
	string	$selected[];

	getSelectedSurfaceShapes( $selected );
	detachASFromSurfacesHF( $selected, "" );
}

global proc HfConnectASToHF(
	string	$attractorSet
)
{
	string	$selected[];

	getSelectedSurfaceShapes( $selected );
	attachASToSurfacesHF( $selected, $attractorSet );
}

global proc HfConnectASToHFSubMenu(
	string	$mi
)
{
	menu -e -deleteAllItems -enable true $mi;
	setParent -menu $mi;

	// add special menu item to disconnect attractor set
	//
	menuItem -label (uiRes("m_FurPluginCreateUI.kASToHFSubMenuNone"))
		-annotation (uiRes("m_FurPluginCreateUI.kASToHFSubMenuNoneAnnot")) 
		-c "HfDisconnectASFromHF";

	// and add menu items for all hair descriptions assigned
	// to selected surfaces
	//
	string $ann = (uiRes("m_FurPluginCreateUI.kConnAttrSetToFurFeedbackAnnot"));
	addASSubMenu(
		"HfConnectASToHF", $ann,
		true, false, ""
	);
	setParent -menu ..;
}

/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Flip Hair Normals menu item
//
/////////////////////////////////////////////////////////////////////////////

addDebugTag("flipHairNormals");

global proc HfFlipHairNormals()
{
	// Pop error message if the operation is not appropriate 
	// (Bug 163391)

	string	$selected[];
	getSelectedSurfaceShapes( $selected );
	
	if (size( $selected ) <= 0){
		error (uiRes("m_FurPluginCreateUI.kSelectionError"));
		return;
	}

	string	$tag = "flipHairNormals";
	string	$selected[];
	string	$s;

	getSelectedSurfaceShapes( $selected );

	for ( $s in $selected ) {
		string	$flipPlug = getFlipNormalsPlug( $s, true );
		int		$flip = `getAttr $flipPlug`;

		$flip = !$flip;
		HfTDebug( $tag, "changing " + $flipPlug + " to " + $flip );
		setAttr $flipPlug $flip;
	}
}

/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Offset Fur Angle menu item
//
/////////////////////////////////////////////////////////////////////////////

addDebugTag("offsetHairAngle");

global proc HfOffsetHairAngle(
	float	$angle
)
{
	string	$selected[];
	string	$tag = "offsetHairAngle";
	string	$offsetAttr=`buildFurFiles -opa`;
	
	getSelectedSurfaceShapes( $selected );
	
	if (size( $selected ) <= 0){
		error (uiRes("m_FurPluginCreateUI.kSelectionError"));
		return;
	}
	
	string	$s;
	for ( $s in $selected ) {
		string	$attr[]=`listAttr -st $offsetAttr $s`;
		string	$offsetPlug = $s + "." + $offsetAttr;
		
		if ( size( $attr ) == 0 ) {
			addAttr -at "float" -ln $offsetAttr -dv 0 -min 0 -max 1 $s;
			HfTDebug( $tag, "adding attribute " + $offsetAttr + " to " + $s);
			
			// if this shape is connected to a feedback node determine plug to which
			// the feedbacks polar input is connected to, break the connection
			// and create an expression which adds the offset in
			//
			string	$feedbackNodes[];
			string $feedbackNode;
			$feedbackNodes = getFurFeedbackNodes( $s );
			
			for ($feedbackNode in $feedbackNodes) {
				if ( $feedbackNode != "" ) { 
					addPolarOffsetToFeedback( $feedbackNode, $offsetPlug );
				}
			}
		}
		HfTDebug( $tag, "changing " + $offsetPlug + " to " + $angle );
		setAttr $offsetPlug $angle;
	}
}

/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Fur->Update Fur Maps menu item
//
/////////////////////////////////////////////////////////////////////////////

global proc HfUpdateFurMaps()
{
	global string	$HfHairAttributes[];
	string $furDescList[] = `ls -type "FurDescription"`;
	for( $furDesc in $furDescList )
	{
		string $furMapAttr[];
		clear $furMapAttr;
		
		for( $attr in $HfHairAttributes)
		{
			$attr +="Map";
			$furMapAttr[size($furMapAttr)] = $furDesc+"."+$attr;
		}
		for ($mapAttr in $furMapAttr) 
		{	
			string	$mapSurfaces[], $mapNames[];
			int	$mapIndexes[];
			getMapped( $mapAttr, $mapSurfaces, $mapNames, $mapIndexes );
			
			int $i;
			for($i =0; $i<size($mapIndexes); $i++)
			{
				string $cmd = "setAttr -type \"string\" "+$mapAttr+"["+$mapIndexes[$i]+"] "+"\""+$mapNames[$i]+"\"";
				eval $cmd;
			}
		}
	}	
}


/////////////////////////////////////////////////////////////////////////////
//
// Support for various types of select menu items
//
/////////////////////////////////////////////////////////////////////////////

proc selectList(
	string	$list[]
)
{
	string	$l;

	select -clear;
	for ( $l in $list ) {
		select -add $l;
	}
}

global proc HfSelectAttached(
	string	$hs
)
{
	string	$members[];
	string	$m;
	int		$multiIndexes[];

	getHairSetMembers( $hs, $members, $multiIndexes );
	selectList( $members );
}

global proc HfSelectAttachedHDSubMenu(
	string	$mi
)
{
	string $ann = (uiRes("m_FurPluginCreateUI.kSelFurDescAttachSurfAnnot"));
	createHDSubMenu(
		$mi, "HfSelectAttached", $ann,
		false, "", "", ""
	);
}

global proc HfSelectAttachedASSubMenu(
	string	$mi
)
{
	string $ann = (uiRes("m_FurPluginCreateUI.kSelAttrSetSurfAnnot"));
	createASSubMenu(
		$mi, "HfSelectAttached", $ann,
		false, ""
	);
}

global proc HfSelectAttractors(
	string	$as
)
{
	string	$attractors[];
	string	$grp;
	int		$a;

	getAttractorsFromAS( $attractors, $as, 0 );
	for ( $a = 0; $a < size( $attractors ); $a++ ) {
		// if this attractor is part of an attractor group
		// select that instead
		//
		$grp = getAttractorGrp( $attractors[$a] );
		if ( $grp != "" ) {
			$attractors[$a] = $grp;
		}
	}
	selectList( $attractors );
}

global proc HfSelectAttractorsASSubMenu(
	string	$mi
)
{
	string $ann = (uiRes("m_FurPluginCreateUI.kSelAttrSetAnnot"));
	createASSubMenu(
		$mi, "HfSelectAttractors", $ann,
		false, ""
	);
}

global proc string HfGetReferenceFile(string $shapeName)
{
	string $refFile = `reference -q -f $shapeName`;
	string $result;
	if(size($refFile) != 0)
	{
		//Find referenced file name
		string $refPath[];
		int $numTokens = `tokenize $refFile "/" $refPath`;
		string $filePath[];
		string $refName;
		$numTokens = `tokenize $refPath[size($refPath)-1] "." $filePath`;
		int $count ;
		for( $count =0; $count < size($filePath)-1; $count++ )
		{
			$refName += $filePath[$count];
			if( $count != size($filePath)-2 )
			{
				$refName += ".";
			}
		}
		$result = $refName;
	}
	return $result;
}

global proc string HfGetFileName(string $refFile)
{
	string $result;
	if(size($refFile) != 0)
	{
		//Find referenced file name
		string $refPath[];
		int $numTokens = `tokenize $refFile "/" $refPath`;
		string $filePath[];
		string $refName;
		$numTokens = `tokenize $refPath[size($refPath)-1] "." $filePath`;
		int $count ;
		for( $count =0; $count < size($filePath)-1; $count++ )
		{
			$refName += $filePath[$count];
			if( $count != size($filePath)-2 )
			{
				$refName += ".";
			}
		}
		$result = $refName;
	}
	return $result;
}

global proc string HfGetReferenceSurface(string $shapeName)
{
	string $refFile = `reference -q -f $shapeName`;
	string $refName = HfGetReferenceFile($shapeName);
	string $result; 
	
	//Get name space
	string $nameSpace;
	$nameSpace = `file -q -ns $refFile`;

	//Get proper surface name
	$shapeName= `substitute $nameSpace $shapeName $refName`;
	string $plug[]; 
	$numTokens = `tokenize $shapeName ":" $plug`;	

	if(size($plug) > 1)
	{
		int $isNameSpace = false;
		int $count = 0;
		for($count = 0; $count <size($plug); $count++)
		{
			if($plug[$count] == $refName)
			{
				$isNameSpace = true;
				$result = $plug[$count];					
			}
			else if($isNameSpace == true)
			{
				$result += $plug[$count];
			}
			if($count != size($plug)-1)
			{
				$result +="_";
			}
		}
	}
	else
	{
		$result = $shapeName;
	}

	$result= replaceCharacterInString($result, "|","_");			
	return $result; 
}
global proc string HfGetReferenceSurfaceBatch(string $shapeName)
{
	string $result;
	int $isReferenced = false;
	global int $gHfMayaState;

	int $isSurfaceFound = false;
	int $isNameSpaceFound = false;
	string $userDefinedAttrList[] = `listAttr -ud $shapeName`;
	for( $userDefinedAttr in $userDefinedAttrList )
	{
		if($userDefinedAttr == "surfaceReference")
		{
			 $isSurfaceFound = true;
		}
		if($userDefinedAttr == "furNameSpace")
		{
			 $isNameSpaceFound = true;
		}

	} 
	if( $gHfMayaState == 1 && $isSurfaceFound)
	{
		if(`getAttr ($shapeName+".surfaceReference")` == true )
		{
			$isReferenced = true;
		}
		else
		{
			$result = $shapeName;
		}
	}
	else
	{
		$result = $shapeName;
	}

	if($isReferenced == true)
	{
		//Get referenced file
		string $refFile;
		string $refName;
		$refFile = `getAttr ($shapeName+".referenceFile")`;
		$refName = HfGetFileName($refFile);

		//Get name space
		string $nameSpace;
		if($isNameSpaceFound)
		{
			$nameSpace = `getAttr ($shapeName+".furNameSpace")`;
		}
		else
		{
			string $refFile = `reference -q -f $shapeName`;
		        $nameSpace = `file -q -ns $refFile`;
		}		
		//Get proper surface name
		$shapeName= `substitute $nameSpace $shapeName $refName`;
		string $plug[]; 
		$numTokens = `tokenize $shapeName ":" $plug`;	

		if(size($plug) > 1)
		{
			int $isNameSpace = false;
			int $count = 0;
			for($count = 0; $count <size($plug); $count++)
			{
				if($plug[$count] == $refName)
				{
					$isNameSpace = true;
					$result = $plug[$count];					
				}
				else if($isNameSpace == true)
				{
					$result += $plug[$count];
				}
				if($count != size($plug)-1)
				{
					$result +="_";
				}
			}
		}
		else
		{
			$result = $shapeName;
		}
	}

	$result= replaceCharacterInString($result, "|","_");			
	return $result; 
}

global proc string[] HfDetachCurvesFromFur(string $hairsys)
{
	string $furDescriptions[];	
	if($hairsys=="") {
		 return $furDescriptions;
	}
	string $curveAttrs[] = `listConnections -shapes true -type "FurCurveAttractors" $hairsys`;
	if( size($curveAttrs) == 1 )
	{
		string $furFeedback[] = `listConnections -shapes true -type "FurFeedback" ($curveAttrs[0]+".CurveAttractorModel")`;				
		for($feedback in $furFeedback)
		{
			string $furDes[] = `listConnections -shapes true -type "FurDescription" ($feedback+".Length")`;
			$furDescriptions[size($furDescriptions)] = $furDes[0];
		}
	        if( size($furDescriptions) > 0 )
		{
	            for ($i = 0; $i < size($furDescriptions); $i++)
	        	{
				string $command = "detachHStoFD ";
		        	$command = ($command 
			        	+ $furDescriptions[$i] 
			        	+ " "
			        	+ $hairsys
			        	+ " ;");
			   	 catch( eval($command) );
	        	}	        
		}
	}
	return $furDescriptions;	
}

global proc HfAttachHairSystemToFur(string $hairsys, string $furDescriptions[])
{
	if( size($furDescriptions) > 0 )
	{
	    	for ($i = 0; $i < size($furDescriptions); $i++)
	    	{
			string $command = "assignHStoFD ";
			$command = ($command 
			    + $furDescriptions[$i] 
			    + " "
			    + $hairsys
			    + " ;");
		     	catch( eval($command) );
	    	}	        
	}
}

//
//
//  Description:
//      Create UI components for Maya Fur plugin
////  Input Arguments:
//
//  Return Value:
//      None.
//
/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Paint Hair Attributes Tool Menu
//
/////////////////////////////////////////////////////////////////////////////

source "artUserPaintProperties.mel" ;

addDebugTag("HairPaintTool");

global int		$HfCurHairAttr;
global string	$HfCurHairPaintContext;

$HfCurHairAttr = 0;
$HfCurHairPaintContext = "";

// list of surface shapes that were active during tool activation
//
global string	$HfPossiblyPaintedSurfaces[];

clear( $HfPossiblyPaintedSurfaces );

proc int numOfPaintableAttrs()
{
	global string	$HfHairPaintAttrUiName[];

	return size($HfHairPaintAttrUiName);
}

proc setCurrentAttrIndex(
	int		$newIndex
)
{
	global int		$HfCurHairAttr;

	$HfCurHairAttr = $newIndex;
}

proc int getCurrentAttrIndex()
{
	global int		$HfCurHairAttr;

	return $HfCurHairAttr;
}

proc string baseAttrNameByIndex(
	int	$i
)
{
	global string	$HfHairPaintAttr[];

	if ( $i >= 0 && $i < numOfPaintableAttrs() ) {
		return $HfHairPaintAttr[$i];
	} else {
		return "";
	}
}

proc string baseAttrName()
{
	global int		$HfCurHairAttr;

	return baseAttrNameByIndex($HfCurHairAttr);
}

proc string baseDirAttrNameByIndex(
	int	$i
)
{
	global string	$HfHairPaintDirAttr[];

	if ( $i >= 0 && $i < numOfPaintableAttrs() ) {
		return $HfHairPaintDirAttr[$i];
	} else {
		return "";
	}
}

proc string baseDirAttrName()
{
	global int		$HfCurHairAttr;

	return baseDirAttrNameByIndex($HfCurHairAttr);
}

proc string uiAttrNameByIndex(
	int		$i
)
{
	global string	$HfHairPaintAttrUiName[];

	if ( $i >= 0 && $i < numOfPaintableAttrs() ) {
		return $HfHairPaintAttrUiName[$i];
	} else {
		return "";
	}
}

proc string uiAttrName()
{
	global int		$HfCurHairAttr;

	return uiAttrNameByIndex($HfCurHairAttr);
}

global proc HfCheckCustomEqualizerMaps( int $isFileOpened, int $oldMethod)
{
	string $hairGlobal = HfBuildHairGlobal();
	string $cmd = "getAttr " + $hairGlobal + ".equalMap";
	int $val = `eval $cmd`;
	
	if($val == 2 && !$isFileOpened && !`inBatchMode`)
	{
		if( $oldMethod )  // If file is from < 6.5 version popup Select Equalizer dialog.
		{
			HfSelectEqualizer_OldScene();
		}		
	}

	if($val == 3) // If it is 3(old custom equalizer) change it to 2(New Custom Equalizer) for old scene file
	{
		$cmd = "setAttr " + $hairGlobal + ".equalMap 2";
		eval $cmd;
	        return;
	}
	
	$cmd = "getAttr " + $hairGlobal + ".equalMap";
	if(`eval $cmd` < 2 ) // If user selected Default Equalizer Map , return from here.
	{
		return;
	}
	
	$cmd = "setAttr " + $hairGlobal + ".equalMap 2";
	eval $cmd;
		
	// Check Project Directory
	HfCheckProjectDir;

	// Dim control for Custom Equalizer attribute
	HfDimCustomEqualizer(false);

	//Find default Equalizer map directory 
	string $strEqualMap = HfGetSceneName();
	string $eqMapPath = getTheProjectDir()+"/";
	$eqMapPath += getProjectDir("fileRule", "furEqualMap")	+ "/" + $strEqualMap;	
	
	//Generate equal map
	buildFurImages -ce $eqMapPath 0 $isFileOpened;
	HfCopyDeleteCustomEqualizer;
	
	ProcessStatus(10);

	CompleteProgress();
	print(uiRes("m_FurPluginCreateUI.kMayaFurRenderer"));

}
proc int hfCheckAttractors()
{
	string	$attractorSets[], $selected[];

	getSelectedSurfaceShapes( $selected );
	if ( size( $selected ) == 0 ) {
		clear( $attractorSets );
		return 1;
	}

	getAllAttractorSets( $attractorSets, true );

	if( size($attractorSets) == 0 )
	{
		string $msg = (uiRes("m_FurPluginCreateUI.kAttractorSetMessage"));
		string $ok = (uiRes("m_FurPluginCreateUI.kOk"));
		string $title = (uiRes("m_FurPluginCreateUI.kAttractorSetTitle"));
		string $result = `confirmDialog -title $title
			-message $msg -ma "left"
			-button $ok -defaultButton $ok 
			-cancelButton $ok
			-dismissString $ok`;
		return 1;
	}
	return 0;
}

proc int hfCheckCurveAttractors()
{
	string	$curveAttractorSets[], $selected[];

	getSelectedSurfaceShapes( $selected );
	if ( size( $selected ) == 0 ) {		
		clear( $curveAttractorSets );
		return 1;
	}

	getAllCurveAttractorSets($curveAttractorSets, true);
	
	if( size($curveAttractorSets) == 0 )
	{
		string $msg = (uiRes("m_FurPluginCreateUI.kCurveAttractorSetMessage"));

		string $title = (uiRes("m_FurPluginCreateUI.kCurveAttractorSetTitle")) ;
		string $ok = (uiRes("m_FurPluginCreateUI.kOk"));
		string $result = `confirmDialog -title $title
			-message $msg -ma "left"
			-button $ok -defaultButton $ok 
			-cancelButton $ok
			-dismissString $ok`;
		return 1;
	}
	return 0;
}

global proc HfUpdateHairPaintAttr(
	string	$attrName,
	string	$context
)
{
	int				$opt, $numOpt, $prevHairAttr, $result, $curveResult;

	$prevHairAttr = getCurrentAttrIndex();
	HfTDebug("HairPaintTool", "Previous Fur Attr  " + $prevHairAttr);
	
	$numOpt = numOfPaintableAttrs();
	for ( $opt = 0; $opt < $numOpt; ++$opt ) {
		if ( $attrName == uiAttrNameByIndex($opt) ) {
			HfTDebug("HairPaintTool", "Current Fur attribute changed from "
				    + uiAttrName() + " to " + $attrName);
			
			if( $attrName == "Custom Equalizer" )
			{
				string $hairGlobal = HfBuildHairGlobal();
				string $cmd = "setAttr " + $hairGlobal + ".equalMap 2";
				eval $cmd;
				HfCheckCustomEqualizerMaps(true, false);
			}
			else if( $attrName == "Attractor Radius" ||
					 $attrName == "Attractor Power" ||
					 $attrName == "Attractor Influence" ||
					 $attrName == "Attractor Start Length" ||
					 $attrName == "Attractor End Length" ||
					 $attrName == "Attractor Threshold Length" )
			{
				$result = hfCheckAttractors();
			}
			else if( $attrName == "Radius" ||
					 $attrName == "Power" ||
					 $attrName == "Influence" ||
					 $attrName == "Start Length" ||
					 $attrName == "End Length" ||
					 $attrName == "Threshold Length" )
			{
				$curveResult = hfCheckCurveAttractors();
			}
			setCurrentAttrIndex( $opt );
			HfCreateMaps;

			// the following lines will make sure that the tool will call HfGetHairPaintAttr
			// again
			// - calls to userPaintCtx have to be couched in eval's since the
			//   command may not exist when this script is interpreted
			//
			eval ( "artUserPaintCtx -e -gac \"\" " + $context );
			eval ( "artUserPaintCtx -e -gac \"HfGetHairPaintAttr\" " + $context );

			// update the tool setting editor
			if( `window -ex HfPaintHairAttrSettingsWindow` ) 
			{
				optionMenuGrp -e -sl (getCurrentAttrIndex() + 1) hairAttrMenu;
			}
		}
	}

	if ( $result ) {
		
		string $prevAttrName = `uiAttrNameByIndex($prevHairAttr)`;
		
		if(	 $prevAttrName == "Attractor Radius" ||
			 $prevAttrName == "Attractor Power" ||
			 $prevAttrName == "Attractor Influence" ||
			 $prevAttrName == "Attractor Start Length" ||
			 $prevAttrName == "Attractor End Length" ||
			 $prevAttrName == "Attractor Threshold Length" )
		{
			setCurrentAttrIndex(0);
		}
		else
		{
			setCurrentAttrIndex( $prevHairAttr );
		}
		// update the tool setting editor
		if( `window -ex HfPaintHairAttrSettingsWindow` ) 
		{
			optionMenuGrp -e -sl (getCurrentAttrIndex() + 1) hairAttrMenu;
		}
	}

	if ( $curveResult ) {
		
		string $prevAttrName = `uiAttrNameByIndex($prevHairAttr)`;
		
		if(	 $prevAttrName == "Radius" ||
			 $prevAttrName == "Power" ||
			 $prevAttrName == "Influence" ||
			 $prevAttrName == "Start Length" ||
			 $prevAttrName == "End Length" ||
			 $prevAttrName == "Threshold Length" )
		{
			setCurrentAttrIndex(0);
		}
		else
		{
			setCurrentAttrIndex( $prevHairAttr );
		}
		// update the tool setting editor
		if( `window -ex HfPaintHairAttrSettingsWindow` ) 
		{
			optionMenuGrp -e -sl (getCurrentAttrIndex() + 1) hairAttrMenu;
		}
	}
	
	if(`window -ex HfPaintHairAttrSettingsWindow`)
	{
		int $index =  getCurrentAttrIndex();
		string $attrMap = uiAttrNameByIndex($index);
		if($attrMap == "Attractor Radius" ||
			$attrMap == "Attractor Power" ||
			$attrMap == "Attractor Influence" ||
			$attrMap == "Attractor Start Length" ||
			$attrMap == "Attractor End Length" ||
			$attrMap == "Attractor Threshold Length" ||
			$attrMap == "Radius" ||
			$attrMap == "Power" ||
			$attrMap == "Influence" ||
			$attrMap == "Start Length" ||
			$attrMap == "End Length" ||
			$attrMap == "Threshold Length" )
		{
			optionMenuGrp -e -en false hairDescMenu;
			optionMenuGrp -e -en true attrSetMenu;
		}
		else
		{
			optionMenuGrp -e -en true hairDescMenu;
			optionMenuGrp -e -en false attrSetMenu;
		}
	}
}

global proc HfUpdateHairPaintDesc(
	string	$optionMenu,
	string	$context
)
{
	string	$tag="HairPaintTool";
	HfTDebug( $tag, "creating maps ");
	HfCreateMaps;
	eval ( "artUserPaintCtx -e -gac \"\" " + "furPaintContext" );
	eval ( "artUserPaintCtx -e -gac \"HfGetHairPaintAttr\" " + "furPaintContext" );

	//Update exportMap Width/Height
	string	$hairDesc = `optionMenuGrp -q -value $optionMenu`;
	if($hairDesc == "None")
	{
	   intFieldGrp -e -value1 0 exportWidthField;
	   intFieldGrp -e -value1 0 exportHeightField;		  
	}
	
	if ( $hairDesc == "Mixed" )
	{  
	   int $attrCheck = false;
	   HfUpdateHairPaintMap ( $optionMenu, $context, $attrCheck );
	}
	else
	{
	   connectControl -index 2 exportWidthField ($hairDesc+".exportWidth");
	   connectControl -index 2 exportHeightField ($hairDesc+".exportHeight"); 
	}
}

global proc HfUpdateHairPaintAttrSet(
	string	$optionMenu,
	string	$context
)
{
	string	$tag="HairPaintTool";
	int		$selected = `optionMenuGrp -q -select $optionMenu`;

	// the first entry is the Mixed placeholder, so don't do anything unless selected
	// is greater than that
	//
	if ( $selected > 1 ) {
		// switch attractor feedback on all selected surfaces
		//
		string	$attrSet = `optionMenuGrp -q -value $optionMenu`;
		if(`nodeType $attrSet` == "FurAttractors") {
			HfTDebug( $tag, "switching feedback to attr set " + $attrSet );
			HfConnectASToHF( $attrSet );
		}
	} else {
		HfPaintHairAttrCheck( $context );
	}
}

global proc HfCreateMaps()
{
 	string	$tag = "maps";
	string	$selected[];
	string	$attrName;

	// if the current context is a artUserPaintCtx
	// and color feedback is on, turn it off while 
	// we do this and then turn it back on afterwards
	// so that color feedback will re-initialize
	//
	string	$context=`currentCtx`;
	string	$ctxClass=`contextInfo -class $context`;
	int		$colorFeedbackDisabled = false;

	if ( $ctxClass == "artUserPaint" ) {
		int	$cf=`eval( "artUserPaintCtx -q -cf " + $context )`;

		if ( $cf ) {
			eval( "artUserPaintCtx -e -cf false " + $context );
			$colorFeedbackDisabled = true;
		}
	}

	getSelectedSurfaceShapes( $selected );
	$attrName=baseAttrName();
	if ( $attrName != "" ) {
		HfTDebug($tag,"HfCreateMaps calling setMapNamesForSurfaces for " + $attrName);
		setMapNamesForSurfaces( $selected, $attrName );
	}
	$attrName=baseDirAttrName();
	if ( $attrName != "" ) {
		HfTDebug($tag,"HfCreateMaps calling setMapNamesForSurfaces for " + $attrName);
		setMapNamesForSurfaces( $selected, $attrName );
	}

	string			$s, $pps;
	global string	$HfPossiblyPaintedSurfaces[];
	global string	$HfFeedbackAttributes[];

	// make sure these surfaces are in the list of possibly painted surfaces
	//
	for ( $s in $selected ) {
		int	$found = 0;

		for ( $pps in $HfPossiblyPaintedSurfaces ) {
			if ( $s == $pps ) {
				$found = 1;
				break;
			} 
		}	
		if ( ! $found ) {
			HfTDebug($tag,"HfCreateMaps adding " + $s + " as possibly painted surface");
			$HfPossiblyPaintedSurfaces[size($HfPossiblyPaintedSurfaces)] = $s;

			// reset all dirty plugs for feedback node on surface
			//
			string $hairDesc;
			string $feedback;

			if(`optionMenuGrp -q -ex hairDescMenu` && `optionMenuGrp -q -numberOfItems hairDescMenu` != 0)
				$hairDesc = `optionMenuGrp -q -value hairDescMenu`;
			if( size($hairDesc) != 0 && $hairDesc != "None" )
				$feedback = getFurFeedbackNode( $s,$hairDesc);
			
			if(size($feedback) == 0)
			{
				$feedback = getHairFeedbackNode( $s );
			}

			if ( $feedback != "" ) {
				int		$numFeedbackAttrs = size($HfFeedbackAttributes);
				int		$n;

				for ( $n = 0; $n < $numFeedbackAttrs; $n++ ) {
					string	$dirtyPlug = $feedback + "."
									   + feedbackSamplesDirtyAttr( $HfFeedbackAttributes[$n] );
		
					setAttr $dirtyPlug 0;
				}
			}
		}
	}

	// re-enable color feedback if it was turned off
	//
	if ( $colorFeedbackDisabled ) {
		eval( "artUserPaintCtx -e -cf true " + $context );
	}
}

global proc string[] HfGetExportMapsName()
{
	string $surfaces[] = `ls -type nurbsSurface -type mesh -type subdiv`;
	return exportDirtyMapsName( $surfaces );
}

global proc HfExportMaps()
{
	string	$surfaces[] = `ls -type nurbsSurface -type mesh -type subdiv`;

	exportDirtyMaps( $surfaces );
}

proc rebuildHairPaintOptionMenu(
	string	$menuName,
	string	$menuItemName,
	string	$entries[],
	string	$activeEntries[]
)
{
	string	$tag="HairPaintTool";

	HfTDebug($tag,"rebuilding " + $menuName);

	// add existing hair descriptions to the place into menu
	//
	int		$nItems = `optionMenuGrp -q -ni $menuName`;
	int		$i;

	// get rid of any that are there
	//
	HfTDebug($tag,"deleting " + $menuName + ": " + $nItems + " items");
	for ( $i = 0; $i < $nItems; $i++ ) {
		HfTDebug($tag, " deleting " + $menuItemName+$i);
		deleteUI ($menuItemName+$i);
	}

	string	$savedParent = `setParent -q`;
	string	$fullName = `setParent $menuName`;

	$i = 0;
	setParent -menu ($fullName + "|OptionMenu");
	if ( size( $entries ) > 0 ) {
		string	$e;

		if ( size( $activeEntries ) == 0 ) {
			menuItem -label (uiRes("m_FurPluginCreateUI.kHairPaintOptionMenuNone")) ($menuItemName+$i);
			$i++;
		} 
		for ( $e in $entries ) {
			HfTDebug($tag, " adding " + $e + ":" + $menuItemName+$i);
			menuItem -label $e ($menuItemName+$i);
			$i++;
		}
	} else {
		menuItem -label (uiRes("m_FurPluginCreateUI.kHairPaintOptMenuNone")) ($menuItemName+$i);
	}
	setParent $savedParent;

	if ( size( $activeEntries ) == 1 ) {
		HfTDebug($tag, " select item " + $activeEntries[0]);
		optionMenuGrp -e -v $activeEntries[0] $menuName;
	} else {
		HfTDebug($tag, " # of active entries = " + size( $activeEntries ) );
		optionMenuGrp -e -sl 1 $menuName;
	}
	eval ( "artUserPaintCtx -e -gac \"\" " + "furPaintContext" );
	eval ( "artUserPaintCtx -e -gac \"HfGetHairPaintAttr\" " + "furPaintContext" );
}

global proc HfHairPaintFeedbackCB()
{
	global string	$HfCurHairPaintContext;

	if ( $HfCurHairPaintContext != "" ) {
		HfPaintHairAttrCheck( $HfCurHairPaintContext );
	}
}

global proc HfPaintHairAttrCheck(
	string	$context
)
{
	string	$tag="HairPaintTool";

	// make sure everything is setup for painting
	//
	HfUpdateHairPaintAttr( uiAttrName(), $context );

	// need to be in texture paint mode (as opposed to projective paint mode)
	//
	//"painttype" command is not supported in the New Artisan architecture.
	//	eval ( "userPaintCtx -e -painttype \"forceTexture\" " + $context );


	// the rest of this doesn't need to be done if there is
	
	if ( ! `window -ex HfPaintHairAttrSettingsWindow` ) {
		return;
	}

	setParent HfPaintHairAttrSettingsWindow;

	// try to determine current hair description and attractor set
	//
	string	$selected[];
	string	$s;
	string	$hairDescs[];
	string	$attrSets[];
	int		$numHD = 0;
	int		$numAS = 0;
	string	$hairDescriptions[];

	getSelectedSurfaceShapes( $selected );
	HfTDebug($tag,"determining hair description from " + size( $selected ) + " selected surfaces");

	string $hairDesc;
	 if(`optionMenuGrp -q -ex hairDescMenu` && `optionMenuGrp -q -numberOfItems hairDescMenu` != 0)
		$hairDesc = `optionMenuGrp -q -value hairDescMenu`;

	for ( $s in $selected ) {
		string $feedback;
		if( size($hairDesc) != 0 && $hairDesc != "None" )
		      $feedback = getFurFeedbackNode( $s,$hairDesc );
		if(size($feedback) ==0)
		{
			$feedback = getHairFeedbackNode( $s );
		}		

		HfTDebug($tag, " feedback for \"" + $s + "\" is \"" + $feedback + "\"");
		if ( $feedback != "" ) {

			string $connections[] = `listConnections -type FurDescription $s`; 
			string $hairDesc = getHairDescFromFeedback( $feedback );
			HfTDebug($tag, " hairDesc for \"" + $feedback + "\" is \"" + $hairDesc + "\"");

			if ( $hairDesc != "" ) {
				int	$hd;

				for ( $hd = 0; $hd < $numHD; $hd++ ) {
					if ( $hairDesc == $hairDescs[$hd] ) {
						break;
					}
					}
				if ( $hd == $numHD ) {
					HfTDebug($tag, " adding " + $hairDesc + " at entry " + $numHD);
					$hairDescs[$numHD] = $hairDesc;
					$numHD++;
				}
			}

			string $attrSet = getAttractorSetFromFeedback( $feedback );
			HfTDebug($tag, " attrSet for \"" + $feedback + "\" is \"" + $attrSet + "\"");

			if ( $attrSet != "" ) {
				int	$as;

				for ( $as = 0; $as < $numAS; $as++ ) {
					if ( $attrSet == $attrSets[$as] ) {
						break;
					}
				}
				if ( $as == $numAS ) {
					HfTDebug($tag, " adding " + $attrSet + " at entry " + $numAS);
					$attrSets[$numAS] = $attrSet;
					$numAS++;
				}
			}
			string $curveAttrSet = getCurveAttractorSetFromFeedback( $feedback );
			if ( $curveAttrSet != "" ) {
				int	$as;

				for ( $as = 0; $as < $numAS; $as++ ) {
					if ( $attrSet == $attrSets[$as] ) {
						break;
					}
				}
				if ( $as == $numAS ) {
					HfTDebug($tag, " adding " + $attrSet + " at entry " + $numAS);
					$attrSets[$numAS] = $curveAttrSet;
					$numAS++;
				}
			}			
			feedbackAttractorSetPlug( $feedback );

			for($con in $connections){				
				$hairDescriptions[size($hairDescriptions)] = $con;
			}
		}
	}
	
	string	$attractorSets[];
	string  $curveAttractorSets[];
	
	$hairDescriptions = stringArrayRemoveDuplicates($hairDescriptions);

	getAllAttractorSets( $attractorSets, false );
	getAllCurveAttractorSets($curveAttractorSets, false);

	appendStringArray($attractorSets, $curveAttractorSets, size($curveAttractorSets));

	rebuildHairPaintOptionMenu(
		"hairDescMenu", "hdItem", $hairDescriptions, $hairDescs
	);
	rebuildHairPaintOptionMenu(
		"attrSetMenu", "asItem", $attractorSets, $attrSets
	);

	//Update exportMap Width/Height
	string $hairDesc;
	$hairDesc = `optionMenuGrp -q -value hairDescMenu`;
	if($hairDesc == "None")
	{
	   intFieldGrp -e -value1 0  exportWidthField;
	   intFieldGrp -e -value1 0  exportHeightField; 
	}

	if ( $hairDesc == "Mixed" )
	{  
	   int $attrCheck = true; 
	   HfUpdateHairPaintMap ( "hairDescMenu", $context, $attrCheck );
	}
	else
	{
	   connectControl -index 2 exportWidthField ($hairDesc+".exportWidth");
	   connectControl -index 2 exportHeightField ($hairDesc+".exportHeight");
	    
	}
}


global proc HfHairPaintToolSelected(
	string	$context
)
{
	global string	$HfCurHairPaintContext;
	global string	$HfPossiblyPaintedSurfaces[];

	//While entering into the Tool, making all attributes as unpaintable
	makePaintable -activateAll false;

	$HfCurHairPaintContext = $context;
	clear( $HfPossiblyPaintedSurfaces );

	int				$numOpt, $opt;

 	HfTDebug("HairPaintTool", "Hair paint tool " + `currentCtx` + " has been selected");
  
  	if ( `window -ex HfPaintHairAttrSettingsWindow` ) {
  		deleteUI HfPaintHairAttrSettingsWindow;
  	}
  
  	setUITemplate -pushTemplate DefaultTemplate;
  	window -title (uiRes("m_FurPluginCreateUI.kPaintFurAttribTool")) HfPaintHairAttrSettingsWindow;
  	columnLayout -adj false -cal left;
  	
	optionMenuGrp -label (uiRes("m_FurPluginCreateUI.kFurAttribute")) -cal 1 right
		-cc ("HfUpdateHairPaintAttr \"#1\" " + $context)
		hairAttrMenu;
	$numOpt = numOfPaintableAttrs();
	for ( $opt = 0; $opt < $numOpt; ++$opt ) {
		menuItem -label `uiAttrNameByIndex($opt)`;
	}
	optionMenuGrp -e -sl (getCurrentAttrIndex() + 1) hairAttrMenu;
	
	string	$hdDescMenuName = `optionMenuGrp -label (uiRes("m_FurPluginCreateUI.kFurDescription")) -cal 1 right hairDescMenu`;
	optionMenuGrp -e -cc ("HfUpdateHairPaintDesc " + $hdDescMenuName + " " + $context)
		hairDescMenu;
	
	string	$asMenuName = `optionMenuGrp -label (uiRes("m_FurPluginCreateUI.kAttractorSet")) -cal 1 right attrSetMenu`;
	optionMenuGrp -e -cc ("HfUpdateHairPaintAttrSet " + $asMenuName + " " + $context)
		attrSetMenu;
	
	int $attrCheck = false;
	
	intFieldGrp -label (uiRes("m_FurPluginCreateUI.kAttributeMapWidth"))  -cal 1 right -numberOfFields 1 -cc ("HfUpdateHairPaintMap " + $hdDescMenuName + " " + $context + " "+ $attrCheck ) exportWidthField;
	
	intFieldGrp -label (uiRes("m_FurPluginCreateUI.kAttributeMapHeight")) -cal 1 right -numberOfFields 1 -cc ("HfUpdateHairPaintMap " + $hdDescMenuName + " " + $context + " "+ $attrCheck ) exportHeightField;
	
  	setParent ..;
  	showWindow;
  	setUITemplate -popTemplate;
  
  	// attach some script jobs to keep the dialog up to date
  	//
  	scriptJob -p HfPaintHairAttrSettingsWindow -e "SelectionChanged" ("HfPaintHairAttrCheck " + $context);
  	scriptJob -p HfPaintHairAttrSettingsWindow -dri -ac (getHairGlobalsProtectPlug(true))
						("HfPaintHairAttrCheck " + $context);

	// make sure everything is ready for painting
	//
	HfPaintHairAttrCheck( $context );
	HfCreateMaps();
}

global proc HfHairPaintToolDeselected(
	string	$context
)
{
	global string	$HfCurHairPaintContext;

	$HfCurHairPaintContext = "";

	HfTDebug("HairPaintTool", "Hair paint tool " + `currentCtx` + " has been un-selected");

	if ( `window -ex HfPaintHairAttrSettingsWindow` ) {
		deleteUI HfPaintHairAttrSettingsWindow;
	}
	
	global string	$HfPossiblyPaintedSurfaces[];

	string	$s;

	// update dirty map flags for any surface feedback attributes
	// that were dirtied during this tool session
	// - this has the side-effect of clearing out maps that were
	//   created but never modified during this use of the tool
	//
	for ( $s in $HfPossiblyPaintedSurfaces ) {
		updateDirtyMapsForSurface( $s );
	}
	clear( $HfPossiblyPaintedSurfaces );
	//While exiting from the Tool, making all attributes as unpaintable
	makePaintable -activateAll false;
}

global proc string HfGetHairPaintAttr(
	string	$name
)
{
	string $fullAttr = "";
	int $setWarningMsg = false;		
	if ( `nodeType $name` == "nurbsSurface"
	  || `nodeType $name` == "mesh"
	  || `nodeType $name` == "subdiv" ) {
		string $connections[];
		string $connection;

		string	$hairDescSelected;
		if(`optionMenuGrp -q -ex hairDescMenu` && `optionMenuGrp -q -numberOfItems hairDescMenu` != 0)
			$hairDescSelected = `optionMenuGrp -q -value hairDescMenu`;

		$connections = getFurFeedbackNodes($name);
		int $attributeAdd = false;
		int $testUsamples = -1;
		int $testVsamples = -1;
		for ( $connection in $connections ) {
			if ( $connection != "" && `nodeType $connection` == "FurFeedback" ) {
				string $hairDesc = getHairDescFromFeedback( $connection );
				string $baseAttr;
				if( $hairDescSelected !="" )
				{
					$baseAttr = baseAttrName();
					if ( $hairDesc != $hairDescSelected )
					{
						if( !( $baseAttr == "Radius" ||
							  $baseAttr == "Power" ||
							  $baseAttr == "Influence" ||
							  $baseAttr == "StartLength" ||
							  $baseAttr == "EndLength" ||
							  $baseAttr == "ThresholdLength" ||
							  $baseAttr == "CurveRadius" ||
							  $baseAttr == "CurvePower" ||
							  $baseAttr == "CurveInfluence" ||
							  $baseAttr == "CurveStartLength" ||
							  $baseAttr == "CurveEndLength" ||
							  $baseAttr == "CurveThresholdLength") )
						{
							continue;
						}
					}
						
				}
				string $plug = feedbackUSamplesPlug($connection);
				int $usamples = `getAttr $plug`;
				$plug = feedbackVSamplesPlug($connection);
				int $vsamples = `getAttr $plug`;
				string $dirAttr = baseDirAttrName();

				if ( $dirAttr != "" ) {
					$fullAttr += " -direction " + $connection
							   + "." + feedbackSamplesAttr($dirAttr);
				}
				if ( $baseAttr == "" ) {
					// paint the special Unused attribute on feedback node
					//
					$baseAttr="Unused";
					setAttr -type "string"
						($connection + "." + feedbackMapAttr( $baseAttr ))
						"UNNAMED";
				}

				if($attributeAdd == false)
				{
					$fullAttr += ( " -grid " + $usamples + " " + $vsamples + " " +
									 $connection + "." + feedbackSamplesAttr( $baseAttr ) );
					$testUsamples = $usamples;
					$testVsamples = $vsamples;
				}
				
				if($baseAttr == "Radius" ||
				   $baseAttr == "Power" ||
				   $baseAttr == "Influence" ||
				   $baseAttr == "StartLength" ||
				   $baseAttr == "EndLength" ||
				   $baseAttr == "ThresholdLength" ||
				   $baseAttr == "CurveRadius" ||
				   $baseAttr == "CurvePower" ||
				   $baseAttr == "CurveInfluence" ||
				   $baseAttr == "CurveStartLength" ||
				   $baseAttr == "CurveEndLength" ||
				   $baseAttr == "CurveThresholdLength"
				  )
				{
					if($attributeAdd == true)
					{
						$fullAttr +=  " " + $connection + "." + feedbackSamplesAttr( $baseAttr ) ;
						if( $setWarningMsg == false )
						{
							if($testUsamples != $usamples || $testVsamples != $vsamples)
									$setWarningMsg = true;					
						}
					}
					else
					{
						$attributeAdd = true;
					}
				}
				else
				{
					break;
				}
			}
		}
	}
	
	if($setWarningMsg)
	{
		warning((uiRes("m_FurPluginCreateUI.kSamplesWarning")));
	}

	HfTDebug("HairPaintTool", ("HfGetHairPaintAttr(" + $name + ") returns " + $fullAttr));
	return $fullAttr;
}

// This was copied from initContexts.mel
//
proc rememberCtxSettings( string $ctxName )
//
// This method sees if an optionVar has been defined
// for the tool.  If it has, the string it contains
// is evaluated to set the tool settings.  SuperContexts
// should not be saved this way, since they have no
// particular settings.
//
{
	if ( `optionVar -exists $ctxName` ){
		string $cmd = `optionVar -q $ctxName`;
		catch( `eval($cmd)` );
	} else {
		// create an empty option var so that this
		// will be saved.
		optionVar -sv $ctxName "";
	}
}

global proc HfPaintHairAttrTool(
	int		$showToolProperties
)
{
	// Pop error message if the operation is not appropriate 
	// (Bug 163391)

	string	$hairDescriptions[];
	getAllHairDescriptions( $hairDescriptions, true );
	if (size( $hairDescriptions ) <= 0){
		getAllFurFeedback( $hairDescriptions, true );
		if (size( $hairDescriptions ) <= 0){
			error ((uiRes("m_FurPluginCreateUI.kSelectSurfaceError")));
			return;
		}
	}

	global string $gHfPaintHairAttrToolCtx;

	if ( true || `isTrue "JasperExists"` ) { 
		// we have to couch all uses of userPaintCtx within eval's since
		// the userPaintCtx command may not exist when this script is
		// interpreted
		//
		if ( $gHfPaintHairAttrToolCtx == "" ) {
			$gHfPaintHairAttrToolCtx=`eval "artUserPaintCtx -i1 \"furPaint.png\" -cf false -dl true -fp true furPaintContext"`;
			rememberCtxSettings $gHfPaintHairAttrToolCtx;			
		}

		string	$cmd;

		$cmd  = "artUserPaintCtx -e";
		$cmd += " -tsc \"HfHairPaintToolSelected\"";
		$cmd += " -tcc \"HfHairPaintToolDeselected\"";
		$cmd += " -ic \"\" -fc \"\" -svc \"\" -gvc \"\" -cc \"\" -gsc \"\"";
		$cmd += " -gac \"HfGetHairPaintAttr\"";
		$cmd += "  -whichTool \"userPaint\"";
		$cmd +=	$gHfPaintHairAttrToolCtx;
		eval $cmd;

		setToolTo $gHfPaintHairAttrToolCtx;
		if ( $showToolProperties ) {
			toolPropertyWindow;
		}
	}
}

global proc HfUpdateHairPaintMap( string $optionMenu, string $context, int $attrCheck )
{
	string	$hairDesc = `optionMenuGrp -q -value $optionMenu`;
	
	if( $hairDesc == "Mixed" )
	{
	   string $evalCommandWidth  = "connectControl -index 2 exportWidthField ";
	   string $evalCommandHeight = "connectControl -index 2 exportHeightField ";
	   
	   //Get Selected Surface
	   string	$selectedSurfaces[];
	   getSelectedSurfaceShapes( $selectedSurfaces );

	   for($surface in $selectedSurfaces)
	   {
		  //Get Feedback node
		  string $feedbackNode; 	  
		  $feedbackNode = getHairFeedbackNode($surface);
		  
		  //Get FurDescription Node
		  string $hairDesc = getHairDescFromFeedback( $feedbackNode );
		  
		  $evalCommandWidth  += $hairDesc + ".exportWidth ";
		  $evalCommandHeight += $hairDesc + ".exportHeight ";
		  
		  if($attrCheck == true)
		  {
			 setAttr ($hairDesc + ".exportWidth") 256;
			 setAttr ($hairDesc + ".exportHeight") 256;
		  }
	   }
	   eval($evalCommandWidth);
	   eval($evalCommandHeight);
	}
}
/////////////////////////////////////////////////////////////////////////////
//
// These procedures control the attribute editor layout for the hair
// description node
//
/////////////////////////////////////////////////////////////////////////////


global proc string AEHairDescAssignedCell(
	string	$hairAttrPlug,
	int		$row,
	int		$col
)
{
	string	$cell;
	string	$assignedTo[];
	int		$multiIndexes[];

	getHairSetMembers( $hairAttrPlug, $assignedTo, $multiIndexes );

	if ( size( $assignedTo ) >= $row ) {
		$cell = $assignedTo[$row-1];
	} else {
		$cell = "";
	}
	HfTDebug ( "AEHairDescAssignedCell",
				("AEHairDescAssignedCell(" + $hairAttrPlug
				+ "," + $row + "," + $col
				+ ") returns " + $cell) ); 

	return $cell;
}

proc createBakeOptionMenu(
	string	$bakeAttrUiNames[]
)
{
	// create bake popup menu
	//
	rowLayout -nc 2 -cw 1 325 -cw 2 60 -cat 2 "right" 0;
	optionMenuGrp -label (uiRes("m_FurPluginCreateUI.kBakeAttribute")) bakeAttrMenu;
	menuItem -label (uiRes("m_FurPluginCreateUI.kBakeAttributeAll"));
	for ( $a = 0; $a < size($bakeAttrUiNames); $a++ ) {
		menuItem -label $bakeAttrUiNames[$a];
	}
	button -label (uiRes("m_FurPluginCreateUI.kBake")) bakeItBtn;
	setParent ..;
}

addDebugTag( "bakeAttrCB" );

proc bakeAttrCB(
	string	$bakeAttrNames[],
	string	$node,
	string	$parent
)
{
	setParent	$parent;

	string		$tag = "bakeAttrCB";
	int			$selected = `optionMenuGrp -q -sl bakeAttrMenu`;
	int			$numAttributes = size($bakeAttrNames);
	int			$dummy[];
	string			$dummyFiles[];

	if ( $selected == 1 ) {
		HfTDebug($tag,"bake all attributes on " + $node);

		for ( $selected = 0; $selected < $numAttributes; $selected++ ) {
			bakeMappedAttribute( $node, $bakeAttrNames[$selected], false, $dummy, $dummyFiles,$dummyFiles );
		}
	} else {
		$selected -= 2;

		if ( $selected >= 0 && $selected < $numAttributes ) {
			HfTDebug($tag,"baking " + $bakeAttrNames[$selected] + " on " + $node);
			bakeMappedAttribute( $node, $bakeAttrNames[$selected], false, $dummy, $dummyFiles,$dummyFiles );
		}
	}
}

addDebugTag( "AEHairDescGeneral" );

global proc AEHairDescBakeMenu()
{
	global string $HfHairAttrUiNames[];

	createBakeOptionMenu( $HfHairAttrUiNames );
}

global proc AEHairDescGeneralNew(
	string	$createBakeMenuCB,
	string	$bakeButtonCB,
	string	$messagePlug
)
{
	int	$a;

	HfTDebug( "AEHairDescGeneral",("in New(" + $messagePlug + ")") );

	// create a single column table with all surfaces that
	// have this hair description assigned to them
	//
    	separator -style "in";

	string $assignedSurfaces;
	string $nodeType = `nodeType $messagePlug`;
	if($nodeType == "FurDescription" ) 
		$assignedSurfaces = "furAssignedSurfaces";
	else if($nodeType == "FurCurveAttractors" )
		$assignedSurfaces = "curveAttractorAssignedSurfaces";
	else if($nodeType == "FurAttractors" )
		$assignedSurfaces = "furAttractorAssignedSurfaces";

	text -label (uiRes("m_FurPluginCreateUI.kAssignedSurfaces")) ;
	textScrollList -ams false -nr 4 $assignedSurfaces;

	// create bake popup menu
	//
    	separator -style "in";
	eval $createBakeMenuCB;

	AEHairDescGeneralReplace( $bakeButtonCB, $messagePlug );
}

global proc HfFurGlobalCheckFurDescription(
	string	$node
)
{
	string $furGlobal[] = `ls -type "FurGlobals"`;
	if( size($furGlobal) == 0 )
	{
		HfDimCustomEqualizer(true);
	}
	else
	{
		int $equalType = `getAttr ("defaultFurGlobals.equalMap")`;
		if($equalType != 2)
		{
			editorTemplate -dimControl $node "CustomEqualizer" true;	
		}
		else
		{
			editorTemplate -dimControl $node "CustomEqualizer" false;	
		}
	}
}

global proc AEHairDescBakeButtonCB(
	string	$node,
	string	$parent
)
{
	global string $HfHairAttributes[];

	bakeAttrCB( $HfHairAttributes, $node, $parent );
}

global proc AEHairDescGeneralReplace(
	string	$bakeButtonCB,
	string	$messagePlug
)
{
	HfTDebug( "AEHairDescGeneral",("in Replace(" + $messagePlug + ")") );

	string	$assignedTo[];
	string	$a;
	int		$multiIndexes[];
	string	$parent = `setParent -q`;

	string $assignedSurfaces;
	string $nodeType = `nodeType $messagePlug`;
	if($nodeType == "FurDescription" ) 
		$assignedSurfaces = "furAssignedSurfaces";
	else if($nodeType == "FurCurveAttractors" )
		$assignedSurfaces = "curveAttractorAssignedSurfaces";
	else if($nodeType == "FurAttractors" )
		$assignedSurfaces = "furAttractorAssignedSurfaces";

	getHairSetMembers( $messagePlug, $assignedTo, $multiIndexes );
	textScrollList -e -removeAll $assignedSurfaces;
	for ( $a in $assignedTo ) {
		string	$aa = $a;

		if ( `nodeType $aa` != "transform" ) {
			string $parent[] =`listRelatives -p -pa $aa`;
			$aa=$parent[0];
		}
		textScrollList -e -append $aa $assignedSurfaces;
	}
	textScrollList -e -deselectAll $assignedSurfaces;
	
	button -e -command
        ($bakeButtonCB + " " + plugNode( $messagePlug ) + " " + $parent) bakeItBtn;
}

addDebugTag( "AEHairDescGetCell" );

global proc string AEHairDescGetCell(
	string	$hairAttrPlug,
	int		$row,
	int		$col
)
{
	string	$cell;
	string	$mapSurfaces[], $mapNames[];
	int		$mapIndexes[];

	getMapped( $hairAttrPlug, $mapSurfaces, $mapNames, $mapIndexes );
	if ( size( $mapSurfaces ) >= $row ) {
		if ( $col == 1 ) {
			$cell = plugNode($mapSurfaces[$row-1]);
		} else {
			$cell = $mapNames[$row-1];
		}
	} else {
		$cell = "";
	}
	HfTDebug( "AEHairDescGetCell",
				( "AEHairDescGetCell(" + $hairAttrPlug
				+ "," + $row + "," + $col
				+ ") returns " + $cell) ); 

	return $cell;
}

addDebugTag( "AEHairDescCellChanged" );

global proc int AEHairDescCellChanged(
	string	$hairAttrMapPlug,
	string  $custom,
	string	$parent,
	int		$row,
	int		$col,
	string	$contents
)
{
	string	$tag = "AEHairDescCellChanged";

	HfTDebug( $tag,
				( "AEHairDescCellChanged(" + $hairAttrMapPlug
				+ "," + $row + "," + $col + "," + $contents
				+ ") called" ) ); 

	int		 $accept = false;

	if ( $col == 2 ) {
		string	$cell;
		string	$mapSurfaces[], $mapNames[];
		int		$mapIndexes[];

		getMapped( $hairAttrMapPlug, $mapSurfaces, $mapNames, $mapIndexes );
		if ( $row <= size( $mapSurfaces ) ) {
			setMapFile(
				($hairAttrMapPlug + "[" + $mapIndexes[$row-1] + "]"),
				$contents );

			// this is being called from scriptTable so it is safest to do
			// a deferred eval of the scriptTable command that will be used
			// to update the table
			//
			string $updateCmd = "setParent " + $parent
							  + "; scriptTable -e";
			if ( size( $contents ) > 0 ) {
				$updateCmd += " -cr ";
			} else {
				$updateCmd += " -dr ";
			}
			if($custom == "Custom")
				$updateCmd += $row + " mappingTableCustom";
			else if ($custom == "CurvePower")
				$updateCmd += $row + " mappingTableCurvePower";
			else
				$updateCmd += $row + " mappingTable";
			evalDeferred $updateCmd;
			$accept = true;
		}
	}

	return $accept;
}

//addDebugTag( "AEHairDescMapNew" );

global proc AEHairDescMapNew(
	string	$hairAttr,
	string	$hairAttrMapPlug
)
{
	HfTDebug( "AEHairDescMapNew",("in AEHairDescMapNew(" + $hairAttr + "," + $hairAttrMapPlug + ")") );

	global int $gTextColumnWidthIndex;
	global int $gAESingleWidgetWidthIndex;

    separator -style "in";

	int	$buttonSize = ((3 * $gAESingleWidgetWidthIndex) / 2 );

    rowLayout -numberOfColumns 3 
		-cw 1 $gTextColumnWidthIndex 
		-cw 2 $buttonSize 
		-cw 3 $buttonSize
		-cal 1 "center" -cal 2 "center" -cal 3 "center"
		-cat 1 "right" 1 -cat 2 "both" 1 -cat 3 "both" 1;
        button -label (uiRes("m_FurPluginCreateUI.kHairDescMapNewAddItem")) -w $buttonSize addButton;
        button -label (uiRes("m_FurPluginCreateUI.kHairDescMapNewRemoveItem")) removeButton;
        button -label (uiRes("m_FurPluginCreateUI.kHairDescMapNewMapItem")) mapButton;
        setParent ..;

    separator -style "none";

	formLayout tableForm;
        scriptTable mappingTable;
		setParent ..;

    formLayout -e
        -height 75
        -af mappingTable top 0
        -af mappingTable left 0
        -af mappingTable bottom 0
        -af mappingTable right 0
        tableForm;

    separator -style "in";

	AEHairDescMapReplace( $hairAttr, $hairAttrMapPlug );
}

global proc AEHairDescMapCustomNew(
	string	$hairAttr,
	string	$hairAttrMapPlug
)
{
	HfCheckCustomEqual( $hairAttr, $hairAttrMapPlug);
	HfTDebug( "AEHairDescMapNew",("in AEHairDescMapNew(" + $hairAttr + "," + $hairAttrMapPlug + ")") );
	
	global int $gTextColumnWidthIndex;
	global int $gAESingleWidgetWidthIndex;

    separator -style "in";

	int	$buttonSize = ((3 * $gAESingleWidgetWidthIndex) / 2 );

    rowLayout -numberOfColumns 3 
		-cw 1 $gTextColumnWidthIndex 
		-cw 2 $buttonSize 
		-cw 3 $buttonSize
		-cal 1 "center" -cal 2 "center" -cal 3 "center"
		-cat 1 "right" 1 -cat 2 "both" 1 -cat 3 "both" 1;
        button -label (uiRes("m_FurPluginCreateUI.kHairDescMapCustNewAddItem")) -w $buttonSize addButtonCustom;
        button -label (uiRes("m_FurPluginCreateUI.kHairDescMapCustNewRemoveItem")) removeButtonCustom;
        button -label (uiRes("m_FurPluginCreateUI.kHairDescMapCustNewMapItem")) mapButtonCustom;
        setParent ..;

    separator -style "none";

	formLayout tableForm;
        scriptTable mappingTableCustom;
		setParent ..;

    formLayout -e
        -height 75
        -af mappingTableCustom top 0
        -af mappingTableCustom left 0
        -af mappingTableCustom bottom 0
        -af mappingTableCustom right 0
        tableForm;

    separator -style "in";

	AEHairDescMapCustomReplace( $hairAttr, $hairAttrMapPlug );
}

global proc AEHairDescMapCurvePowerNew(
	string	$hairAttr,
	string	$hairAttrMapPlug
)
{
	HfCheckCurvePower( $hairAttr, $hairAttrMapPlug);
	HfTDebug( "AEHairDescMapNew",("in AEHairDescMapNew(" + $hairAttr + "," + $hairAttrMapPlug + ")") );
	
	global int $gTextColumnWidthIndex;
	global int $gAESingleWidgetWidthIndex;

         separator -style "in";

	int	$buttonSize = ((3 * $gAESingleWidgetWidthIndex) / 2 );

    	rowLayout -numberOfColumns 3 
		-cw 1 $gTextColumnWidthIndex 
		-cw 2 $buttonSize 
		-cw 3 $buttonSize
		-cal 1 "center" -cal 2 "center" -cal 3 "center"
		-cat 1 "right" 1 -cat 2 "both" 1 -cat 3 "both" 1;
        button -label (uiRes("m_FurPluginCreateUI.kHairDescMapCrvPowNewAddItem")) -w $buttonSize addButtonCurvePower;
        button -label (uiRes("m_FurPluginCreateUI.kHairDescMapCrvPowNewRemoveItem")) removeButtonCurvePower;
        button -label (uiRes("m_FurPluginCreateUI.kHairDescMapCrvPowNewMapItem")) mapButtonCurvePower;
        setParent ..;

        separator -style "none";

	formLayout tableForm;
        scriptTable mappingTableCurvePower;
		setParent ..;

        formLayout -e
        	-height 75
        	-af mappingTableCurvePower top 0
        	-af mappingTableCurvePower left 0
        	-af mappingTableCurvePower bottom 0
        	-af mappingTableCurvePower right 0
        tableForm;

    	separator -style "in";

    	AEHairDescMapCurvePowerReplace( $hairAttr, $hairAttrMapPlug );
}

global proc int AEHairDescAddCB(
	string	$hairAttrPlug,
	string  $custom,
	string	$parent,
	string	$mapFile, 
	string	$filetype
)
{
	if ( size( $mapFile ) > 0 ) {
		setMapFile( $hairAttrPlug, makeProjectRelative( $mapFile ) );
		setParent $parent;
		if($custom == "Custom")
			scriptTable -e -ir 1 -ct "mappingTableCustom";
		else if($custom == "CurvePower")
			scriptTable -e -ir 1 -ct "mappingTableCurvePower";
		else
			scriptTable -e -ir 1 -ct "mappingTable";
			
	}

	return true;
}

addDebugTag("AEHairDescAddButtonCB");

global proc AEHairDescAddButtonCB(
	string  $hairAttr,
	string	$hairAttrMapPlug,
	string	$parent,
	string  $custom
)
{
	HfTDebug("AEHairDescAddButtonCB",("in AEHairDescAddButtonCB( " + $hairAttrMapPlug + ")") );

	setParent $parent;

	// find out which surface is selected
	//
	int		$sr = 0;
	int		$ns;

	setParent ..;

	string $assignedSurfaces;
	string $nodeType = `nodeType $hairAttrMapPlug`;
	if($nodeType == "FurDescription" ) 
		$assignedSurfaces = "furAssignedSurfaces";
	else if($nodeType == "FurCurveAttractors" )
		$assignedSurfaces = "curveAttractorAssignedSurfaces";
	else if($nodeType == "FurAttractors" )
		$assignedSurfaces = "furAttractorAssignedSurfaces";
		
	$ns = `textScrollList -q -nsi $assignedSurfaces`;
	HfTDebug("AEHairDescAddButtonCB",(" " + $ns + " items selected") );
	if ( $ns == 1 ) {
		int	$sel[];
		$sel = `textScrollList -q -sii $assignedSurfaces`;
		$sr = $sel[0];
		HfTDebug("AEHairDescAddButtonCB",("Item " + $sr + " selected") );
	}
	setParent $parent;

	if ( $sr <= 0 ) {
		return;
	}

	string	$hsMembers[];
	int		$hsIndexes[];

	getHairSetMembers( $hairAttrMapPlug, $hsMembers, $hsIndexes );
	if ( $sr <= size( $hsMembers ) ) {
		// setup the project
		HfCheckProjectDir();

		string 	$workspace = `workspace -q -fn`;
		
		setWorkingDirectory $workspace "furAttrMap" "furAttrMap";

		string $import = (uiRes("m_FurPluginCreateUI.kImport"));
		int $isSuccess = fileBrowser(
			("AEHairDescAddCB " + $hairAttrMapPlug + "[" + $hsIndexes[$sr-1] + "] " +"\""+$custom+"\""+ $parent),
			$import, "image", 0
		);
		if($isSuccess)
		{
			string	$mapSurfaces[];
			string	$mapFiles[];
			int	$mapIndexes[];	
			getMapped( $hairAttrMapPlug, $mapSurfaces, $mapFiles, $mapIndexes );
			string $node = plugNode($hairAttrMapPlug);
			bakeMappedAttribute( $node, $hairAttr, true, $mapIndexes, $mapFiles, $mapFiles );
		}
	}
}

addDebugTag("AEHairDescRemoveButtonCB");

global proc AEHairDescRemoveButtonCB(
	string  $hairAttr,
	string	$hairAttrMapPlug,
	string	$parent,
	string  $custom
)
{
	setParent	$parent;

	// find out which entry is selected
	//
	int	$sr;
	if($custom == "Custom")
		$sr = `scriptTable -q -sr mappingTableCustom`;
	else if($custom == "CurvePower")
		$sr = `scriptTable -q -sr mappingTableCurvePower`;
	else
		$sr = `scriptTable -q -sr mappingTable`;
	HfTDebug("AEHairDescRemoveButtonCB",("in AEHairDescRemoveButtonCB(" + $hairAttrMapPlug + "): selected " + $sr) );
	
	if ( $sr <= 0 ) {
		return;
	}

	HfTDebug("AEHairDescRemoveButtonCB",("removing entry " + $sr + " of " + $hairAttrMapPlug) );

	string	$mapSurfaces[];
	string	$mapFiles[];
	int		$mapIndexes[];

	getMapped( $hairAttrMapPlug, $mapSurfaces, $mapFiles, $mapIndexes );
	if ( $sr <= size( $mapSurfaces ) ) {
		setMapFile(
			($hairAttrMapPlug + "[" + $mapIndexes[$sr-1] + "]"),
			""
		);
		if($custom == "Custom")
			scriptTable -e -dr $sr mappingTableCustom;
		else if($custom == "CurvePower")
			scriptTable -e -dr $sr mappingTableCurvePower;
		else
			scriptTable -e -dr $sr mappingTable;
		getMapped( $hairAttrMapPlug, $mapSurfaces, $mapFiles, $mapIndexes );
		string $node = plugNode($hairAttrMapPlug);
		bakeMappedAttribute($node, $hairAttr, true, $mapIndexes, $mapFiles, $mapFiles);		
	}
}

global proc int AEHairDescMapCB(
	string	$hairAttrPlug,
	string  $custom,
	string	$parent,
	string	$mapFile, 
	string	$filetype
)
{
	if ( size( $mapFile ) > 0 ) {
		setMapFile( $hairAttrPlug, makeProjectRelative( $mapFile ) );
		setParent $parent;
		if($custom == "Custom")
			scriptTable -e -ct "mappingTableCustom";
		else if($custom == "CurvePower")
			scriptTable -e -ct "mappingTableCurvePower";
		else
			scriptTable -e -ct "mappingTable";
			
	}

	return true;
}

addDebugTag("AEHairDescMapButtonCB");

global proc AEHairDescMapButtonCB(
	string  $hairAttr,
	string	$hairAttrMapPlug,
	string	$parent,
	string  $custom
)
{
	setParent $parent;

	// find out which entry is selected
	//
	int	$sr;
	if($custom == "Custom")
		$sr = `scriptTable -q -sr mappingTableCustom`;
	else if($custom == "CurvePower")
		$sr = `scriptTable -q -sr mappingTablePower`;
	else
		$sr = `scriptTable -q -sr mappingTable`;

	HfTDebug("AEHairDescMapButtonCB",("in AEHairDescMapButtonCB(" + $hairAttrMapPlug + "): selected " + $sr) );
	
	if ( $sr <= 0 ) {
		return;
	}

	string	$mapSurfaces[];
	string	$mapFiles[];
	int	$mapIndexes[];
	string	$previousMapFiles[];

	getMapped( $hairAttrMapPlug, $mapSurfaces, $mapFiles, $mapIndexes );
	$previousMapFiles = $mapFiles;
	if ( $sr <= size( $mapSurfaces ) ) {
		// setup the project
		HfCheckProjectDir();

		string 	$workspace = `workspace -q -fn`;
		
		setWorkingDirectory $workspace "furAttrMap" "furAttrMap";

		string $import = (uiRes("m_FurPluginCreateUI.kImport"));
		int $isSuccess = fileBrowser(
			("AEHairDescMapCB " + $hairAttrMapPlug + "[" + $mapIndexes[$sr-1] + "] " +"\""+$custom+"\""+ $parent),
			$import, "image", 0
		);
		if($isSuccess)
		{
			getMapped( $hairAttrMapPlug, $mapSurfaces, $mapFiles, $mapIndexes );
			string $node = plugNode($hairAttrMapPlug);
			bakeMappedAttribute( $node, $hairAttr, true, $mapIndexes, $mapFiles,$previousMapFiles );
		}
	}
}

//addDebugTag( "AEHairDescMapReplace" );

global proc AEHairDescMapReplace(
	string	$hairAttr,
	string	$hairAttrMapPlug
)
{
	HfTDebug("AEHairDescMapReplace",("in AEHairDescMapReplace(" + $hairAttr + "," + $hairAttrMapPlug + ")") );

	string	$mapSurfaces[], $mapNames[];
	int		$mapIndexes[];
	string	$parent = `setParent -q`;

	getMapped( $hairAttrMapPlug, $mapSurfaces, $mapNames, $mapIndexes );

	string  $plugParts[];
	tokenize( $hairAttrMapPlug, ".", $plugParts );
	string  $node = $plugParts[0];
	string  $mapAttr  = `attributeName -nice ($node + "." + $hairAttr)`;
	string  $mapLabel = (uiRes("m_FurPluginCreateUI.kAttrMap"));

	scriptTable -e
        -label 1 (uiRes("m_FurPluginCreateUI.kHairDescMapReplaceSurface")) 
		-label 2 `format -s $mapAttr $mapLabel`
		-getCellCmd ("AEHairDescGetCell " + $hairAttrMapPlug)
		-cellChangedCmd ("AEHairDescCellChanged " + $hairAttrMapPlug + " \" \"" + $parent)
		-rows (`size($mapSurfaces)` + 1) -columns 2
		-cw 1 175 -cw 2 175 -ct
        mappingTable;

    button -e -command
        ("AEHairDescAddButtonCB "+$hairAttr + " "+ $hairAttrMapPlug + " " + $parent+" \" \"") addButton;

    button -e -command
        ("AEHairDescRemoveButtonCB "+$hairAttr + " " +$hairAttrMapPlug + " " + $parent+" \" \"") removeButton;

    button -e -command
        ("AEHairDescMapButtonCB "+$hairAttr + " " +$hairAttrMapPlug + " " + $parent+" \" \"") mapButton;
}

global proc AEHairDescMapCustomReplace(
	string	$hairAttr,
	string	$hairAttrMapPlug
)
{
	HfTDebug("AEHairDescMapReplace",("in AEHairDescMapReplace(" + $hairAttr + "," + $hairAttrMapPlug + ")") );

	string	$mapSurfaces[], $mapNames[];
	int		$mapIndexes[];
	string	$parent = `setParent -q`;

	getMapped( $hairAttrMapPlug, $mapSurfaces, $mapNames, $mapIndexes );

	string  $plugParts[];
	tokenize( $hairAttrMapPlug, ".", $plugParts );
	string  $node = $plugParts[0];
	string  $mapAttr  = `attributeName -nice ($node + "." + $hairAttr)`;
	string  $mapLabel = (uiRes("m_FurPluginCreateUI.kAttrMapCustomReplace"));

	scriptTable -e
        -label 1 (uiRes("m_FurPluginCreateUI.kHairDescMapCustReplaceSurface")) 
		-label 2 `format -s $mapAttr $mapLabel`
		-getCellCmd ("AEHairDescGetCell " + $hairAttrMapPlug)
		-cellChangedCmd ("AEHairDescCellChanged " + $hairAttrMapPlug + " \"Custom\"" + $parent)
		-rows (`size($mapSurfaces)` + 1) -columns 2
		-cw 1 175 -cw 2 175 -ct
        mappingTableCustom;

    button -e -command
        ("AEHairDescAddButtonCB "+ $hairAttr + " " + $hairAttrMapPlug + " " + $parent+" \"Custom\"" ) addButtonCustom;

    button -e -command
        ("AEHairDescRemoveButtonCB "+$hairAttr + " " +$hairAttrMapPlug + " " + $parent+" \"Custom\"") removeButtonCustom;

    button -e -command
        ("AEHairDescMapButtonCB "+$hairAttr + " " +$hairAttrMapPlug + " " + $parent+" \"Custom\"") mapButtonCustom;

	HfCheckCustomEqual( $hairAttr, $hairAttrMapPlug);
}
global proc AEHairDescMapCurvePowerReplace(
	string	$hairAttr,
	string	$hairAttrMapPlug
)
{
	HfTDebug("AEHairDescMapReplace",("in AEHairDescMapReplace(" + $hairAttr + "," + $hairAttrMapPlug + ")") );

	string	$mapSurfaces[], $mapNames[];
	int		$mapIndexes[];
	string	$parent = `setParent -q`;

	getMapped( $hairAttrMapPlug, $mapSurfaces, $mapNames, $mapIndexes );

	string  $plugParts[];
	tokenize( $hairAttrMapPlug, ".", $plugParts );
	string  $node = $plugParts[0];
	string  $mapAttr  = `attributeName -nice ($node + "." + $hairAttr)`;
	string  $mapLabel = (uiRes("m_FurPluginCreateUI.kAttrMapPowerReplace"));

	scriptTable -e
        -label 1 (uiRes("m_FurPluginCreateUI.kHairDescMapCrvPowReplaceSurface")) 
		-label 2 `format -s $mapAttr $mapLabel`
		-getCellCmd ("AEHairDescGetCell " + $hairAttrMapPlug)
		-cellChangedCmd ("AEHairDescCellChanged " + $hairAttrMapPlug + " \"CurvePower\"" + $parent)
		-rows (`size($mapSurfaces)` + 1) -columns 2
		-cw 1 175 -cw 2 175 -ct
        mappingTableCurvePower;

    button -e -command
        ("AEHairDescAddButtonCB "+ $hairAttr + " " + $hairAttrMapPlug + " " + $parent+" \"CurvePower\"" ) addButtonCurvePower;

    button -e -command
        ("AEHairDescRemoveButtonCB "+$hairAttr + " " +$hairAttrMapPlug + " " + $parent+" \"CurvePower\"") removeButtonCurvePower;

    button -e -command
        ("AEHairDescMapButtonCB "+$hairAttr + " " +$hairAttrMapPlug + " " + $parent+" \"CurvePower\"") mapButtonCurvePower;

    HfCheckCurvePower( $hairAttr, $hairAttrMapPlug);
}

global proc HfCheckCurvePower(
	string	$attr,
	string  $node
)
{
	
	$node=plugNode($node);
	int $modelType = `getAttr ($node+".CurveAttractorModel")`;
	if( $modelType == 0 )
	{
		$cmd = "editorTemplate -dimControl "+$node+" "+"CurvePower true";	
		evalDeferred $cmd;

		if(`button -q -ex "addButtonCurvePower"`)
			button -e -enable false addButtonCurvePower;
		if(`button -q -ex "removeButtonCurvePower"`)
			button -e -enable false removeButtonCurvePower;
		if(`button -q -ex "mapButtonCurvePower"`)
			button -e -enable false mapButtonCurvePower;
		if(`scriptTable -q -ex "mappingTableCurvePower"`)
			scriptTable -e -enable false mappingTableCurvePower;
		
		editorTemplate -dimControl $node "CurvePowerMapOffset" true;
		editorTemplate -dimControl $node "CurvePowerMapMult" true;
		editorTemplate -dimControl $node "CurvePowerNoise" true;
		editorTemplate -dimControl $node "CurvePowerNoiseFreq" true;
	}
	else
	{
		$cmd = "editorTemplate -dimControl "+$node+" "+"CurvePower false";	
		evalDeferred $cmd;

		if(`button -q -ex "addButtonCurvePower"`)
			button -e -enable true addButtonCurvePower;
		if(`button -q -ex "removeButtonCurvePower"`)
			button -e -enable true removeButtonCurvePower;
		if(`button -q -ex "mapButtonCurvePower"`)
			button -e -enable true mapButtonCurvePower;
		if(`scriptTable -q -ex "mappingTableCurvePower"`)
			scriptTable -e -enable true mappingTableCurvePower;

		editorTemplate -dimControl $node "CurvePower" false;
		editorTemplate -dimControl $node "CurvePowerMapOffset" false;
		editorTemplate -dimControl $node "CurvePowerMapMult" false;
		editorTemplate -dimControl $node "CurvePowerNoise" false;
		editorTemplate -dimControl $node "CurvePowerNoiseFreq" false;
	}
}

global proc HfCheckCustomEqual(
	string	$attr,
	string  $node
)
{
	string $furGlobal[] = `ls -type "FurGlobals"`;
	string $cmd;
	if( size($furGlobal) == 0 )
	{
		$cmd = "editorTemplate -dimControl "+$node+" "+($attr)+" true";	
		evalDeferred $cmd;

			if(`button -q -ex "addButtonCustom"`)
				button -e -enable false addButtonCustom;
			if(`button -q -ex "removeButtonCustom"`)
				button -e -enable false removeButtonCustom;
			if(`button -q -ex "mapButtonCustom"`)
				button -e -enable false mapButtonCustom;
			if(`scriptTable -q -ex "mappingTableCustom"`)
				scriptTable -e -enable false mappingTableCustom;
	}
	else
	{
		int $equalType = `getAttr ("defaultFurGlobals.equalMap")`;
		if($equalType != 2)
		{
			$cmd = "editorTemplate -dimControl "+$node+" "+($attr)+" true";	
			evalDeferred $cmd;
			
			if(`button -q -ex "addButtonCustom"`)
				button -e -enable false addButtonCustom;
			if(`button -q -ex "removeButtonCustom"`)
				button -e -enable false removeButtonCustom;
			if(`button -q -ex "mapButtonCustom"`)
				button -e -enable false mapButtonCustom;
			if(`scriptTable -q -ex "mappingTableCustom"`)
				scriptTable -e -enable false mappingTableCustom;
		}
		else
		{
			$cmd = "editorTemplate -dimControl "+$node+" "+($attr)+" false";	
			evalDeferred $cmd;

			if(`button -q -ex "addButtonCustom"`)
				button -e -enable true addButtonCustom;
			if(`button -q -ex "removeButtonCustom"`)
				button -e -enable true removeButtonCustom;
			if(`button -q -ex "mapButtonCustom"`)
				button -e -enable true mapButtonCustom;
			if(`scriptTable -q -ex "mappingTableCustom"`)
				scriptTable -e -enable true mappingTableCustom;
		}
	}
}

proc generateHairCustomEqualAttrDetails(
	string $title,
	string $baseAttr
)
{
	editorTemplate -beginLayout $title;
		editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kMaps"));
		editorTemplate -callCustom
			("AEHairDescMapCustomNew " + $baseAttr)
			("AEHairDescMapCustomReplace " + $baseAttr)
			`hairMapsAttr($baseAttr)`;
		editorTemplate -endLayout;
	editorTemplate -endLayout;
}

proc generateHairCurvePowerAttrDetails(
	string $title,
	string $baseAttr
)
{
	editorTemplate -beginLayout $title;
		editorTemplate -label (uiRes("m_FurPluginCreateUI.kGenHairCrvPowAttrMapOffset")) -addControl `hairMapOffsetAttr($baseAttr)`;
		editorTemplate -label (uiRes("m_FurPluginCreateUI.kGenHairCrvPowAttrMapMultiplier")) -addControl `hairMapMultAttr($baseAttr)`;
		editorTemplate -label (uiRes("m_FurPluginCreateUI.kGenHairCrvPowAttrNoiseAmplitude")) -addControl `hairNoiseAttr($baseAttr)`;
		editorTemplate -label (uiRes("m_FurPluginCreateUI.kGenHairCrvPowAttrNoiseFrequency")) -addControl `hairNoiseFreqAttr($baseAttr)`;		
		
		editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kMaps"));
		editorTemplate -callCustom
			("AEHairDescMapCurvePowerNew " + $baseAttr)
			("AEHairDescMapCurvePowerReplace " + $baseAttr)
			`hairMapsAttr($baseAttr)`;
		editorTemplate -endLayout;
	editorTemplate -endLayout;
}


proc generateHairAttrDetails(
	string $title,
	string $baseAttr
)
{
	editorTemplate -beginLayout $title;
		editorTemplate -label (uiRes("m_FurPluginCreateUI.kGenHairAttrMapOffset")) -addControl `hairMapOffsetAttr($baseAttr)`;
		editorTemplate -label (uiRes("m_FurPluginCreateUI.kGenHairAttrMapMultiplier")) -addControl `hairMapMultAttr($baseAttr)`;
		editorTemplate -label (uiRes("m_FurPluginCreateUI.kGenHairAttrNoiseAmplitude")) -addControl `hairNoiseAttr($baseAttr)`;
		editorTemplate -label (uiRes("m_FurPluginCreateUI.kGenHairAttrNoiseFrequency")) -addControl `hairNoiseFreqAttr($baseAttr)`;

		editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kMaps"));
		editorTemplate -callCustom
			("AEHairDescMapNew " + $baseAttr)
			("AEHairDescMapReplace " + $baseAttr)
			`hairMapsAttr($baseAttr)`;
		editorTemplate -endLayout;
	editorTemplate -endLayout;
}

// bug 178401 Make baking Fur's attribute map(s) more user friendly 
global proc AEfurDescBakeMapWidthNew(
	string	$uiName,
	string	$attrPlug
)
{
	string	$attrName = plugAttr( $attrPlug );
	intFieldGrp -label $uiName ($attrName + "Field");
	AEfurDescBakeMapWidthReplace( $uiName, $attrPlug );
}

global proc AEfurDescBakeMapWidthReplace(
	string	$uiName,
	string	$attrPlug
)
{

	string	$attrName = plugAttr( $attrPlug );
	connectControl -index 2 ($attrName + "Field") $attrPlug;
}

global proc AEfurDescBakeMapHeightNew(
	string	$uiName,
	string	$attrPlug
)
{
	string	$attrName = plugAttr( $attrPlug );
	intFieldGrp -label $uiName ($attrName + "Field");
	separator -style "in";
	AEfurDescBakeMapHeightReplace( $uiName, $attrPlug );
}

global proc AEfurDescBakeMapHeightReplace(
	string	$uiName,
	string	$attrPlug
)
{

	string	$attrName = plugAttr( $attrPlug );
	connectControl -index 2 ($attrName + "Field") $attrPlug;
}

global proc AEFurDescriptionTemplate(
	string	$nodeName
)
{
	global string $HfHairAttributes[];
	global string $HfHairAttrUiNames[];

	int	$numHairAttributes = size($HfHairAttributes);
	int	$a;

    editorTemplate -beginScrollLayout;

		editorTemplate -addControl "LightModel";
		editorTemplate -addControl "Density";
		editorTemplate -addControl "GlobalScale";

		editorTemplate -callCustom
			"AEHairDescGeneralNew AEHairDescBakeMenu AEHairDescBakeButtonCB"
			"AEHairDescGeneralReplace AEHairDescBakeButtonCB"
			message;

		// bug 178401 Make baking Fur's attribute map(s) more user friendly 
		string $label = (uiRes("m_FurPluginCreateUI.kMapWidth"));
		editorTemplate -callCustom
		    ("AEfurDescBakeMapWidthNew \""+$label+"\"")
		    ("AEfurDescBakeMapWidthReplace \""+$label+"\"") "exportWidth";
	
	    $label = (uiRes("m_FurPluginCreateUI.kMapHeight"));
	    editorTemplate -callCustom
		    ("AEfurDescBakeMapHeightNew \""+$label+"\"")
		    ("AEfurDescBakeMapHeightReplace \""+$label+"\"") "exportHeight";
				
		for ( $a = 0; $a < $numHairAttributes; $a++ ) {
			string	$attr = hairDefaultAttr($HfHairAttributes[$a]);
			if($attr != "CustomEqualizer")
				editorTemplate -addControl $attr;
			else
				editorTemplate -addControl $attr "HfFurGlobalCheckFurDescription";
		}

		editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kDetails"));
		for ( $a = 0; $a < $numHairAttributes; $a++ ) {
			if(hairDefaultAttr($HfHairAttributes[$a]) != "CustomEqualizer")
				generateHairAttrDetails($HfHairAttrUiNames[$a],$HfHairAttributes[$a]);
			else
				generateHairCustomEqualAttrDetails($HfHairAttrUiNames[$a],$HfHairAttributes[$a]);
		}
		editorTemplate -endLayout;

        // include/call base class/node attributes
        AEdependNodeTemplate $nodeName;

		for ( $a = 0; $a < $numHairAttributes; $a++ ) {
			string $mapFileName = hairMapFileAttr($HfHairAttributes[$a]);
			editorTemplate -suppress $mapFileName;
		}
		editorTemplate -suppress CustomEqualizerMapOffset;
		editorTemplate -suppress CustomEqualizerMapMult;
		editorTemplate -suppress CustomEqualizerNoise;
		editorTemplate -suppress CustomEqualizerNoiseFreq;
		editorTemplate -suppress dagSetMembers;
		editorTemplate -suppress uvSetName;
		editorTemplate -suppress furGlobals;
		editorTemplate -suppress BaseColorMapUSamples;
		editorTemplate -suppress BaseColorMapVSamples;
		editorTemplate -suppress TipColorMapUSamples;
		editorTemplate -suppress TipColorMapVSamples;
		editorTemplate -suppress BaseAmbientColorMapUSamples;
		editorTemplate -suppress BaseAmbientColorMapVSamples;
		editorTemplate -suppress TipAmbientColorMapUSamples;
		editorTemplate -suppress TipAmbientColorMapVSamples;
		editorTemplate -suppress SpecularColorMapUSamples;
		editorTemplate -suppress SpecularColorMapVSamples;
		editorTemplate -suppress LengthMapUSamples;
		editorTemplate -suppress LengthMapVSamples;
		editorTemplate -suppress SpecularSharpnessMapUSamples;
		editorTemplate -suppress SpecularSharpnessMapVSamples;
		editorTemplate -suppress BaldnessMapUSamples;
		editorTemplate -suppress BaldnessMapVSamples;
		editorTemplate -suppress BaseOpacityMapUSamples;
		editorTemplate -suppress BaseOpacityMapVSamples;
		editorTemplate -suppress TipOpacityMapUSamples;
		editorTemplate -suppress TipOpacityMapVSamples;
		editorTemplate -suppress BaseWidthMapUSamples;
		editorTemplate -suppress BaseWidthMapVSamples;
		editorTemplate -suppress TipWidthMapUSamples;
		editorTemplate -suppress TipWidthMapVSamples;
		editorTemplate -suppress SegmentsMapUSamples;
		editorTemplate -suppress SegmentsMapVSamples;
		editorTemplate -suppress BaseCurlMapUSamples;
		editorTemplate -suppress BaseCurlMapVSamples;
		editorTemplate -suppress TipCurlMapUSamples;
		editorTemplate -suppress TipCurlMapVSamples;
		editorTemplate -suppress ScraggleMapUSamples;
		editorTemplate -suppress ScraggleMapVSamples;
		editorTemplate -suppress ScraggleFrequencyMapUSamples;
		editorTemplate -suppress ScraggleFrequencyMapVSamples;
		editorTemplate -suppress ScraggleCorrelationMapUSamples;
		editorTemplate -suppress ScraggleCorrelationMapVSamples;
		editorTemplate -suppress ClumpingMapUSamples;
		editorTemplate -suppress ClumpingMapVSamples;
		editorTemplate -suppress ClumpingFrequencyMapUSamples;
		editorTemplate -suppress ClumpingFrequencyMapVSamples;
		editorTemplate -suppress ClumpShapeMapUSamples;
		editorTemplate -suppress ClumpShapeMapVSamples;
		editorTemplate -suppress InclinationMapUSamples;
		editorTemplate -suppress InclinationMapVSamples;
		editorTemplate -suppress RollMapUSamples;
		editorTemplate -suppress RollMapVSamples;
		editorTemplate -suppress PolarMapUSamples;
		editorTemplate -suppress PolarMapVSamples;
		editorTemplate -suppress AttractionMapUSamples;
		editorTemplate -suppress AttractionMapVSamples;
		editorTemplate -suppress OffsetMapUSamples;
		editorTemplate -suppress OffsetMapVSamples;
		editorTemplate -suppress CustomEqualizerMapUSamples;
		editorTemplate -suppress CustomEqualizerMapVSamples;
		editorTemplate -suppress feedbackUSamples;
		editorTemplate -suppress feedbackVSamples;
		editorTemplate -suppress feedbackExportWidth;
		editorTemplate -suppress feedbackExportHeight;
		editorTemplate -suppress feedbackColorEnabled;
		editorTemplate -suppress feedbackDrawAttractors;
 		editorTemplate -suppress feedbackFurAccuracy;
        editorTemplate -addExtraControls;

    editorTemplate -endScrollLayout;
}

addDebugTag( "AEfeedback" );

global proc AEfeedbackEditFieldNew(
	string	$uiName,
	string	$attrPlug
)
{
	string	$tag="AEfeedback";
	string	$attrName = plugAttr( $attrPlug );

	HfTDebug($tag,"called AEfeedbackEditFieldNew(" + $uiName + "," + $attrPlug);

	intFieldGrp -label $uiName ($attrName + "Field");

	AEfeedbackEditFieldReplace( $uiName, $attrPlug );
}

global proc AEfeedbackEditFieldReplace(
	string	$uiName,
	string	$attrPlug
)
{
	string	$tag="AEfeedback";
	string	$attrName = plugAttr( $attrPlug );

	HfTDebug($tag,"called AEfeedbackEditFieldReplace(" + $uiName + "," + $attrPlug);

	connectControl -index 2 ($attrName + "Field") $attrPlug;
}
global proc int furAppendUniqueEntry( string $new, string $array[] )
{
	// add string "new" to "array" if it is not already included
	int $len = size( $array );
	int $i;
	for( $i = 0; $i < $len; $i++ ){
		if( $new == $array[$i] ){
			$new = "";
			break;
		}
	}
	if( $new != "" ){
		$array[$len] = $new;
		$len++;
	}
	return( $len );
}

global proc string[] AEFurFeedbackRelated( string $node )
{
	string $retval[];
	
	// Make sure that the shape is first in the list so that
	$retval[0] = $node;

	// Get the default tabs for this node

	string $relNodes[] = `defaultNavigation -ren -d $node`;
	string $preferredNode = `defaultNavigation -dwn -d $node`;

	for ($relNode in $relNodes) {
		$retval[size($retval)] = $relNode;
	}
	
	//Get HairSystem Nodes
	string $globalHairSystems[];
	string $curveNodes[] = `listConnections -shapes true -type "nurbsCurve" $node`;
	for( $curve in $curveNodes)
	{
		string $follicleNodes[] = `listConnections -shapes true -type "follicle" $curve`;
		for( $follicle in $follicleNodes)
		{
			string $hairSystems[] = `listConnections -shapes true -type "hairSystem" $follicle`;
			for( $hairSystem in $hairSystems)
			{
				int $len = furAppendUniqueEntry($hairSystem, $globalHairSystems);
			}
		}
	}	
	for ($globalHairSystem in $globalHairSystems) {
		$retval[size($retval)] = $globalHairSystem;
	}
	
	if ( $preferredNode != "" ) {
		$retval[size($retval)] = $preferredNode;
	}
	if( size( $retval ) == 0 ) {
		$retval[0] = $node;
	} 
	
	return $retval;	
}

global proc HfExportThreshold(string $node)
{
	string	$feedback = plugNode( $node );
	if ( $feedback != "" ) {
		string	$dirtyPlug = $feedback + ".PolarSamplesDirty";
		int		$dirty = `getAttr $dirtyPlug`;
		setAttr $dirtyPlug 1;
		
		$dirtyPlug = $feedback + "." + "PolarMapDirty";
		$dirty = `getAttr $dirtyPlug`;
		setAttr $dirtyPlug 1;		
	}
}

global proc AEFurFeedbackTemplate(
	string	$nodeName
)
{
    editorTemplate -beginScrollLayout;

		editorTemplate -addControl `feedbackUSamplesAttr`;
		editorTemplate -addControl `feedbackVSamplesAttr`;
		editorTemplate -addControl "furAccuracy";
		editorTemplate -addControl "colorFeedbackEnabled";
		editorTemplate -addControl `feedbackExportWrapThresholdAttr`;

		editorTemplate -suppress "drawAttractors";

		editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kRenderStats"));
			editorTemplate -beginNoOptimize;
			editorTemplate -addControl "primaryVisibility";
			editorTemplate -addControl "castsShadows";
			editorTemplate -label (uiRes("m_FurPluginCreateUI.kReceiveShadows")) -addControl "receiveShadows";
			editorTemplate -label (uiRes("m_FurPluginCreateUI.kMotionBlur")) -addControl "motionBlur";
			editorTemplate -label (uiRes("m_FurPluginCreateUI.kVisibleReflections")) -addControl "visibleInReflections";
			editorTemplate -label (uiRes("m_FurPluginCreateUI.kVisibleRefractions")) -addControl "visibleInRefractions";
			editorTemplate -suppress "doubleSided";
			editorTemplate -suppress "opposite";
			editorTemplate -suppress "shadingSamplesOverride";
			editorTemplate -suppress "shadingSamples";
			editorTemplate -suppress "maxShadingSamples";
			editorTemplate -suppress "volumeSamplesOverride";
			editorTemplate -suppress "volumeSamples";
			editorTemplate -suppress "maxVisibilitySamplesOverride";
			editorTemplate -suppress "maxVisibilitySamples";
			editorTemplate -endNoOptimize;
		editorTemplate -endLayout;

		// supress locator position
		//
		editorTemplate -suppress "localPosition";
		editorTemplate -suppress Attraction;
		editorTemplate -suppress AttractionMap;
		editorTemplate -suppress AttractionMapDirty;
		editorTemplate -suppress AttractionMapMult;
		editorTemplate -suppress AttractionMapOffset;
		editorTemplate -suppress AttractionNoise;
		editorTemplate -suppress AttractionNoiseFreq;
		editorTemplate -suppress AttractionSamples;
		editorTemplate -suppress AttractionSamplesDirty;
		editorTemplate -suppress Baldness;
		editorTemplate -suppress BaldnessMap;
		editorTemplate -suppress BaldnessMapDirty;
		editorTemplate -suppress BaldnessMapMult;
		editorTemplate -suppress BaldnessMapOffset;
		editorTemplate -suppress BaldnessNoise;
		editorTemplate -suppress BaldnessNoiseFreq;
		editorTemplate -suppress BaldnessSamples;
		editorTemplate -suppress BaldnessSamplesDirty;
		editorTemplate -suppress BaseAmbientColorMap;
		editorTemplate -suppress BaseAmbientColorMapDirty;
		editorTemplate -suppress BaseAmbientColorNoise;
		editorTemplate -suppress BaseAmbientColorNoiseFreq;
		editorTemplate -suppress BaseAmbientColorSamples;
		editorTemplate -suppress BaseAmbientColorSamplesDirty;
		editorTemplate -suppress BaseColorMap;
		editorTemplate -suppress BaseColorMapDirty;
		editorTemplate -suppress BaseColorNoise;
		editorTemplate -suppress BaseColorNoiseFreq;
		editorTemplate -suppress BaseColorSamples;
		editorTemplate -suppress BaseColorSamplesDirty;
		editorTemplate -suppress BaseCurl;
		editorTemplate -suppress BaseCurlMap;
		editorTemplate -suppress BaseCurlMapDirty;
		editorTemplate -suppress BaseCurlMapMult;
		editorTemplate -suppress BaseCurlMapOffset;
		editorTemplate -suppress BaseCurlNoise;
		editorTemplate -suppress BaseCurlNoiseFreq;
		editorTemplate -suppress BaseCurlSamples;
		editorTemplate -suppress BaseCurlSamplesDirty;
		editorTemplate -suppress BaseOpacity;
		editorTemplate -suppress BaseOpacityMap;
		editorTemplate -suppress BaseOpacityMapDirty;
		editorTemplate -suppress BaseOpacityMapMult;
		editorTemplate -suppress BaseOpacityMapOffset;
		editorTemplate -suppress BaseOpacityNoise;
		editorTemplate -suppress BaseOpacityNoiseFreq;
		editorTemplate -suppress BaseOpacitySamples;
		editorTemplate -suppress BaseOpacitySamplesDirty;
		editorTemplate -suppress BaseWidth;
		editorTemplate -suppress BaseWidthMap;
		editorTemplate -suppress BaseWidthMapDirty;
		editorTemplate -suppress BaseWidthMapMult;
		editorTemplate -suppress BaseWidthMapOffset;
		editorTemplate -suppress BaseWidthNoise;
		editorTemplate -suppress BaseWidthNoiseFreq;
		editorTemplate -suppress BaseWidthSamples;
		editorTemplate -suppress BaseWidthSamplesDirty;
		editorTemplate -suppress ClumpShape;
		editorTemplate -suppress ClumpShapeMap;
		editorTemplate -suppress ClumpShapeMapDirty;
		editorTemplate -suppress ClumpShapeMapMult;
		editorTemplate -suppress ClumpShapeMapOffset;
		editorTemplate -suppress ClumpShapeNoise;
		editorTemplate -suppress ClumpShapeNoiseFreq;
		editorTemplate -suppress ClumpShapeSamples;
		editorTemplate -suppress ClumpShapeSamplesDirty;
		editorTemplate -suppress Clumping;
		editorTemplate -suppress ClumpingFrequency;
		editorTemplate -suppress ClumpingFrequencyMap;
		editorTemplate -suppress ClumpingFrequencyMapDirty;
		editorTemplate -suppress ClumpingFrequencyMapMult;
		editorTemplate -suppress ClumpingFrequencyMapOffset;
		editorTemplate -suppress ClumpingFrequencyNoise;
		editorTemplate -suppress ClumpingFrequencyNoiseFreq;
		editorTemplate -suppress ClumpingFrequencySamples;
		editorTemplate -suppress ClumpingFrequencySamplesDirty;
		editorTemplate -suppress ClumpingMap;
		editorTemplate -suppress ClumpingMapDirty;
		editorTemplate -suppress ClumpingMapMult;
		editorTemplate -suppress ClumpingMapOffset;
		editorTemplate -suppress ClumpingNoise;
		editorTemplate -suppress ClumpingNoiseFreq;
		editorTemplate -suppress ClumpingSamples;
		editorTemplate -suppress ClumpingSamplesDirty;
		editorTemplate -suppress CurveEndLength;
		editorTemplate -suppress CurveEndLengthMap;
		editorTemplate -suppress CurveEndLengthMapDirty;
		editorTemplate -suppress CurveEndLengthMapMult;
		editorTemplate -suppress CurveEndLengthMapOffset;
		editorTemplate -suppress CurveEndLengthNoise;
		editorTemplate -suppress CurveEndLengthNoiseFreq;
		editorTemplate -suppress CurveEndLengthSamples;
		editorTemplate -suppress CurveEndLengthSamplesDirty;
		editorTemplate -suppress CurveInfluence;
		editorTemplate -suppress CurveInfluenceMap;
		editorTemplate -suppress CurveInfluenceMapDirty;
		editorTemplate -suppress CurveInfluenceMapMult;
		editorTemplate -suppress CurveInfluenceMapOffset;
		editorTemplate -suppress CurveInfluenceNoise;
		editorTemplate -suppress CurveInfluenceNoiseFreq;
		editorTemplate -suppress CurveInfluenceSamples;
		editorTemplate -suppress CurveInfluenceSamplesDirty;
		editorTemplate -suppress CurvePower;
		editorTemplate -suppress CurvePowerMap;
		editorTemplate -suppress CurvePowerMapDirty;
		editorTemplate -suppress CurvePowerMapMult;
		editorTemplate -suppress CurvePowerMapOffset;
		editorTemplate -suppress CurvePowerNoise;
		editorTemplate -suppress CurvePowerNoiseFreq;
		editorTemplate -suppress CurvePowerSamples;
		editorTemplate -suppress CurvePowerSamplesDirty;
		editorTemplate -suppress CurveRadius;
		editorTemplate -suppress CurveRadiusMap;
		editorTemplate -suppress CurveRadiusMapDirty;
		editorTemplate -suppress CurveRadiusMapMult;
		editorTemplate -suppress CurveRadiusMapOffset;
		editorTemplate -suppress CurveRadiusNoise;
		editorTemplate -suppress CurveRadiusNoiseFreq;
		editorTemplate -suppress CurveRadiusSamples;
		editorTemplate -suppress CurveRadiusSamplesDirty;
		editorTemplate -suppress CurveStartLength;
		editorTemplate -suppress CurveStartLengthMap;
		editorTemplate -suppress CurveStartLengthMapDirty;
		editorTemplate -suppress CurveStartLengthMapMult;
		editorTemplate -suppress CurveStartLengthMapOffset;
		editorTemplate -suppress CurveStartLengthNoise;
		editorTemplate -suppress CurveStartLengthNoiseFreq;
		editorTemplate -suppress CurveStartLengthSamples;
		editorTemplate -suppress CurveStartLengthSamplesDirty;
		editorTemplate -suppress CurveThresholdLength;
		editorTemplate -suppress CurveThresholdLengthMap;
		editorTemplate -suppress CurveThresholdLengthMapDirty;
		editorTemplate -suppress CurveThresholdLengthMapMult;
		editorTemplate -suppress CurveThresholdLengthMapOffset;
		editorTemplate -suppress CurveThresholdLengthNoise;
		editorTemplate -suppress CurveThresholdLengthNoiseFreq;
		editorTemplate -suppress CurveThresholdLengthSamples;
		editorTemplate -suppress CurveThresholdLengthSamplesDirty;
		editorTemplate -suppress CustomEqualizer;
		editorTemplate -suppress CustomEqualizerMap;
		editorTemplate -suppress CustomEqualizerMapDirty;
		editorTemplate -suppress CustomEqualizerMapMult;
		editorTemplate -suppress CustomEqualizerMapOffset;
		editorTemplate -suppress CustomEqualizerNoise;
		editorTemplate -suppress CustomEqualizerNoiseFreq;
		editorTemplate -suppress CustomEqualizerSamples;
		editorTemplate -suppress CustomEqualizerSamplesDirty;
		editorTemplate -suppress EndLength;
		editorTemplate -suppress EndLengthMap;
		editorTemplate -suppress EndLengthMapDirty;
		editorTemplate -suppress EndLengthMapMult;
		editorTemplate -suppress EndLengthMapOffset;
		editorTemplate -suppress EndLengthNoise;
		editorTemplate -suppress EndLengthNoiseFreq;
		editorTemplate -suppress EndLengthSamples;
		editorTemplate -suppress EndLengthSamplesDirty;
		editorTemplate -suppress Equalizer;
		editorTemplate -suppress EqualizerMap;
		editorTemplate -suppress EqualizerMapDirty;
		editorTemplate -suppress EqualizerMapMult;
		editorTemplate -suppress EqualizerMapOffset;
		editorTemplate -suppress EqualizerNoise;
		editorTemplate -suppress EqualizerNoiseFreq;
		editorTemplate -suppress EqualizerSamples;
		editorTemplate -suppress EqualizerSamplesDirty;
		editorTemplate -suppress Inclination;
		editorTemplate -suppress InclinationMap;
		editorTemplate -suppress InclinationMapDirty;
		editorTemplate -suppress InclinationMapMult;
		editorTemplate -suppress InclinationMapOffset;
		editorTemplate -suppress InclinationNoise;
		editorTemplate -suppress InclinationNoiseFreq;
		editorTemplate -suppress InclinationSamples;
		editorTemplate -suppress InclinationSamplesDirty;
		editorTemplate -suppress Influence;
		editorTemplate -suppress InfluenceMap;
		editorTemplate -suppress InfluenceMapDirty;
		editorTemplate -suppress InfluenceMapMult;
		editorTemplate -suppress InfluenceMapOffset;
		editorTemplate -suppress InfluenceNoise;
		editorTemplate -suppress InfluenceNoiseFreq;
		editorTemplate -suppress InfluenceSamples;
		editorTemplate -suppress InfluenceSamplesDirty;
		editorTemplate -suppress Length;
		editorTemplate -suppress LengthMap;
		editorTemplate -suppress LengthMapDirty;
		editorTemplate -suppress LengthMapMult;
		editorTemplate -suppress LengthMapOffset;
		editorTemplate -suppress LengthNoise;
		editorTemplate -suppress LengthNoiseFreq;
		editorTemplate -suppress LengthSamples;
		editorTemplate -suppress LengthSamplesDirty;
		editorTemplate -suppress Offset;
		editorTemplate -suppress OffsetMap;
		editorTemplate -suppress OffsetMapDirty;
		editorTemplate -suppress OffsetMapMult;
		editorTemplate -suppress OffsetMapOffset;
		editorTemplate -suppress OffsetNoise;
		editorTemplate -suppress OffsetNoiseFreq;
		editorTemplate -suppress OffsetSamples;
		editorTemplate -suppress OffsetSamplesDirty;
		editorTemplate -suppress Polar;
		editorTemplate -suppress PolarMap;
		editorTemplate -suppress PolarMapDirty;
		editorTemplate -suppress PolarMapMult;
		editorTemplate -suppress PolarMapOffset;
		editorTemplate -suppress PolarNoise;
		editorTemplate -suppress PolarNoiseFreq;
		editorTemplate -suppress PolarSamples;
		editorTemplate -suppress PolarSamplesDirty;
		editorTemplate -suppress Power;
		editorTemplate -suppress PowerMap;
		editorTemplate -suppress PowerMapDirty;
		editorTemplate -suppress PowerMapMult;
		editorTemplate -suppress PowerMapOffset;
		editorTemplate -suppress PowerNoise;
		editorTemplate -suppress PowerNoiseFreq;
		editorTemplate -suppress PowerSamples;
		editorTemplate -suppress PowerSamplesDirty;
		editorTemplate -suppress Radius;
		editorTemplate -suppress RadiusMap;
		editorTemplate -suppress RadiusMapDirty;
		editorTemplate -suppress RadiusMapMult;
		editorTemplate -suppress RadiusMapOffset;
		editorTemplate -suppress RadiusNoise;
		editorTemplate -suppress RadiusNoiseFreq;
		editorTemplate -suppress RadiusSamples;
		editorTemplate -suppress RadiusSamplesDirty;
		editorTemplate -suppress Roll;
		editorTemplate -suppress RollMap;
		editorTemplate -suppress RollMapDirty;
		editorTemplate -suppress RollMapMult;
		editorTemplate -suppress RollMapOffset;
		editorTemplate -suppress RollNoise;
		editorTemplate -suppress RollNoiseFreq;
		editorTemplate -suppress RollSamples;
		editorTemplate -suppress RollSamplesDirty;
		editorTemplate -suppress Scraggle;
		editorTemplate -suppress ScraggleCorrelation;
		editorTemplate -suppress ScraggleCorrelationMap;
		editorTemplate -suppress ScraggleCorrelationMapDirty;
		editorTemplate -suppress ScraggleCorrelationMapMult;
		editorTemplate -suppress ScraggleCorrelationMapOffset;
		editorTemplate -suppress ScraggleCorrelationNoise;
		editorTemplate -suppress ScraggleCorrelationNoiseFreq;
		editorTemplate -suppress ScraggleCorrelationSamples;
		editorTemplate -suppress ScraggleCorrelationSamplesDirty;
		editorTemplate -suppress ScraggleFrequency;
		editorTemplate -suppress ScraggleFrequencyMap;
		editorTemplate -suppress ScraggleFrequencyMapDirty;
		editorTemplate -suppress ScraggleFrequencyMapMult;
		editorTemplate -suppress ScraggleFrequencyMapOffset;
		editorTemplate -suppress ScraggleFrequencyNoise;
		editorTemplate -suppress ScraggleFrequencyNoiseFreq;
		editorTemplate -suppress ScraggleFrequencySamples;
		editorTemplate -suppress ScraggleFrequencySamplesDirty;
		editorTemplate -suppress ScraggleMap;
		editorTemplate -suppress ScraggleMapDirty;
		editorTemplate -suppress ScraggleMapMult;
		editorTemplate -suppress ScraggleMapOffset;
		editorTemplate -suppress ScraggleNoise;
		editorTemplate -suppress ScraggleNoiseFreq;
		editorTemplate -suppress ScraggleSamples;
		editorTemplate -suppress ScraggleSamplesDirty;
		editorTemplate -suppress Segments;
		editorTemplate -suppress SegmentsMap;
		editorTemplate -suppress SegmentsMapDirty;
		editorTemplate -suppress SegmentsMapMult;
		editorTemplate -suppress SegmentsMapOffset;
		editorTemplate -suppress SegmentsNoise;
		editorTemplate -suppress SegmentsNoiseFreq;
		editorTemplate -suppress SegmentsSamples;
		editorTemplate -suppress SegmentsSamplesDirty;
		editorTemplate -suppress SpecularColorMap;
		editorTemplate -suppress SpecularColorMapDirty;
		editorTemplate -suppress SpecularColorNoise;
		editorTemplate -suppress SpecularColorNoiseFreq;
		editorTemplate -suppress SpecularColorSamples;
		editorTemplate -suppress SpecularColorSamplesDirty;
		editorTemplate -suppress SpecularSharpness;
		editorTemplate -suppress SpecularSharpnessMap;
		editorTemplate -suppress SpecularSharpnessMapDirty;
		editorTemplate -suppress SpecularSharpnessMapMult;
		editorTemplate -suppress SpecularSharpnessMapOffset;
		editorTemplate -suppress SpecularSharpnessNoise;
		editorTemplate -suppress SpecularSharpnessNoiseFreq;
		editorTemplate -suppress SpecularSharpnessSamples;
		editorTemplate -suppress SpecularSharpnessSamplesDirty;
		editorTemplate -suppress StartLength;
		editorTemplate -suppress StartLengthMap;
		editorTemplate -suppress StartLengthMapDirty;
		editorTemplate -suppress StartLengthMapMult;
		editorTemplate -suppress StartLengthMapOffset;
		editorTemplate -suppress StartLengthNoise;
		editorTemplate -suppress StartLengthNoiseFreq;
		editorTemplate -suppress StartLengthSamples;
		editorTemplate -suppress StartLengthSamplesDirty;
		editorTemplate -suppress ThresholdLength;
		editorTemplate -suppress ThresholdLengthMap;
		editorTemplate -suppress ThresholdLengthMapDirty;
		editorTemplate -suppress ThresholdLengthMapMult;
		editorTemplate -suppress ThresholdLengthMapOffset;
		editorTemplate -suppress ThresholdLengthNoise;
		editorTemplate -suppress ThresholdLengthNoiseFreq;
		editorTemplate -suppress ThresholdLengthSamples;
		editorTemplate -suppress ThresholdLengthSamplesDirty;
		editorTemplate -suppress TipAmbientColorMap;
		editorTemplate -suppress TipAmbientColorMapDirty;
		editorTemplate -suppress TipAmbientColorNoise;
		editorTemplate -suppress TipAmbientColorNoiseFreq;
		editorTemplate -suppress TipAmbientColorSamples;
		editorTemplate -suppress TipAmbientColorSamplesDirty;
		editorTemplate -suppress TipColorMap;
		editorTemplate -suppress TipColorMapDirty;
		editorTemplate -suppress TipColorNoise;
		editorTemplate -suppress TipColorNoiseFreq;
		editorTemplate -suppress TipColorSamples;
		editorTemplate -suppress TipColorSamplesDirty;
		editorTemplate -suppress TipCurl;
		editorTemplate -suppress TipCurlMap;
		editorTemplate -suppress TipCurlMapDirty;
		editorTemplate -suppress TipCurlMapMult;
		editorTemplate -suppress TipCurlMapOffset;
		editorTemplate -suppress TipCurlNoise;
		editorTemplate -suppress TipCurlNoiseFreq;
		editorTemplate -suppress TipCurlSamples;
		editorTemplate -suppress TipCurlSamplesDirty;
		editorTemplate -suppress TipOpacity;
		editorTemplate -suppress TipOpacityMap;
		editorTemplate -suppress TipOpacityMapDirty;
		editorTemplate -suppress TipOpacityMapMult;
		editorTemplate -suppress TipOpacityMapOffset;
		editorTemplate -suppress TipOpacityNoise;
		editorTemplate -suppress TipOpacityNoiseFreq;
		editorTemplate -suppress TipOpacitySamples;
		editorTemplate -suppress TipOpacitySamplesDirty;
		editorTemplate -suppress TipWidth;
		editorTemplate -suppress TipWidthMap;
		editorTemplate -suppress TipWidthMapDirty;
		editorTemplate -suppress TipWidthMapMult;
		editorTemplate -suppress TipWidthMapOffset;
		editorTemplate -suppress TipWidthNoise;
		editorTemplate -suppress TipWidthNoiseFreq;
		editorTemplate -suppress TipWidthSamples;
		editorTemplate -suppress TipWidthSamplesDirty;
		editorTemplate -suppress Unused;
		editorTemplate -suppress UnusedMap;
		editorTemplate -suppress UnusedMapDirty;
		editorTemplate -suppress UnusedMapMult;
		editorTemplate -suppress UnusedMapOffset;
		editorTemplate -suppress UnusedNoise;
		editorTemplate -suppress UnusedNoiseFreq;
		editorTemplate -suppress UnusedSamples;
		editorTemplate -suppress UnusedSamplesDirty;
		editorTemplate -suppress antialiasingLevel;
		editorTemplate -suppress attractorGlobalScale;
		editorTemplate -suppress compInstObjGroups;
		editorTemplate -suppress curveAttractorGlobalScale;
		editorTemplate -suppress depthJitter;
		editorTemplate -suppress exportAttr;
		editorTemplate -suppress exportFile;
		editorTemplate -suppress exportHeight;
		editorTemplate -suppress exportWidth;
		editorTemplate -suppress furGlobalScale;
		editorTemplate -suppress furStartPosition;
		editorTemplate -suppress furUseStartPosition;
		editorTemplate -suppress geometryAntialiasingOverride;
		editorTemplate -suppress ignoreSelfShadowing;
		editorTemplate -suppress inputCurve;
		editorTemplate -suppress inputMesh;
		editorTemplate -suppress inputSubdiv;
		editorTemplate -suppress inputSurface;
		editorTemplate -suppress localScale;
		editorTemplate -suppress realUSamples;
		editorTemplate -suppress realVSamples;

	AEshapeTemplate $nodeName;
	editorTemplate -addExtraControls;

    editorTemplate -endScrollLayout;
}
//
// reuse the stuff from the hair description attribute editor
//

global proc AEAttractorsBakeMenu()
{
	global string $HfAttractorAttrUiNames[];

	createBakeOptionMenu( $HfAttractorAttrUiNames );
}

global proc AEAttractorsBakeButtonCB(
	string	$node,
	string	$parent
)
{
	global string $HfAttractorAttributes[];

	bakeAttrCB( $HfAttractorAttributes, $node, $parent );
}

global proc AEFurAttractorsTemplate(
	string	$nodeName
)
{
	global string $HfAttractorAttributes[];
	global string $HfAttractorAttrUiNames[];

	int	$numAttractorAttributes = size($HfAttractorAttributes);
	int	$a;

    editorTemplate -beginScrollLayout;

		editorTemplate -addControl "AttractorModel";
		editorTemplate -addControl "AttractorsPerHair";
		editorTemplate -addControl "GlobalScale";

		editorTemplate -callCustom
			"AEHairDescGeneralNew AEAttractorsBakeMenu AEAttractorsBakeButtonCB"
			"AEHairDescGeneralReplace AEAttractorsBakeButtonCB"
			message;

		for ( $a = 0; $a < $numAttractorAttributes; $a++ ) {
			string	$attr = hairDefaultAttr($HfAttractorAttributes[$a]);
			editorTemplate -addControl $attr;
		}

		editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kDetails"));
		for ( $a = 0; $a < $numAttractorAttributes; $a++ ) {
			generateHairAttrDetails(
				$HfAttractorAttrUiNames[$a],$HfAttractorAttributes[$a]
			);
		}
		editorTemplate -endLayout;

        // include/call base class/node attributes
        AEdependNodeTemplate $nodeName;

        editorTemplate -addExtraControls;

		editorTemplate -suppress dagSetMembers;
		editorTemplate -suppress attractors;
		editorTemplate -suppress furGlobals;
		editorTemplate -suppress RadiusMapFile;
		editorTemplate -suppress RadiusMapUSamples;
		editorTemplate -suppress RadiusMapVSamples;
		editorTemplate -suppress PowerMapFile;
		editorTemplate -suppress PowerMapUSamples;
		editorTemplate -suppress PowerMapVSamples;
		editorTemplate -suppress InfluenceMapFile;
		editorTemplate -suppress InfluenceMapUSamples;
		editorTemplate -suppress InfluenceMapVSamples;
		editorTemplate -suppress StartLengthMapFile;
		editorTemplate -suppress StartLengthMapUSamples;
		editorTemplate -suppress StartLengthMapVSamples;
		editorTemplate -suppress EndLengthMapFile;
		editorTemplate -suppress EndLengthMapUSamples;
		editorTemplate -suppress EndLengthMapVSamples;
		editorTemplate -suppress ThresholdLengthMapFile;
		editorTemplate -suppress ThresholdLengthMapUSamples;
		editorTemplate -suppress ThresholdLengthMapVSamples;

    editorTemplate -endScrollLayout;
}
//
// reuse the stuff from the hair description attribute editor
//

global proc AEAttractorsBakeMenu()
{
	global string $HfCurveAttractorAttrUiNames[];

	createBakeOptionMenu( $HfCurveAttractorAttrUiNames );
}

global proc AEAttractorsBakeButtonCB(
	string	$node,
	string	$parent
)
{
	global string $HfCurveAttractorAttributes[];

	bakeAttrCB( $HfCurveAttractorAttributes, $node, $parent );
}

global proc HfControlLocalCurve(
	string	$node
)
{
	HfCheckCurvePower("CurveAttractorModel", ($node+".CurveAttractorModel"));
}

global proc AEFurCurveAttractorsTemplate(
	string	$nodeName
)
{
	global string $HfCurveAttractorAttributes[];
	global string $HfCurveAttractorAttrUiNames[];

	int	$numAttractorAttributes = size($HfCurveAttractorAttributes);
	int	$a;

    editorTemplate -beginScrollLayout;

		editorTemplate -label (uiRes("m_FurPluginCreateUI.kAttractorModel")) -addControl "CurveAttractorModel" "HfControlLocalCurve";
		editorTemplate -label (uiRes("m_FurPluginCreateUI.kCurvesPerFur")) -addControl "CurveAttractorsPerHair";
		editorTemplate -label (uiRes("m_FurPluginCreateUI.kGlobalScale")) -addControl "CurveGlobalScale";

		editorTemplate -callCustom
			"AEHairDescGeneralNew AEAttractorsBakeMenu AEAttractorsBakeButtonCB"
			"AEHairDescGeneralReplace AEAttractorsBakeButtonCB"
			message;

		for ( $a = 0; $a < $numAttractorAttributes; $a++ ) {
			string	$attr = hairDefaultAttr($HfCurveAttractorAttributes[$a]);
			string	$lab  = $HfCurveAttractorAttrUiNames[$a];
			editorTemplate -label $lab -addControl $attr;
		}

		editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kDetails"));
		for ( $a = 0; $a < $numAttractorAttributes; $a++ ) {
			if(hairDefaultAttr($HfCurveAttractorAttributes[$a]) != "CurvePower")
				generateHairAttrDetails($HfCurveAttractorAttrUiNames[$a],$HfCurveAttractorAttributes[$a]);
			else
				generateHairCurvePowerAttrDetails($HfCurveAttractorAttrUiNames[$a],$HfCurveAttractorAttributes[$a]);
		}
		editorTemplate -endLayout;

        // include/call base class/node attributes
        AEdependNodeTemplate $nodeName;
 
		editorTemplate -suppress dagSetMembers;
		editorTemplate -suppress curveAttractors;
		editorTemplate -suppress furGlobals;
		editorTemplate -suppress CurveRadiusMapFile;
		editorTemplate -suppress CurveRadiusMapUSamples;
		editorTemplate -suppress CurveRadiusMapVSamples;
		editorTemplate -suppress CurvePowerMapFile;
		editorTemplate -suppress CurvePowerMapUSamples;
		editorTemplate -suppress CurvePowerMapVSamples;
		editorTemplate -suppress CurveInfluenceMapFile;
		editorTemplate -suppress CurveInfluenceMapUSamples;
		editorTemplate -suppress CurveInfluenceMapVSamples;
		editorTemplate -suppress CurveStartLengthMapFile;
		editorTemplate -suppress CurveStartLengthMapUSamples;
		editorTemplate -suppress CurveStartLengthMapVSamples;
		editorTemplate -suppress CurveEndLengthMapFile;
		editorTemplate -suppress CurveEndLengthMapUSamples;
		editorTemplate -suppress CurveEndLengthMapVSamples;
		editorTemplate -suppress CurveThresholdLengthMapFile;
		editorTemplate -suppress CurveThresholdLengthMapUSamples;
		editorTemplate -suppress CurveThresholdLengthMapVSamples;

        editorTemplate -addExtraControls;

    editorTemplate -endScrollLayout;
}

global proc AEfurGlobalsEqualizerNew( string $dummy, string $attrName )
{
	string $list[];
	tokenize( $attrName, ".", $list);

	if (!`attributeQuery -ex -node $list[0] "equalMap"`)
	{
		string	$parent = `setParent -q`;
		if ( `optionMenuGrp -exists ($parent + "|furGlobalEqualMenu")` ) 
		{
			deleteUI ($parent + "|furGlobalEqualMenu");
		}
		return;
	}

	setUITemplate -pst attributeEditorTemplate;

	optionMenuGrp -label (uiRes("m_FurPluginCreateUI.kEqualizerMaps2"))
		-cc ("AEFurGlobalsCheckReadEqualMap "+$list[0]) furGlobalEqualMenu;

		menuItem -label (uiRes("m_FurPluginCreateUI.kNoEqualizerMaps"))	   -data 0;
		menuItem -label (uiRes("m_FurPluginCreateUI.kDefaultEqualizerMaps"))   -data 1;		
		menuItem -label (uiRes("m_FurPluginCreateUI.kCustomEqualizerMaps"))    -data 2;
		
	connectControl -index 2 furGlobalEqualMenu $attrName;

	setUITemplate -ppt;
}

global proc AEfurGlobalsEqualizerReplace( string $dummy, string $attrName )
{	
	string $list[];
	string $parent = `setParent -q`;
	tokenize( $attrName, ".", $list);

	// If the control doesn't exist, create it.
	//
	if ( !`optionMenuGrp -ex ($parent + "|furGlobalEqualMenu")`)
	{
		AEfurGlobalsEqualizerNew($dummy,$attrName);
	}
	else 
	{
		if (!`attributeQuery -ex -node $list[0] "equalMap"`)
		{
			deleteUI furGlobalEqualMenu;
		}
		else 
		{
			connectControl -index 2 furGlobalEqualMenu $attrName;
		}
	}
}

global proc createEqualMapAttr()
{
	string $furGlobal = HfBuildHairGlobal();
	if(!`attributeQuery -ex -node $furGlobal "createEqualMap"`)
		addAttr -at bool -ln "createEqualMap" -dv false $furGlobal;
	setAttr ($furGlobal+ ".createEqualMap") true;
}

global proc HfMapSizeChanged(string $attrPlug)
{
	int     $width    = `getAttr $attrPlug`;
	intFieldGrp -e -value1 $width equalizerMapWidthField;	
	
	$attrPlug = plugNode( $attrPlug )+".equalizerMapHeight";
	int     $height    = `getAttr $attrPlug`;
	intFieldGrp -e -value1 $height equalizerMapHeightField;	
	
	createEqualMapAttr();
}

//  Need to be able specify equalizer maps size. (incl. larger than 256) 
global proc AEfurGlobalsEqualizerMapWidthNew(
	string	$uiName,
	string	$attrPlug
)
{
	string	$attrName = plugAttr( $attrPlug );
	intFieldGrp -label $uiName -cc createEqualMapAttr ($attrName + "Field");
	AEfurGlobalsEqualizerMapWidthReplace( $uiName, $attrPlug );
	
	string	$script = "HfMapSizeChanged " + $attrPlug;
	addAttrChangedScriptJob( `scriptJob -ac $attrPlug $script` );
}

global proc AEfurGlobalsEqualizerMapWidthReplace(
	string	$uiName,
	string	$attrPlug
)
{

	string	$attrName = plugAttr( $attrPlug );
	connectControl -index 2 ($attrName + "Field") $attrPlug;
}

global proc AEfurGlobalsEqualizerMapHeightNew(
	string	$uiName,
	string	$attrPlug
)
{
	string	$attrName = plugAttr( $attrPlug );
	intFieldGrp -label $uiName -cc createEqualMapAttr ($attrName + "Field");
	AEfurGlobalsEqualizerMapWidthReplace( $uiName, $attrPlug );
}

global proc AEfurGlobalsEqualizerMapHeightReplace(
	string	$uiName,
	string	$attrPlug
)
{

	string	$attrName = plugAttr( $attrPlug );
	connectControl -index 2 ($attrName + "Field") $attrPlug;
}

global proc AEfurGlobalsUseFrameNew(
	string	$uiName,
	string	$attrPlug
)
{
	string	$attrName = plugAttr( $attrPlug );
	floatFieldGrp -label $uiName ($attrName + "Field");
	AEfurGlobalsEqualizerMapWidthReplace( $uiName, $attrPlug );
}

global proc AEfurGlobalsUseFrameReplace(
	string	$uiName,
	string	$attrPlug
)
{

	string	$attrName = plugAttr( $attrPlug );
	connectControl -index 2 ($attrName + "Field") $attrPlug;
}

global proc AEfurGlobalsCopyAttrMapsNew( string $dummy, string $attrName )
{
	string $list[];
	string $attrOnly;
	tokenize( $attrName, ".", $list);
	if ( size($list) > 1 ) {
		$attrOnly = $list[1];
	} else {
		$attrOnly = "copyAttrMaps";
	}

	if (!`attributeQuery -ex -node $list[0] $attrOnly`)
	{
		string	$parent = `setParent -q`;
		if ( `optionMenuGrp -exists ($parent + "|furGlobalCopyMenu")` ) 
		{
			deleteUI ($parent + "|furGlobalEqualMenu");
		}
		return;
	}

	setUITemplate -pst attributeEditorTemplate;

	optionMenuGrp -label (uiRes("m_FurPluginCreateUI.kCopyAttrMaps")) furGlobalCopyMenu;
		menuItem -label (uiRes("m_FurPluginCreateUI.kUnlessReferenced"))	-data 0;
		menuItem -label (uiRes("m_FurPluginCreateUI.kAlways"))					-data 1;
		menuItem -label (uiRes("m_FurPluginCreateUI.kNever"))						-data 2;
		
	connectControl -index 2 furGlobalCopyMenu $attrName;

	setUITemplate -ppt;
}

global proc AEfurGlobalsCopyAttrMapsReplace( string $dummy, string $attrName )
{
	string $list[];
	string $parent = `setParent -q`;
	tokenize( $attrName, ".", $list);
	string $attrOnly;
	if ( size($list) > 1 ) {
		$attrOnly = $list[1];
	} else {
		$attrOnly = "copyAttrMaps";
	}

	// If the control doesn't exist, create it.
	//
	if ( !`optionMenuGrp -ex ($parent + "|furGlobalCopyMenu")`)
	{
		AEfurGlobalsCopyAttrMapsNew($dummy,$attrName);
	}
	else 
	{
		if (!`attributeQuery -ex -node $list[0] $attrOnly`)
		{
			deleteUI furGlobalCopyMenu;
		}
		else
		{
			connectControl -index 2 furGlobalCopyMenu $attrName;
		}
	}
}

global proc AEFurGlobalsCheckReadFurImagePath (string $nodeName)
{
	int $method = `getAttr ($nodeName+".readFurImage")`;
	
	if(`textField -q -ex readFurImagePathField`)
	{
		if ($method) 
			textField -e -en true readFurImagePathField;
		else
			textField -e -en false readFurImagePathField;
	}
}

global proc AEFurGlobalsCheckReadFurFilesPath (string $nodeName)
{
	int $method = `getAttr ($nodeName+".readFurFiles")`;
	
	if(`textField -q -ex readFurFilesPathField`)
	{
		if ($method) 
					textField -e -en true readFurFilesPathField;		
		else
			textField -e -en false readFurFilesPathField;
	}
}

global proc AEFurGlobalsCheckReadShadowMapPath (string $nodeName)
{
	int $method = `getAttr ($nodeName+".readShadowMap")`;
	
	if(`textField -q -ex readShadowMapPathField`)
	{
		if ($method) 
			textField -e -en true readShadowMapPathField;
		else
			textField -e -en false readShadowMapPathField;
	}
}

global proc AEFurGlobalsCheckUseFrame(string $nodeName)
{
	int $areaVal = `getAttr ($nodeName+".areaValue")`;
	int $equalVal= `getAttr ($nodeName+".equalMap")`;
	
	if($areaVal == "0" && $equalVal == 0)
	{
		editorTemplate -dimControl $nodeName "useFrame" true;
	}
	else
	{
		editorTemplate -dimControl $nodeName "useFrame" false;
	}
	if($equalVal == 0)
	{
		editorTemplate -dimControl $nodeName "equalizerMapWidth" true;
		editorTemplate -dimControl $nodeName "equalizerMapHeight" true;	
	}
	else
	{
		editorTemplate -dimControl $nodeName "equalizerMapWidth" false;
		editorTemplate -dimControl $nodeName "equalizerMapHeight" false;	
	}
}

global proc AEFurGlobalsCheckReadEqualMap (string $nodeName)
{
	int $method = `getAttr ($nodeName+".equalMap")`;
	global int	$validMap;
	string $mayaFurRenderer = (uiRes("m_FurPluginCreateUI.kMayaFurRenderer"));
	
	// Check Project Directory
	HfCheckProjectDir;

	// Read Equal Map AND Custom Equal Map
	if($method == 2)
	{
		if(!`inBatchMode`)
		{
			string $baseName = HfGetBaseName();
			if($baseName =="")
			{
				CompleteProgress();
				string $nodeName = HfBuildHairGlobal();
	 			string $cmd = "setAttr " + $nodeName + ".equalMap 1";
				eval $cmd;
				
				// Dim control for Custom Equalizer attribute
				HfDimCustomEqualizer(true);
				AEFurGlobalsCheckUseFrame($nodeName);
				print($mayaFurRenderer);
				return;
			}
			else
			{
                //If Read Equalizer Prefix is "untitled" or ""(NULL)
                //sceneName will be used as prefix for Equalizer map. 
                //
				string	$hairGlobals = HfBuildHairGlobal();
				$hairGlobals +=".readEqualMapPath";
				string $tmpPath = `getAttr ($hairGlobals)`;				
				
				if($tmpPath !="")
					$tmpPath = basename($tmpPath,"");
					
				if( $tmpPath == (untitledFileName()) || $tmpPath == "")
				{
					$baseName = HfGetFileName($baseName);
					string $eqMapPath = getProjectDir("fileRule", "furEqualMap")  + "/" + $baseName;
					setAttr -type "string" ($hairGlobals) $eqMapPath;
				}			
			}
        }
	}

	if ($method == 2) //Custom Equal Map
	{
		string $cmd = "setAttr " + $nodeName + ".equalMap 2";
		eval $cmd;              
		// Dim control for Custom Equalizer attribute
		HfDimCustomEqualizer(false);

		//Find default Equalizer map directory 
		string $strEqualMap = HfGetSceneName();
		string $eqMapPath = getTheProjectDir()+"/";
		$eqMapPath += getProjectDir("fileRule", "furEqualMap")  + "/" + $strEqualMap;
                
		//Generate equal map
		buildFurImages -ce $eqMapPath 0 1;
		HfCopyDeleteCustomEqualizer;
		
		ProcessStatus(10);
		
		CompleteProgress();
		print($mayaFurRenderer);
	}
	else if ($method == 1)   //Default Equal Map
	{
		$cmd = "setAttr " + $nodeName + ".equalMap 1";
		eval $cmd; 
		
		// Dim control for Custom Equalizer attribute
		HfDimCustomEqualizer(true);
		
		string	$hairGlobals = HfBuildHairGlobal();
		$hairGlobals +=".readEqualMapPath";
		string $sceneName = HfGetSceneName();
		string $eqMapPath = getProjectDir("fileRule", "furEqualMap")  + "/" + $sceneName;
		setAttr -type "string" ($hairGlobals) $eqMapPath;
	}
	else
	{
		$cmd = "setAttr " + $nodeName + ".equalMap 0";
		evalDeferred $cmd; 
        
        // Dim control for Custom Equalizer attribute
        HfDimCustomEqualizer(true);
	}

	string $furDescs[] = `ls -type "FurDescription"`;
	for( $fur in $furDescs )
	{
		float $lengthAttr = `getAttr ($fur+".Length")`;
		setAttr  ($fur+".Length") $lengthAttr;
	}
	AEFurGlobalsCheckUseFrame($nodeName);

}

global proc HfDimCustomEqualizer(int $status)
{
	string $furDesc[] = `ls -l -type "FurDescription"`;
	int $count;
	for($count=0;$count<size($furDesc); $count++)
	{
		string $cmd = "editorTemplate -dimControl "+$furDesc[$count]+"\"CustomEqualizer\" "+$status;
		evalDeferred $cmd;
	}
}

global proc HfFurGlobalCheck()
{
	string $furGlobal[] = `ls -type "FurGlobals"`;
	if( size($furGlobal) == 0 )
	{
		HfDimCustomEqualizer(true);
	}
	else
	{
		int $equalType = `getAttr ("defaultFurGlobals.equalMap")`;
		if($equalType != 2)
		{
			HfDimCustomEqualizer(true);	
		}
		else
		{
			HfDimCustomEqualizer(false);
		}
	}
}

global proc AEfurGlobalsReadFurFilesPathNew (string $dummy, string $fileAttribute)
{
  	string $list[];
 	tokenize( $fileAttribute, ".", $list);
 	
 	if(! `attributeQuery -ex -node $list[0] "readFurFilesPath" ` )
 	{
 		string	$parent = `setParent -q`;
		if ( `rowLayout -q -exists ($parent + "|furFilesPathLayout")` ) {
			deleteUI ($parent + "|furFilesPathLayout");
		}
		return;
 	}
	
 	setUITemplate -pst attributeEditorTemplate;
 	
	rowLayout -nc 2 furFilesPathLayout;
 	text -label (uiRes("m_FurPluginCreateUI.kFurGlobalFurFilesPath"));
 	textField readFurFilesPathField;
 	
	setParent ..;
 	
	setUITemplate -ppt;
	
	connectControl -fileName readFurFilesPathField $fileAttribute;

    AEfurGlobalsReadFurFilesPathReplace $dummy $fileAttribute;
}

global proc AEfurGlobalsReadFurFilesPathReplace (string $dummy, string $fileAttribute)
{
 	string $list[];
 	tokenize( $fileAttribute, ".", $list);
 	string $parent = `setParent -q`;
 	 
 	if ( !`rowLayout -q -exists ($parent + "|furFilesPathLayout")`){
		AEfurGlobalsReadFurFilesPathNew($dummy,$fileAttribute);
	} else {
		if (!`attributeQuery -ex -node $list[0] "readFurFilesPath"`){
			deleteUI furFilesPathLayout;
		} else {
    		connectControl -fileName readFurFilesPathField $fileAttribute;
  		}
	}
}

global proc AEfurGlobalsReadShadowMapPathNew (string $dummy, string $fileAttribute)
{
  	string $list[];
 	tokenize( $fileAttribute, ".", $list);
 	
 	if(! `attributeQuery -ex -node $list[0] "readShadowMapPath" ` )
 	{
 		string	$parent = `setParent -q`;
		if ( `rowLayout -q -exists ($parent + "|shadowMapPathLayout")` ) {
			deleteUI ($parent + "|shadowMapPathLayout");
		}
		return;
 	}
	
 	setUITemplate -pst attributeEditorTemplate;
 	
	rowLayout -nc 2 shadowMapPathLayout;
 	text -label (uiRes("m_FurPluginCreateUI.kFurGlobalShadowMapsPath"));
 	textField readShadowMapPathField;
 	
	setParent ..;
 	
	setUITemplate -ppt;
	
	connectControl -fileName readShadowMapPathField $fileAttribute;

    AEfurGlobalsReadShadowMapPathReplace $dummy $fileAttribute;
}

global proc AEfurGlobalsReadShadowMapPathReplace (string $dummy, string $fileAttribute)
{
 	string $list[];
 	tokenize( $fileAttribute, ".", $list);
 	string $parent = `setParent -q`;
 	 
 	if ( !`rowLayout -q -exists ($parent + "|shadowMapPathLayout")`){
		AEfurGlobalsReadShadowMapPathNew($dummy,$fileAttribute);
	} else {
		if (!`attributeQuery -ex -node $list[0] "readShadowMapPath"`){
			deleteUI shadowMapPathLayout;
		} else {
    		connectControl -fileName readShadowMapPathField $fileAttribute;
  		}
	}
}

global proc AEfurGlobalsReadFurImagePathNew (string $dummy, string $fileAttribute)
{
  	string $list[];
 	tokenize( $fileAttribute, ".", $list);
 	
 	if(! `attributeQuery -ex -node $list[0] "readFurImagePath" ` )
 	{
 		string	$parent = `setParent -q`;
		if ( `rowLayout -q -exists ($parent + "|furImagePathLayout")` ) {
			deleteUI ($parent + "|furImagePathLayout");
		}
		return;
 	}
	
 	setUITemplate -pst attributeEditorTemplate;
 	
	rowLayout -nc 2 furImagePathLayout;
 	text -label (uiRes("m_FurPluginCreateUI.kFurGlobalsFurImagesPath"));
 	textField readFurImagePathField;
 	
	setParent ..;
 	
	setUITemplate -ppt;
	
	connectControl -fileName readFurImagePathField $fileAttribute;

    AEfurGlobalsReadFurImagePathReplace $dummy $fileAttribute;
}

global proc AEfurGlobalsReadFurImagePathReplace (string $dummy, string $fileAttribute)
{
 	string $list[];
 	tokenize( $fileAttribute, ".", $list);
 	string $parent = `setParent -q`;
 	 
 	if ( !`rowLayout -q -exists ($parent + "|furImagePathLayout")`){
		AEfurGlobalsReadFurImagePathNew($dummy,$fileAttribute);
	} else {
		if (!`attributeQuery -ex -node $list[0] "readFurImagePath"`){
			deleteUI furImagePathLayout;
		} else {
    		connectControl -fileName readFurImagePathField $fileAttribute;
  		}
	}
}

global proc AEFurGlobalsTemplate(
	string	$nodeName
)
{
	string $hairPerPixel = (uiRes("m_FurPluginCreateUI.kHairsPerPixel"));
    editorTemplate -beginScrollLayout;

		editorTemplate -addSeparator;

	    editorTemplate -label (uiRes("m_FurPluginCreateUI.kEnableFur")) -addControl "renderFur";

		editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kFurRenderOptions"));
		    editorTemplate -label (uiRes("m_FurPluginCreateUI.kCalcAreaValues")) -addControl "areaValue" AEFurGlobalsCheckUseFrame;
		    editorTemplate -callCustom 
			    ("AEfurGlobalsEqualizerNew dummy") 
			    ("AEfurGlobalsEqualizerReplace dummy") "equalMap";
			string $label = (uiRes("m_FurPluginCreateUI.kEqualizerMapWidth"));
		    editorTemplate -callCustom
			    ("AEfurGlobalsEqualizerMapWidthNew \""+$label+"\"")
			    ("AEfurGlobalsEqualizerMapWidthReplace \""+$label+"\"") "equalizerMapWidth";
			$label = (uiRes("m_FurPluginCreateUI.kEqualizerMapHeight"));   
		    editorTemplate -callCustom
			    ("AEfurGlobalsEqualizerMapHeightNew \""+$label+"\"")
			    ("AEfurGlobalsEqualizerMapHeightReplace \""+$label+"\"")	"equalizerMapHeight";
		    editorTemplate -label (uiRes("m_FurPluginCreateUI.kEqualizerMapFillBackground")) -addControl "equalizerFillBackground";
			$label = (uiRes("m_FurPluginCreateUI.kUseFrame"));
		    editorTemplate -callCustom
			    ("AEfurGlobalsUseFrameNew \""+$label+"\"")
			    ("AEfurGlobalsUseFrameReplace \""+$label+"\"") "useFrame";
		    editorTemplate -addSeparator;
		    editorTemplate -beginNoOptimize;
			editorTemplate -label (uiRes("m_FurPluginCreateUI.kCompFur")) -addControl "compFur";
		    editorTemplate -label (uiRes("m_FurPluginCreateUI.kKeepTempFiles")) -addControl "keepIntermediateFiles";
			editorTemplate -endNoOptimize;
		    editorTemplate -addControl "keepFurImages";
		    editorTemplate -callCustom
			    ("AEfurGlobalsCopyAttrMapsNew dummy")
			    ("AEfurGlobalsCopyAttrMapsReplace dummy") "copyAttrMaps";
		    
		    editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kAdvancedOptions"));
				editorTemplate -beginNoOptimize;
				editorTemplate -label (uiRes("m_FurPluginCreateUI.kEnableFurImageRen")) -addControl "renderFurImages"; 
				editorTemplate -label (uiRes("m_FurPluginCreateUI.kEnableFurShading")) -addControl "renderShadowMaps"; 
				editorTemplate -label (uiRes("m_FurPluginCreateUI.kDisableMayaRender")) -addControl "disableGeometryRendering"; 
				editorTemplate -label (uiRes("m_FurPluginCreateUI.kAutoBackShadeSpotlights")) -addControl "enableBackShadeSpotLight"; 
				editorTemplate -endNoOptimize;
				editorTemplate -addControl "nurbsTesselation";
				editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kFurImageRendering"));
					editorTemplate -label $hairPerPixel -addControl "furPixelBufferSize";
					editorTemplate -label (uiRes("m_FurPluginCreateUI.kUseFurShading")) -addControl "shadowFur";
				editorTemplate -endLayout;
				editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kShadowMapRendering"));
					editorTemplate -label $hairPerPixel -addControl "shadowPixelBufferSize";
				editorTemplate -endLayout;
		    editorTemplate -endLayout;
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kReferencePaths"));			
	  	    editorTemplate -addControl "readFurFiles" "AEFurGlobalsCheckReadFurFilesPath";
			editorTemplate -callCustom 
				("AEfurGlobalsReadFurFilesPathNew dummy") 
				("AEfurGlobalsReadFurFilesPathReplace dummy") "readFurFilesPath";

	  	    editorTemplate -label (uiRes("m_FurPluginCreateUI.kFurGlobalsReadShadowMaps")) -addControl "readShadowMap" "AEFurGlobalsCheckReadShadowMapPath";
			editorTemplate -callCustom 
				("AEfurGlobalsReadShadowMapPathNew dummy") 
				("AEfurGlobalsReadShadowMapPathReplace dummy") "readShadowMapPath";
							

	  	    editorTemplate -label (uiRes("m_FurPluginCreateUI.kReadFurImages")) -addControl "readFurImage" "AEFurGlobalsCheckReadFurImagePath";
			editorTemplate -callCustom 
				("AEfurGlobalsReadFurImagePathNew dummy") 
				("AEfurGlobalsReadFurImagePathReplace dummy") "readFurImagePath";
			
		editorTemplate -endLayout;
		
		editorTemplate -suppress "shadowGeometry";
                        editorTemplate -suppress "readEqualMap";
			editorTemplate -suppress "callback";
		editorTemplate -suppress "readShadowMapPath";
		editorTemplate -suppress "readFurImagePath";
		editorTemplate -suppress "readEqualMapPath";
		editorTemplate -suppress "includePidInFilename";
		editorTemplate -suppress "projectLocation";

		if(`attributeQuery -exists -node $nodeName "rogl"`)
		{
			editorTemplate -suppress "referencedFurGlobals";
		}
		editorTemplate -suppress "wt";
		editorTemplate -suppress "caching";
		editorTemplate -suppress "nodeState";
		editorTemplate -suppress "furNodeList";

		editorTemplate -addExtraControls;
    AEdependNodeTemplate $nodeName;	
    editorTemplate -endScrollLayout;

	string $plug = $nodeName + ".equalMap";
	scriptJob -attributeChange $plug "HfFurGlobalCheck";	
}
//	This file contains attribute editor code to add extra controls
//	dealing with Maya Fur Shadowing into the various light attribute editors.
//	The Maya light attribute editor scripts call AEFurShading() to add an
//	expand/contract for Fur Shading. 
//

// If the attribute editor is open, see if a form has already
// been created for the spotlight.  If so, delete it.

if ( `window -exists AEWindow` ){
	int	$update = false;
	if ( `formLayout -exists AttrEdspotLightFormLayout` ){
		deleteUI AttrEdspotLightFormLayout;
		$update = true;
	}
	if ( `formLayout -exists AttrEdpointLightFormLayout` ){
		deleteUI AttrEdpointLightFormLayout;
		$update = true;
	}
	if ( `formLayout -exists AttrEddirectionalLightFormLayout` ){
		deleteUI AttrEddirectionalLightFormLayout;
		$update = true;
	}
	if ( `formLayout -exists AttrEdambientLightFormLayout` ){
		deleteUI AttrEdambientLightFormLayout;
		$update = true;
	}
	if ( `formLayout -exists AttrEdareaLightFormLayout` ){
		deleteUI AttrEdareaLightFormLayout;
		$update = true;
	}
	if ( $update ) {
		autoUpdateAttrEd;
	}
}

addDebugTag("AElight");

proc addShadeAttrControl(
	int		$idx
)
{
	string $tag = "AElight";

	global string $HfShadeNameL[];

	if ( $idx >= 0 && $idx < size( $HfShadeNameL ) ) {
		string	$cmd = "editorTemplate ";
		$cmd += "-addControl " + $HfShadeNameL[$idx];

		HfTDebug($tag,"eval " + $cmd);
		eval $cmd;		   
	}
}

proc dimShadeAttrControl(
	string	$node,
	int		$idx,
	int		$dimIt
)
{
	string $tag = "AElight";

	global string $HfShadeNameL[];

	if ( $idx >= 0 && $idx < size( $HfShadeNameL ) ) {
		string	$cmd = "editorTemplate -dimControl " + $node
					 + " " + $HfShadeNameL[$idx] + " " + $dimIt;

		HfTDebug($tag,"eval " + $cmd);
		eval $cmd;		   
	}
}

proc addShadeAttrControls(
	int		$shadeType
)
{
	global int $HfShadeType[];

	int		$a;
	int		$na = size( $HfShadeType );

	for ( $a = 0; $a < $na; $a++ ) {
		if ( $HfShadeType[$a] == $shadeType ) {
			addShadeAttrControl( $a );
		}
	}
}

proc dimShadeAttrControls(
	int		$shadeType,
	string	$node,
	int		$dimIt
)
{
	global int $HfShadeType[];

	int		$a;
	int		$na = size( $HfShadeType );

	for ( $a = 0; $a < $na; $a++ ) {
		if ( $HfShadeType[$a] == $shadeType ) {
			dimShadeAttrControl( $node, $a, $dimIt );
		}
	}
}

global proc checkFurShadingType ( string $nodeName )
{
	string $tag="AElight";
	HfTDebug( $tag, "checkFurShadingType(" + $nodeName + ")");

	if (`attributeQuery -ex -node $nodeName "furShadingType"`){
		int	$allowShadowMaps = `nodeType $nodeName` == "spotLight";
		string $nodeAttr = $nodeName + ".furShadingType";
		int $value = `getAttr $nodeAttr`;
		int	$autoshadeDim, $shadowMapDim;

		switch ( $value ) {
		case 0:
		default:
			// dim everything
			$autoshadeDim = true;
			$shadowMapDim = true;
			break;
		case 1:
			// dim shadow map stuff and undim auto shade
			//
			$autoshadeDim = false;
			$shadowMapDim = true;
			break;
		case 2:
			// dim autoshade stuff and undim shadow map
			//
			$autoshadeDim = true;
			$shadowMapDim = false;
			string $depthMapAttr = $nodeName + ".useDepthMapShadows";
			string $autoFocusAttr= $nodeName + ".useDmapAutoFocus";
			if( `getAttr $depthMapAttr` && `getAttr $autoFocusAttr` )
			{
				string $warningMsg = (uiRes("m_FurPluginCreateUI.kFurShadowsWarn"));
				warning ( $warningMsg );
			}
			break;
		}

		dimShadeAttrControls( 0, $nodeName, $autoshadeDim);
		if ( $allowShadowMaps ) {
			dimShadeAttrControls( 1, $nodeName, $shadowMapDim );
		}
	}
}

//------------------------------------------------------------
// New methods needed by the Maya Fur Attributes
//
global proc AEfurShadingTypeNew ( int $allowShadowMaps, string $attrName )
//
// Add the custom UI for the fur shading type.
//
{
	string $tag="AElight";
	string $list[];
	tokenize( $attrName, ".", $list);

	HfTDebug( $tag, "AEfurShadingTypeNew(" + $attrName + ")");

	if (!`attributeQuery -ex -node $list[0] "furShadingType"`){
		string	$parent = `setParent -q`;
		HfTDebug( $tag, " no furShadingType attribute");
		if ( `optionMenuGrp -exists ($parent + "|furShadingMenu")` ) {
			deleteUI ($parent + "|furShadingMenu");
		}
		return;
	}

	setUITemplate -pst attributeEditorTemplate;

	optionMenuGrp -label (uiRes("m_FurPluginCreateUI.kFurShadingType"))
		-cc ("checkFurShadingType "+$list[0])
		furShadingMenu;

		menuItem -label (uiRes("m_FurPluginCreateUI.kNoShading")) -data 0;
		menuItem -label (uiRes("m_FurPluginCreateUI.kAutoShading")) -data 1;
		if ( $allowShadowMaps ) {
			menuItem -label (uiRes("m_FurPluginCreateUI.kFurShadingShadowMaps")) -data 2;
		}

	connectControl -index 2 furShadingMenu $attrName;

	//
	// Fix for bug #126916:
	// Highlighting of Fur Shading/Shadowing buttons not updated correctly
	// the first time the attribute editor is displayed. Now force it to
	// update using a deferred check.
	//
	evalDeferred( "checkFurShadingType " + $list[0] );
	// End of fix.

	setUITemplate -ppt;
}


global proc AEfurShadingTypeReplace ( int $allowShadowMaps, string $attrName )
{
	string $tag="AElight";
	string $list[];
	string $parent = `setParent -q`;

	tokenize( $attrName, ".", $list);

	HfTDebug( $tag, "AEfurShadingTypeReplace(" + $attrName + ")");

	// If the control doesn't exist, create it.
	//
	if ( !`optionMenuGrp -ex ($parent + "|furShadingMenu")`){
		AEfurShadingTypeNew($allowShadowMaps,$attrName);
	} else {
		if (!`attributeQuery -ex -node $list[0] "furShadingType"`){
			HfTDebug( $tag, " no furShadingType attribute");
			deleteUI furShadingMenu;
		} else {
			connectControl -index 2 furShadingMenu $attrName;
			optionMenuGrp -edit -cc ("checkFurShadingType "+$list[0]) furShadingMenu;
		}
	}
	evalDeferred( "checkFurShadingType " + $list[0] );
}

// This is called from the standard Maya light attribute editor templates.
// 
global proc AEFurShading(
	string	$nodeName,
	int		$doBeginLayout,
	int		$doEndLayout
)
{
	string	$nodeType = `nodeType $nodeName`;
	int		$allowShadowMaps = $nodeType == "spotLight";

	if( $nodeType == "volumeLight" )
	{
	   return;
	}

	if ( $doBeginLayout ) {
		editorTemplate -beginLayout (uiRes("m_FurPluginCreateUI.kFurShadingShadowing"));
	}
	editorTemplate -callCustom
		("AEfurShadingTypeNew " + $allowShadowMaps)
		("AEfurShadingTypeReplace " + $allowShadowMaps)
		"furShadingType";
	addShadeAttrControls( 0 );
	if ( $allowShadowMaps ) {
		addShadeAttrControls( 1 );
	}
	if ( $nodeType == "areaLight" )
	{
		addShadeAttrControls( 2 );
	}
	editorTemplate -label (uiRes("m_FurPluginCreateUI.kIntensityMultiplier")) -addControl "furLightMultiplier";
	evalDeferred( "checkFurShadingType " + $nodeName );
	if ( $doEndLayout ) {
		editorTemplate -endLayout;
	}
}
/////////////////////////////////////////////////////////////////////////////
//
// These procedures deal with the Hair->Render Hair menu
//
/////////////////////////////////////////////////////////////////////////////

global proc string HfgetPluginPath()
{
	global string	$gHfPluginPath;
	return $gHfPluginPath;
}

proc string getRenderWindowPanel()
{
	string $renderPanel;
	string $renderPanels[] = `getPanel -scriptType "renderWindowPanel"`;
	
	if( size($renderPanels) == 0 )
	{
		$renderPanel = "";
	}
	else
	{
		$renderPanel = $renderPanels[0];
	}
	
	return $renderPanel;
}

global proc string HfGetRenderCamera()
{
    string	$renderPanel = `getRenderWindowPanel`;
    string	$camera;
    if (size($renderPanel) != 0)
    {
        $camera = `renderWindowEditor -q -currentCamera $renderPanel`;
        if (size($camera) != 0)
        {
            string	$cameraShapes[] = `listRelatives -shapes $camera`;
            $camera = $cameraShapes[0];
        }
    }
    
    if( !size($camera) || (`about -batch`))
    {
        //
        //	So get the current camera.
        //
        string $currentPanel = `getPanel -wf`;
        if( `modelPanel -exists $currentPanel` )
        {
            $camera = `modelPanel -q -cam $currentPanel`;
            string	$cameraShapes[]=`listRelatives -shapes $camera`;
            $camera = $cameraShapes[0];
        }
        else
        {
            // Since we have to make a guess at what camera to use, we'll
            // first guess that it's something typical (namely: persp).
            // If that's not a good guess, we'll just guess that it's the
            // first camera in the scene.
            //
            int $useFirstCamera = true;
            
            string $defCameras[] = `ls persp|perspShape`;
            if (size($defCameras) > 0) {
                string $defCamera = $defCameras[0];
                if (`objectType -isa "camera" $defCamera`) {
                    $camera = $defCamera;
                    $useFirstCamera = false;
                }
            }
            
            if ($useFirstCamera) {
                string	$cameras[] = `ls -cameras`;				
                $camera = $cameras[0];
            }
        }
    }
    
    return $camera;
}

global proc float[] HfGetRenderFrame()
{
 	float $frames[];
 	//	Render globals item.
 	//
 	string	$globals[] = `ls -renderGlobals`;
 	int		$framesSet = false;

 	if( size($globals[0]) > 0 ) 
 	{
 		string	$animAttr = $globals[0] + ".animation";
		$frames[0] = `getAttr $animAttr`;
		if ( $frames[0] )
 		{
			$frames[1] = `getAttr ($globals[0] + ".startFrame")`;
 			$frames[2] = `getAttr ($globals[0] + ".endFrame")`;
 			$frames[3] = `getAttr ($globals[0] + ".byFrameStep")`;
 			
 			$frames[1] = ceil( $frames[1] );
			
 			$frames[4] = `getAttr ($globals[0]+".motionBlur")`;
 			if ( $frames[4] ) 
 			{
				$frames[5] = `getAttr ($globals[0]+".motionBlurByFrame")`;
 			}
			else
			{
				$frames[5] = 0; 
			}
 			$framesSet = true;
 		}
 	}

 	if ( ! $framesSet ) 
 	{
		$frames[0] = 0; 
 		$frames[1] = `currentTime -q`;
 		$frames[2] = $frames[1];
 		$frames[3] = 1;
 		$frames[4] = 0;
 		$frames[5] = 0;
 	}

	return $frames;	

}

global proc int[] HfGetGlobalsResolution()
{
	//
	//	Image globals item.
	//
	string	$globals[] = `ls -renderGlobals`;
	int		$res[2] = { 320, 240 };

	if( size($globals[0]) > 0 )
	{
		string	$connect[] = `listConnections ($globals[0] + ".resolution")`;

		if( size($connect[0]) > 0 )
		{
			$res[0] = `getAttr ($connect[0] + ".width" )`;
			$res[1] = `getAttr ($connect[0] + ".height" )`;
		}
	}

	return $res;
}

addDebugTag( "globals" );

global proc float[] HfGetHairGlobalAttr()
{
	float $attr[];

	string $hairGlobal = HfBuildHairGlobal();
	$attr[0] = `getAttr ($hairGlobal + ".renderFur")`;
	$attr[1] = `getAttr ($hairGlobal + ".areaValue")`;
	$attr[2] = `getAttr ($hairGlobal + ".shadowGeometry")`;
	$attr[3] = `getAttr ($hairGlobal + ".shadowFur")`;
	$attr[4] = `getAttr ($hairGlobal + ".equalMap")`;
	$attr[5] = `getAttr ($hairGlobal + ".furPixelBufferSize")`;
	$attr[6] = `getAttr ($hairGlobal + ".shadowPixelBufferSize")`;
	$attr[7] = `getAttr ($hairGlobal + ".nurbsTesselation")`;
	//bug 164294  Need to be able specify equalizer maps size. (incl. larger than 256)
	$attr[8] = `getAttr ($hairGlobal + ".equalizerMapWidth")`;
	$attr[9] = `getAttr ($hairGlobal + ".equalizerMapHeight")`;
	$attr[10] = `getAttr ($hairGlobal + ".equalMap")`;
	$attr[11] = `getAttr ($hairGlobal + ".enableBackShadeSpotLight")`;
	$attr[12] = `getAttr ($hairGlobal + ".equalizerFillBackground")`;

	return $attr;	
}


proc int hfFindHairGlobalInList( string $list[], string $refString )
{
	string $buffer[];
	int $length = size($list);
	for( $i = 0; $i < $length; $i++ )
	{
		if( size($list[$i]) > 0
			&& tokenize( $list[$i], ".", $buffer )
			&& size($buffer[0]) > 0
			&& (`nodeType $buffer[0]` == "FurGlobals")
			&& $buffer[0] == $refString )
		{
			return $i;			
		}	
	}						
	return -1;
}

global proc string HfCheckRenderCondition( string $cam )
{
	return "";
}

proc string createHairGlobals(
	string	$renderGlobals
)
{
	string $hairGlobals = `createNode -skipSelect "FurGlobals" -n "defaultFurGlobals"`;
	HfTDebug("globals","created fur globals " + $hairGlobals);
	
	// In V3.0, the areaValue attribute was changed from a boolean to an enum. To maintain
	// backwards compatibility with old files, the default value had to stay at 1 which is
	// to calculate area values globally. However we really want the default to be 2 which is
	// to calculate area values per fur description. Therefore we set it to 2 whenever we create
	// a fur globals node
	//
	setAttr ($hairGlobals + ".areaValue") 2;

	addAttr -at message -sn "cb" -ln "callback" $hairGlobals;
	string $cmd = "connectAttr " + $renderGlobals + ".rcb " + $hairGlobals + ".cb";
	HfTDebug("globals","running: " + $cmd);
	eval $cmd;

	// We'll add these dynamically for pre-3.0.1 Fur plugin which doesn't
	// have these attrs
	string $attr = "copyAttrMaps";
	if ( !`attributeQuery -ex -node $hairGlobals $attr` )
	{
		addAttr -at short -ln $attr $hairGlobals;
	}

	$attr = "projectLocation";
	if ( !`attributeQuery -ex -node $hairGlobals $attr` )
	{
		addAttr -dt "string" -ln $attr $hairGlobals;
	}
	string $ws = `workspace -q -rd`;
	if ( $ws != "" )
	{
		setAttr ( $hairGlobals + ".projectLocation" ) -type "string" $ws;
	}

	checkNode( $hairGlobals );
	return $hairGlobals;
}

global proc HfDeleteExtraFurGlobals()
{
	string	$tag = "globals";
	string	$globals[] = `ls -renderGlobals`;
	
	if( size($globals) > 0 ) 
	{
		string $rcp = $globals[0] + ".rendercallback";

		// try and delete extra fur globals that were detected during
		// hair global cleanup
		//
		global string	$extraFurGlobals[];
		string			$fgp;
		
		for ( $fgp in $extraFurGlobals ) {
			string	$fg = plugNode( $fgp );
			
			// check if the node is still there
			//
			if ( `objExists $fg` ) {
				// check if connection is still there
				//
				if ( `isConnected $rcp $fgp` ) {
					HfTDebug($tag,"disconnecting " + $rcp + " from " + $fgp);
					if ( `checkAndDisconnectAttr $rcp $fgp` ) {
						HfTDebug($tag,"deleting " + $fg);
						if ( ! `checkAndDelete $fg` ) {
							HfTDebug($tag,"deletion of " + $fg + " failed");
						}
					}
				} else {
					HfTDebug($tag,"deleting " + $fg);
					if ( ! `checkAndDelete $fg` ) {
						HfTDebug($tag,"deletion of " + $fg + " failed");
					}
				}
			}
		}
		clear( $extraFurGlobals );
	}
}

global proc string[] HfCleanUpHairGlobal()
{
	string	$tag = "globals";

	string $dfltHairGlobalsName = "defaultFurGlobals";

	string $returnString[2];
	$returnString[0] = "";
	$returnString[1] = "";

	string $globals[] = `ls -renderGlobals`;
	if( size($globals) > 0 ) 
	{
		$returnString[0] = $globals[0];

 		int $foundAttr = false;
		int	$foundAHairGlobals = false;
		string $dynAttr[];
		if(`objExists $globals[0]`)
			$dynAttr= `listAttr $globals[0]`;

 		for ($a in $dynAttr)
 		{
 			if( $a == "rendercallback" )
			{
				$foundAttr = true;
				string $plug = $globals[0] + ".rendercallback";

				// find everything connected to the "rendercallback plug
				//
				string $source[] = getDstPlugs( $plug );

				if( size($source) > 0 )
				{
					int $rc = hfFindHairGlobalInList( $source, $dfltHairGlobalsName );
					
					// mark all the connections except 
					// the real one (i.e. $rc) for deletion
					int $length = size($source);
					for( $i = 0; $i < $length; $i++ )
					{
						string	$node = plugNode( $source[$i] );
						int		$isHairGlobals = `nodeType $node` == "FurGlobals";
						
						if ( $isHairGlobals ) {
							$foundAHairGlobals = true;
						}
						if( $i != $rc && $isHairGlobals )
						{
							global string	$extraFurGlobals[];

							HfTDebug($tag,"marking " + $node + " for deletion");
							$extraFurGlobals[size($extraFurGlobals)]=$source[$i];
						}		
					}		
					
					if( $rc != -1 )
					{
						$returnString[1] = $dfltHairGlobalsName;
					}
				}
				break;
			}
 		}
		
		if( !$foundAttr && `objExists $globals[0]`)
		{
			// this shouldn't happen in a real Maya 1.5 environment but let's try
			// to deal with it
			//
			HfTDebug($tag,$globals[0] + " rendercallback attribute not there - adding");
			addAttr -at message -sn "rcb" -ln "rendercallback" $globals[0];

			string	$objects[] = `ls "*Globals*"`;
			string	$obj;

			for ( $obj in $objects ) {
				if( `nodeType $obj` == "FurGlobals" ) {
					$foundAHairGlobals = true;
					if ( $obj == $dfltHairGlobalsName ) {
						$returnString[1] = $obj;
						string $cmd = "connectAttr " + $globals[0] + ".rcb " + $obj + ".cb";
						HfTDebug($tag,"running: " + $cmd);
						eval $cmd;
					}
				}
			}
		}
		
		// if THE default hair globals node is not there, but we stumbled across one
		// that was imported/referenced, then create a default hair globals
		//
		if ( $returnString[1] == "" && $foundAHairGlobals ) {
			$returnString[1] = createHairGlobals( $returnString[0] );
		}
	}

	evalDeferred HfDeleteExtraFurGlobals;

	return $returnString;
}

global proc string HfBuildHairGlobal()
{
	string $rc[] = HfCleanUpHairGlobal();

	if( $rc[1] == "" )
	{
		$rc[1] = createHairGlobals( $rc[0] );
	}

	HfFurGlobalCheck();
	return $rc[1];
}

global proc string HfGetHairGlobal()
{
	string $rc[] = HfCleanUpHairGlobal();

	return $rc[1];
}

global proc int HfKillRender()
{
	string $yes = (uiRes("m_FurPluginCreateUI.kYes"));
	string $no = (uiRes("m_FurPluginCreateUI.kNo"));
	string $rc = `confirmDialog -title (uiRes("m_FurPluginCreateUI.kConfirmDlgTitle")) 
		-message (uiRes("m_FurPluginCreateUI.kConfirmDlgMessage"))
		-button $yes -button $no -defaultButton $yes
		-cancelButton $no -dismissString $no`;
	if( $rc == $yes )
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

global proc HfShowHairGlobal()
{
 	// create the hair global node and make the connect if necessary
 	string $hairGlobal = HfBuildHairGlobal();
	
 	// show the editor
 	showEditor $hairGlobal; 
}

global proc HfRenderCancel()
{
	buildFurImages -k;
}

global int $HfCommandPortLoaded;

global proc HfDoCommandPortLoad( string $portid )
{
	global int $HfCommandPortLoaded;
	if( $HfCommandPortLoaded == 0 )
	{
		$HfCommandPortLoaded = 1;
		commandPort -n $portid -prefix " buildFurImages -feedback";
	}
}

global proc HfCommandPortLoad( string $portid )
{
	global string	$gMainWindow;
	
	// If the size of the $gMainWindow string is greater than 0 assume we have
	// some UI in place and we can do the command port load. Otherwise create a script job
	// which will create the command port on the first tool change at which point we better
	// have some UI
	//
	if ( size( $gMainWindow ) > 0 ) {
		HfDoCommandPortLoad( $portid );
	} else {
		scriptJob -runOnce true -event "ToolChanged" ("HfDoCommandPortLoad \"" + $portid + "\"");
	}
}

global proc string HfGetFurImagePrefix( )
{
	string	$globals[] = `ls -renderGlobals`;
	string  $imagePrefix;

	if( size($globals[0]) > 0 )
	{
		$imagePrefix = `getAttr ($globals[0]+".imageFilePrefix")`;
	}
	
	if( size($imagePrefix) == 0 )
	{
		$imagePrefix = HfGetSceneName();
	}

	return $imagePrefix;
}

global proc HFGetRenderCameraFocalLength(float $focalLength)
{
	string $camera = `HfGetRenderCamera`;
	string $cmd = "camera -q -focalLength ";
	$cmd += $camera;
	$focalLength = `eval $cmd`;
}

global proc HFGetRenderCameraHFilmAperture(float $aperture)
{
	string $camera = `HfGetRenderCamera`;
	string $cmd = "camera -q -horizontalFilmAperture ";
	$cmd += $camera;
	$aperture = `eval $cmd`;
}

global proc float[] HFGetCameraAttr()
{
	float $attr[];
	
	string $camera = `HfGetRenderCamera`;
	$attr[0] = `getAttr ($camera + ".focalLength")`;
	$attr[1] = `getAttr ($camera + ".horizontalFilmAperture")`;
	
	return $attr;	
}global string	$HfLightShapes[];

// initialize list of possible light shapes
//
clear( $HfLightShapes );
$HfLightShapes[size($HfLightShapes)] = "spotLight";
$HfLightShapes[size($HfLightShapes)] = "directionalLight";
$HfLightShapes[size($HfLightShapes)] = "ambientLight";
$HfLightShapes[size($HfLightShapes)] = "pointLight";
$HfLightShapes[size($HfLightShapes)] = "areaLight";
$HfLightShapes[size($HfLightShapes)] = "volumeLight";

proc int getLightShapes(
	string	$items[],		// should be unique path names
	string	$lights[],
	int		$index,
	int		$transforms
)
{
	global string	$HfLightShapes[];

	$index = getShapes(
		$items, $HfLightShapes, $lights, $index, $transforms
	);

	return $index;
}

proc string getChildLightShape(
	string	$transform
)
{
	if ( `nodeType $transform` != "transform" ) {
		return $transform;
	}

	string	$childShapes[] = `listRelatives -shapes -pa $transform`;
	string $cs;

	// if there is only one non-intermediate shape, then we
	// will use it
	//
	for ( $cs in $childShapes ) {
		int	$isIntermediate = getAttr( $cs  + ".intermediateObject");
		if ( ! $isIntermediate && $cs != "" )
		{
			global string	$HfLightShapes[];

			string $lightType = `nodeType $cs`;

			for ( $ls in $HfLightShapes )
			{
				if ( $lightType == $ls )
				{
					return $cs;
				}
			}
		}
	}
	return "";
}

global proc HfCheckFurShadowingMenu(
	string	$mi
)
{
	// Just enable all menu items and use error messages
	// if the operation is not appropriate (Bug 163391)
	
	menu -e -enable true $mi;
}

proc HFaddLightAttr(
	string $lightShape
)
{
	// check if the attribute has been added
	int $found = false;
	string $attrList[];
	$attrList = `listAttr -ud $lightShape`;
	for( $a in $attrList )
	{
		if( $a == "furShadingType" )
		{
			$found = true;
			break;
		}
	}
	
	if( !$found )
	{
		string $lightType = `nodeType $lightShape`;
		float  $furLightMultDflt = 1.0;

		if( $lightType == "spotLight" )
		{
			addAttr -at short  -sn "hs" -ln "furShadingType" -dv 1
				-min 0 -max 2 $lightShape;

			// add a bunch of shadow map specific attributes
			//
			makeShadeAttributes( $lightShape, 1 );
		}
		else
		{
			addAttr -at short  -sn "hs" -ln "furShadingType" -dv 1
				-min 0 -max 1 $lightShape;
		}
		makeShadeAttributes( $lightShape, 0 );

		if ( $lightType == "areaLight" )
		{
			makeShadeAttributes( $lightShape, 2 );
			$furLightMultDflt = 1.0;
		}
		
		// add a fur light intensity multiplier to all lights
		//
		addAttr -at double -sn "flmu" -ln "furLightMultiplier" -dv $furLightMultDflt
			-min 0 -max 10 $lightShape;

	}
}

global proc HfPerformAddLightAttr()
{
	string	$selected[];

	// Pop error message if the operation is not appropriate 
	// (Bug 163391)

	getLightShapes(
		`ls -sl -transforms -lights`,
		$selected, 0, 0
	);
	if (size( $selected ) <= 0){
		error ((uiRes("m_FurPluginCreateUI.kSelectLightObjectError")));
	}
	
	string	$s;

	getLightShapes(
		`ls -sl -transforms -lights`,
		$selected, 0, 1
	);

	for ( $s in $selected ) 
	{
		string	$light = getChildLightShape( $s );
		string $lightType = `nodeType $light`;
		if ( $light != "" )
		{
			// Pop warning message if it is a volumeLight
			if( $lightType == "volumeLight" )
			{
			   warning ((uiRes("m_FurPluginCreateUI.kFurShadingWarn")));
			   continue;
			}
			global string	$HfLightShapes[];

			for ( $ls in $HfLightShapes )
			{
				if ( $lightType == $ls )
				{
					HFaddLightAttr( $light );
					break;
				}
			}
		}
	}
}


proc HFremoveLightAttr(
	string $lightShape
)
{
	global string $HfShadeNameL[];

	string $tag="shadeAttr";

	// check if the attribute has been added
	string $attrList[];
	$attrList = `listAttr -ud $lightShape`;
	for( $a in $attrList )
	{
		int	$deleteIt = false;

		if( $a == "furShadingType" ||
			$a == "furLightMultiplier" ) {
			$deleteIt = true;
		} else {
			for ( $sa in $HfShadeNameL ) {
				if ( $sa == $a ) {
					$deleteIt = true;
					break;
				}
			}
		}

		if ( $deleteIt )
		{
			HfTDebug($tag,"removing " + $a + " from " + $lightShape);
			deleteAttr -at $a $lightShape;
		}
	}
}

global proc HfPerformRemoveLightAttr()
{
	string	$selected[];

	// Pop error message if the operation is not appropriate 
	// (Bug 163391)

	getLightShapes(
		`ls -sl -transforms -lights`,
		$selected, 0, 0
	);
	if (size( $selected ) <= 0){
		error (uiRes("m_FurPluginCreateUI.kSelectLightObjectError"));
	}
	
	string	$s;

	getLightShapes(
		`ls -sl -transforms -lights`,
		$selected, 0, 1
	);

	for ( $s in $selected ) 
	{
		string	$light = getChildLightShape( $s );
		string $lightType = `nodeType $light`;
		if ( $light != "" )
		{
			// Pop warning message if it is a volumeLight
			if( $lightType == "volumeLight" )
			{
			   warning (uiRes("m_FurPluginCreateUI.kFurShadingWarn"));
			   continue;
			}
			global string	$HfLightShapes[];

			for ( $ls in $HfLightShapes )
			{
				if ( $lightType == $ls )
				{
					HFremoveLightAttr( $light );
					break;
				}
			}
		}
	}
}

global proc string[] HfGetLightLinkedObjects(string $lightName)
{
	string $linkedObjects[] = `lightlink -query -light $lightName -shapes true -sets false -transforms false -hierarchy false`;
	return $linkedObjects;
}

global proc int HfGetPathCB(
	string $whichPath,
	string $fileName,
	string $fileType
)
{
	// make filename project relative if possible
	//
	$fileName = makeProjectRelative( $fileName );

	string $cmd = "textFieldButtonGrp -e -tx \"" + $fileName + "\" " + $whichPath;
	eval $cmd;
	return true;
}

global proc pathsBrowser(
	string $whichPath,    // e.g. furFilesPath
	string $pathName,     // e.g. FurFiles
	string $dirRule
)
{
	int $foundRule = false;
	string $dir = "";
	$listOfFileRules = `workspace -q -fr`;
	for ($rule in $listOfFileRules)
	{
		if( $foundRule )
		{
			$dir = $rule;
			break;
		}
		else if( $rule == $dirRule )
		{
			$foundRule = true;
		}
	}

	string  $workspace = `workspace -q -fn`;
	setWorkingDirectory $workspace $dirRule $dir;
	fileBrowser( "HfGetPathCB " + $whichPath + " ", 
				 "Set " + $pathName + " Path", 
				 $pathName, 1 );
}

global proc int HfEqualOption()
{
	return `checkBoxGrp -q -v1 furOptionEqlChk`;
}

global proc HfAssignReadEqualPath()
{
	string $hairGlobal = HfBuildHairGlobal();
	string $cmd;
	string $equalMapPath = `getAttr ($hairGlobal +".readEqualMapPath")`;
	if($equalMapPath =="")
	{
	    string $sceneName = HfGetSceneName();
		string $ePath  = getDirPath("fileRule", "furEqualMap") + "/" + $sceneName;
		$cmd = "setAttr -type \"string\" " + $hairGlobal + ".readEqualMapPath  \"" + $ePath + "\"";
		eval $cmd;
	}
}
global proc HfAdvanceRenderAction()
{
	string $hairGlobal = HfBuildHairGlobal();
	string $cmd;	

	HfCheckProjectDir;

	if( `radioButton -q -sl furBtn` )
	{
		string $strEqualMap = HfGetSceneName();	
	
		// build fur files
		string $fPath = `textFieldButtonGrp -q -tx furFilesLocFld`;
		string $ePath = getProjectDir("fileRule", "furEqualMap")  + "/" + $strEqualMap;
		int    $eqOn = HfEqualOption();
		int    $areaValues = `getAttr ($hairGlobal+".areaValue")`;

		if( HfEqualOption() )
		{
			$cmd = "setAttr " + $hairGlobal + ".equalMap 1";
		}
		else
		{
			$cmd = "setAttr " + $hairGlobal + ".equalMap 0";
		}
		eval $cmd;


		$cmd = "setAttr " + $hairGlobal + ".areaValue " + $areaValues;
		eval $cmd;
		$cmd = "setAttr -type \"string\" " + $hairGlobal + ".readFurFilesPath  \"" + $fPath + "\"";
		eval $cmd;
		$cmd = "setAttr -type \"string\" " + $hairGlobal + ".readEqualMapPath  \"" + $ePath + "\"";
		eval $cmd;

		buildFurImages -f $fPath $ePath;
	}
	else if( `radioButton -q -sl equalBtn` )
	{
		// build equalizer maps
		string $strEqualMap = HfGetSceneName();
		string $eqPath = getProjectDir("fileRule", "furEqualMap")  + "/" + $strEqualMap;

		$cmd = "setAttr " + $hairGlobal + ".equalMap 1";
		eval $cmd;
		$cmd = "setAttr -type \"string\" " + $hairGlobal + ".readEqualMapPath  \"" 
			+ $eqPath + "\"";
		eval $cmd;
	
		buildFurImages -e $eqPath;
	}
	else
	{
		// build shadow maps and/or images
		string $fPath     = `textFieldButtonGrp -q -tx readFurLocFld2`;
		int    $buildMode = `radioButtonGrp -q -select createShadowChoice`;
		string $sdwPath   = `textFieldButtonGrp -q -tx shadowMapLocFld`;
		string $imgPath   = `textFieldButtonGrp -q -tx imageLocFld`;

		$cmd = "setAttr -type \"string\" " + $hairGlobal + ".readShadowMapPath \"" + $sdwPath + "\"";
		eval $cmd;
		$cmd = "setAttr -type \"string\" " + $hairGlobal + ".readFurImagePath \"" + $imgPath + "\"";
		eval $cmd;

		// build fur shadows and images
		int $buildShadow = ( $buildMode == 1 || $buildMode == 3 );
		int $buildImage = ( $buildMode == 2 || $buildMode == 3 );
		buildFurImages -i $fPath $sdwPath $imgPath $buildShadow $buildImage;
	}
}

global proc HfAdvancedFurDimming()
{
	setParent AdvancedFurWnd;               
	setParent createShadowTab;
	
	// dim the fur images tab appropriately
	//
	int $shadowsNeeded = true;
	int $fileChoice = `radioButtonGrp -q -select createShadowChoice`;
	
	if ( !$shadowsNeeded ){
		radioButtonGrp -edit -select 2 -en1 0 -en3 0 createShadowChoice;        
		$fileChoice = 2;        
		disable shadowMapLocFld;
		disable -v 0 imageLocFld;
		
	} else {
		radioButtonGrp -edit -en1 1 -en3 1 createShadowChoice;
		disable -v 0 shadowMapLocFld;
		if ( $fileChoice == 1 || $fileChoice == 3 ){            
			textFieldButtonGrp -e -label (uiRes("m_FurPluginCreateUI.kAdvFurShadowMapsPath")) shadowMapLocFld;
		} else {
			textFieldButtonGrp -e -label (uiRes("m_FurPluginCreateUI.kAdvFurReadShadowMaps")) shadowMapLocFld;
		}
		disable -v ( $fileChoice == 1 ) imageLocFld;
	}
}
                   
global proc HfAdvanceRender()
{
	if ( !`window -exists AdvancedFurWnd` )
	{
		// setup the project directories
		HfCheckProjectDir;
		string $strEqualMap = HfGetSceneName();
		string $filePath  = getProjectDir("fileRule", "furFiles")     + "/" + $strEqualMap;
		string $eqMapPath = getProjectDir("fileRule", "furEqualMap")  + "/" + $strEqualMap;
		string $shwPath   = getProjectDir("fileRule", "furShadowMap") + "/" + $strEqualMap;
		string $imgPath   = getProjectDir("fileRule", "furImages")    + "/" + $strEqualMap;
	
		window
			-w 520
			-h 390
			-title (uiRes("m_FurPluginCreateUI.kAdvFurRendering"))
			AdvancedFurWnd;
		
		setUITemplate -pushTemplate DefaultTemplate;
		
		formLayout -nd 100 furForm;
		
		text -label (uiRes("m_FurPluginCreateUI.kKindOfFile")) txt1;
                        
		radioCollection -parent furForm fileChoice;
                
		radioButton -label (uiRes("m_FurPluginCreateUI.kFurFiles"))
			-onc "tabLayout -edit -st createFurFilesTab createTab"
			furBtn;
                        
		radioButton -label (uiRes("m_FurPluginCreateUI.kEqualizerMaps"))
			-onc "tabLayout -edit -st createEqualTab createTab"
			equalBtn;
                        
		radioButton -label (uiRes("m_FurPluginCreateUI.kAdvRenderShadowMapsFurImages"))
			-onc "tabLayout -edit -st createShadowTab createTab"
			shadowBtn;

		separator -style "double" -horizontal true sep1;
                        
		tabLayout -tabsVisible false -scr false createTab;
                        
		setParent ..;
                        
		button -label (uiRes("m_FurPluginCreateUI.kCreateFiles")) 
			-c "HfAdvanceRenderAction"
			createBtn;
                        
		button -label (uiRes("m_FurPluginCreateUI.kClose"))
			-c "deleteUI AdvancedFurWnd"
			closeBtn;
                        
		formLayout -edit
			-af txt1 left 10
			-af txt1 top 10
			-an txt1 right
			-an txt1 bottom
			
			-af furBtn left 60
			-ac furBtn top 10 txt1
			-an furBtn right
			-an furBtn bottom
			
			-af equalBtn left 60
			-ac equalBtn top 0 furBtn
			-an equalBtn right
			-an equalBtn bottom
                                
			-af shadowBtn left 60
			-ac shadowBtn top 0 equalBtn
			-an shadowBtn right
			-an shadowBtn bottom
                                        
			-af sep1 left 0
			-ac sep1 top 10 shadowBtn
			-af sep1 right 0
			-an sep1 bottom

			-af createBtn left 30
			-an createBtn top
			-ap createBtn right 15 50
			-af createBtn bottom 10
			
			-ap closeBtn left 15 50
			-an closeBtn top
			-af closeBtn right 30
			-af closeBtn bottom 10
			
			-af createTab left 10
			-ac createTab top 0 sep1
			-ac createTab bottom 10 createBtn
			-af createTab right 10
			
			furForm;
                        
		//-------------------------------------
		// make the form for creating fur files
		//
		setParent AdvancedFurWnd;
		setParent createTab;
                
		columnLayout -rs 10 -adj true createFurFilesTab;
		
		text -l "";
		
		textFieldButtonGrp
			-label (uiRes("m_FurPluginCreateUI.kAdvRenderFurFilesPath"))
			-tx $filePath
			-bl (uiRes("m_FurPluginCreateUI.kBrowse"))
			-bc "pathsBrowser \"furFilesLocFld\" \"FurFiles\" \"furFiles\""
			furFilesLocFld;
		
		
		checkBoxGrp
			-ncb 1
			-l "" -h 22
			-label1 (uiRes("m_FurPluginCreateUI.kCBEqualizerMap"))
			-on1 "setParent AdvancedFurWnd;"
			-of1 "setParent AdvancedFurWnd;"
			-v1 true
			furOptionEqlChk;

		//-------------------------------------
		// make the form for creating equalizer maps
		//
		setParent AdvancedFurWnd;
		setParent createTab;
                
		columnLayout -rs 10 -adj true createEqualTab;
		
		text -l "";
		
		//bug 164294  Need to be able specify equalizer maps size. (incl. larger than 256)
		string $hairGlobal = HfBuildHairGlobal();
		
		intFieldGrp -label (uiRes("m_FurPluginCreateUI.kEqualizerMapWidth")) -numberOfFields 1 equalizerMapWidth;
		connectControl -index 2 equalizerMapWidth ($hairGlobal+".equalizerMapWidth");
		intFieldGrp -label (uiRes("m_FurPluginCreateUI.kEqualizerMapHeight")) -numberOfFields 1 equalizerMapHeight;
		connectControl -index 2 equalizerMapHeight ($hairGlobal+".equalizerMapHeight");

		
        
		//-------------------------------------
		// make the form for creating shadow maps and fur images
		//
		setParent AdvancedFurWnd;
		setParent createTab;
		
		columnLayout -rs 10 -adj true createShadowTab;
		
		text -align left
			-label (uiRes("m_FurPluginCreateUI.kCreatedFurFiles"));
		
		text -align left
			-label (uiRes("m_FurPluginCreateUI.kCreatedEqualizerMaps"));
                        
		textFieldButtonGrp
			-label (uiRes("m_FurPluginCreateUI.kReadFurFiles"))
			-tx $filePath
			-bl (uiRes("m_FurPluginCreateUI.kReadFurFilesBrowse"))
			-bc "pathsBrowser \"readFurLocFld2\" \"FurFiles\" \"furFiles\""
			readFurLocFld2;
		
		radioButtonGrp
			-nrb 3
			-l ""
			-label1 (uiRes("m_FurPluginCreateUI.kAdvRenderShadowMaps"))
			-label2 (uiRes("m_FurPluginCreateUI.kFurImages"))
			-label3 (uiRes("m_FurPluginCreateUI.kBoth"))
			-select 3
			-cw 2 120
			-cw 3 100
			-cc HfAdvancedFurDimming
			createShadowChoice;             
		
		textFieldButtonGrp
			-label (uiRes("m_FurPluginCreateUI.kAdvRenderShadowMapsPath"))
			-tx $shwPath
			-bl (uiRes("m_FurPluginCreateUI.kShadowMapsPathBrowse"))
			-bc "pathsBrowser \"shadowMapLocFld\" \"Shadow Maps\" \"furShadowMap\""
			shadowMapLocFld;
		
		textFieldButtonGrp
			-label (uiRes("m_FurPluginCreateUI.kAdvRenderFurImagesPath"))
			-tx $imgPath
			-bl (uiRes("m_FurPluginCreateUI.kFurImagesPathBrowse"))
			-bc "pathsBrowser \"imageLocFld\" \"Fur Images\" \"furImages\""
			imageLocFld;
		
		HfAdvancedFurDimming;
                
		//-----------------------------
        
		radioCollection -edit -select furBtn fileChoice;
                
		setUITemplate -popTemplate;
	}

	showWindow AdvancedFurWnd;
}

global proc HfAdvanceRenderUpdate()
{
	//Updating fur files prefix name in advanced Fur Render Dialog box 
	HfCheckProjectDir;
	string $strEqualMap = HfGetSceneName();

	string $filePath  = getProjectDir("fileRule", "furFiles")     + "/" + $strEqualMap;
	string $shwPath   = getProjectDir("fileRule", "furShadowMap") + "/" + $strEqualMap;
	string $imgPath   = getProjectDir("fileRule", "furImages")    + "/" + $strEqualMap;

	textFieldButtonGrp -e -tx $filePath  furFilesLocFld;
	textFieldButtonGrp -e -tx $filePath  readFurLocFld2;
	textFieldButtonGrp -e -tx $shwPath   shadowMapLocFld;
	textFieldButtonGrp -e -tx $imgPath	 imageLocFld;
}

global proc string HfGetSceneName()
{
	string $tmpName = `file -q -sn`;
	string $sceneName;
	if(size ( $tmpName ) == 0 )
	{
		//if file is Temporary, assign "untitled" to sceneName;
		$sceneName = untitledFileName();
	}
	else
	{
		string $secondBuffer[];
	    string $firstBuffer[];
		string $tmpBuffer;
		
		//split the $tmpName according to split character "/"
		int $numTokens = `tokenize $tmpName "/" $firstBuffer`;
		
		$tmpBuffer = $firstBuffer[size($firstBuffer)-1];
		
		//split the $tmpBuffer according to split character "."
		int $insideNumTokebns = `tokenize  $tmpBuffer  "." $secondBuffer`;
	
		if(size( $secondBuffer ) > 1 )
		{
			int $count;
			for ( $count = 0; $count < (size($secondBuffer) - 1); ++$count )
			{
				if($count > 0)
				{
					$sceneName += ".";
				}
				$sceneName += $secondBuffer[$count];
			}
		}
		else
		{
			$sceneName = $secondBuffer[0];
		}
	}
	return 	$sceneName;		
}

global	proc string HfGetReferenceEqualMap(string $shapeName)
{
	string	$refEqualMapName;
	global	int	$gHfMayaState;

	//Surface reference
	int	$isReferenced = false;
	int	$isSurfaceFound = false;
	int	$isReferenceFileFound = false;
	string	$userDefinedAttrList[] = `listAttr -ud $shapeName`;
	for( $userDefinedAttr in	$userDefinedAttrList	)
	{
		if($userDefinedAttr == "surfaceReference")
		{
			 $isSurfaceFound = true;
		}
		if($userDefinedAttr == "referenceFile")
		{
			$isReferenceFileFound = true;
		}
	} 

	if( $gHfMayaState == 1	&& $isSurfaceFound)
	{
		if(`getAttr ($shapeName+".surfaceReference")`	== true )
		{
			$isReferenced = true;
		}
	}
	else
	{
		$isReferenced = `reference -q -inr $shapeName`;
	}

	if( $isReferenced )
	{
		// Find dag set	members from	instObjGroups
		string	$dsm[] = `listConnections	-s 0 -p 1 ($shapeName+".iog")`;

		int	$count;
		for($count=0; $count <	size($dsm); $count++ )
		{
			$isReferenced = false;		   
			string	$plug	= plugNode	($dsm[$count]);
			
			//Fur Description reference	
			if(`nodeType $dsm[$count]` ==	"FurDescription") 
			{
				int	$isFurDescFound = false;
				string	$userDefinedAttrList[] = `listAttr -ud $plug`;			   

				for( $userDefinedAttr in	$userDefinedAttrList	)
				{
					if($userDefinedAttr == "furReference")
					{
						$isFurDescFound = true;
					}
				}		   
				   
				if( $gHfMayaState == 1 && $isFurDescFound)
				{
					if(`getAttr ($plug+".furReference")`	== true )
					{
						$isReferenced = true;
					}
				}
				else
				{
					   $isReferenced = `reference	-q	-inr $dsm[$count]`;
				}
			}
			
			if( $isReferenced )
			{
				// If equalizer map path	if different from default	path,
				// Find out the	sceneName
				string $prefixName = HfCheckRefEqualizerMaps($shapeName);
				if($prefixName != ""	)
				{
					if($gHfMayaState != 1)
					{
						$refEqualMapName =	HfGetRefSurface($shapeName,$prefixName);
					}					   
					else
					{
						if($isReferenceFileFound)
							$refEqualMapName =	HfGetRefSurfaceBatch($shapeName,$prefixName);
						else
							$refEqualMapName =	HfGetRefSurface($shapeName,$prefixName);
					}
					$refEqualMapName =	replaceCharacterInString($refEqualMapName, ":","_");	
					$refEqualMapName =	replaceCharacterInString($refEqualMapName, "|","_"); 					
				}
				else
				{					
					if($gHfMayaState != 1)
					{
						$refEqualMapName =	HfGetReferenceSurface($shapeName);
					}					   
					else
					{
					if($isReferenceFileFound)
						$refEqualMapName =	HfGetReferenceSurfaceBatch($shapeName);
					else
						$refEqualMapName =	HfGetReferenceSurface($shapeName);
					}
							
					$refEqualMapName =	replaceCharacterInString($refEqualMapName, ":","_");	
					$refEqualMapName =	replaceCharacterInString($refEqualMapName, "|","_"); 
				}
			}
		}
	}

	if( size($refEqualMapName) == 0)
	{
		return " ";
	}
	else
	{
		return $refEqualMapName;
	}
}

// build fur files
global proc HfBuildFurFiles(string $fPath, int $equalOption)
{
	string $hairGlobal = HfBuildHairGlobal();
	string $cmd;

	HfCheckProjectDir;

	string $strEqualMap = HfGetSceneName();		
	string $ePath = getProjectDir("fileRule", "furEqualMap")  + "/" + $strEqualMap;
	
	if( $equalOption )
		$cmd = "setAttr " + $hairGlobal + ".equalMap 1";
	else
		$cmd = "setAttr " + $hairGlobal + ".equalMap 0";
	eval $cmd;

	$cmd = "setAttr -type \"string\" " + $hairGlobal + ".readFurFilesPath  \"" + $fPath + "\"";
	eval $cmd;
	$cmd = "setAttr -type \"string\" " + $hairGlobal + ".readEqualMapPath  \"" + $ePath + "\"";
	eval $cmd;

	buildFurImages -f $fPath $ePath;
}

// Build equalizer maps
global proc HfBuildEqualMap()
{
	string $hairGlobal = HfBuildHairGlobal();
	string $cmd;	

	HfCheckProjectDir;

	string $strEqualMap = HfGetSceneName();
	string $eqPath = getProjectDir("fileRule", "furEqualMap")  + "/" + $strEqualMap;

	$cmd = "setAttr " + $hairGlobal + ".equalMap 1";
	eval $cmd;
	$cmd = "setAttr -type \"string\" " + $hairGlobal + ".readEqualMapPath  \"" + $eqPath + "\"";
	eval $cmd;
	
	buildFurImages -e $eqPath; 
}

// build fur shadows and images
global proc HfBuildFurImages(string $fPath, string $sdwPath, string $imgPath, int $buildShadow, int $buildImage)
{
	string $hairGlobal = HfBuildHairGlobal();
	string $cmd;	

	HfCheckProjectDir;
	
	$cmd = "setAttr -type \"string\" " + $hairGlobal + ".readShadowMapPath \"" + $sdwPath + "\"";
	eval $cmd;
	$cmd = "setAttr -type \"string\" " + $hairGlobal + ".readFurImagePath \"" + $imgPath + "\"";
	eval $cmd;

	buildFurImages -i $fPath $sdwPath $imgPath $buildShadow $buildImage;
}

// Cancel Advanced Fur Rendering
global proc HfCancelAFR()
{
	buildFurImages -k;
}global proc HfDeleteAttributeSelection()
{
	if( `popupMenu -q -exists tempHFMM` )
	{
		popupMenu -e -dai tempHFMM;
		deleteUI tempHFMM;
	}
}

proc string HfReturnToolSetupCmd()
{
	string  $currentContext = `currentCtx`;
	string  $currBaseContext = `contextInfo -c $currentContext`;

	if( $currBaseContext == "artUserPaint" )
	{
		string $cmd = "artUserPaintCtx -q -tsc ";
		$cmd += $currentContext;
		return `eval $cmd`;
	}
	return "";
}


global proc HfAttributeSelection()
{
	string $toolsetupcmd = HfReturnToolSetupCmd();
	if( $toolsetupcmd == "HfHairPaintToolSelected" )
	{
		HfDeleteAttributeSelection();
		popupMenu -mm 1 -b 1 -p `findPanelPopupParent` tempHFMM;
		   	menuItem -rp "NW" -label (uiRes("m_FurPluginCreateUI.kAngle")) -sm true;
			   menuItem -rp "N" -label (uiRes("m_FurPluginCreateUI.kDirection"))
				   -c "HfUpdateHairPaintAttr \"Direction\" `currentCtx`";
			   menuItem -rp "W" -label (uiRes("m_FurPluginCreateUI.kInclination"))
				   -c "HfUpdateHairPaintAttr \"Inclination\" `currentCtx`";
			   menuItem -rp "S" -label (uiRes("m_FurPluginCreateUI.kPolar"))	
				   -c "HfUpdateHairPaintAttr \"Polar\" `currentCtx`";
   			   menuItem -rp "E" -label (uiRes("m_FurPluginCreateUI.kRoll"))
			      -c "HfUpdateHairPaintAttr \"Roll\" `currentCtx`";
			setParent -m ..;   
		   	menuItem -rp "W" -label (uiRes("m_FurPluginCreateUI.kScraggle")) -sm true;
			   menuItem -rp "N" -label (uiRes("m_FurPluginCreateUI.kScraggleMenu"))
			      -c "HfUpdateHairPaintAttr \"Scraggle\" `currentCtx`";
			   menuItem -rp "W" -label (uiRes("m_FurPluginCreateUI.kFrequency"))
			      -c "HfUpdateHairPaintAttr \"Scraggle Frequency\" `currentCtx`";
			   menuItem -rp "S" -label (uiRes("m_FurPluginCreateUI.kCorrelation"))
			      -c "HfUpdateHairPaintAttr \"Scraggle Correlation\" `currentCtx`";
			setParent -m ..;   
		   	menuItem -rp "SW" -label (uiRes("m_FurPluginCreateUI.kOthers")) -sm true;
			   menuItem -rp "NW" -label (uiRes("m_FurPluginCreateUI.kLength"))
			      -c "HfUpdateHairPaintAttr \"Length\" `currentCtx`";
			   menuItem -rp "W" -label (uiRes("m_FurPluginCreateUI.kBaldness"))
			      -c "HfUpdateHairPaintAttr \"Baldness\" `currentCtx`";
			   menuItem -rp "SW" -label (uiRes("m_FurPluginCreateUI.kSegments"))
			      -c "HfUpdateHairPaintAttr \"Segments\" `currentCtx`";
			   menuItem -rp "S"  -label (uiRes("m_FurPluginCreateUI.kAttraction"))
			      -c "HfUpdateHairPaintAttr \"Attraction\" `currentCtx`";
			   menuItem -rp "SE" -label (uiRes("m_FurPluginCreateUI.kCustomEqualizer"))
			      -c "HfUpdateHairPaintAttr \"Custom Equalizer\" `currentCtx`";
   			   menuItem -rp "E" -label (uiRes("m_FurPluginCreateUI.kOffset"))
			      -c "HfUpdateHairPaintAttr \"Offset\" `currentCtx`";
			setParent -m ..;   
			string $tip = (uiRes("m_FurPluginCreateUI.kTip"));
			string $base = (uiRes("m_FurPluginCreateUI.kBase"));
		   	menuItem -rp "NE" -label (uiRes("m_FurPluginCreateUI.kOpacity")) -sm true;
			   menuItem -rp "N" -label $tip
			      -c "HfUpdateHairPaintAttr \"Tip Opacity\" `currentCtx`";
			   menuItem -rp "S" -label $base
			      -c "HfUpdateHairPaintAttr \"Base Opacity\" `currentCtx`";
			setParent -m ..;   
		   	menuItem -rp "E" -label (uiRes("m_FurPluginCreateUI.kWidth")) -sm true;
			   menuItem -rp "N" -label $tip
			      -c "HfUpdateHairPaintAttr \"Tip Width\" `currentCtx`";
			   menuItem -rp "S" -label $base
			      -c "HfUpdateHairPaintAttr \"Base Width\" `currentCtx`";
			setParent -m ..;   
		   	menuItem -rp "SE" -label (uiRes("m_FurPluginCreateUI.kCurl")) -sm true;
			   menuItem -rp "N" -label $tip
			      -c "HfUpdateHairPaintAttr \"Tip Curl\" `currentCtx`";
			   menuItem -rp "S" -label $base
			      -c "HfUpdateHairPaintAttr \"Base Curl\" `currentCtx`";
			   setParent -m ..;   
	   setParent -m ..;	 
		
	}
	
}




global proc HfNameCommandSetup()
{
	if (`exists PaintFurAttributesMarkingMenu`) {
		return;
	}

	// 
	// Marking menus
	//
	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kPressPaintFurAttribToolAnnot"))
		-default true
		-command "PaintFurAttributesMarkingMenu"
		HfAttrSelect_Menu;

	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kReleasePaintFurAttribToolAnnot"))
		-default true
		-command "PaintFurAttributesMarkingMenuPopDown"
		HfAttrSelect_Menu_revert;

	// Maya Fur Plugin hot keys
	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kAttachNewFurDescAnnot"))
		-default true
	    -command "AttachFurDescription";

	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kReverseFurNormalsAnnot"))
		-default true
	    -command "ReverseFurNormals";

	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kOffsetFurDir0Annot"))
		-default true
	    -command "OffsetFur0Degrees";

	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kOffsetFurDir90Annot"))
		-default true
	    -command "OffsetFur90Degrees";

	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kOffsetFurDir180Annot"))
		-default true
	    -command "OffsetFur180Degrees";

	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kOffsetFurDir270Annot"))
		-default true
	    -command "OffsetFur270Degrees";

	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kCreateAttractorAnnot"))
		-default true
	    -command "CreateFurAttractor";

	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kShowFurGlobalNodeAnnot"))
		-default true
	    -command "ShowFurGlobals";

	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kAddShadowAttributeAnnot"))
		-default true
	    -command "AddShadowingToSelectedLight";

	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kRemoveShadowAttributeAnnot"))
		-default true
	    -command "RemoveShadowingFromSelectedLight";

	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kInvokePaintFurAttributeAnnot"))
		-default true
	    -command "PaintFurAttributesTool";

	nameCommand -annotation (uiRes("m_FurPluginCreateUI.kFurUVSetLinkingAnnot"))
		-default true
	    -command "FurUVSetLinkingEditor";

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kPressPaintFurAttributesMenuAnnot"))
		-category   ("Fur")
		-command    ("HfAttributeSelection")
		PaintFurAttributesMarkingMenu;

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kReleasePaintFurAttributesMenuAnnot"))
		-category   ("Fur")
		-command    ("HfDeleteAttributeSelection")
		PaintFurAttributesMarkingMenuPopDown;

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kAttNewFurDescAnnot"))
		-category   ("Fur")
		-command    ("HfCreateAndAssignHD 0")
		AttachFurDescription;

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kRevFurNormalsAnnot"))
		-category   ("Fur")
		-command    ("HfFlipHairNormals")
		ReverseFurNormals;

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kOffFurDir0DegAnnot"))
		-category   ("Fur")
		-command    ("HfOffsetHairAngle 0.0")
		OffsetFur0Degrees;

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kOffFurDir90DegAnnot"))
		-category   ("Fur")
		-command    ("HfOffsetHairAngle 0.25")
		OffsetFur90Degrees;

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kOffFurDir180DegAnnot"))
		-category   ("Fur")
		-command    ("HfOffsetHairAngle 0.50")
		OffsetFur180Degrees;

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kOffFurDir270DegAnnot"))
		-category   ("Fur")
		-command    ("HfOffsetHairAngle 0.75")
		OffsetFur270Degrees;

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kCreateFurAttractorAnnot"))
		-category   ("Fur")
		-command    ("HfCreateAttractor")
		CreateFurAttractor;

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kShowFurGlobalAnnot"))
		-category   ("Fur")
		-command    ("HfShowHairGlobal")
		ShowFurGlobals;

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kAddShadowAttribAnnot"))
		-category   ("Fur")
		-command    ("HfPerformAddLightAttr")
		AddShadowingToSelectedLight;

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kRemoveShadowAttribAnnot"))
		-category   ("Fur")
		-command    ("HfPerformRemoveLightAttr")
		RemoveShadowingFromSelectedLight;

	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kInvokePaintFurAttribAnnot"))
		-category   ("Fur")
		-command    ("HfPaintHairAttrTool 0")
		PaintFurAttributesTool;
	
	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kFurUVLinkingAnnot"))
		-category   ("Window")
		-command    ("furUVLinkingEditor")
		FurUVSetLinkingEditor;
	
	runTimeCommand -default true
		-annotation (uiRes("m_FurPluginCreateUI.kSpecifyHairSystemAnnot"))
		-category   ("Window")
		-command    ("hairFurLinkingEditor")
		HairFurRelationshipEditor;	
	
	HfSetHotkeys();
}

global proc HfSetHotkeys()
{
	//adding default hot key for paint attribute marking menu.

    string $existMapping = `hotkeyCheck -k "0"`;
    if( $existMapping == "" ) {
		hotkey -k "0" -name "HfAttrSelect_Menu";
    }

	$existMapping = `hotkeyCheck -k "0" -keyUp`;
	if( $existMapping == "" ) {
		hotkey -k "0" -releaseName "HfAttrSelect_Menu_revert";
    }
}/////////////////////////////////////////////////////////////////////////////
//
// Create Hair and Fur UI
//
/////////////////////////////////////////////////////////////////////////////

global proc HfFurCreateEditMenuUI()
{
	global string $gEditSelectAllByTypeSubMenu;
	global string $gSelAllFursItem;

	if (`menu -q -exists $gEditSelectAllByTypeSubMenu` && `menu -q -ni $gEditSelectAllByTypeSubMenu` > 0 && !`menuItem -q -exists $gSelAllFursItem`)
	{
		string $furStr = uiRes("m_FurPluginCreateUI.kFurMenu");
		setParent -m $gEditSelectAllByTypeSubMenu;
		$gSelAllFursItem = `menuItem -label $furStr
			-ia selFluidsItem
			-annotation (uiRes("m_FurPluginCreateUI.kSelectAllFurAnnot")) 
			-command ("SelectAllFurs")`;
	}

	global string $gEditDeleteAllByTypeSubMenu;
	global string $gClearAllFursItem;

	if (`menu -q -exists $gEditDeleteAllByTypeSubMenu` && `menu -q -ni $gEditDeleteAllByTypeSubMenu` > 0 && !`menuItem -q -exists $gClearAllFursItem`)
	{
		string $furStr = uiRes("m_FurPluginCreateUI.kFurMenu");
		setParent -m $gEditDeleteAllByTypeSubMenu;
		$gClearAllFursItem = `menuItem -label $furStr
			-ia clearFluidsItem
			-annotation (uiRes("m_FurPluginCreateUI.kDeleteAllFurAnnot")) 
			-command ("DeleteAllFurs")`;
	}
}

global proc HfFurCreateUI()
{
	global string $gDisplayShowSubmenu;
	global string $gShowFurItem;
	string $furStr = (uiRes("m_FurPluginCreateUI.kFurMenu"));
	
	if (`menu -q -ni $gDisplayShowSubmenu` > 0)
	{
		setParent -m $gDisplayShowSubmenu;
		$gShowFurItem = `menuItem -label $furStr
						-ia showFolliclesItem
						-annotation (uiRes("m_FurPluginCreateUI.kShowAllFurAnnot")) 
						-c "ShowFur"`;
	}
	
	global string $gDisplayHideSubmenu;
	global string $gHideFurItem;
	
	if (`menu -q -ni $gDisplayHideSubmenu` > 0)
	{
		setParent -m $gDisplayHideSubmenu;
		$gHideFurItem = `menuItem -label $furStr
						-ia hideFolliclesItem
						-annotation (uiRes("m_FurPluginCreateUI.kHideAllFurAnnot")) 
						-c "HideFur"`;
	}
}

global proc HfFurDeleteUI()
{
	global string $gShowFurItem;
	global string $gHideFurItem;
	global string $gSelAllFursItem;
	global string $gClearAllFursItem;
	
	if (`menuItem -exists $gHideFurItem`)
		deleteUI -mi $gHideFurItem;
	if (`menuItem -exists $gShowFurItem`)
		deleteUI -mi $gShowFurItem;
	if (`menuItem -exists $gSelAllFursItem`)
		deleteUI -mi $gSelAllFursItem;
	if (`menuItem -exists $gClearAllFursItem`)
		deleteUI -mi $gClearAllFursItem;
}

global proc HfCreateUI()
{
	global string $gMayaMode;          // the current rendering set
	global string $gMainWindow;        // the main Maya window
	global string $gRenderingMenus[];  // list of menus in Rendering menu set
	global string $gHfHairMenu = "SBSHairMenu";

	// if no such Rendering menuSet exists, then skip
	if (!`menu -q -exists $gHfHairMenu`) {
	setParent $gMainWindow;

	// If the hair menu is already there, the plugin must have been
	// loaded already, so delete all items. If it isn't there
	// create it
	//
	int	$createdMenu = false;

	if ( `menu -exists $gHfHairMenu`) {
		menu -e -deleteAllItems $gHfHairMenu;
	} else {
		$gRenderingMenus[size($gRenderingMenus)] = `menu
			-label (uiRes("m_FurPluginCreateUI.kCreateFurMenu")) -allowOptionBoxes true -tearOff true
			-familyImage "menuIconFur.png" $gHfHairMenu`;
		$createdMenu = true;

		// get the rendering menuSet
		string $renderingstr = (uiRes("m_FurPluginCreateUI.kRendering"));
		string $renderingMenuSet = `findMenuSetFromLabel $renderingstr`;
		if ($renderingMenuSet != "") {
			string $furLabel = `menu -q -label $gHfHairMenu`;
			string $furMenu = `findMenuFromMenuSet $renderingMenuSet $furLabel`;
			if ($furMenu == "") {
				menuSet -addMenu $gHfHairMenu $renderingMenuSet;
			}
		}
	}

	// Unless the Rendering set is currently displayed, hide the menu
	//
	if ( $gMayaMode != "renderingMenuSet" ) {
		menu -e -vis 0 $gHfHairMenu;
	} else {
		menu -e -enable true $gHfHairMenu;
	}

	// enable menu and initialize the pre menu callback
	//
	menu -e
		-pmc (
			"HfCheckHDSubMenu1 editHDItem true;"
		  //+ "HfCheckHDSubMenu1 attachHFItem true;"
		  + "HfCheckHairPaintMenu hairPaintItem hairPaintDialogItem;"
		  + "HfCheckFurShadowingMenu furShadowItem;"
		  + "string $menuItems[];"
		  + "$menuItems[0] = \"assignHDItem\";"
		  + "$menuItems[1] = \"flipNormalsItem\";"
		  + "$menuItems[2] = \"offsetAngleItem\";"
		  + "HfEnableIfSelectedSurfaces($menuItems);"
		)
		$gHfHairMenu;

	// add menu items
	//
	setParent -menu $gHfHairMenu;

	menuItem -label (uiRes("m_FurPluginCreateUI.kAttachFurDesc")) 
		-annotation (uiRes("m_FurPluginCreateUI.kAttachFurDescAnnot")) 
		-subMenu true
		-pmc "HfAssignHDSubMenu assignHDItem"
		-allowOptionBoxes true
		assignHDItem;
		menuItem -label (uiRes("m_FurPluginCreateUI.kAttachFurDescNone")) ;
	setParent -menu ..;

	menuItem -label (uiRes("m_FurPluginCreateUI.kCreateUIEditFurDesc")) 
		-annotation (uiRes("m_FurPluginCreateUI.kCreateUIEditFurDescAnnot")) 
		-subMenu true
		-pmc "HfEditHDSubMenu editHDItem"
		editHDItem;
		menuItem -label (uiRes("m_FurPluginCreateUI.kCreateUIEditFurDescNone")) ;
	setParent -menu ..;

	// create a user paint context for painting hair attributes
	//
	menuItem -label (uiRes("m_FurPluginCreateUI.kPaintFurAttrib")) 
		-annotation (uiRes("m_FurPluginCreateUI.kPaintFurAttribAnnot")) 
		-image "furPaint.png"
		-c "HfPaintHairAttrTool 0"
		hairPaintItem;
		menuItem -optionBox true 
			-annotation (uiRes("m_FurPluginCreateUI.kPaintFurAttribOptBoxAnnot")) 
			-image "furPaint.png"
			-label (uiRes("m_FurPluginCreateUI.kPaintFurAttribOptBox"))
			-c "HfPaintHairAttrTool 1" 
			hairPaintDialogItem;
	
	menuItem -label (uiRes("m_FurPluginCreateUI.kUpdateFurMaps"))  
		-annotation (uiRes("m_FurPluginCreateUI.kUpdateFurMapsAnnot")) 
		-c "HfUpdateFurMaps"
		furMapsItem;	
	
	menuItem -label (uiRes("m_FurPluginCreateUI.kFurDesc")) 
		-subMenu true -allowOptionBoxes true
		-pmc (
			"HfCheckHDSubMenu3 CopyHDItem selectHDItem deleteHDItem false;"
		  + "HfCheckHDSubMenu1 unassignHDItem true;"
		)
		-tearOff true
		furDescriptionItem;

		menuItem -label (uiRes("m_FurPluginCreateUI.kCreateUnattach")) 
			-annotation (uiRes("m_FurPluginCreateUI.kCreateUnattachAnnot")) 
			-c "HfPerformCreateHD 0"
			createHDItem;

		menuItem -label (uiRes("m_FurPluginCreateUI.kDetach")) 
			-annotation (uiRes("m_FurPluginCreateUI.kDetachAnnot")) 
			-subMenu true
			-pmc "HfUnassignHDSubMenu unassignHDItem"
			unassignHDItem;
			menuItem -label (uiRes("m_FurPluginCreateUI.kDetachNone")) ;
		setParent -menu ..;

		menuItem -label (uiRes("m_FurPluginCreateUI.kDuplicate")) 
			-annotation (uiRes("m_FurPluginCreateUI.kDuplicateAnnot")) 
			-subMenu true
			-pmc "HfCopyHDSubMenu CopyHDItem"
			CopyHDItem;
			menuItem -label (uiRes("m_FurPluginCreateUI.kDuplicateNone")) ;
		setParent -menu ..;

		menuItem -label (uiRes("m_FurPluginCreateUI.kDelete")) 
			-annotation (uiRes("m_FurPluginCreateUI.kDeleteAnnot")) 
			-subMenu true
			-pmc "HfDeleteHDSubMenu deleteHDItem"
			deleteHDItem;
			menuItem -label (uiRes("m_FurPluginCreateUI.kDeleteNone")) ;
		setParent -menu ..;

		menuItem -label (uiRes("m_FurPluginCreateUI.kSelSurfAttach")) 
			-annotation (uiRes("m_FurPluginCreateUI.kSelSurfAttachAnnot")) 
			-subMenu true
			-pmc "HfSelectAttachedHDSubMenu selectHDItem"
			selectHDItem;
			menuItem -label (uiRes("m_FurPluginCreateUI.kSelSurfAttachNone")) ;
		setParent -menu ..;
	setParent -menu ..;

	menuItem -divider true;

	menuItem -label (uiRes("m_FurPluginCreateUI.kRevFurNorm")) 
		-annotation (uiRes("m_FurPluginCreateUI.kRevFurNormAnnot")) 
		-c "HfFlipHairNormals"
		flipNormalsItem;

	menuItem -label (uiRes("m_FurPluginCreateUI.kOffFurDir")) 
		-annotation (uiRes("m_FurPluginCreateUI.kOffFurDirAnnot")) 
		-subMenu true
		-tearOff true
		offsetAngleItem;
		menuItem -label (uiRes("m_FurPluginCreateUI.kOffFur0Deg")) 
			-annotation (uiRes("m_FurPluginCreateUI.kOffFur0DegAnnot")) 
			-c "HfOffsetHairAngle 0.0"
			offset0Item;
		menuItem -label (uiRes("m_FurPluginCreateUI.kOffFur90Deg")) 
			-c "HfOffsetHairAngle 0.25"
			-annotation (uiRes("m_FurPluginCreateUI.kOffFur90DegAnnot")) 
			offset90Item;
		menuItem -label (uiRes("m_FurPluginCreateUI.kOffFur180Deg")) 
			-c "HfOffsetHairAngle 0.50"
			-annotation (uiRes("m_FurPluginCreateUI.kOffFur180DegAnnot")) 
			offset180Item;
		menuItem -label (uiRes("m_FurPluginCreateUI.kOffFur270Deg")) 
			-c "HfOffsetHairAngle 0.75"
			-annotation (uiRes("m_FurPluginCreateUI.kOffFur270DegAnnot")) 
			offset270Item;
	setParent -menu ..;

	menuItem -divider true;

	menuItem -label (uiRes("m_FurPluginCreateUI.kFurShadowAttrib")) 
		-annotation (uiRes("m_FurPluginCreateUI.kFurShadowAttribAnnot")) 
		-subMenu true
		-tearOff true
		furShadowItem;
		menuItem -label (uiRes("m_FurPluginCreateUI.kAddSelLight")) 
			-annotation (uiRes("m_FurPluginCreateUI.kAddSelLightAnnot")) 
			-c "HfPerformAddLightAttr"
			addLightAttrItem;
		menuItem -label (uiRes("m_FurPluginCreateUI.kRemoveSelLight")) 
			-annotation (uiRes("m_FurPluginCreateUI.kRemoveSelLightAnnot")) 
			-c "HfPerformRemoveLightAttr"
			removeLightAttrItem;
	setParent -menu ..;

	menuItem -label (uiRes("m_FurPluginCreateUI.kFurRenderSettings")) 
		-annotation (uiRes("m_FurPluginCreateUI.kFurRenderSettingsAnnot")) 
		-c "HfShowHairGlobal" 
		hairGlobalItem;

	menuItem -divider true;

	menuItem -label (uiRes("m_FurPluginCreateUI.kAttachHairSystem")) 
		-annotation (uiRes("m_FurPluginCreateUI.kAttachHairSystemAnnot")) 
		-subMenu true
		-pmc "HfAssignHSFDSubMenu assignHSFDItem"			
		assignHSFDItem;
		menuItem -label (uiRes("m_FurPluginCreateUI.kAttachHairSystemNone")) ;
	setParent -menu ..;

	menuItem -label (uiRes("m_FurPluginCreateUI.kDetachHairSystem")) 
		-annotation (uiRes("m_FurPluginCreateUI.kDetachHairSystemAnnot")) 
		-subMenu true
		-pmc "HfDetachHSSubMenu detachHSItem"			
		detachHSItem;
		menuItem -label (uiRes("m_FurPluginCreateUI.kDetachHairSystemNone")) ;
	setParent -menu ..;	
		
	menuItem -label (uiRes("m_FurPluginCreateUI.kEditCrvAttractor")) 
		-annotation (uiRes("m_FurPluginCreateUI.kEditCrvAttractorAnnot")) 
		-subMenu true
		-pmc "HfEditCASSubMenu editCASItem"
		editCASItem;
		menuItem -label (uiRes("m_FurPluginCreateUI.kEditCrvAttractorNone")) ;
	setParent -menu ..;

	menuItem -label (uiRes("m_FurPluginCreateUI.kSetStartPos")) 
		-annotation (uiRes("m_FurPluginCreateUI.kSetStartPosAnnot")) 
		-subMenu true
		-pmc "HfSetStartPositionMenu setStartPosItem"
		setStartPosItem;
		menuItem -label (uiRes("m_FurPluginCreateUI.kSetStartPosNone")) ;
	setParent -menu ..;
	
	menuItem -label (uiRes("m_FurPluginCreateUI.kDelCrvAttractor")) 
		-annotation (uiRes("m_FurPluginCreateUI.kDelCrvAttractorAnnot")) 
		-subMenu true
		-pmc "HfDeleteCASSubMenu deleteCASItem"
		deleteCASItem;
		menuItem -label (uiRes("m_FurPluginCreateUI.kDelCrvAttractorNone")) ;
	setParent -menu ..;


	if ( $createdMenu ) {
		hotBox -um;    // rebuild the hotbox with the new menu
		updateMenuModeUI;
	}
	HfNameCommandSetup();

	//Add Fur/UV Linking menu item.
	//
	global string $uvMainLinkMenu;
	global string $furUVLinkMenuItem;

	if ( `menuItem -exists $uvMainLinkMenu` )
	{
		setParent -m $uvMainLinkMenu;

		$furUVLinkMenuItem = `menuItem -ecr false -label (uiRes("m_FurPluginCreateUI.kFurUV"))  
		-annotation (getRunTimeCommandAnnotation("FurUVSetLinkingEditor"))
		-c "FurUVSetLinkingEditor"`;
	}
	
	//Add Hair/Fur Linking menu item.
	//
	global string $relationshipEditorPulldownMenu;
	global string $hairFurLinkMenuItem;
	if ( `menuItem -exists $relationshipEditorPulldownMenu` )
	{
		setParent -m $relationshipEditorPulldownMenu;
		$hairFurLinkMenuItem = `menuItem -ecr false -label (uiRes("m_FurPluginCreateUI.kFurHairLink")) 
		-annotation (uiRes("m_FurPluginCreateUI.kFurHairLinkAnnot")) 
		-c "HairFurRelationshipEditor"`;
	}
  }
		
}

// This is called by the plugin so that we know where the plugin was
// located
//
global proc FurPluginPath(
	string	$pluginPath,
	string	$pluginName
)
{
	global string	$gHfPluginPath;
	global string	$gHfPluginName;

	$gHfPluginPath = $pluginPath;
	$gHfPluginName = $pluginName;
}

// This is called by the plugin so that we know what state Maya is in
// and whether an edit license is available. This is the point where
// the Maya Fur UI is created, if applicable.
//
global proc FurPluginMayaState(
	int		 $state,	// 0 - interactive, 1 - batch, -1 - Everything else
	int		 $editLicense
)
{
	global int		$gHfMayaState;

	$gHfMayaState = $state;

	// only create UI if Maya is in interactive mode and if an
	// edit license is available
	//
	if ( $state == 0 && $editLicense ) {
		global string	$gMainWindow;
		
		// If the size of the $gMainWindow string is greater than 0 assume we have
		// some UI in place and we can create our UI. Otherwise create a script job
		// which will create the UI on the first tool change at which point we better
		// have some UI
		//
		if ( size( $gMainWindow ) > 0 ) {
			HfCreateUI;
		} else {
			scriptJob -runOnce true -event "ToolChanged" "HfCreateUI";
		}
	}		
}
//////////////////////////////////////////////////////////
//														//
// Description: Procedures used for MayaFur Test suite. //
//														//				
//////////////////////////////////////////////////////////


global proc HfBakeMappedAttribute( string $node, string	$attr )
{
	int $dummy[];
	string $dummyFiles[];
	bakeMappedAttribute($node,$attr, false, $dummy, $dummyFiles,$dummyFiles);
}

global proc HfSetCreateEqualMap()
{
	string $hairGlobal = HfBuildHairGlobal();
	if(`attributeQuery -ex -node $hairGlobal "createEqualMap"`)
		setAttr ($hairGlobal+ ".createEqualMap") false;
}
