## +
## ===================================================================
## Copyright(C) 2010 - 2012 Basefount Technology (Hong Kong) Limited.
## and/or its licensors.  All rights reserved.
##
## The coded instructions, statements, computer programs, and/or
## related material (collectively the "Data") in these files contain
## unpublished information proprietary to Basefount Technology
## (Hong Kong) Limitd. ("Basefount") and/or its licensors, which is
## protected by Hong Kong copyright law and by international treaties.
##
## The Data is provided for use exclusively by You. You have the right 
## to use, modify, and incorporate this Data into other products for 
## purposes authorized by the Basefount software license agreement, 
## without fee.
##
## The copyright notices in the Software and this entire statement, 
## including the above license grant, this restriction and the 
## following disclaimer, must be included in all copies of the 
## Software, in whole or in part, and all derivative works of 
## the Software, unless such copies or derivative works are solely 
## in the form of machine-executable object code generated by a 
## source language processor.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
## BASEFOUNT DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR
## IMPLIED WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES
## OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
## PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR 
## TRADE PRACTICE. IN NO EVENT WILL BASEFOUNT AND/OR ITS LICENSORS 
## BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL, 
## DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF BASEFOUNTAIN 
## AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY 
## OR PROBABILITY OF SUCH DAMAGES.
##
## ===================================================================
## -

## +
## ===================================================================
##  Module Name: McdRenderRMFunction.py
##
##  Description:
##    Deal with relationship between actions and state machine nodes.
##
## ===================================================================
## -

import gzip
import os
import shutil
from McdGeneral import *
import maya.cmds as cmds
import maya.mel as mel


if int(mel.eval("getApplicationVersionAsFloat")) >= 2013:
    import mentalray.renderProxyUtils
else:
    import maya.app.mentalray.renderProxyUtils
    
def McdMRSetupCurrentFrame():
    # create temp namespace temptemp
    # read export path name from MGlobal
    # read export file name from MGlobal
    # check availablity
    # create extra path
    # execute
    # create box and naming it to McdMRRenderDummy
    # link this to MR contents
    # no animation:
    
    
    
    allAgents = cmds.ls(type = "McdAgent")
    if allAgents == [] or allAgents == None:
        cmds.confirmDialog(t = "Error", m = 'Please Place your agents firstly.')
        return
    
    
    allRenderGlobals = cmds.ls(type = "renderGlobals")
    if allRenderGlobals == None or allRenderGlobals == []:
        return;
        
    for i in range(len(allRenderGlobals)):
        anim = cmds.getAttr(allRenderGlobals[i] + '.animation')
        if anim > 0:
            cmds.confirmDialog(t = "Question", m = 'Will automatically setup Render from "frame range" to "single frame"')
            break;
        
    for i in range(len(allRenderGlobals)):
        try:
            cmds.setAttr(allRenderGlobals[i] + '.animation', 0)
        except:
            pass
    
    try:
        globalNode = mel.eval("McdSimpleCommand -exe 2;")
        if globalNode == "_NULL_":
            raise
    except:
        cmds.confirmDialog(t = "Error", m = "Cannot find Miarmy Global Node, please create it in Miarmy > Miarmy Ready")
        return;
    

    # read export path name from MGlobal
    outputPath = cmds.getAttr(globalNode + ".outputMIFolder")
    # read export file name from MGlobal
    outputName = cmds.getAttr(globalNode + ".outputMIName")
    
    # check availablity
    if outputPath == None:
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    
    if not os.access(outputPath, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    
    # create extra path
    try:
        os.makedirs(outputPath + "/" + outputName)
    except:
        pass
    
    try:
        os.makedirs(outputPath + "/" + outputName + "/miFrameDump")
    except:
        pass
    
    try:
        os.makedirs(outputPath + "/" + outputName + "/miProxy")
    except:
        pass
    
    if not os.access(outputPath + "/" + outputName, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    if not os.access(outputPath + "/" + outputName + "/miFrameDump", os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    if not os.access(outputPath + "/" + outputName + "/miProxy", os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    
    # add namespace for exporting!! -----------------------------------------
    try:
        cmds.namespace(add = "temptemp")
    except:
        pass
    allGeoGrps = cmds.ls("Geometry_*")
    if allGeoGrps != [] and allGeoGrps != None:
        for i in range(len(allGeoGrps)):
            if i == 0:
                cmds.select(allGeoGrps[i])
            else:
                cmds.select(allGeoGrps[i], add = True)
    cmds.select(hi = True)
    selObjs = cmds.ls(sl = True)
    allNeedToBeRename = []
    if selObjs != [] and selObjs != None:
        for i in range(len(selObjs)):
            if cmds.nodeType(selObjs[i]) != "mesh":
                allNeedToBeRename.append(selObjs[i])
    if allNeedToBeRename != []:
        for i in range(len(allNeedToBeRename)):
            k = len(allNeedToBeRename) - i - 1
            if (allNeedToBeRename[k].find("|") >= 0 ):
                restName = allNeedToBeRename[k].split("|")[-1]
                cmds.rename(allNeedToBeRename[k], "temptemp:" + restName)
            else:
                cmds.rename(allNeedToBeRename[k], "temptemp:" + allNeedToBeRename[k])
    # add namespace for exporting!! -----------------------------------------
    
    
    # ############################################################
    # randomize textures:
    isRandTex = False
    stat = cmds.confirmDialog(t = "Question", m = "Do you want to try randomizing the textures?", b = ["Yes", "No"])
    if stat == "Yes":
        isRandTex = True
        cmds.setAttr(globalNode + ".boolMaster[2]", 1)
    else:
        cmds.setAttr(globalNode + ".boolMaster[2]", 0)
        
    if isRandTex:
        McdRandomMRTexturePre()
    # ----- link down
    
    # execute
    # example: McdRenderExportCmd -r 0 -filePath "d:/abc/abc" -fileName "testing"
    melCmd = 'McdRenderExportCmd -r 0 -filePath "' + outputPath + '" -fileName "' + outputName + '"'
    mel.eval(melCmd)

    # ----- up link
    if isRandTex:
        McdRandomMRTexturePost()
    McdClearFrameDump()
    # ############################################################
    
    # add namespace for exporting!! -----------------------------------------
    selObjs = cmds.ls("temptemp:*")
    allNSObjs = []
    if selObjs != [] and selObjs != None:
        for i in range(len(selObjs)):
            if cmds.nodeType(selObjs[i]) != "mesh":
                allNSObjs.append(selObjs[i])
    if allNSObjs != []:
        cmds.select(allNSObjs)
        for i in range(len(allNSObjs)):
            allObj = cmds.ls(sl = True)
            newName = allObj[i].split(":")[-1]
            newName = newName.split("|")[-1]
            cmds.rename(allObj[i], newName)

    try:
        cmds.namespace(remove = "temptemp")
    except:
        pass
    # add namespace for exporting!! -----------------------------------------
    
    # create box and naming it to McdMRRenderDummy
    dummyCubeTemp = cmds.ls("McdMRRenderDummy")
    dummyCube = ""
    if dummyCubeTemp != [] and dummyCubeTemp != None:
        dummyCube = dummyCubeTemp[0]
    if dummyCube == "":
        cmds.polyPlane(n = "McdMRRenderDummy", sx = 1, sy = 1)
    
    # pading:
    currentFrame = cmds.currentTime(q = True)
    frameNumber = str(int(currentFrame))
    while(len(frameNumber) < 4):
        frameNumber = "0" + frameNumber
        
    
    # link this to MR contents
    cmds.setAttr("McdMRRenderDummy.miProxyFile", outputPath + "/" + outputName + "/miProxy/proxy" + outputName + "." + frameNumber + ".mi", \
                                                type = "string")


    if int(mel.eval("getApplicationVersionAsFloat")) >= 2013:
        mentalray.renderProxyUtils.resizeToBoundingBox("McdMRRenderDummyShape")
    else:
        maya.app.mentalray.renderProxyUtils.resizeToBoundingBox("McdMRRenderDummyShape")
        


def McdMRSetupAllFrame():
    try:
        cmds.delete("McdMRRenderDummy")
    except:
        pass
    
    allAgents = cmds.ls(type = "McdAgent")
    if allAgents == [] or allAgents == None:
        cmds.confirmDialog(t = "Error", m = 'Please Place your agents firstly.')
        return
    
    allRenderGlobals = cmds.ls(type = "renderGlobals")
    if allRenderGlobals == None or allRenderGlobals == []:
        return;
        
    for i in range(len(allRenderGlobals)):
        anim = cmds.getAttr(allRenderGlobals[i] + '.animation')
        if anim > 0:
            cmds.confirmDialog(t = "Question", m = 'Will automatically setup Render from "frame range" to "single frame"')
            break;
        
    for i in range(len(allRenderGlobals)):
        try:
            cmds.setAttr(allRenderGlobals[i] + '.animation', 0)
        except:
            pass
    
    # delete pre mel script:
    allRenderGlobals = cmds.ls(type = "renderGlobals")
    if allRenderGlobals == None or allRenderGlobals == []:
        return;
        
    for i in range(len(allRenderGlobals)):
        try:
            cmds.setAttr(allRenderGlobals[i] + '.preMel','', type = "string")
        except:
            pass
    
    # find global node:
    try:
        globalNode = mel.eval("McdSimpleCommand -exe 2;")
        if globalNode == "_NULL_":
            raise
    except:
        cmds.confirmDialog(t = "Error", m = "Cannot find Miarmy Global Node, please create it in Miarmy > Miarmy Ready")
        return;
    
    # read export path name from MGlobal
    outputPath = cmds.getAttr(globalNode + ".outputMIFolder")
    # read export file name from MGlobal
    outputName = cmds.getAttr(globalNode + ".outputMIName")
    isGzip = cmds.getAttr(globalNode + ".outputMIGzip")
    
    # check availablity
    if not os.access(outputPath, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    
    # create extra path
    try:
        os.makedirs(outputPath + "/" + outputName)
    except:
        pass
    
    try:
        os.makedirs(outputPath + "/" + outputName + "/miFrameDump")
    except:
        pass
    
    try:
        os.makedirs(outputPath + "/" + outputName + "/miProxy")
    except:
        pass
    
    if not os.access(outputPath + "/" + outputName, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    if not os.access(outputPath + "/" + outputName + "/miFrameDump", os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    if not os.access(outputPath + "/" + outputName + "/miProxy", os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;        

    
    # ############################################################
    # randomize textures:
    isRandTex = False
    stat = cmds.confirmDialog(t = "Question", m = "Do you want to try randomizing the textures?", b = ["Yes", "No"])
    if stat == "Yes":
        isRandTex = True
        cmds.setAttr(globalNode + ".boolMaster[2]", 1)
    else:
        cmds.setAttr(globalNode + ".boolMaster[2]", 0)
        
    if isRandTex:
        McdRandomMRTexturePre()
    # ----- link down
    
    # not execute
    # example: McdRenderExportCmd -r 0 -filePath "d:/abc/abc" -fileName "testing"
    melCmd = 'McdRenderExportCmd -r 0 -filePath "' + outputPath + '" -fileName "' + outputName + '"'
    
    minFrame = cmds.playbackOptions(q = True, min = True)
    maxFrame = cmds.playbackOptions(q = True, max = True)
    nbFrame = int(maxFrame - minFrame + 1)
    
    stat = cmds.confirmDialog(t = "Note", m = "Export .mi file from " + str(minFrame) + " to " + str(maxFrame) + "\n" + \
                                     "We recommend you save your sence before exporting, continue?", b = ["Proceed", "Cancel"])
    
    if stat == "Cancel":
        return;
    
    # create box and naming it to McdMRRenderDummy
    dummyGrpTemp = cmds.ls("McdMRRenderDummy_Grp")
    dummyGrp = ""
    if dummyGrpTemp != [] and dummyGrpTemp != None:
        dummyGrp = dummyGrpTemp[0]
    if dummyGrp == "":
        cmds.select(clear = True)
        cmds.group(n = "McdMRRenderDummy_Grp", em = True)
    
    for i in range(nbFrame):
        frameNumberNum = minFrame + i
        cmds.currentTime(frameNumberNum)
        
        # add namespace for exporting!! -----------------------------------------
        try:
            cmds.namespace(add = "temptemp")
        except:
            pass
        allGeoGrps = cmds.ls("Geometry_*")
        if allGeoGrps != [] and allGeoGrps != None:
            for i in range(len(allGeoGrps)):
                if i == 0:
                    cmds.select(allGeoGrps[i])
                else:
                    cmds.select(allGeoGrps[i], add = True)
        cmds.select(hi = True)
        selObjs = cmds.ls(sl = True)
        allNeedToBeRename = []
        if selObjs != [] and selObjs != None:
            for i in range(len(selObjs)):
                if cmds.nodeType(selObjs[i]) != "mesh":
                    allNeedToBeRename.append(selObjs[i])
        if allNeedToBeRename != []:
            for i in range(len(allNeedToBeRename)):
                k = len(allNeedToBeRename) - i - 1
                if (allNeedToBeRename[k].find("|") >= 0 ):
                    restName = allNeedToBeRename[k].split("|")[-1]
                    cmds.rename(allNeedToBeRename[k], "temptemp:" + restName)
                else:
                    cmds.rename(allNeedToBeRename[k], "temptemp:" + allNeedToBeRename[k])
                
        # add namespace for exporting!! -----------------------------------------
        
        # real execute:
        mel.eval(melCmd)
        
        # add namespace for exporting!! -----------------------------------------
        selObjs = cmds.ls("temptemp:*")
        allNSObjs = []
        if selObjs != [] and selObjs != None:
            for i in range(len(selObjs)):
                if cmds.nodeType(selObjs[i]) != "mesh":
                    allNSObjs.append(selObjs[i])
        if allNSObjs != []:
            cmds.select(allNSObjs)
            for i in range(len(allNSObjs)):
                allObj = cmds.ls(sl = True)
                newName = allObj[i].split(":")[-1]
                newName = newName.split("|")[-1]
                cmds.rename(allObj[i], newName)
    
        try:
            cmds.namespace(remove = "temptemp")
        except:
            pass
        # add namespace for exporting!! -----------------------------------------
        
        # pading:
        frameNumber = str(int(frameNumberNum))
        while(len(frameNumber) < 4):
            frameNumber = "0" + frameNumber
            
        if isGzip == 1:
            os.rename(outputPath + "/" + outputName + "/geo" + outputName + "." + frameNumber + ".mi", \
                      outputPath + "/" + outputName + "/geo" + outputName + "." + frameNumber + ".mi.tmp")
            
            f_in = open(outputPath + "/" + outputName + "/geo" + outputName + "." + frameNumber + ".mi.tmp", 'rb')
            f_out = gzip.open(outputPath + "/" + outputName + "/geo" + outputName + "." + frameNumber + ".mi", 'wb')
            f_out.writelines(f_in)
            f_out.close()
            f_in.close()
            
            os.remove(outputPath + "/" + outputName + "/geo" + outputName + "." + frameNumber + ".mi.tmp")
            

        # create box and naming it to McdMRRenderDummy
        dummyCubeTemp = cmds.ls("McdMRRenderDummy" + frameNumber)
        dummyCube = ""
        if dummyCubeTemp != [] and dummyCubeTemp != None:
            dummyCube = dummyCubeTemp[0]
        if dummyCube == "":
            cmds.polyPlane(n = "McdMRRenderDummy" + frameNumber, sx = 1, sy = 1)
            
        # keyframe for hide/unhide:
        cmds.setKeyframe("McdMRRenderDummy" + frameNumber, v = 0, at='v', t = frameNumberNum - 1 )
        cmds.setKeyframe("McdMRRenderDummy" + frameNumber, v = 1, at='v', t = frameNumberNum )
        cmds.setKeyframe("McdMRRenderDummy" + frameNumber, v = 0, at='v', t = frameNumberNum + 1 )
            
        childNode = cmds.listRelatives("McdMRRenderDummy" + frameNumber, c = True, p = False)[0]
        
        # link this to MR contents
        cmds.setAttr("McdMRRenderDummy" + frameNumber + ".miProxyFile", \
                   outputPath + "/" + outputName + "/miProxy/proxy" + outputName + "." + frameNumber + ".mi", \
                   type = "string")
        
        if int(mel.eval("getApplicationVersionAsFloat")) >= 2013:
            mentalray.renderProxyUtils.resizeToBoundingBox(childNode)
        else:
            maya.app.mentalray.renderProxyUtils.resizeToBoundingBox(childNode)
        
        try:
            cmds.parent("McdMRRenderDummy" + frameNumber, "McdMRRenderDummy_Grp")
        except:
            pass
        
    # ----- up link
    if isRandTex:
        McdRandomMRTexturePost()
    McdClearFrameDump()
    # ############################################################

def McdMRLinkMISequence():
    try:
        cmds.delete("McdMRRenderDummy")
    except:
        pass
    
    allAgents = cmds.ls(type = "McdAgent")
    if allAgents == [] or allAgents == None:
        cmds.confirmDialog(t = "Error", m = 'Please Place your agents firstly.')
        return
    
    allRenderGlobals = cmds.ls(type = "renderGlobals")
    if allRenderGlobals == None or allRenderGlobals == []:
        return;
        
    for i in range(len(allRenderGlobals)):
        anim = cmds.getAttr(allRenderGlobals[i] + '.animation')
        if anim > 0:
            cmds.confirmDialog(t = "Question", m = 'Will automatically setup Render from "frame range" to "single frame"')
            break;
        
    for i in range(len(allRenderGlobals)):
        try:
            cmds.setAttr(allRenderGlobals[i] + '.animation', 0)
        except:
            pass
    
    # delete pre mel script:
    allRenderGlobals = cmds.ls(type = "renderGlobals")
    if allRenderGlobals == None or allRenderGlobals == []:
        return;
        
    for i in range(len(allRenderGlobals)):
        try:
            cmds.setAttr(allRenderGlobals[i] + '.preMel','', type = "string")
        except:
            pass
    
    # find global node:
    try:
        globalNode = mel.eval("McdSimpleCommand -exe 2;")
        if globalNode == "_NULL_":
            raise
    except:
        cmds.confirmDialog(t = "Error", m = "Cannot find Miarmy Global Node, please create it in Miarmy > Miarmy Ready")
        return;
    
    # read export path name from MGlobal
    outputPath = cmds.getAttr(globalNode + ".outputMIFolder")
    # read export file name from MGlobal
    outputName = cmds.getAttr(globalNode + ".outputMIName")
    isGzip = cmds.getAttr(globalNode + ".outputMIGzip")
    
    # check availablity
    if not os.access(outputPath, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    
    # create extra path
    try:
        os.makedirs(outputPath + "/" + outputName)
    except:
        pass
    
    try:
        os.makedirs(outputPath + "/" + outputName + "/miFrameDump")
    except:
        pass
    
    try:
        os.makedirs(outputPath + "/" + outputName + "/miProxy")
    except:
        pass
    
    if not os.access(outputPath + "/" + outputName, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    if not os.access(outputPath + "/" + outputName + "/miFrameDump", os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    if not os.access(outputPath + "/" + outputName + "/miProxy", os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;        

    
    # ############################################################
    # randomize textures:
    isRandTex = False
    stat = cmds.confirmDialog(t = "Question", m = "Do you want to try randomizing the textures?", b = ["Yes", "No"])
    if stat == "Yes":
        isRandTex = True
        cmds.setAttr(globalNode + ".boolMaster[2]", 1)
    else:
        cmds.setAttr(globalNode + ".boolMaster[2]", 0)
        
    if isRandTex:
        McdRandomMRTexturePre()
    # ----- link down
    
    # not execute
    # example: McdRenderExportCmd -r 0 -filePath "d:/abc/abc" -fileName "testing"
    melCmd = 'McdRenderExportCmd -r 0 -filePath "' + outputPath + '" -fileName "' + outputName + '"'
    
    minFrame = cmds.playbackOptions(q = True, min = True)
    maxFrame = cmds.playbackOptions(q = True, max = True)
    nbFrame = int(maxFrame - minFrame + 1)
    
    stat = cmds.confirmDialog(t = "Note", m = "Link existed .mi file from " + str(minFrame) + " to " + str(maxFrame) + "\n" + \
                                     "We recommend you save your sence before exporting, continue?", b = ["Proceed", "Cancel"])
    
    if stat == "Cancel":
        return;
    
    # create box and naming it to McdMRRenderDummy
    dummyGrpTemp = cmds.ls("McdMRRenderDummy_Grp")
    dummyGrp = ""
    if dummyGrpTemp != [] and dummyGrpTemp != None:
        dummyGrp = dummyGrpTemp[0]
    if dummyGrp == "":
        cmds.select(clear = True)
        cmds.group(n = "McdMRRenderDummy_Grp", em = True)
    
    for i in range(nbFrame):
        frameNumberNum = minFrame + i
        cmds.currentTime(frameNumberNum)
        
        
        # pading:
        frameNumber = str(int(frameNumberNum))
        while(len(frameNumber) < 4):
            frameNumber = "0" + frameNumber
            

        # create box and naming it to McdMRRenderDummy
        dummyCubeTemp = cmds.ls("McdMRRenderDummy" + frameNumber)
        dummyCube = ""
        if dummyCubeTemp != [] and dummyCubeTemp != None:
            dummyCube = dummyCubeTemp[0]
        if dummyCube == "":
            cmds.polyPlane(n = "McdMRRenderDummy" + frameNumber, sx = 1, sy = 1)
            
        # keyframe for hide/unhide:
        cmds.setKeyframe("McdMRRenderDummy" + frameNumber, v = 0, at='v', t = frameNumberNum - 1 )
        cmds.setKeyframe("McdMRRenderDummy" + frameNumber, v = 1, at='v', t = frameNumberNum )
        cmds.setKeyframe("McdMRRenderDummy" + frameNumber, v = 0, at='v', t = frameNumberNum + 1 )
            
        childNode = cmds.listRelatives("McdMRRenderDummy" + frameNumber, c = True, p = False)[0]
        
        # link this to MR contents
        cmds.setAttr("McdMRRenderDummy" + frameNumber + ".miProxyFile", \
                   outputPath + "/" + outputName + "/miProxy/proxy" + outputName + "." + frameNumber + ".mi", \
                   type = "string")
        
        if int(mel.eval("getApplicationVersionAsFloat")) >= 2013:
            mentalray.renderProxyUtils.resizeToBoundingBox(childNode)
        else:
            maya.app.mentalray.renderProxyUtils.resizeToBoundingBox(childNode)
        
        try:
            cmds.parent("McdMRRenderDummy" + frameNumber, "McdMRRenderDummy_Grp")
        except:
            pass
        
    # ----- up link
    if isRandTex:
        McdRandomMRTexturePost()
    McdClearFrameDump()
    # ############################################################
        
        
def McdClearMIs():
    # read export path name from MGlobal
    # read export file name from MGlobal
    # check availablity
    # create extra path
    # execute
    # create box and naming it to McdMRRenderDummy
    # link this to MR contents
    
    try:
        globalNode = mel.eval("McdSimpleCommand -exe 2;")
        if globalNode == "_NULL_":
            raise
    except:
        cmds.confirmDialog(t = "Error", m = "Cannot find Miarmy Global Node, please create it in Miarmy > Miarmy Ready")
        return;
    
    # read export path name from MGlobal
    outputPath = cmds.getAttr(globalNode + ".outputMIFolder")
    # read export file name from MGlobal
    outputName = cmds.getAttr(globalNode + ".outputMIName")
    
    stat = cmds.confirmDialog(t = "Question", m = "Are you sure remove all mi file at:\n" + \
                                            outputPath + "/" + outputName, b = ["Sure", "No"])
    if stat == "No":
        return
    
    try:
        shutil.rmtree(outputPath + "/" + outputName)
    except:
        pass
    
def McdClearFrameDump():
    # read export path name from MGlobal
    # read export file name from MGlobal
    # check availablity
    # create extra path
    # execute
    # create box and naming it to McdMRRenderDummy
    # link this to MR contents
    
    try:
        globalNode = mel.eval("McdSimpleCommand -exe 2;")
        if globalNode == "_NULL_":
            raise
    except:
        cmds.confirmDialog(t = "Error", m = "Cannot find Miarmy Global Node, please create it in Miarmy > Miarmy Ready")
        return;
    
    # read export path name from MGlobal
    outputPath = cmds.getAttr(globalNode + ".outputMIFolder")
    # read export file name from MGlobal
    outputName = cmds.getAttr(globalNode + ".outputMIName")
    
    try:
        shutil.rmtree(outputPath + "/" + outputName + "/miFrameDump")
    except:
        pass

def McdUpdateRenderView(isFillMel):
    allRenderGlobals = cmds.ls(type = "renderGlobals")
    if allRenderGlobals == None or allRenderGlobals == []:
        return;
        
    if isFillMel == 1:
        for i in range(len(allRenderGlobals)):
            try:
                cmds.setAttr(allRenderGlobals[i] + '.preMel','python("McdMRSetupCurrentFrame()");', type = "string")
            except:
                pass
    else:
        for i in range(len(allRenderGlobals)):
            try:
                cmds.setAttr(allRenderGlobals[i] + '.preMel','', type = "string")
            except:
                pass
    
    
def McdMRExportShader():
    # create temp namespace temptemp
    # read export path name from MGlobal
    # read export file name from MGlobal
    # check availablity
    # create extra path
    # execute
    # no animation:
    allAgents = cmds.ls(type = "McdAgent")
    if allAgents == [] or allAgents == None:
        cmds.confirmDialog(t = "Error", m = 'Please Place your agents firstly.')
        return
    
    
    allRenderGlobals = cmds.ls(type = "renderGlobals")
    if allRenderGlobals == None or allRenderGlobals == []:
        return;
        
    for i in range(len(allRenderGlobals)):
        anim = cmds.getAttr(allRenderGlobals[i] + '.animation')
        if anim > 0:
            cmds.confirmDialog(t = "Question", m = 'Will automatically setup Render from "frame range" to "single frame"')
            break;
        
    for i in range(len(allRenderGlobals)):
        try:
            cmds.setAttr(allRenderGlobals[i] + '.animation', 0)
        except:
            pass
    
    try:
        globalNode = mel.eval("McdSimpleCommand -exe 2;")
        if globalNode == "_NULL_":
            raise
    except:
        cmds.confirmDialog(t = "Error", m = "Cannot find Miarmy Global Node, please create it in Miarmy > Miarmy Ready")
        return;
    
    # read export path name from MGlobal
    outputPath = cmds.getAttr(globalNode + ".outputMIFolder")
    # read export file name from MGlobal
    outputName = cmds.getAttr(globalNode + ".outputMIName")
    
    # check availablity
    if not os.access(outputPath, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    
    # create extra path
    try:
        os.makedirs(outputPath + "/" + outputName)
    except:
        pass
    
    try:
        os.makedirs(outputPath + "/" + outputName + "/miFrameDump")
    except:
        pass
    
    try:
        os.makedirs(outputPath + "/" + outputName + "/miProxy")
    except:
        pass
    
    if not os.access(outputPath + "/" + outputName, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    if not os.access(outputPath + "/" + outputName + "/miFrameDump", os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    if not os.access(outputPath + "/" + outputName + "/miProxy", os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;        

    matPath = outputPath + "/" + outputName + "/mat" + outputName + ".mi"
    if os.access(matPath, os.R_OK):
        stat = cmds.confirmDialog(t = "Warning", m = "find shader existed, overwrite it?", b = ["Yes", "No"])
        if stat == "Yes":
            # execute
            # example: McdRenderExportCmd -r 0 -filePath "d:/abc/abc" -fileName "testing"
            melCmd = 'McdRenderExportCmd -r 10 -filePath "' + outputPath + '" -fileName "' + outputName + '"'
            mel.eval(melCmd)
    
    
def McdMRExportAndReplaceShader():
    # create temp namespace temptemp
    # read export path name from MGlobal
    # read export file name from MGlobal
    # check availablity
    # create extra path
    # execute
    # no animation:
    
    allRenderGlobals = cmds.ls(type = "renderGlobals")
    if allRenderGlobals == None or allRenderGlobals == []:
        return;
        
    for i in range(len(allRenderGlobals)):
        anim = cmds.getAttr(allRenderGlobals[i] + '.animation')
        if anim > 0:
            cmds.confirmDialog(t = "Question", m = 'Will automatically setup Render from "frame range" to "single frame"')
            break;
        
    for i in range(len(allRenderGlobals)):
        try:
            cmds.setAttr(allRenderGlobals[i] + '.animation', 0)
        except:
            pass
    
    try:
        globalNode = mel.eval("McdSimpleCommand -exe 2;")
        if globalNode == "_NULL_":
            raise
    except:
        cmds.confirmDialog(t = "Error", m = "Cannot find Miarmy Global Node, please create it in Miarmy > Miarmy Ready")
        return;
    
    # read export path name from MGlobal
    outputPath = cmds.getAttr(globalNode + ".outputMIFolder")
    # read export file name from MGlobal
    outputName = cmds.getAttr(globalNode + ".outputMIName")
    
    # check availablity
    if not os.access(outputPath, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    
    # create extra path
    try:
        os.makedirs(outputPath + "/" + outputName)
    except:
        pass
    
    try:
        os.makedirs(outputPath + "/" + outputName + "/miFrameDump")
    except:
        pass
    
    try:
        os.makedirs(outputPath + "/" + outputName + "/miProxy")
    except:
        pass
    
    if not os.access(outputPath + "/" + outputName, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    if not os.access(outputPath + "/" + outputName + "/miFrameDump", os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    if not os.access(outputPath + "/" + outputName + "/miProxy", os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write mi file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;

    matPath = outputPath + "/" + outputName + "/mat" + outputName + ".mi"
    if not os.access(matPath, os.R_OK):
        cmds.confirmDialog(t = "Abort", m = "No original material file found.")
        return;

    allFiles = os.listdir(outputPath + "/" + outputName)
    nbMiProxy = 0;
    nbMatMI = 0;
    for i in range(len(allFiles)):
        if allFiles[i].find("mat") == 0:
            nbMatMI += 1;
        elif allFiles[i].find("miProxy") == 0:
            nbMiProxy +=1;
    
    indexStr = str(1);
    if nbMatMI > nbMiProxy:
        indexStr = str(nbMatMI);
    else:
        indexStr = str(nbMiProxy);
        
    matPathNew = outputPath + "/" + outputName + "/mat" + outputName + indexStr + ".mi"
    
    # execute
    # example: McdRenderExportCmd -r 0 -filePath "d:/abc/abc" -fileName "testing" -fileIndex 2;
    melCmd = 'McdRenderExportCmd -r 20 -filePath "' + outputPath + '" -fileName "' + outputName + '" -fileIndex ' + indexStr + ';'
    mel.eval(melCmd)
    
    # ----------------------------------------------------------------------------
    
    # open material file
    # get all material names <n times>
    # get first material and copy <n times>
    # change name of them
    # creat new batch proxy folder with indexing
    # replace the path in scene
    # end of pipeline
    
    # open material file
    in_f = open(matPath, "r")
    allMatNames = []
    while(1):
        lineContents = in_f.readline()
        if lineContents.find("material \"") == 0:
            allSegs = lineContents.split('"')
            if len(allSegs) > 2:
                allMatNames.append(allSegs[1])
        if lineContents == "":
            break;
    in_f.close()
    
    if len(allMatNames) == 0:
        cmds.confirmDialog(t = "Failure", m = "No contents in original material mi file.")
        return
    
    # get first material and copy <n times>
    in_f = open(matPathNew, "r")
    matSpots = []
    counter = 0;
    preContents = ""
    matContents = ""
    matContentsFirstLine = ""
    while(1):
        # read
        lineContents = in_f.readline()
        
        # find
        if lineContents.find("material \"") == 0 or lineContents.find("end material") == 0:
            matSpots.append(counter)
              
        # record
        if len(matSpots) == 0:
            preContents += lineContents
        if len(matSpots) == 1:
            if matContentsFirstLine == "":
                matContentsFirstLine = lineContents
            else:
                matContents += lineContents
                
        if lineContents == "":
            break;
        if len(matSpots) == 2:
            matContents += lineContents
            break;
        
        counter += 1;
    in_f.close()
    
    doIt = False
    if len(matSpots) == 2:
        if matSpots[1] > matSpots[0]:
            doIt = True
            
    if not doIt:
        cmds.confirmDialog(t = "Failure", m = "No contents in new material mi file.")
        return
    
    newMatBlock = ""
    for i in range(len(allMatNames)):
        allSegs = matContentsFirstLine.split('"')
        newFirstLine = ""
        if len(allSegs) > 2:
            newFirstLine = allSegs[0] + '"' + allMatNames[i] + '"' + allSegs[2]
            newMatBlock += newFirstLine + matContents
            
    
    allNewContents = preContents + newMatBlock
    
    out_f = open(matPathNew, "w")
    out_f.write(allNewContents)
    out_f.close()
    
    
    # ----------------------------------------------------------------------------
    # creat new batch proxy folder with indexing
    newProxyFolder = outputPath + "/" + outputName + "/miProxy" + indexStr + "/"
    oldProxyFolder = outputPath + "/" + outputName + "/miProxy/"
    try:
        print newProxyFolder
        os.makedirs(newProxyFolder)
    except:
        pass
    
    if not os.access(newProxyFolder, os.W_OK):
        cmds.confirmDialog(t = "Failure", m = "Location unwritable.")
        return
    
    allProxyFiles = os.listdir(outputPath + "/" + outputName + "/miProxy")
    for i in range(len(allProxyFiles)):
        in_f = open(oldProxyFolder + allProxyFiles[i], "r")
        newContents = ""
        counter = 0
        while(1):
            currentLine = in_f.readline()
            
            if counter == 1:
                currentLine = '$include "' + matPathNew + '"' + "\r\n"
            
            newContents += currentLine
            
            if currentLine == "":
                break
            
            counter += 1
        in_f.close()
        
        out_f = open(newProxyFolder + allProxyFiles[i], "w")
        out_f.write(newContents)
        out_f.close()
    
    # --------------------------------------------------------------------------
    # change scene contents:
    
    minFrame = cmds.playbackOptions(q = True, min = True)
    maxFrame = cmds.playbackOptions(q = True, max = True)
    nbFrame = int(maxFrame - minFrame + 1)
    
    stat = cmds.confirmDialog(t = "Note", m = "Replace Shader with Current Setup " + str(minFrame) + " to " + str(maxFrame) + "\n" + \
                                     "We highly recommend you \"SAVE AS\" your sence before exporting, continue?", b = ["Proceed", "Cancel"])
    
    if stat == "Cancel":
        return;
    
    # create box and naming it to McdMRRenderDummy
    dummyGrpTemp = cmds.ls("McdMRRenderDummy_Grp")
    dummyGrp = ""
    if dummyGrpTemp != [] and dummyGrpTemp != None:
        dummyGrp = dummyGrpTemp[0]
    if dummyGrp == "":
        cmds.select(clear = True)
        cmds.group(n = "McdMRRenderDummy_Grp", em = True)
    
    
    counter = 0
    totalCount = nbFrame
    cmds.progressWindow(title = "Replacing", progress = 0, \
                      min = 0, max = totalCount, \
                      status = 'Replacing', isInterruptable = True )
    
    for i in range(nbFrame):
        frameNumberNum = minFrame + i
        cmds.currentTime(frameNumberNum)
        
        # pading:
        frameNumber = str(int(frameNumberNum))
        while(len(frameNumber) < 4):
            frameNumber = "0" + frameNumber

        # create box and naming it to McdMRRenderDummy
        dummyCubeTemp = cmds.ls("McdMRRenderDummy" + frameNumber)
        dummyCube = ""
        if dummyCubeTemp != [] and dummyCubeTemp != None:
            dummyCube = dummyCubeTemp[0]
        if dummyCube == "":
            cmds.polyPlane(n = "McdMRRenderDummy" + frameNumber, sx = 1, sy = 1)
            
        # keyframe for hide/unhide:
        cmds.setKeyframe("McdMRRenderDummy" + frameNumber, v = 0, at='v', t = frameNumberNum - 1 )
        cmds.setKeyframe("McdMRRenderDummy" + frameNumber, v = 1, at='v', t = frameNumberNum )
        cmds.setKeyframe("McdMRRenderDummy" + frameNumber, v = 0, at='v', t = frameNumberNum + 1 )
            
        childNode = cmds.listRelatives("McdMRRenderDummy" + frameNumber, c = True, p = False)[0]
        
        # link this to MR contents
        cmds.setAttr("McdMRRenderDummy" + frameNumber + ".miProxyFile", \
                   outputPath + "/" + outputName + "/miProxy" + indexStr + "/proxy" + outputName + "." + frameNumber + ".mi", \
                   type = "string")
    
        if int(mel.eval("getApplicationVersionAsFloat")) >= 2013:
            mentalray.renderProxyUtils.resizeToBoundingBox(childNode)
        else:
            maya.app.mentalray.renderProxyUtils.resizeToBoundingBox(childNode)
        
        try:
            cmds.parent("McdMRRenderDummy" + frameNumber, "McdMRRenderDummy_Grp")
        except:
            pass
        
        cmds.progressWindow( edit = True, progress = i )
    cmds.progressWindow( endProgress=1 )


def McdRandomMRTexturePre():
    texInfoNode = ""
    allTexNodes = cmds.ls(type = "McdTexInfo")
    if MIsBlank(allTexNodes):
        # create new one:
        texInfoNode = cmds.createNode("McdTexInfo")
    else:
        texInfoNode = allTexNodes[0]
    
    # find out all geo obj
    # duplicate shading group
    # build the mapping list and store
    # delete the McdTexInfo node
    # create new one
    allGeoGrp = cmds.ls("*Geometry_*")
    allGeoGrpRef = cmds.ls("*:Geometry_*")
    allGeoGrp.extend(allGeoGrpRef)
    if McdIsBlank(allGeoGrp):
        return
    allGeoGrpList = []
    for i in range(len(allGeoGrp)):
        geoGrpParent = cmds.listRelatives(allGeoGrp[i], p = True, c = False)
        if McdIsBlank(geoGrpParent):
            continue
        if cmds.nodeType(geoGrpParent[0]) == "McdAgentGroup":
            allGeoGrpList.append(allGeoGrp[i])
    
    allGeos = []
    for i in range(len(allGeoGrpList)):
        allSubNodes = cmds.listRelatives(allGeoGrpList[i], c = True, p = False, ad = True, path = True)
        if McdIsBlank(allSubNodes):
            continue
        for j in range(len(allSubNodes)):
            if cmds.nodeType(allSubNodes[j]) == "mesh":
                if not cmds.getAttr(allSubNodes[j] + ".intermediateObject"):
                    allGeos.append(allSubNodes[j])
    if allGeos == []:
        return
    
    # find all shaders ---------------------------------------------------------
    allShdGrp = []
    for i in range(len(allGeos)):
        allConns = cmds.listConnections(allGeos[i], d = True, s = False)
        if McdIsBlank(allConns):
            continue
        for j in range(len(allConns)):
            if cmds.nodeType(allConns[j]) == "shadingEngine":
                if allConns[j] not in allShdGrp:
                    allShdGrp.append(allConns[j])
    if allShdGrp == []:
        return
        
    allShdGrpCorrect = []
    allShaders = []
    for i in range(len(allShdGrp)):
        allConns = cmds.listConnections(allShdGrp[i], s = True, d = False, p = True)
        if McdIsBlank(allConns):
            continue
        for j in range(len(allConns)):
            if allConns[j].find(".outColor") > 0:
                shaderName = allConns[j].split(".outColor")[0]
                if shaderName not in allShaders:
                    allShaders.append(shaderName)
                    allShdGrpCorrect.append(allShdGrp[i])
    if allShaders == []:
        return

    duplicatedObject = []

    sgCounter = 0
    # for each shaders: --------------------------------------------------------
    for i in range(len(allShaders)):
        # test is this can be randmize
        # find outColor node, "file" node --------------------------------------
        currentShader = allShaders[i]
        belongingSG = allShdGrpCorrect[i]
        allConns = cmds.listConnections(currentShader, d = False, s = True, p = True)
        if McdIsBlank(allConns):
            continue
        allFileRaw = []
        for j in range(len(allConns)):
            if allConns[j].find(".outColor") > 0:
                allFileRaw.append(allConns[j].split(".outColor")[0])
        if allFileRaw == []:
            continue
        
        fileNodeColor = "" # file node connect agaist with color attribute
        for j in range(len(allFileRaw)):
            allConns2 = cmds.listConnections(allFileRaw[j], d = True, s = False, p = True)
            for k in range(len(allConns2)):
                if allConns2[k].find(".color") > 0:
                    fileNodeColor = allFileRaw[j]
                    break
            if fileNodeColor != "":
                break;
        if fileNodeColor == "":
            continue

        # --- we have:
        # 1. fileNodeColor
        # 2. currentShader
        # find file path, and test randomizable? -------------------------------
        texMaster = cmds.getAttr(fileNodeColor + ".fileTextureName")
        if texMaster == None:
            print "# # Error: texture path not set."
            continue
        if not os.access(texMaster, os.R_OK):
            print texMaster
            print "# # Error: texture path not correct."
            continue
        #                                                               # d:/abc/bbb/kkk_ggg_0.jpg
        dirName = os.path.dirname(texMaster)                            # d:/abc/bbb
        baseName = os.path.basename(texMaster)                          # kkk_ggg_0.jpg
            
        baseNameExt = baseName.split(".")[-1]                           # jpg
        baseNamePre = baseName.split("." + baseNameExt)[0]              # kkk_ggg_0
        lastUS = baseNamePre.rfind("_")
        if lastUS <= 0:
            continue
        baseNamePrePre = baseNamePre[0 : lastUS]                        # kkk_ggg
        baseNamePreIdStr = baseNamePre[lastUS+1 : len(baseNamePre)]     # 0
        
        if not baseNamePreIdStr.isdigit():
            continue
        
        baseNamePreId = int(baseNamePreIdStr)
        baseNamePreIdStr = str(baseNamePreId)
        
        newPath = dirName + "/" + baseNamePrePre + "_" + baseNamePreIdStr + "." + baseNameExt
        if not os.access(newPath, os.R_OK):
            continue
        
        allPaths = []
        while(True):
            baseNamePreId +=1
            baseNamePreIdStr = str(baseNamePreId)
            newPath = dirName + "/" + baseNamePrePre + "_" + baseNamePreIdStr + "." + baseNameExt
            
            if not os.access(newPath, os.R_OK):
                break
        
            allPaths.append(newPath)
            
        if allPaths == []:
            continue
        
        # duplicate shaders:
        allNewShaders = []
        allNewSGNodes = []
        for n in range(len(allPaths)):
            strn = str(n)
            newShader = cmds.duplicate(currentShader, un = True, n = currentShader + "_mcdsg_" + strn)[0] #input connection
            newSGNode = cmds.duplicate(belongingSG, n = belongingSG + "_mcdsg_" + strn)[0] #new sg node
            duplicatedObject.append(newShader)
            duplicatedObject.append(newSGNode)
            
            
            # from new shader find file connect to color:
            allConnsNew = cmds.listConnections(newShader, d = False, s = True, p = True)
            if McdIsBlank(allConnsNew):
                continue
            allFileRawNew = []
            for j in range(len(allConnsNew)):
                if allConnsNew[j].find(".outColor") > 0:
                    allFileRawNew.append(allConnsNew[j].split(".outColor")[0])
            if allFileRawNew == []:
                continue
            
            fileNodeColorNew = "" # file node connect agaist with color attribute
            for j in range(len(allFileRawNew)):
                allConns2New = cmds.listConnections(allFileRawNew[j], d = True, s = False, p = True)
                for k in range(len(allConns2New)):
                    if allConns2New[k].find(".color") > 0:
                        fileNodeColorNew = allFileRawNew[j]
                        break
                if fileNodeColorNew != "":
                    break;
            if fileNodeColorNew == "":
                continue
            
            cmds.setAttr(fileNodeColorNew + ".fileTextureName", allPaths[n], type = "string")
            allNewShaders.append(newShader)
            allNewSGNodes.append(newSGNode)
            
            # connect shader to shading group:
            cmds.connectAttr( newShader + ".outColor", newSGNode + ".surfaceShader", f = True)
            
        cmds.setAttr(texInfoNode + ".sgNamesOrg[" + str(sgCounter) + "]", belongingSG, type = "string")
        cmds.setAttr(texInfoNode + ".sgEndID[" + str(sgCounter) + "]", len(allNewSGNodes))
            
        sgCounter += 1
        
    cmds.setAttr(texInfoNode + ".sgNodesNum", sgCounter)
    
def McdRandomMRTexture():
    # get shader info list:
    # for each selected object,
    #     find out the shader
    #     use the mapping list to set random shader
    
    allGeos = cmds.ls(sl = True)
    
    if MIsBlank(allGeos):
        return
    
    # get shader info list:
    texInfoNode = ""
    allTexNodes = cmds.ls(type = "McdTexInfo")
    if MIsBlank(allTexNodes):
        return
    else:
        texInfoNode = allTexNodes[0]
        
    agentID = cmds.getAttr(texInfoNode + ".agentID")
        
    allSGNodesOrg = []
    allSGNodesNb = []
    iterCounter = 0
    
    sgCounter = cmds.getAttr(texInfoNode + ".sgNodesNum")
    
    for i in range(sgCounter):
        stri = str(i)
        sgNode = cmds.getAttr(texInfoNode + ".sgNamesOrg[" + stri + "]")
        if sgNode == "" or sgNode == "None":
            break
        sgNodeNb = cmds.getAttr(texInfoNode + ".sgEndID[" + stri + "]")
        
        allSGNodesOrg.append(sgNode)    
        allSGNodesNb.append(sgNodeNb)
    
    sgNodeTemp = ""
    for i in range(len(allGeos)):
        # find sg node
        currentShape = cmds.listRelatives(allGeos[i], c = True, p = False)[0]
        allConns = cmds.listConnections(currentShape, d = True, s = False)
        if McdIsBlank(allConns):
            continue
        for j in range(len(allConns)):
            if cmds.nodeType(allConns[j]) == "shadingEngine":
                sgNodeTemp = allConns[j]
                break
        if sgNodeTemp == "":
            continue
        
        # split name of shader
        sgNode = sgNodeTemp.split("_mcdsg_")[0]
        
        # assign the random shader use info
        idx = -1
        try:
            idx = allSGNodesOrg.index(sgNode)
        except:
            continue
        if idx < 0:
            continue
        
        #print "belong: " + allSGNodesOrg[idx]
        #print "sum: " + str(allSGNodesNb[idx])
        
        # random based by 0 and allSGNodesNb[idx]
        min = 0
        max = allSGNodesNb[idx] + 1
    
        seed = int((float(agentID) + 0.797) * 1.71 + (float(i) + 0.877) * 1.77)
        randNum = int(McdSolveASeedMinMax(seed, 11.457, min, max))
        
        if randNum >= max - 1:
            randNum = -1 # org shader
            targetSGNode = allSGNodesOrg[idx]
        else:
            targetSGNode = allSGNodesOrg[idx] + "_mcdsg_" + str(randNum)
            
        #print "target: " + targetSGNode
        
        if targetSGNode == sgNodeTemp:
            continue;
        
        try:
            cmds.sets(allGeos[i], e = True, forceElement = targetSGNode)
        except:
            pass
            

    #print "in -------------------";

def McdRandomMRTexturePost():
    # reset the shader back
    # delete the duplicated shader network
    
    # reset the shader back
    allGeoGrp = cmds.ls("*Geometry_*")
    allGeoGrpRef = cmds.ls("*:Geometry_*")
    allGeoGrp.extend(allGeoGrpRef)
    if McdIsBlank(allGeoGrp):
        return
    allGeoGrpList = []
    for i in range(len(allGeoGrp)):
        geoGrpParent = cmds.listRelatives(allGeoGrp[i], p = True, c = False)
        if McdIsBlank(geoGrpParent):
            continue
        if cmds.nodeType(geoGrpParent[0]) == "McdAgentGroup":
            allGeoGrpList.append(allGeoGrp[i])
    
    allGeos = []
    for i in range(len(allGeoGrpList)):
        allSubNodes = cmds.listRelatives(allGeoGrpList[i], c = True, p = False, ad = True, path = True)
        if McdIsBlank(allSubNodes):
            continue
        for j in range(len(allSubNodes)):
            if cmds.nodeType(allSubNodes[j]) == "mesh":
                if not cmds.getAttr(allSubNodes[j] + ".intermediateObject"):
                    allGeos.append(allSubNodes[j])
    if allGeos == []:
        return
    
    # find all shaders 
    for i in range(len(allGeos)):
        allConns = cmds.listConnections(allGeos[i], d = True, s = False)
        if McdIsBlank(allConns):
            continue
        for j in range(len(allConns)):
            if cmds.nodeType(allConns[j]) == "shadingEngine":
                if allConns[j].find("_mcdsg_") > 0:
                    orgSGNode = allConns[j].split("_mcdsg_")[0]
                    # print orgSGNode
                    cmds.sets(allGeos[i], e = True, forceElement = orgSGNode)
                    
                    
    allSG = cmds.ls(type = "shadingEngine")
    for i in range(len(allSG)):
        if allSG[i].find("_mcdsg_") > 0:
            allHis = cmds.listHistory(allSG[i])
            if MIsBlank(allHis):
                continue
            for j in range(len(allHis)):
                try:
                    cmds.delete(allHis[j])
                except:
                    pass
    
    
def McdExportMRHairFur():
    pass
    
    
def McdImportMRHairFur():
    pass
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
