## +
## ===================================================================
## Copyright(C) 2010 - 2012 Basefount Technology (Hong Kong) Limited.
## and/or its licensors.  All rights reserved.
##
## The coded instructions, statements, computer programs, and/or
## related material (collectively the "Data") in these files contain
## unpublished information proprietary to Basefount Technology
## (Hong Kong) Limitd. ("Basefount") and/or its licensors, which is
## protected by Hong Kong copyright law and by international treaties.
##
## The Data is provided for use exclusively by You. You have the right 
## to use, modify, and incorporate this Data into other products for 
## purposes authorized by the Basefount software license agreement, 
## without fee.
##
## The copyright notices in the Software and this entire statement, 
## including the above license grant, this restriction and the 
## following disclaimer, must be included in all copies of the 
## Software, in whole or in part, and all derivative works of 
## the Software, unless such copies or derivative works are solely 
## in the form of machine-executable object code generated by a 
## source language processor.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
## BASEFOUNT DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR
## IMPLIED WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES
## OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
## PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR 
## TRADE PRACTICE. IN NO EVENT WILL BASEFOUNT AND/OR ITS LICENSORS 
## BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL, 
## DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF BASEFOUNTAIN 
## AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY 
## OR PROBABILITY OF SUCH DAMAGES.
##
## ===================================================================
## -

## +
## ===================================================================
##  Module Name: McdDecisionEditorGUI.py
##
##  Description:
##    Deal with details of McdDecisionNode.
##
## ===================================================================
## -

import maya.cmds as cmds
import maya.mel as mel
from McdGeneral import *

import McdDecisionEditor
reload(McdDecisionEditor)
from McdDecisionEditor import *

def McdRefreshDecisionEditor():
    
    try:
        cmds.deleteUI("gui_dc_na")
    except:
        pass
    try:
        cmds.deleteUI("gui_dc_dd")
    except:
        pass
    try:
        cmds.deleteUI("gui_dc_1")
    except:
        pass
    try:
        cmds.deleteUI("gui_dc_2")
    except:
        pass
    try:
        cmds.deleteUI("gui_dc_3")
    except:
        pass
    try:    
        cmds.deleteUI("gui_dc_4")
    except:
        pass
    try:
        cmds.deleteUI("gui_dc_5")
    except:
        pass
    
    cmds.setParent("gui_dc_main")
    buildDecisionGUIContents()

def McdDecisionEditorGUI():
    winName = "McdDecisionEditor"
    if cmds.window(winName, ex = True):
        cmds.deleteUI(winName)
            
    cmds.window(winName, title = "Decision Node Editor",rtf =True,menuBar=True, width=660)
    cmds.menu( label='Options')
    cmds.menuItem( label='Refresh contents', c = "McdRefreshDecisionEditor()")
    cmds.menuItem( label='Switch Mode', c = "switchDecisionMode()" )
    cmds.menuItem( label='Help' )
    cmds.menuItem( divider=True )
    cmds.menuItem( label='Exit', c = "McdExitDecisionEditor()" )

    form = cmds.formLayout()
    tabs = cmds.tabLayout(innerMarginWidth=5, innerMarginHeight=5)
    cmds.formLayout( form, edit=True, attachForm=((tabs, 'top', 0), (tabs, 'left', 0), \
                                                (tabs, 'bottom', 0), (tabs, 'right', 0)) )
    
    #--------------------------  Main GUI  --------------------------#
    child0 = cmds.columnLayout("gui_dc_main", adj = True)
    
    buildDecisionGUIContents()
    
    cmds.setParent("..") # parent gui_dc_main 
    
    
    #------------------------------- Quick Help --------------------------------#
    child1 = cmds.columnLayout(adj = True)
    #separator(h = 10)
    cmds.text(l = "* Logic Tips", fn = "smallBoldLabelFont", align = "left")
    cmds.text(l = "* Greater than 10(>10) means: 10 to +oo (+infinity) ", align = "left")
    cmds.text(l = "* Less than 10(>10) means: -oo (-infinity) to 10 ", align = "left")
    cmds.text(l = "* Fuzzy means: value +- fuzzy value:", align = "left")
    cmds.text(l = "* e.g. 10 fuzzy 2 => from (10-2) to (10+2) => 8 to 12\n", align = "left")
    
    cmds.text(l = "* Vision is inefficient, use bound.in to block some vision", align = "left")
    
    
    cmds.text(l = "")

    cmds.button(l = "Check detailed help", h = 40)
    
    cmds.setParent( '..' )
    
    cmds.tabLayout( tabs, edit=True,tabLabel=((child0, "Logic Table"),\
                                            (child1, "Logic Tips")))
    
    cmds.showWindow(winName)

    
def buildDecisionGUIContents():
    activeName = McdGetActiveAgentName()
    globalNode = McdGetMcdGlobalNode()
    
    dAutoFillFzOut = cmds.getAttr(globalNode + ".boolMaster[0]")
    
    nonActive = False
    selObj = cmds.ls(sl = True, long = True)
    isDefault = 0
    isAct = 0
    if selObj != [] and selObj != None:
        dcNode = selObj[0]
        if cmds.nodeType(dcNode) == "McdDecision" :
            cmds.setAttr(globalNode + ".nextAgentType", dcNode, type = "string")
            isAct = mel.eval("McdCheckNodeActiveCmd;")
            if isAct == 1:
                isDefault = cmds.getAttr(dcNode + ".default")
    
    decisionCondition = 0
    if isDefault < 1 and isAct == 1:
        decisionCondition = 1 # not default
    elif isDefault > 0 and isAct == 1:
        decisionCondition = 2 # default
    
    cmds.rowColumnLayout("gui_dc_1", nc = 10, cw = [(1,100),(2,100),(3,20),(4,80),(5,120),(6,20),(7,150), (8, 20), (9, 150), (10, 150)])
    cmds.text(l = "Active Agent Name:")
    cmds.textField(ed = False,  tx = activeName)
    cmds.text(l = "")
    cmds.text(l = "Node Name:")
    cmds.textField("DecisionNodeName", ed = False)
    cmds.text(l = "")
    if decisionCondition == 1: # not default
        cmds.button("Make Default/Global", c = "MakeDecisionDefault(\""+ dcNode +"\")")
    elif decisionCondition == 2: # default
        cmds.button("Make Normal", c = "MakeDecisionNonDefault(\""+ dcNode +"\")")
    cmds.text(l = "")
    try:
        if cmds.getAttr(dcNode + ".absMode") == 1:
            cmds.text(l = "Abs Mode", bgc = [.5, 1, .6])
    except:
        pass
    try:
        if cmds.getAttr(dcNode + ".enable") != 1:
            cmds.text(l = "Turned Off", bgc = [.8, .3, .3])
    except:
        pass
            
    
        ## auto clear dynamic channels:
        #dynIndexList = []
        #counter = 0;
        #while (cmds.getAttr(dcNode + ".outAtv[" + str(counter) + "]") == 1):
        #    outVal = cmds.getAttr(dcNode + ".output[" + str(counter) + "]")
        #    if outVal != None:
        #        if outVal.find("dynamics.active")>=0:
        #            dynIndexList.append(counter)
        #    counter += 1;
        #    
        #if dynIndexList != []:
        #    cmds.confirmDialog(t = "Warning", m = "Please do not fill dynamic active channel in default decision.\nAuto erase for you.")
        #    
        #    for i in range(len(dynIndexList)):
        #        cmds.setAttr(dcNode + ".output[" + str(dynIndexList[i]) + "]", "", type = "string")
        
    cmds.setParent("..")

    # for input perception:
    if decisionCondition != 2:
        cmds.rowColumnLayout("gui_dc_2", nc = 17, cw = [(1,20),(2,45),(3,40),(4,25),(5,30),(6,200),\
                            (7,25),(8,50),(9,25),(10,50),(11,50),(12,50),(13, 188), (14,68), (15,50) ,(16,30),(17,30)])
        cmds.text(l = "On", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "Priority", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "Logic", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "Not", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "ID  ", fn = "smallBoldLabelFont", align = "right")
        cmds.text(l = "Input", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "Inf", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "Min", fn = "smallBoldLabelFont", align = "center")
        cmds.text(l = "Inf", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "Max", fn = "smallBoldLabelFont", align = "center")
        cmds.text(l = "FuzzyIn", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "FuzzyOut", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "")
        cmds.text(l = "Type", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "")
        cmds.text(l = "")
        cmds.text(l = "")
        
        # for parsing selected object and fill contents;
        nonActive = False
        selObj = cmds.ls(sl = True, long = True)
        isDefault = 0
        if selObj != [] and selObj != None:
            dcNode = selObj[0]
            if cmds.nodeType(dcNode) == "McdDecision" :
                cmds.setAttr(globalNode + ".nextAgentType", dcNode, type = "string")
                isAct = mel.eval("McdCheckNodeActiveCmd;")
                if isAct == 1:
                    
                    isDefault = cmds.getAttr(dcNode + ".default")
                    if isDefault < 1:
                        
                        dcName = dcNode.split("_decision_")[0]
                        cmds.textField("DecisionNodeName", e = True, tx = dcName)
                        # for displaying detail of node:
                        numOfDisable = 0;
                        for i in range(20):
                            stri = str(i)
                            # active value:
                            dActive = cmds.getAttr(dcNode + ".active[" +stri+ "]")
                            dPriority = cmds.getAttr(dcNode + ".priority[" +stri+ "]")
                            dLogic = cmds.getAttr(dcNode + ".logic[" +stri+ "]")
                            dNot = cmds.getAttr(dcNode + ".not[" +stri+ "]")
                            dId = getIdString(i)
                            dInput = cmds.getAttr(dcNode + ".input[" +stri+ "]")
                            dMin = cmds.getAttr(dcNode + ".inputValueMin[" +stri+ "]")
                            dInfMin = cmds.getAttr(dcNode + ".inputInfinityMin[" +stri+ "]")
                            dMax = cmds.getAttr(dcNode + ".inputValueMax[" +stri+ "]")
                            dInfMax = cmds.getAttr(dcNode + ".inputInfinityMax[" +stri+ "]")
                            dFuzzyIn = cmds.getAttr(dcNode + ".fuzzyIn[" +stri+ "]")
                            dFuzzyOut = cmds.getAttr(dcNode + ".fuzzyOut[" +stri+ "]")
                            dInputType = cmds.getAttr(dcNode + ".inputType[" + stri + "]")
                            if numOfDisable > 0:
                                continue;
                            if dActive == 0:
                                numOfDisable += 1
                                cmds.checkBox("cd_dn_active" + stri,l = "", v = 0, onc = "cb_dn_active(" + stri + ")") #active
                                cmds.intField("if_dn_priority" + stri, en = False) #priority
                                cmds.optionMenu("if_dn_logic" + stri, en = False) #logic
                                cmds.checkBox("cd_dn_false" + stri, l = "", en = False) #false
                                cmds.text("t_dn_id" + stri, l = "", en = False)
                                cmds.textField("if_dn_input" + stri, en = False) # input
                                cmds.checkBox("cd_dn_infMin" + stri, l = "", en = False) #infinity min
                                cmds.intField("if_dn_min" + stri, en = False) # min
                                cmds.checkBox("cd_dn_infMax" + stri, l = "", en = False) #infinity max
                                cmds.intField("if_dn_max" + stri, en = False) # max
                                cmds.intField("if_dn_fzmin" + stri, en = False) # fuzzy min
                                cmds.intField("if_dn_fzmax" + stri, en = False) # fuzzy max
                                cmds.intField("if_dn_bgrh" + stri, en = False) # graphic
                                cmds.optionMenu("if_dn_inTyp" + stri, en = False) #input type
                                cmds.button(l = "Auto Fill", en = False) # auto fill
                                cmds.button(l = "Up", en = False)
                                cmds.button(l = "Del", en = False)
                            else:
                                
                                psrNode = checkAndGetPolySplitRing(i, dcNode)
                                gfvalues = updatePSRNodeData(i, dcNode, dInfMin, dInfMax, dMin, dMax, dFuzzyIn, dFuzzyOut, psrNode)
                                
                                cmds.checkBox("cd_dn_active" + stri,l = "", v = 1, ofc = "cb_dn_deActive(" + stri + ")") #active
                                cmds.intField("if_dn_priority" + stri, v = dPriority, cc = "in_dn_prio(" + stri + ")") #priority
                                cmds.optionMenu("if_dn_logic" + stri, cc = "om_dn_logic(" + stri + ")") #logic
                                setupOmDecisionLogic(dLogic, stri)
                                
                                cmds.checkBox("cd_dn_false" + stri, l = "", v = dNot, onc = "cb_dns_False_on(" + stri + ")",\
                                                                                    ofc = "cb_dns_False_off(" + stri + ")")
                                if dNot == True:
                                    cmds.text("t_dn_id" + stri, l = "not " + dId + " ", align = "right")
                                else:
                                    cmds.text("t_dn_id" + stri, l = dId + " ", align = "right")
                                cmds.textField("if_dn_input" + stri, tx = dInput, cc = "tf_dns_inputCC(" + stri + ")") # input
                                cmds.checkBox("cd_dn_infMin" + stri, l = "", v = dInfMin, onc = "cb_dns_infMin_on(" + stri + ")",\
                                                                                        ofc = "cb_dns_infMin_off(" + stri + ")")
                                if dInfMin == True:
                                    cmds.text(l = "- infinity")
                                else:
                                    cmds.floatField("if_dn_min" + stri, v = dMin, pre = 2, cc = "ff_inputVMinCC(" + stri + ")") # min
                                cmds.checkBox("cd_dn_infMax" + stri, l = "", v = dInfMax, onc = "cb_dns_infMax_on(" + stri + ")",\
                                                                                        ofc = "cb_dns_infMax_off(" + stri + ")")
                                if dInfMax == True:
                                    cmds.text(l = "+ infinity")
                                else:
                                    cmds.floatField("if_dn_max" + stri, v = dMax, pre = 2, cc = "ff_inputVMaxCC(" + stri + ")") # max
                                if dInfMin == True:
                                    cmds.text(l = "")
                                else:
                                    if dAutoFillFzOut == 0:
                                        cmds.floatField("if_dn_fzmin" + stri,v = dFuzzyIn, pre = 2, cc = "ff_inputFVMinCC(" + stri + ")")#fuzzy min
                                    else:
                                        cmds.floatField("if_dn_fzmin" + stri,v = dFuzzyIn, pre = 2, cc = "ff_inputFVMinCC2(" + stri + ")")#fuzzy min
                                if dInfMax == True:
                                    cmds.text(l = "")
                                else:
                                    cmds.floatField("if_dn_fzmax" + stri,v = dFuzzyOut, pre = 2, cc= "ff_inputFVMaxCC(" + stri + ")")#fuzzy min
                                    
                                cmds.gradientControl( "grad_" + stri, at = psrNode + '.profileCurve', h  =20, en = False)
                                    
                                cmds.optionMenu("if_dn_inTyp" + stri, cc = "om_dn_inTyp(" + stri + ")") #input type
                                setupOmDecisionInTyp(dInputType, stri)
                                cmds.button(l = "Auto Fill", c = "autoFillSentence(" + stri + ", \"" + dcNode + "\")")
                                if i == 0:
                                    cmds.text(l = "")
                                else:
                                    cmds.button(l = "Up", c = "moveUpSentence(" + stri + ", \"" + dcNode + "\", 1)")
                                cmds.button(l = "Del", c = "deleteSentence(" + stri + ", \"" + dcNode + "\")")
                                
                                # ranging result------------------------------
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.rowColumnLayout(nc = 4, cw = [(1,47),(2,47),(3,47),(4,47)])
                                if not dInfMin:
                                    cmds.floatField("gfpos1" + stri, v = gfvalues[0], pre = 2, en = False) # graphic
                                    cmds.floatField("gfpos2" + stri, v = gfvalues[1], pre = 2, en = False) # graphic
                                else:
                                    cmds.text(l = "")
                                    cmds.text(l = "")
                                if not dInfMax:
                                    cmds.floatField("gfpos3" + stri, v = gfvalues[2], pre = 2, en = False) # graphic
                                    cmds.floatField("gfpos4" + stri, v = gfvalues[3], pre = 2, en = False) # graphic
                                else:
                                    cmds.text(l = "")
                                    cmds.text(l = "")
                                cmds.setParent("..")
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.text(l = "")
                                cmds.text(l = "")
                else:
                    nonActive = True;
                        
        cmds.setParent("..")
    
    
    selObj = cmds.ls(sl = True)
    if selObj != [] and selObj != None:
        dcNode = selObj[0]
        if isDefault == 1:
            cmds.text("gui_dc_dd", l = "Default Decision:", fn = "smallBoldLabelFont", align = "left")
            defaultActionName = cmds.getAttr(dcNode + ".da")
            cmds.rowColumnLayout("gui_dc_3", nc = 2, cw = [(1,100),(2,100)])
            cmds.text(l = "Default Action:", fn = "smallBoldLabelFont", align = "left")
            cmds.textField("TF_defaultAction", tx = defaultActionName, cc = "editDefaultAction(\"" + dcNode + "\")")
            cmds.setParent("..")
        else:
            if cmds.nodeType(dcNode) == "McdDecision" and nonActive == False:
                cmds.rowColumnLayout("gui_dc_3", nc = 2, cw = [(1,75), (2, 420)])
                cmds.text(l = "Parse Result:")
                inputResult = mel.eval("McdParseDecisionCmd;")
                cmds.textField("parseResult", tx = inputResult, ed = False)
                cmds.setParent("..")
    
    
    # for output decision:
    if isDefault == 0:
        cmds.rowColumnLayout("gui_dc_4", nc = 6, cw = [(1,20),(2,200),(3,80),(4, 50), (5, 60), (6, 60)])
        cmds.text(l = "On", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "Decision", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "Value", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "")
        cmds.text(l = "Filter", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "")
    else:
        # default:
        cmds.rowColumnLayout("gui_dc_4", nc = 6, cw = [(1,20),(2,200),(3,80),(4,100),(5,80),(6, 50)])
        cmds.text(l = "On", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "Decision", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "Default Else", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "Output Type", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "Defuzz Type", fn = "smallBoldLabelFont", align = "left")
        cmds.text(l = "")

    # for parsing selected object and fill contents;
    selObj = cmds.ls(sl = True)
    if selObj != [] and selObj != None:
        dcNode = selObj[0]
        if cmds.nodeType(dcNode) == "McdDecision" and nonActive == False:
            if isReferenceScene():
                dcName = dcNode
            else:
                dcName = dcNode.split("_decision_")[0]
            cmds.textField("DecisionNodeName", e = True, tx = dcName)
            # for displaying detail of node:
            numOfDisable = 0;
            for i in range(20):
                stri = str(i)
                # active value:
                dOutputActive = cmds.getAttr(dcNode + ".outputActive[" +stri+ "]")
                dOutput = cmds.getAttr(dcNode + ".output[" +stri+ "]")
                dOutputValue = cmds.getAttr(dcNode + ".outputValue[" +stri+ "]")
                dOutputFilter = cmds.getAttr(dcNode + ".outputFilter[" +stri+ "]")
                if isDefault ==1:
                    dOutputType = cmds.getAttr(dcNode + ".outputType[" +stri+ "]")
                    dDefuzzType = cmds.getAttr(dcNode + ".defuzzType[" +stri+ "]")
                    
                if numOfDisable > 0:
                    continue;
                if dOutputActive == 0:
                    numOfDisable += 1
                    cmds.checkBox("cd_dn_outAvt" + stri,l = "", v = 0, onc = "cb_dno_active(" + stri + ")") #active
                    cmds.textField("tf_dn_out" + stri, en = False) # output decison:
                    cmds.floatField("ff_dn_ov" + stri, en = False) # output value
                    if isDefault == 1:
                        cmds.optionMenu("om_dn_otype" + stri, en = False) # output type
                        cmds.optionMenu("om_dn_dfztype" + stri, en = False) # defuzz type
                    cmds.button(l = "Auto Fill", en = False)
                    if isDefault != 1:
                        cmds.floatField("ff_dn_frt" + stri, en = False) # output value
                        cmds.text(l = "% Percent", en = False)
                        
                else:
                    cmds.checkBox("cd_dn_outAvt" + stri,l = "", v = 1, ofc = "cb_dno_deActive(" + stri + ")") #active
                    cmds.textField("tf_dn_out" + stri, tx = dOutput, cc = "tf_dn_outCC(" + stri + ")") # output decision
                    cmds.floatField("ff_dn_ov" + stri, v = dOutputValue, pre = 2, cc = "ff_dn_ovCC(" + stri + ")") # output value
                    if isDefault == 1:
                        cmds.optionMenu("om_dn_otype" + stri, cc = "om_dn_outType(" + stri + ")") # output type
                        setupOmDecisionOutType(dOutputType, stri)
                        cmds.optionMenu("om_dn_dfztype" + stri, cc = "om_dn_dfzType(" + stri + ")") # output type
                        setupOmDecisionDfzType(dDefuzzType, stri)
                    cmds.button(l = "Auto Fill", c = "autoFillDecision(" + stri + ", \"" + dcNode + "\")")
                    if isDefault != 1:
                        cmds.intField("ff_dn_frt" + stri, v = dOutputFilter, cc = "om_dn_outFilter(" + stri + ")", min = 0, max = 99) # output value
                        cmds.text(l = "% Percent")
                    
    cmds.setParent("..")
    
    
    selObj = cmds.ls(sl = True)
    if selObj != [] and selObj != None:
        dcNode = selObj[0]
        if cmds.nodeType(dcNode) == "McdDecision" and nonActive == False:
            try:
                dNotes = cmds.getAttr(dcNode + ".comment")
            except:
                dNotes = "Put your comments here."
            cmds.rowColumnLayout("gui_dc_5", nc = 2, cw = [(1,85), (2, 415)])
            cmds.text(l = "Node Comments:")
            cmds.textField("DecisionComments", tx = dNotes, cc = "decisionNotesChange(\""+ dcNode +"\")")
            cmds.setParent("..")
    
    if nonActive == True:
        cmds.text("gui_dc_na", l = "\nNon active decision node (or non decision node) selected\n" + \
                "Please firstly activate this agent (or select decision node) in agent manager")

def McdExitDecisionEditor():
    try:
        cmds.deleteUI("McdDecisionEditor")
    except:
        pass


