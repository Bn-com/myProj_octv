## +
## ===================================================================
## Copyright(C) 2010 - 2012 Basefount Technology (Hong Kong) Limited.
## and/or its licensors.  All rights reserved.
##
## The coded instructions, statements, computer programs, and/or
## related material (collectively the "Data") in these files contain
## unpublished information proprietary to Basefount Technology
## (Hong Kong) Limitd. ("Basefount") and/or its licensors, which is
## protected by Hong Kong copyright law and by international treaties.
##
## The Data is provided for use exclusively by You. You have the right 
## to use, modify, and incorporate this Data into other products for 
## purposes authorized by the Basefount software license agreement, 
## without fee.
##
## The copyright notices in the Software and this entire statement, 
## including the above license grant, this restriction and the 
## following disclaimer, must be included in all copies of the 
## Software, in whole or in part, and all derivative works of 
## the Software, unless such copies or derivative works are solely 
## in the form of machine-executable object code generated by a 
## source language processor.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
## BASEFOUNT DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR
## IMPLIED WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES
## OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
## PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR 
## TRADE PRACTICE. IN NO EVENT WILL BASEFOUNT AND/OR ITS LICENSORS 
## BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL, 
## DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF BASEFOUNTAIN 
## AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY 
## OR PROBABILITY OF SUCH DAMAGES.
##
## ===================================================================
## -

## +
## ===================================================================
##  Module Name: McdMiarmyGlobal
##
##  Description:
##    Miarmy Tools
##
## ===================================================================
## -


import maya.cmds as cmds
import maya.mel as mel
from McdGeneral import *
from McdMiarmyGlobal import *
from McdRenderFBXFunctions import *
import platform
import os
import sys

#try:
#    import FbxCommon
#    from fbx import *
#except:
#    pass

def setSingleNumericAttrSliderGrpMiG(option, control, nodeName, attrName):
    #option: 0: bool, 1:int, 2: float
    if option == 0:
        qValue = cmds.checkBoxGrp(control, q = True, v1 = True)
        if control == "mdr_emd" and qValue == 1:
            # if using 2011:
            if int(mel.eval("getApplicationVersionAsFloat")) <= 2011:
                cmds.confirmDialog(t = "Warning", m = "This feature is much faster on Maya 2012 due to the Maya internal method.")
        cmds.setAttr(nodeName + "." + attrName, qValue)
        if control == "mgfbk_cbg":
            if qValue == 1:
                allAgents = cmds.ls(type = "McdAgent")
                if allAgents != None and allAgents != []:
                    for i in range(len(allAgents)):
                        cmds.setAttr(allAgents[i] + ".fMark", False)
                        
        if attrName == "smpTrans" and qValue == 1:
            cmds.confirmDialog(t = "Warning", m = "Simple Transition is not support following features:\n* Action Blending\n* Action Group"+\
                                                "\n\nPlease check your channels and avoid using them.")
    elif option == 1:
        qValue = cmds.intFieldGrp(control, q= True, v1 = True)
        cmds.setAttr(nodeName + "." + attrName, qValue)
    elif option == 2:
        qValue = cmds.floatSliderGrp(control, q= True, v = True)
        cmds.setAttr(nodeName + "." + attrName, qValue) 


def setSingleNumericAttrFieldGrpMiGA(option, control, nodeName, attrName):
    #option: 0: bool, 1:int, 2: float
    if option == 1:
        qValue = cmds.intFieldGrp(control, q= True, v1 = True)
        cmds.setAttr(nodeName + "." + attrName, qValue)
    elif option == 2:
        qValue = cmds.floatFieldGrp(control, q= True, v1 = True)
        cmds.setAttr(nodeName + "." + attrName, qValue) 

def MiarmyCacheCheckExistanceAndFill(globalNode):

    rawPath = cmds.textFieldGrp("mcc_cf", q = True, tx = True)
    
    folderName = envPath2AbsPath(rawPath)
        
    print "Set path: " + folderName
    
    exist = os.access(folderName, os.W_OK)
    if not exist:
        stat = cmds.confirmDialog(t = "IO error", m = "The folder cannot write(or not access), create it:\n" + folderName, b = ["Yes", "No"])
        if stat == "Yes":
            try:
                os.makedirs(folderName)
                cmds.confirmDialog(t = "Note", m = "The folder:\n" + folderName + "\nbeen created successfully.")
                cmds.setAttr(globalNode + ".cacheFolder", folderName, type = "string")
            except:
                cmds.confirmDialog(t = "Error", m = "The folder:\n" + folderName + "\ncannot be created.")
                cmds.textFieldGrp("mcc_cf", e = True, tx = "")
        else:
            cmds.textFieldGrp("mcc_cf", e = True, tx = "")
    else:
        cmds.setAttr(globalNode + ".cacheFolder", rawPath, type = "string")
    
def MiarmySCCacheCheckExistanceAndFill(globalNode):
    rawPath = cmds.textFieldGrp("mmc_cf", q = True, tx = True)
    
    folderName = envPath2AbsPath(rawPath)
    
    print "Set path: " + folderName
    
    exist = os.access(folderName, os.W_OK)
    if not exist:
        stat = cmds.confirmDialog(t = "IO error", m = "The folder cannot write(or not access), create it:\n" + folderName, b = ["Yes", "No"])
        if stat == "Yes":
            try:
                os.makedirs(folderName)
                cmds.confirmDialog(t = "Note", m = "The folder:\n" + folderName + "\ncreated successfully.")
                cmds.setAttr(globalNode + ".scFolder", rawPath, type = "string")
            except:
                cmds.confirmDialog(t = "Error", m = "The folder:\n" + folderName + "\ncannot be created.")
                cmds.textFieldGrp("mmc_cf", e = True, tx = "")
        else:
            cmds.textFieldGrp("mcc_cf", e = True, tx = "")
    else:
        cmds.setAttr(globalNode + ".scFolder", rawPath, type = "string")

def MiarmyFootMapCheckExistanceAndFill(globalNode):
    folderName = cmds.textFieldGrp("fmf_tfg", q = True, tx = True)
    exist = os.access(folderName, os.W_OK)
    if not exist:
        cmds.textFieldGrp("fmf_tfg", e = True, tx = "")
        cmds.confirmDialog(t = "IO error", m = "The folder path you specified is not writable (or not exist).")
        return;
    else:
        cmds.setAttr(globalNode + ".footMapPath", folderName, type = "string")
    
def MiarmySCCacheChangeCacheName(globalNode):
    cacheName = cmds.textFieldGrp("mmc_cn", q = True, tx = True)
    cmds.setAttr(globalNode + ".scName", cacheName, type = "string")
    
def MiarmyFootMapChangeCacheName(globalNode):
    cacheName = cmds.textFieldGrp("fmn_tfg", q = True, tx = True)
    cmds.setAttr(globalNode + ".footMapName", cacheName, type = "string")
    
def MDDuplicateStoreMem():
    # ###################################
    # check is there any agents in scene
    # check naming
    #   # agent group and Geometry_<Agt>
    #   # agent 
    # duplicate geo group and simplify
    #   # rename
    #   # delete history
    #   # delete useless shape nodes
    # get shapes to be duplicate
    # parse string list
    # duplicate and renaming
    # ###################################
    allAgents = cmds.ls(type = "McdAgent")
    if allAgents == [] or allAgents == None:
        stat = cmds.confirmDialog(t = "Error", m = "Please place your agents out firstly.")
        return;
    
    if len(allAgents) > 1000:
        stat = cmds.confirmDialog(t = "Save Notice", m = "This process is very memory consuming and cannot be undone,\n" + \
                                                "We highly recommend you save your scene before processing.\n" + \
                                                "Are you sure to duplicate?", b = ["Yes", "No"])
        if stat == "No":
            return
    
    # ################# Modify > Prefix Hierarchy Names... ###############
    # ~/Autodesk/Maya2012/2013/others/prefixHierarchy.mel
    renameCommand = '\
        proc prefixNode(string $prefix, string $node){\
            string $isType[]	= `ls -type transform $node`;\
            if (size($isType) > 0 ) {\
                string $nodeName = `substitute ".*|" $node ""`;\
                string $newName = `rename $node ( $prefix + $nodeName )`;\
            }\
        }\
        string $prefix = "MDG_";\
        string $currentNodes[] = eval("listRelatives -pa -ad `ls -sl -l`");\
        if ( size( $currentNodes ) > 0 ) {\
            for( $i=0; $i < size( $currentNodes ); $i++ ) {\
                prefixNode( $prefix, $currentNodes[$i] );\
            }\
        }\
        $currentNodes = `ls -sl -l`;\
        if ( size( $currentNodes ) > 0 ) {\
            for( $i=0; $i < size( $currentNodes ); $i++ ) {\
                prefixNode( $prefix, $currentNodes[$i] );\
            }\
        }\
    '
    renamePrefixCommandPre = '\
        proc prefixNode(string $prefix, string $node){\
            string $isType[]	= `ls -type transform $node`;\
            if (size($isType) > 0 ) {\
                string $nodeName = `substitute ".*|" $node ""`;\
                string $newName = `rename $node ( $prefix + $nodeName )`;\
            }\
        }\
        string $prefix = "'
    
    renamePrefixCommandPost = '";\
        string $currentNodes[] = eval("listRelatives -pa -ad `ls -sl -l`");\
        if ( size( $currentNodes ) > 0 ) {\
            for( $i=0; $i < size( $currentNodes ); $i++ ) {\
                prefixNode( $prefix, $currentNodes[$i] );\
            }\
        }\
        $currentNodes = `ls -sl -l`;\
        if ( size( $currentNodes ) > 0 ) {\
            for( $i=0; $i < size( $currentNodes ); $i++ ) {\
                prefixNode( $prefix, $currentNodes[$i] );\
            }\
        }\
    '
    # ################# Modify > Prefix Hierarchy Names... ###############
    
    # duplicate the geometry_<agt>
    allAgtGrpNode = cmds.ls(type = "McdAgentGroup")
    if allAgtGrpNode == [] or allAgtGrpNode == None:
        return
    
    refMode = False
    for i in range(len(allAgtGrpNode)):
        if i == 0:
            if allAgtGrpNode[i].find(":") > 0:
                refMode = True
                
        if refMode:
            if allAgtGrpNode[i].find(":") <= 0:
                cmds.confirmDialog(t = "Naming Error", m = "Hybrid naming with real name and namespace mode.\nAuto selected, check outliner.")
                cmds.select(allAgtGrpNode[i])
                return 1
        else:
            if allAgtGrpNode[i].find(":") > 0:
                cmds.confirmDialog(t = "Naming Error", m = "Hybrid naming with real name and namespace mode.\nAuto selected, check outliner.")
                cmds.select(allAgtGrpNode[i])
                return 1
    
    oddRecordList = [[],[]]
    
    for i in range(len(allAgtGrpNode)):
        allAgtGrpChd = cmds.listRelatives(allAgtGrpNode[i], c = True)
        if allAgtGrpChd == [] or allAgtGrpChd == None:
            continue;
        for j in range(len(allAgtGrpChd)):
            try:
                if allAgtGrpChd[j].find("Geometry_") == 0:
                    ##########################
                    dupNode = cmds.ls("MDG_MDG_" + allAgtGrpChd[j])
                    if dupNode != [] and dupNode != None:
                        continue;
                    
                    if McdCheckSubNodesNaming(allAgtGrpChd[j]) != 0:
                        return
                    
                    dupNode = cmds.duplicate(allAgtGrpChd[j], name = "MDG_" + allAgtGrpChd[j])
                    cmds.hide(dupNode[0])
                    cmds.parent(dupNode[0], w = True)
                    
                    oddRecord = McdCheckAndFixName(allAgtGrpChd[j], dupNode)
                    oddRecordList[0].extend(oddRecord[0])
                    oddRecordList[1].extend(oddRecord[1])
                    
                    cmds.select(clear = True)
                    cmds.select("MDG_" + allAgtGrpChd[j])
                    mel.eval(renameCommand)
                
                    # re-check the hierarchy:
                    allDupNodes = cmds.listRelatives(ad = True, path = True)
                    for k in range(len(allDupNodes)):
                        if cmds.getAttr(allDupNodes[k] + ".intermediateObject") == 0:
                            if allDupNodes[k].find("|") >= 0:
                                realName = allDupNodes[k].split("|")[-1]
                                if realName.find("MDG_") != 0:
                                    cmds.rename(allDupNodes[k], "MDG_" + realName)
                
                    # clear the geo history and useless shapes!
                    cmds.select("MDG_MDG_" + allAgtGrpChd[j], hi = True)
                    allSelObj = cmds.ls(sl = True, l = True)
                    if allSelObj == [] or allSelObj == None:
                        continue
                    for k in range(len(allSelObj)):
                        # delete history:
                        cmds.delete(allSelObj[k], ch = True)
                        
                        # delete extra shapes:
                        if cmds.nodeType(allSelObj[k]) == "transform":
                            allGeoShapes = cmds.listRelatives(allSelObj[k], c = True, path = True)
                            if allGeoShapes != [] and allGeoShapes != None:
                                if cmds.nodeType(allGeoShapes[0]) == "mesh":
                                    for l in range(len(allGeoShapes)):
                                        if cmds.getAttr(allGeoShapes[l] + ".intermediateObject") == 1:
                                            try:
                                                cmds.delete(allGeoShapes[l])
                                            except:
                                                pass
                                            
                elif allAgtGrpChd[j].find(":Geometry_") > 0:
                    ##########################
                    dupNode = cmds.ls("MDG_" + allAgtGrpChd[j])
                    if dupNode != [] and dupNode != None:
                        continue;
                    
                    if McdCheckSubNodesNaming(allAgtGrpChd[j]) != 0:
                        return
                    
                    
                    nmSpStr = allAgtGrpChd[j].split(":")[0]
                    nameStr = allAgtGrpChd[j].split(":")[1]
                    
                    dupNode = cmds.duplicate(allAgtGrpChd[j], name = "MDG_" + nameStr)
                    cmds.hide(dupNode[0])
                    cmds.parent(dupNode[0], w = True)
                    
                    oddRecord = McdCheckAndFixName(allAgtGrpChd[j], dupNode, "MDG_" + nmSpStr + "_")
                    oddRecordList[0].extend(oddRecord[0])
                    oddRecordList[1].extend(oddRecord[1])
                    
                    renameCmd2 = renamePrefixCommandPre + "MDG_" + nmSpStr + "_" + renamePrefixCommandPost
                    
                    cmds.select(clear = True)
                    cmds.select("MDG_" + nameStr)
                    mel.eval(renameCmd2)
                    
                    # re-check the hierarchy:
                    allDupNodes = cmds.listRelatives(ad = True, path = True)
                    for k in range(len(allDupNodes)):
                        if cmds.getAttr(allDupNodes[k] + ".intermediateObject") == 0:
                            if allDupNodes[k].find("|") >= 0:
                                realName = allDupNodes[k].split("|")[-1]
                                if realName.find("MDG_") != 0:
                                    cmds.rename(allDupNodes[k], "MDG_" + nmSpStr + realName)
                
                    # clear the geo history and useless shapes!
                    cmds.select("MDG_" + nmSpStr + "_MDG_" + nameStr, hi = True)
                    allSelObj = cmds.ls(sl = True, l = True)
                    if allSelObj == [] or allSelObj == None:
                        continue
                    for k in range(len(allSelObj)):
                        # delete history:
                        cmds.delete(allSelObj[k], ch = True)
                        
                        # delete extra shapes:
                        if cmds.nodeType(allSelObj[k]) == "transform":
                            allGeoShapes = cmds.listRelatives(allSelObj[k], c = True, path = True)
                            if allGeoShapes != [] and allGeoShapes != None:
                                if cmds.nodeType(allGeoShapes[0]) == "mesh":
                                    for l in range(len(allGeoShapes)):
                                        if cmds.getAttr(allGeoShapes[l] + ".intermediateObject") == 1:
                                            try:
                                                cmds.delete(allGeoShapes[l])
                                            except:
                                                pass

            except:
                cmds.confirmDialog(t = "Naming Error", m = "Please check the naming conventions")
                return
    
    dupGeomGrp = cmds.ls("MDGGrp_*", l = True)
    if dupGeomGrp != [] and dupGeomGrp != None:
        stat = cmds.confirmDialog(t = "Question", \
                                m = "Maybe already duplicated, do you want to delete and re-duplicate them again", \
                                b = ["Yes", "No"])
        if stat == "No":
            return
    for i in range(len(dupGeomGrp)):
        try:
            cmds.delete(dupGeomGrp[i])
        except:
            pass
    
    # get shapes to be duplicate:
    meshListRaw = []
    meshListRaw = mel.eval("McdGetRenderGeoCmd -rec 1;") # get and storing

    #print meshListRaw
    if meshListRaw == []:
        return
    # parse string list:
    agentNameList = []
    meshList = []
    
    isGetName = False # flag
    meshListUnit = [] # flag
    for i in range(len(meshListRaw)):
        if not isGetName:
            agentNameList.append("MDGGrp_" + meshListRaw[i])
            isGetName = True
            continue
        if meshListRaw[i] != "#":
            
            if meshListRaw[i].find(":") <= 0:
                if meshListRaw[i].find('|') > 0:
                    meshListUnit.append("MDG_MDG_" + meshListRaw[i].replace("|", "|MDG_"))
                else:
                    meshListUnit.append("MDG_" + meshListRaw[i])
            else:
                
                if meshListRaw[i].find('|') > 0:
                    nmsp = meshListRaw[i].split(":")[0]
                    newName = meshListRaw[i].replace(nmsp + ":", "")
                    
                    firstName = newName.split("|")[0]
                    firstNameNew = "MDG_" + nmsp + "_MDG_" + firstName
                    
                    newNameSegs = newName.split("|")
                    newNameNew = ""
                    for j in range(len(newNameSegs)):
                        if j == 0:
                            newNameNew += firstNameNew
                        else:
                            newNameNew += "|MDG_" + nmsp + "_" + newNameSegs[j]
                    
                    meshListUnit.append(newNameNew)
                else:
                    newName = meshListRaw[i].split(":")[1]
                    nameSpc = meshListRaw[i].split(":")[0]
                    meshListUnit.append("MDG_" + nameSpc + "_" + newName)
                    
        else:
            isGetName = False
            meshList.append(meshListUnit)
            meshListUnit = []
    
    # duplicate and renaming:
    amount = 0
    counter = 0
    totalCount = len(agentNameList)
    cmds.progressWindow( title = "Duplicating:", progress = 0, \
                      min = 0, max = 100, \
                      status = 'Copying', isInterruptable = True )
    
    for i in range(len(agentNameList)):
        mel.eval("flushUndo;")
        cmds.group(n = agentNameList[i], em = True)
        
        if oddRecordList != [[],[]]:
            for j in range(len(meshList[i])):
                try:
                    idx = oddRecordList[0].index(meshList[i][j])
                    meshList[i][j] = oddRecordList[1][idx]
                except:
                    pass
        try:
            dupList = cmds.duplicate(meshList[i], rr = True)
        except:
            cmds.progressWindow(endProgress=1)
            
        for j in range(len(dupList)):
            try:
                currentShape = cmds.listRelatives(dupList[j], c = True, path = True)[0]
                if currentShape.find("|") >= 0:
                    realName = currentShape.split("|")[-1]
                    cmds.rename(currentShape, realName + "agent" + str(i))
            except:
                pass
            
        cmds.parent(dupList, agentNameList[i])
    
        ## progress operation: ////////////////////////////////////////////////
        if cmds.progressWindow( query = True, isCancelled = True ):
            break
        counter += 1
        amount = float(counter) / float(totalCount) * 100.0
        cmds.progressWindow( edit = True, progress = amount )
        
    cmds.progressWindow(endProgress=1)
    
    mel.eval("McdGetRenderGeoCmd -rec 2;") # pairing in mem
    
    stat = cmds.confirmDialog(t = "Randomize Shader", m = "Try to randomize shader for duplicated geometries??",\
                            b = ["Duplicate Random", "Cancel"])
    
    if stat == "Duplicate Random":
        try:
            McdRandomizeTexturesDuplicate()
        except:
            pass
        
    mel.eval("flushUndo;")
    
    
def PairingMem():
    mel.eval("McdGetRenderGeoCmd -rec 1;") # get and storing
    mel.eval("McdGetRenderGeoCmd -rec 2;") # pairing in mem
    
def clearGeom():
    agentNodes = cmds.ls(type = "McdAgent")
    if agentNodes != [] and agentNodes != None:
        cmds.confirmDialog(t = "Abort", m = "Cannot clear duplicated geometries when agents still in scene,\nPlease de-place firstly.")
        return
    
    # delete and flush undo queue
    allDupGeom = cmds.ls("MDGGrp_*")
    
    for i in range(len(allDupGeom)):
        try:
            cmds.delete(allDupGeom[i])
        except:
            pass
        
    allGrps = cmds.ls("MDG_*", l = True)
    if allGrps != [] and allGrps != None:
        for i in range(len(allGrps)):
            try:
                cmds.delete(allGrps[i])
            except:
                pass
        
    mel.eval("flushUndo;")
    
def convertSCCache():
    
    # test cache existance
    globalNode = McdGetMcdGlobalNode()
    cacheFolder = cmds.getAttr(globalNode + ".scFolder")
    if cacheFolder == "" or cacheFolder == None:
        cmds.confirmDialog(t = "Error", m = "Please fill the folder name above")
        raise Exception("The output folder is not exist.")
        
    cacheFolder = envPath2AbsPath(cacheFolder)
    
    if cacheFolder == "" or cacheFolder == None:
        cmds.confirmDialog(t = "Error", m = "The output folder is not exist. Specify it in Miarmy > Miarmy Global.")
        raise Exception("The output folder is not exist.")
        
    if not os.access(cacheFolder, os.W_OK):
        print cacheFolder
        cmds.confirmDialog(t = "Error", m = "The output folder is not writable. Specify it in Miarmy > Miarmy Global")
        raise Exception("The output folder is not exist.")
        
    
    # create folder
    
    stat = cmds.confirmDialog(t = "Question", m = "Are you going to create single character cache?", b = ["Yes", "No"])
    if stat == "Yes":
        mel.eval("McdRenderExportCmd -r 6;")
    
    
def convertSCCache2():
    # create folder
    
    stat = cmds.confirmDialog(t = "Question", m = "Are you going to create single character cache?", b = ["Yes", "No"])
    if stat == "Yes":
        mel.eval("McdRenderExportCmd -r 7;")
    
                            
def clearContent(rootNode):
    allSubNodes = cmds.listRelatives(rootNode, ad = True, c = True, p = False, path = True)
    allNodesNeedDel = []
    for i in range(len(allSubNodes)):
        if cmds.nodeType(allSubNodes[i]) != "joint":
            allNodesNeedDel.append(allSubNodes[i])
            
    cmds.delete(allNodesNeedDel)
    
    cmds.select(cmds.listRelatives(rootNode, c = True, p = False, path = True)[0])
    
    cho = cmds.confirmDialog(t = "Question", m = "Please choose renaming scheme for Middle Rig:", b = ["Same as Rig", "Add Suffix"])
    
    if cho == "Same as Rig":
        allJoints = mel.eval("McdSimpleCommand -exe 31;");
        nbJoints = len(allJoints)
        for j in range(nbJoints):
            i = nbJoints - j - 1
            try:
                newNameRaw = allJoints[i].split("|")[-1]
                newName = newNameRaw.split("_ogb_")[0]
                cmds.rename(allJoints[i], newName)
            except:
                pass
            
    elif cho == "Add Suffix":
        melCommand = getRenameHiCmdStr_("_mid_rig")
        mel.eval(melCommand)
    
def GetFirstBone(rootAgtGrp):
    allChild = getAllChildren(rootAgtGrp)
    for i in range(len(allChild)):
        if allChild[i].find("MiddleRig_") >= 0:
            allJointRaw = getAllChildren(allChild[i], "joint")
            if MIsBlank(allJointRaw):
                return []
            return allJointRaw[0]
    
def bakeAndExportFBX(globalNode, brainNode):
    
    # enable single cache
    # based on the cache place cache accessable
    # while loop start baking
    #   put it to min frame
    #   read brain type feedback
    #   find root bone
    #   un-parent
    #   exporting fbx
    #   parent
    #   export FBX

    allAgents = cmds.ls(type = "McdAgent")
    if not MIsBlank(allAgents):
        cmds.confirmDialog(t = "Auto abort", m = "Please de-place agents firstly")
        return

    # --------------------------------------------------------------------------
    # enable single cache
    cmds.setAttr(brainNode + ".enableChar", 1)
    
    cacheFolder = cmds.getAttr(globalNode + ".cacheFolder")
    cacheName = cmds.getAttr(globalNode + ".cacheName") + "_scCache"
    cacheTranslate = cmds.getAttr(globalNode + ".cacheTrans")
    
    scCachePath = cacheFolder + "/" + cacheName
    
    try:
        if not os.access(scCachePath, os.R_OK):
            cmds.confirmDialog(t = "Question", m = "Single Character Cache not found.")
            return
    except:
        cmds.confirmDialog(t = "Question", m = "Single Character Cache not found.")
        return
    
    startFrame = int(cmds.playbackOptions(q =True, min = True))
    endFrame = int(cmds.playbackOptions(q =True, max = True))
    nbFame = endFrame - startFrame + 1
    
    allAgtGrp = getAllAgentGroups()
    if MIsBlank(allAgtGrp):
        return
    
    allTids = []
    for i in range(len(allAgtGrp)):
        allTids.append(cmds.getAttr(allAgtGrp[i] + ".tempTypeId"))
    
    autoKeyState = cmds.autoKeyframe( q = True, state = True)
    cmds.autoKeyframe( e = True, state = False)
    
    # while loop start baking
    counter = 0;
    while(True):
        # based on the cache place cache accessable
        if not os.access(scCachePath + '/agent' + str(counter) + ".mcc", os.R_OK):
            break
        
        cmds.setAttr(brainNode + ".charId", counter)
        cmds.setAttr(brainNode + ".driveMidRig", 1)
        
        # put it to min frame
        cmds.currentTime(startFrame)
        
        # read brain type feedback
        feedTid = cmds.getAttr(brainNode + ".agentTypeFeedback")
        
        # find root bone
        assetId = -1
        for i in range(len(allTids)):
            if feedTid == allTids[i]:
                assetId = i
        if assetId == -1:
            continue
        
        rootJoint = GetFirstBone(allAgtGrp[assetId])
        allAD = cmds.listRelatives(rootJoint, c = True, p = False, ad = True, path = True)
        
        # baking
        for i in range(nbFame):
            cmds.currentTime(startFrame + i)
            
            # keyframe root
            cmds.setAttr(rootJoint + ".sz", k = False, cb = True)
            cmds.setAttr(rootJoint + ".sy", k = False, cb = True)
            cmds.setAttr(rootJoint + ".sx", k = False, cb = True)
            cmds.setAttr(rootJoint + ".v", k = False, cb = True)
            cmds.setKeyframe(rootJoint)
            
            # list all child
            if i == 0:
                for j in range(len(allAD)):
                    cmds.setAttr(allAD[j] + ".v", k = False, cb = True)
                    cmds.setAttr(allAD[j] + ".sx", k = False, cb = True)
                    cmds.setAttr(allAD[j] + ".sy", k = False, cb = True)
                    cmds.setAttr(allAD[j] + ".sz", k = False, cb = True)
                    if cacheTranslate != 1:
                        cmds.setAttr(allAD[j] + ".tx", k = False, cb = True)
                        cmds.setAttr(allAD[j] + ".ty", k = False, cb = True)
                        cmds.setAttr(allAD[j] + ".tz", k = False, cb = True)
                
            for j in range(len(allAD)):
                cmds.setKeyframe(allAD[j])
                    
        # un-parent
        parentNode = getParent(rootJoint)
        cmds.parent(rootJoint, w = True)
        
        # exporting fbx
        rootJoint = cmds.ls(sl = True)[0]
        cmds.select(rootJoint)
        cmds.file("d:/abc/fbx/agent_" + str(counter) + ".fbx", force = True, options = "v=0", typ = "FBX export", pr = True, es = True)
        
        # parent
        cmds.parent(rootJoint, parentNode)
        
        counter += 1
    
    cmds.autoKeyframe( e = True, state = autoKeyState)
    
    
def setSingleNumericAttrSliderGrpMiCallback(option, control, nodeName, attrName):
    #option: 0: bool, 1:int, 2: float
    if option == 0:
        qValue = cmds.checkBoxGrp(control, q = True, v1 = True)
        
        if control == "callsim" and qValue == 1:
            val = cmds.checkBoxGrp("callch", q = True, v1 = True)
            if val == 1:
                cmds.checkBoxGrp("callch", e = True, v1 = False)
                cmds.setAttr(nodeName + ".boolMaster[6]", 0)
        
        if control == "callch" and qValue == 1:
            val = cmds.checkBoxGrp("callsim", q = True, v1 = True)
            if val == 1:
                cmds.checkBoxGrp("callsim", e = True, v1 = False)
                cmds.setAttr(nodeName + ".boolMaster[5]", 0)
        
        cmds.setAttr(nodeName + "." + attrName, qValue)
    
    
def McdCmdTxtFill(controlName, index, globalNode):
    val = cmds.textFieldGrp(controlName, q = True, tx = True)
    
    cmds.setAttr(globalNode + '.cmdMaster[' + str(index) + ']', val, type = "string")
    
    
    
    
    







