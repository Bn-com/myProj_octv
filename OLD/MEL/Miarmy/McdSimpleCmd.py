## +
## ===================================================================
## Copyright(C) 2010 - 2012 Basefount Technology (Hong Kong) Limited.
## and/or its licensors.  All rights reserved.
##
## The coded instructions, statements, computer programs, and/or
## related material (collectively the "Data") in these files contain
## unpublished information proprietary to Basefount Technology
## (Hong Kong) Limitd. ("Basefount") and/or its licensors, which is
## protected by Hong Kong copyright law and by international treaties.
##
## The Data is provided for use exclusively by You. You have the right 
## to use, modify, and incorporate this Data into other products for 
## purposes authorized by the Basefount software license agreement, 
## without fee.
##
## The copyright notices in the Software and this entire statement, 
## including the above license grant, this restriction and the 
## following disclaimer, must be included in all copies of the 
## Software, in whole or in part, and all derivative works of 
## the Software, unless such copies or derivative works are solely 
## in the form of machine-executable object code generated by a 
## source language processor.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
## BASEFOUNT DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR
## IMPLIED WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES
## OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
## PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR 
## TRADE PRACTICE. IN NO EVENT WILL BASEFOUNT AND/OR ITS LICENSORS 
## BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL, 
## DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF BASEFOUNTAIN 
## AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY 
## OR PROBABILITY OF SUCH DAMAGES.
##
## ===================================================================
## -

## +
## ===================================================================
##  Module Name: McdSimpleCommand.py
##
##  Description:
##      Misc 
##
## ===================================================================
## -

import os
import shutil

import maya.cmds as cmds
import maya.mel as mel
from McdGeneral import *
import platform

def McdSelectMcdGlobal():
    
    McdClearUselessNodes()
    
    cmds.playbackOptions( view = "all" ) # update all, feedback usage
    cmds.playbackOptions( playbackSpeed = 0 ) # play every frame
    cmds.playbackOptions( by = 1.0 ) # by 1.0 for each update
    cmds.playbackOptions( maxPlaybackSpeed = 1 ) # max speed, 24fps
    
    #create McdBrain and McdBrainPost
    allSolveNode = cmds.ls(type = "McdBrain")
    if allSolveNode == [] or allSolveNode == None:
        cmds.createNode("McdBrain")
        
        
    allSolveNode = cmds.ls(type = "McdBrainPost")
    if allSolveNode == [] or allSolveNode == None:
        cmds.createNode("McdBrainPost")
    
    #create McdGlobal and contents
    allMcdGlobal = cmds.ls(type = "McdGlobal");
    allContentsNodes = cmds.ls("Miarmy_Contents")
    if allContentsNodes == [] or allContentsNodes == None:
        if allMcdGlobal != [] and allMcdGlobal != None:
            for i in range(len(allMcdGlobal)):
                try:
                    cmds.delete(allMcdGlobal[i])
                except:
                    pass
    
    allMcdGlobal = cmds.ls(type = "McdGlobal");        
    if allMcdGlobal == [] or allMcdGlobal == None:
        McdCreateMcdGlobal()
        allMcdGlobal = cmds.ls(type = "McdGlobal");
        cmds.select(allMcdGlobal[0]);
    else:
        mel.eval("McdSimpleCommand -exe 1;")
        
    # feedback:
    cmds.confirmDialog(t = "Miarmy Ready!", m = "You clicked this, following things were done for you:\n\n" + \
                     
                                                " -  Playback setup: update all viewport.\n" + \
                                                " -  Playback setup: play every frame.\n" + \
                                                " -  Playback setup: by 1.0 for each update.\n" + \
                                                " -  Playback setup: max playback speed is realtime.\n\n" + \
                                                
                                                " *  1 McdBrain node created.\n" + \
                                                " *  1 McdBrainPost node created.\n" + \
                                                " *  1 McdGlobal node created.\n" + \
                                                " *  Miarmy contents inventory created, check it out in Outliner.")
    
    setupConfig()
    
def McdClearUselessNodes():
    allGlobal = cmds.ls(type = "McdGlobal")
    if not MIsBlank(allGlobal):
        if (len(allGlobal) > 1):
            global1 = "McdGlobal1"
            if global1 in allGlobal:
                for i in range(len(allGlobal)):
                    if allGlobal[i] != global1:
                        try:
                            cmds.delete(allGlobal[i])
                        except:
                            pass
            else:
                for i in range(len(allGlobal)):
                    if i == 0:
                        continue
                    try:
                        cmds.delete(allGlobal[i])
                    except:
                        pass

def McdListMcdGlobal():
    allMcdGlobal = cmds.ls(type = "McdGlobal");
    if allMcdGlobal == [] or allMcdGlobal == None:
        McdCreateMcdGlobal()
        allMcdGlobal = cmds.ls(type = "McdGlobal");
        return allMcdGlobal[0]
    else:
        return mel.eval("McdSimpleCommand -exe 2;")

def McdListMcdBrain():
    allMcdBrain = cmds.ls(type = "McdBrain");
    if allMcdBrain == [] or allMcdBrain == None:
        cmds.create("McdBrain")
        allMcdGlobal = cmds.ls(type = "McdGlobal");
        return allMcdGlobal[0]
    else:
        return mel.eval("McdSimpleCommand -exe 3;")

def McdSelectMcdBrain():
    # check McdBrain and McdBrainPost
    brainNode = cmds.ls(type = "McdBrain")
    cannotDel = False
    if brainNode == [] or brainNode == None:
        cmds.createNode("McdBrain")
    else:
        if len(brainNode) > 1:
            for i in range(len(brainNode)):
                try:
                    cmds.delete(brainNode[i])
                except:
                    cannotDel = True
    brainNode2 = cmds.ls(type = "McdBrain")
    if brainNode2 != [] and brainNode2 != None and len(brainNode2) > 1:
        if cannotDel == True:
            cmds.confirmDialog(t = "Error", m = "Please make sure you have only one McdBrain node in your scene.")
            raise Exception("Agent name in McdGlobal is not valid.")
    
    brainPostNode = cmds.ls(type = "McdBrainPost")
    
    
    
    cmds.select(allThisType[0]);
    
def McdCreateStateCmd():
    allMcdGlobal = cmds.ls(type = "McdGlobal");
    stop = False;
    if allMcdGlobal == [] or allMcdGlobal == None:
        cmds.confirmDialog(t = "Error.", m = "No found Miarmy Global, please create it in \"Miarmy > Miarmy Global\"")
        raise Exception("No found Miarmy Global, please create it in \"Miarmy > Miarmy Global\"")
    else:
        globalNode = allMcdGlobal[0]
        isValid = CheckStringIsValid(cmds.getAttr(globalNode + ".activeAgentName"))
        if isValid == False:
            cmds.confirmDialog(t = "Error", m = "Agent name in McdGlobal is not valid.")
            raise Exception("Agent name in McdGlobal is not valid.")
    
    result = cmds.promptDialog( title='Specify State Name:', message='Enter State Name:', button=['Create', 'Cancel'], defaultButton='Create', cancelButton='Cancel', dismissString='Cancel')
    newState = ""
    if result == 'Create':
        newState = cmds.promptDialog(query=True, text=True)
    
    if newState != "":
        isValid = CheckStringIsValid(newState)
        if isValid == False:
            cmds.confirmDialog(t = "Error", m = "New State name not valid.")
            raise Exception("New State name not valid.")
            
        activeAgentName = McdGetActiveAgentName()
        McdGetOrCreateTransitionMapGrp(activeAgentName, 1)
        McdCreateState(newState, activeAgentName)
        

def McdCreateActionShellCmd():
    allMcdGlobal = cmds.ls(type = "McdGlobal");
    stop = False;
    if allMcdGlobal == [] or allMcdGlobal == None:
        cmds.confirmDialog(t = "Error", m = "No found Miarmy Global, please create it in \"Miarmy > Miarmy Global\"")
        raise Exception("No found Miarmy Global, please create it in \"Miarmy > Miarmy Global\"")
    else:
        globalNode = allMcdGlobal[0]
        isValid = CheckStringIsValid(cmds.getAttr(globalNode + ".activeAgentName"))
        if isValid == False:
            cmds.confirmDialog(t = "Error", m = "Agent name in McdGlobal is not valid.")
            raise Exception("Agent name in McdGlobal is not valid.")
    
    result = cmds.promptDialog( title='Specify Action Name:', message='Enter Action Shell Name:',\
                button=['Create', 'Cancel'], defaultButton='Create', cancelButton='Cancel', dismissString='Cancel')
    newAction = ""
    if result == 'Create':
        newAction = cmds.promptDialog(query=True, text=True)
    
    if newAction != "":
        isValid = CheckStringIsValid(newAction)
        if isValid == False:
            cmds.confirmDialog(t = "Error", m = "New action shell name not valid.")
            raise Exception("New action shell name not valid.")
            
        activeAgentName = McdGetActiveAgentName()
        McdGetOrCreateActionShellGrp(activeAgentName, 1)
        McdCreateAction(newAction, activeAgentName)
    
def McdCreateActionProxyCmd():
    allMcdGlobal = cmds.ls(type = "McdGlobal");
    stop = False;
    if allMcdGlobal == [] or allMcdGlobal == None:
        cmds.confirmDialog(t = "Error", m = "No found Miarmy Global, please create it in \"Miarmy > Miarmy Global\"")
        raise Exception("No found Miarmy Global, please create it in \"Miarmy > Miarmy Global\"")
    else:
        globalNode = allMcdGlobal[0]
        isValid = CheckStringIsValid(cmds.getAttr(globalNode + ".activeAgentName"))
        if isValid == False:
            cmds.confirmDialog(t = "Error", m = "Agent name in McdGlobal is not valid.")
            raise Exception("Agent name in McdGlobal is not valid.")
            
    activeAgentName = McdGetActiveAgentName()
    McdGetOrCreateActionProxyGrp(activeAgentName, 1)
    McdCreateActionProxy(activeAgentName)
    
def McdCreateStoryListCmd():
    allMcdGlobal = cmds.ls(type = "McdGlobal");
    stop = False;
    if allMcdGlobal == [] or allMcdGlobal == None:
        cmds.confirmDialog(t = "Error", m = "No found Miarmy Global, please create it in \"Miarmy > Miarmy Global\"")
        raise Exception("No found Miarmy Global, please create it in \"Miarmy > Miarmy Global\"")
    else:
        globalNode = allMcdGlobal[0]
        isValid = CheckStringIsValid(cmds.getAttr(globalNode + ".activeAgentName"))
        if isValid == False:
            cmds.confirmDialog(t = "Error", m = "Agent name in McdGlobal is not valid.")
            raise Exception("Agent name in McdGlobal is not valid.")

    result = cmds.promptDialog( title='Specify Story Name:', message='Enter Story Name:', button=['Create', 'Cancel'], defaultButton='Create', cancelButton='Cancel', dismissString='Cancel')
    newStory = ""
    if result == 'Create':
        newStory = cmds.promptDialog(query=True, text=True)
    
    if newStory != "":
        isValid = CheckStringIsValid(newStory)
        if isValid == False:
            cmds.confirmDialog(t = "Error", m = "New story name not valid.")
            raise Exception("New story name not valid.")
            
        activeAgentName = McdGetActiveAgentName()
        McdGetOrCreateStoryListGrp(activeAgentName, 1)
        McdCreateStoryList(newStory, activeAgentName)
    
    
def McdStateContextToolOn():
    isContextExist = cmds.contextInfo("McdStateContextTool1", q = True, ex = True)
    if (isContextExist == 0):
        mel.eval("McdStateContextTool McdStateContextTool1;");
    cmds.setToolTo("McdStateContextTool1");
    
    
def McdCreateDecisionCmd():
    allMcdGlobal = cmds.ls(type = "McdGlobal");
    stop = False;
    if allMcdGlobal == [] or allMcdGlobal == None:
        cmds.confirmDialog(t = "Error", m = "No found Miarmy Global, please create it in \"Miarmy > Miarmy Global\"")
        raise Exception("No found Miarmy Global, please create it in \"Miarmy > Miarmy Global\"")
    else:
        globalNode = allMcdGlobal[0]
        isValid = CheckStringIsValid(cmds.getAttr(globalNode + ".activeAgentName"))
        if isValid == False:
            cmds.confirmDialog(t = "Error", m = "Agent name in McdGlobal is not valid.")
            raise Exception("Agent name in McdGlobal is not valid.")

    result = cmds.promptDialog( title='Specify Decision Name:', message='Enter Decision Name:', button=['Create', 'Cancel'], defaultButton='Create', cancelButton='Cancel', dismissString='Cancel')
    newDecision = ""
    if result == 'Create':
        newDecision = cmds.promptDialog(query=True, text=True)
    
    if newDecision != "":
        isValid = CheckStringIsValid(newDecision)
        if isValid == False:
            cmds.confirmDialog(t = "Error", m = "New decision name not valid.")
            raise Exception("New decision name not valid.")
            
        activeAgentName = McdGetActiveAgentName()
        McdGetOrCreateDecisionGrp(activeAgentName, 1)
        McdCreateDecision(newDecision, activeAgentName)

    
def soundRangeSwitch():
    try:
        recordSel = cmds.ls(sl = True)
        selObj = cmds.ls(type = "McdAgent")[0]
        cmds.getAttr(selObj + "._SwitchSoundVis")
        if recordSel != [] and recordSel != None:
            cmds.select(clear = True)
            cmds.select(recordSel)
        else:
            cmds.select(selObj)
            cmds.select(clear = True)
    except:
        pass
    
def visionRangeSwitch():
    try:
        recordSel = cmds.ls(sl = True)
        selObj = cmds.ls(type = "McdAgent")[0]
        cmds.getAttr(selObj + "._SwitchVisionVis")
        if recordSel != [] and recordSel != None:
            cmds.select(clear = True)
            cmds.select(recordSel)
        else:
            cmds.select(selObj)
            cmds.select(clear = True)
    except:
        pass
    
def HPSwitch():
    try:
        recordSel = cmds.ls(sl = True)
        selObj = cmds.ls(type = "McdAgent")[0]
        cmds.getAttr(selObj + "._SwitchHPVis")
        if recordSel != [] and recordSel != None:
            cmds.select(clear = True)
            cmds.select(recordSel)
        else:
            cmds.select(selObj)
            cmds.select(clear = True)
    except:
        pass
    
    
def actionSwitch():
    try:
        recordSel = cmds.ls(sl = True)
        selObj = cmds.ls(type = "McdAgent")[0]
        cmds.getAttr(selObj + "._SwitchActVis")
        if recordSel != [] and recordSel != None:
            cmds.select(clear = True)
            cmds.select(recordSel)
        else:
            cmds.select(selObj)
            cmds.select(clear = True)
    except:
        pass

def Maya2012ImportMa():
    importFilePath = cmds.fileDialog(m = 0, dm = "*.ma")
    if os.access(importFilePath, os.R_OK):
        cmds.file(importFilePath, i = True)
    else:
        print "nothing import"
    
def Maya2012ImportMb():
    importFilePath = cmds.fileDialog(m = 0, dm = "*.mb")
    if os.access(importFilePath, os.R_OK):
        cmds.file(importFilePath, i = True)
    else:
        print "nothing import"

def McdAttachClothCmd():
    
    selObj = cmds.ls(sl = True)
    if MIsBlank(selObj):
        cmds.confirmDialog(t = "Error", m = "Firstly select cloth points (the cloth need bind to original agent)")
        
    sel = selObj[0].split(".")[0]
    allChild = cmds.listRelatives(sel, c = True, p = False)
    if MIsBlank(allChild):
        cmds.confirmDialog(t = "Error", m = "Firstly select cloth points (the cloth need bind to original agent)")
        
    allConns = cmds.listConnections(allChild[0], d = True, s = False)
    
    for i in range(len(allConns)):
        if cmds.nodeType(allConns[i]) == "McdCloth":
            stat = cmds.confirmDialog(t = "Question", m = "We detected already done for marking cloth, are you want to override?",\
                                    b = ["Yes", "No"])
            if stat == "Yes":
                cmds.delete(allConns[i])
            else:
                return
    
    cmd = "McdCreateClothCmd;"
    mel.eval(cmd)
    
def McdClearCloth():
    #remove related McdCloth node only
    try:
        selObj = cmds.ls(sl = True)[0]
    except:
        cmds.confirmDialog(t = "Error", m = "Please select a cloth firstly.")
        raise Exception("Need selection.")
        
    clearDone = False
    allChild = cmds.listRelatives(selObj, parent = False, c = True)
    if allChild != None and allChild != []:
        for i in range(len(allChild)):
            if cmds.nodeType(allChild[i]) == "mesh":
                allCnns = cmds.listConnections(allChild[i], s = True, c = False);
                if allCnns != None and allCnns != []:
                    for j in range(len(allCnns)):
                        if cmds.nodeType(allCnns[j]) == "McdCloth":
                            try:
                                cmds.delete(allCnns[j])
                                clearDone = True
                            except:
                                cmds.confirmDialog(t = "Abort", m = "Cannot clear" + allCnns[j])
            
    if clearDone == True:
        cmds.confirmDialog(t = "Note", m = "Clear done.")
    
def McdMarkClothMeshSkinClusterOnAndOff(turnOn):
    
    allClothNodes = cmds.ls(type = "McdCloth")
    if MIsBlank(allClothNodes):
        return
    
    allSkinCluster = []
    
    for i in range(len(allClothNodes)):
        allConns = cmds.listConnections(allClothNodes[i], s = True, d = False, shapes = True)
        if MIsBlank(allConns):
            continue;
        allHis = cmds.listHistory(allConns[0])
        if MIsBlank(allHis):
            continue;
        for j in range(len(allHis)):
            if cmds.nodeType(allHis[j]) == "skinCluster":
                allSkinCluster.append(allHis[j])
                
    if allSkinCluster == []:
        return
    
    if turnOn == 1:
        for i in range(len(allSkinCluster)):
            cmds.setAttr(allSkinCluster[i] + ".envelope", 1)
    else:
        for i in range(len(allSkinCluster)):
            cmds.setAttr(allSkinCluster[i] + ".envelope", 0)
    
    
def McdReturnClothPoints():
    allClothNodes = cmds.ls(type = "McdCloth")
    if MIsBlank(allClothNodes):
        return
    
    for i in range(len(allClothNodes)):
        allConns = cmds.listConnections(allClothNodes[i], s = True, d = False, shapes = True)
        if MIsBlank(allConns):
            continue
        clothMesh = allConns[0]
        if cmds.nodeType(clothMesh) != "mesh":
            continue
        result = cmds.ls(clothMesh + ".vtx[0:*]")
        if MIsBlank(result):
            continue
        nbPointRaw = result[0].split("[0:")[-1]
        nbPointStr = nbPointRaw.split("]")[0]
        if not nbPointStr.isdigit():
            continue
        nbPoitn = int(nbPointStr) + 1
        
        for j in range(nbPoitn):
            strj = str(j)
            cmds.setAttr(clothMesh + ".vtx[" + strj + "]", 0, 0, 0)
            
            
            
def McdAddSubdAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.addAttr(selObj[i], ln = "asSubd", at = "bool", dv = 1)
                cmds.setAttr(selObj[i] + ".asSubd", k = False, cb = True)
            except:
                pass
            try:
                cmds.addAttr(selObj[i], ln = "asHiSubd", at = "bool", dv = 0)
                cmds.setAttr(selObj[i] + ".asHiSubd", k = False, cb = True)
            except:
                pass
            try:
                cmds.addAttr(selObj[i], ln = "interpolateBoundary", at = "bool", dv = 1)
                cmds.setAttr(selObj[i] + ".interpolateBoundary", k = False, cb = True)
            except:
                pass
    
def McdDeleteSubdAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.deleteAttr(n = selObj[i], at = "asSubd")
                cmds.deleteAttr(n = selObj[i], at = "interpolateBoundary")
                cmds.deleteAttr(n = selObj[i], at = "asHiSubd")
            except:
                pass
            
def McdAddDispBAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.addAttr(selObj[i], ln = "displacementBound", at = "float", dv = 1)
                cmds.setAttr(selObj[i] + ".displacementBound", k = False, cb = True)
            except:
                pass
    
def McdDeleteDispBAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.deleteAttr(n = selObj[i], at = "displacementBound")
            except:
                pass
            
def McdAddMatteAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.addAttr(selObj[i], ln = "matte", at = "bool", dv = 1)
                cmds.setAttr(selObj[i] + ".matte", k = False, cb = True)
            except:
                pass
    
def McdDeleteMatteAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.deleteAttr(n = selObj[i], at = "matte")
            except:
                pass

def McdAddCustomStringAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.addAttr(selObj[i], ln = "McdRMAttr", dt = "string")
            except:
                pass
    
def McdDeleteCustomStringAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.deleteAttr(n = selObj[i], at = "McdRMAttr")
            except:
                pass

def McdAddShaderHullAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.addAttr(selObj[i], ln = "shaderHull", dt = "string")
            except:
                pass
    
def McdDeleteShaderHullAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.deleteAttr(n = selObj[i], at = "shaderHull")
            except:
                pass

def McdAddGeoWeightAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.addAttr(selObj[i], ln = "geoWeight", at = "long", dv = 1)
                cmds.setAttr(selObj[i] + ".geoWeight", k = False, cb = True)
            except:
                pass
    
def McdAddTexRandMethodToShaderAttr():
    selObj = cmds.ls(sl = True)
    if MIsBlank(selObj):
        cmds.confirmDialog(t = "Warning", m = "Please select a shader and try again.")
        return
    
    allConns = cmds.listConnections(selObj[0], s = False, d = True)
    if MIsBlank(allConns):
        cmds.confirmDialog(t = "Warning", m = "Please select a shader and try again.")
        return
    
    canAdd = False
    for i in range(len(allConns)):
        if cmds.nodeType(allConns[i]) == "shadingEngine":
            canAdd = True
            
    if canAdd:
        try:
            cmds.addAttr(selObj[0], ln = "texRandByAgent", at = "bool", dv = 1)
            cmds.setAttr(selObj[0] + ".texRandByAgent", k = False, cb = True)
        except:
            pass
    else:
        cmds.confirmDialog(t = "Warning", m = "Please select a shader and try again.")
        
        
def McdDelTexRandMethodToShaderAttr():
    selObj = cmds.ls(sl = True)
    if MIsBlank(selObj):
        cmds.confirmDialog(t = "Warning", m = "Please select a shader and try again.")
        return
    
    allConns = cmds.listConnections(selObj[0], s = False, d = True)
    if MIsBlank(allConns):
        cmds.confirmDialog(t = "Warning", m = "Please select a shader and try again.")
        return
    
    canAdd = False
    for i in range(len(allConns)):
        if cmds.nodeType(allConns[i]) == "shadingEngine":
            canAdd = True
            
    if canAdd:
        try:
            cmds.deleteAttr(n = selObj[0], at = "texRandByAgent")
        except:
            pass
    else:
        cmds.confirmDialog(t = "Warning", m = "Please select a shader and try again.")
    
    
def McdDeleteGeoWeightAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.deleteAttr(n = selObj[i], at = "geoWeight")
            except:
                pass

def McdAddClothMatAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.addAttr(selObj[i], ln = "density", at = "float", dv = 1)
                cmds.addAttr(selObj[i], ln = "bendStiff", at = "float", dv = 1, min = 0, max = 1)
                cmds.addAttr(selObj[i], ln = "stretchStiff", at = "float", dv = 1, min = 0, max = 1)
                cmds.addAttr(selObj[i], ln = "dampCoef", at = "float", dv = 0.5, min = 0, max = 1)
                cmds.addAttr(selObj[i], ln = "friction", at = "float", dv = 0, min = 0, max = 1)
                
                cmds.setAttr(selObj[i] + ".density", k = False, cb = True)
                cmds.setAttr(selObj[i] + ".bendStiff", k = False, cb = True)
                cmds.setAttr(selObj[i] + ".stretchStiff", k = False, cb = True)
                cmds.setAttr(selObj[i] + ".dampCoef", k = False, cb = True)
                cmds.setAttr(selObj[i] + ".friction", k = False, cb = True)
            except:
                pass
    
def McdDeleteClothMatAttr():
    selObj = cmds.ls(sl = True)
    if selObj != None and selObj != []:
        for i in range(len(selObj)):
            try:
                cmds.deleteAttr(n = selObj[i], at = "density")
                cmds.deleteAttr(n = selObj[i], at = "bendStiff")
                cmds.deleteAttr(n = selObj[i], at = "stretchStiff")
                cmds.deleteAttr(n = selObj[i], at = "dampCoef")
                cmds.deleteAttr(n = selObj[i], at = "friction")
            except:
                pass


def createPxPushFF():
    miarmyMain = cmds.ls("Miarmy_Contents")
    if miarmyMain == [] or miarmyMain == None:
        cmds.confirmDialog(t = "Error", m = 'Cannot find "Miarmy_Contents" Group.')
        raise Exception('Cannot find "Miarmy_Contents" Group.')

    nbNode = str(McdGetNumOfThisType("McdSpot"))
    newNodeTrans = cmds.createNode("transform", n = "McdSpot" + nbNode)
    spotNode = cmds.createNode("McdSpot", n = "McdSpot" + nbNode + "Shape", p = newNodeTrans)
    
    newNode = cmds.ls(sl = True)
    if newNode != [] or newNode != None:
        cmds.setAttr(newNode[0] + ".feelMode", 2)

def createPxPullFF():
    miarmyMain = cmds.ls("Miarmy_Contents")
    if miarmyMain == [] or miarmyMain == None:
        cmds.confirmDialog(t = "Error", m = 'Cannot find "Miarmy_Contents" Group.')
        raise Exception('Cannot find "Miarmy_Contents" Group.')

    nbNode = str(McdGetNumOfThisType("McdSpot"))
    newNodeTrans = cmds.createNode("transform", n = "McdSpot" + nbNode)
    spotNode = cmds.createNode("McdSpot", n = "McdSpot" + nbNode + "Shape", p = newNodeTrans)

    newNode = cmds.ls(sl = True)
    if newNode != [] or newNode != None:
        cmds.setAttr(newNode[0] + ".feelMode", 2)
        cmds.setAttr(newNode[0] + ".fieldType", 1)

def createPxVortexFF():
    miarmyMain = cmds.ls("Miarmy_Contents")
    if miarmyMain == [] or miarmyMain == None:
        cmds.confirmDialog(t = "Error", m = 'Cannot find "Miarmy_Contents" Group.')
        raise Exception('Cannot find "Miarmy_Contents" Group.')

    nbNode = str(McdGetNumOfThisType("McdSpot"))
    newNodeTrans = cmds.createNode("transform", n = "McdSpot" + nbNode)
    spotNode = cmds.createNode("McdSpot", n = "McdSpot" + nbNode + "Shape", p = newNodeTrans)

    newNode = cmds.ls(sl = True)
    if newNode != [] or newNode != None:
        cmds.setAttr(newNode[0] + ".feelMode", 2)
        cmds.setAttr(newNode[0] + ".fieldType", 2)

def createPxKineBox():

    miarmyMain = cmds.ls("Miarmy_Contents")
    if miarmyMain == [] or miarmyMain == None:
        cmds.confirmDialog(t = "Error", m = 'Cannot find "Miarmy_Contents" Group.')
        raise Exception('Cannot find "Miarmy_Contents" Group.')

    nbNode = str(McdGetNumOfThisType("McdKinePrim"))
    newNodeTrans = cmds.createNode("transform", n = "McdKinePrim" + nbNode)
    spotNode = cmds.createNode("McdKinePrim", n = "McdKinePrim" + nbNode + "Shape", p = newNodeTrans)

def createPxKineSphere():
    miarmyMain = cmds.ls("Miarmy_Contents")
    if miarmyMain == [] or miarmyMain == None:
        cmds.confirmDialog(t = "Error", m = 'Cannot find "Miarmy_Contents" Group.')
        raise Exception('Cannot find "Miarmy_Contents" Group.')

    nbNode = str(McdGetNumOfThisType("McdKinePrim"))
    newNodeTrans = cmds.createNode("transform", n = "McdKinePrim" + nbNode)
    spotNode = cmds.createNode("McdKinePrim", n = "McdKinePrim" + nbNode + "Shape", p = newNodeTrans)
    
    newNode = cmds.ls(sl = True)
    if newNode != [] or newNode != None:
        cmds.setAttr(newNode[0] + ".primType", 1)
        
def createMarkKineMesh():
    targetMesh = getSelection('mesh')

    allConns = cmds.listConnections(targetMesh, d = True, s = False, shapes = True)
    if not MIsBlank(allConns):
        for i in range(len(allConns)):
            if cmds.nodeType(allConns[i]) == "McdKinePrim":
                cmds.confirmDialog(t = "Abort", m = 'Already Connected to kinematic primitive object, no need do again.')
                return
        

    miarmyMain = cmds.ls("Miarmy_Contents")
    if miarmyMain == [] or miarmyMain == None:
        cmds.confirmDialog(t = "Error", m = 'Cannot find "Miarmy_Contents" Group.')
        return

    nbNode = str(McdGetNumOfThisType("McdKinePrim"))
    newNodeTrans = cmds.createNode("transform", n = "McdKinePrim" + nbNode)
    spotNode = cmds.createNode("McdKinePrim", n = "McdKinePrim" + nbNode + "Shape", p = newNodeTrans)
    
    newNode = cmds.ls(sl = True)
    if newNode != [] or newNode != None:
        cmds.setAttr(newNode[0] + ".primType", 2)
    
    try:
        cmds.connectAttr(targetMesh + ".v", newNode[0] + ".inMesh")
    except:
        cmds.confirmDialog(t = "Error", m = 'Cannot connect attr between mesh and kine prim node.')
    
    
        
def createPxRBDEmitter():
    # context check:
    miarmyMain = cmds.ls("Miarmy_Contents")
    if miarmyMain == [] or miarmyMain == None:
        cmds.confirmDialog(t = "Error", m = 'Cannot find "Miarmy_Contents" Group.')
        raise Exception('Cannot find "Miarmy_Contents" Group.')

    nbNode = str(McdGetNumOfThisType("McdRBDEmitter"))
    newNodeTrans = cmds.createNode("transform", n = "McdRBDEmitter" + nbNode)
    spotNode = cmds.createNode("McdRBDEmitter", n = "McdRBDEmitter" + nbNode + "Shape", p = newNodeTrans)

def McdTransitionMapViewerGUI():
    mel.eval("McdSimpleCommand -exe 6;")
    try:
        cmds.deleteUI("TransitionMapView")
    except:
        pass
    windowEntity = cmds.window("TransitionMapView")
    cmds.paneLayout()
    aa = cmds.modelPanel()
    cmds.showWindow(windowEntity)
    mel.eval('setRendererInModelPanel McdTransitionMap "' + aa + '";')
    cmds.modelPanel(aa, e = True, cam = "Cam_Transition_Map")
    
    
def McdBrainViewerGUI():
    mel.eval("McdSimpleCommand -exe 7;")
    try:
        cmds.deleteUI("BrainViewer")
    except:
        pass
    windowEntity = cmds.window("BrainViewer")
    cmds.paneLayout()
    aa = cmds.modelPanel()
    cmds.showWindow(windowEntity)
    mel.eval('setRendererInModelPanel McdBrainView "' + aa + '";')
    cmds.modelPanel(aa, e = True, cam = "Cam_Brain_View")

def McdTryToTurnOffFeedback():
    trmapEx = cmds.window("TransitionMapView", ex = True)
    brainEx = cmds.window("BrainViewer", ex = True)
    
    if trmapEx or brainEx:
        return
    
    allMcdGlobal = cmds.ls(type = "McdGlobal");
    if allMcdGlobal != [] and allMcdGlobal != None:
        globalNode = mel.eval("McdSimpleCommand -exe 2;")
    else:
        return
    
    cmds.setAttr(globalNode + ".selectionCallback", 1)


def delightConfigWin(miarmyInstallLocation):    
    # test install
    delightInstallLocation = os.getenv("DELIGHT")
    if delightInstallLocation == None or delightInstallLocation == "":
        return False
    
    delightBin = delightInstallLocation + "/bin"
    if not os.access(delightBin, os.R_OK):
        return False
    
    shaderdlFile = delightBin + "/shaderdl.exe"
    if not os.access(shaderdlFile, os.R_OK):
        return False
    
    # test shader repository
    shaderPathRaw = os.getenv("DL_SHADERS_PATH")
    if shaderPathRaw == None or shaderPathRaw == "":
        return False
    
    shaderPath = shaderPathRaw.split(";")[0]
    shaderPathExist = False
    while shaderPath != "":
        if os.access(shaderPath, os.W_OK):
            shaderPathExist = True
            break
        
        newShaderTemp = ""
        for i in range(len(shaderPath)):
            if i == 0:
                continue
            newShaderTemp += shaderPath[i]
        shaderPath = newShaderTemp
    
    if not shaderPathExist:
        return False
    
    shaderSrcPath = miarmyInstallLocation + "/shaders/src"

    # compile shader for you:
    #example: 'd:/progar/asdf/3delight/bin/shaderdl -d "d:/abc/ddd" "x:/asdf/fasdf/xxxx.sl"'
    
    commandStr = 'shaderdl -d "'
    disPath = shaderPath + '" "'
    
    shader = shaderSrcPath + '/McdTxtPlastic.sl"'
    sysCmdRaw = commandStr + disPath + shader
    sysCmd = sysCmdRaw.replace("\\", "/")
    os.popen(sysCmd).read()
    
    shader = shaderSrcPath + '/McdBumpy.sl"'
    sysCmdRaw = commandStr + disPath + shader
    sysCmd = sysCmdRaw.replace("\\", "/")
    os.popen(sysCmd).read()
    
    shader = shaderSrcPath + '/McdDOF.sl"'
    sysCmdRaw = commandStr + disPath + shader
    sysCmd = sysCmdRaw.replace("\\", "/")
    os.popen(sysCmd).read()
    
    shader = shaderSrcPath + '/McdGatherAO.sl"'
    sysCmdRaw = commandStr + disPath + shader
    sysCmd = sysCmdRaw.replace("\\", "/")
    os.popen(sysCmd).read()
    
    shader = shaderSrcPath + '/McdSpotlightInv.sl"'
    sysCmdRaw = commandStr + disPath + shader
    sysCmd = sysCmdRaw.replace("\\", "/")
    os.popen(sysCmd).read()
    
    return True    


def miarmyInstallWin():
    # unload plugin:
    aa = cmds.pluginInfo("MiarmyDebugx64", q= True, l = True)
    bb = cmds.pluginInfo("MiarmyExpressForMaya2011x64", q= True, l = True)
    cc = cmds.pluginInfo("MiarmyExpressForMaya2012x64", q= True, l = True)
    dd = cmds.pluginInfo("MiarmyExpressForMaya2011x86", q= True, l = True)
    ee = cmds.pluginInfo("MiarmyExpressForMaya2012x86", q= True, l = True)
    
    if aa or bb or cc or dd or ee:
        cmds.confirmDialog(t = "Unload Needed", m = "Please unload Miarmy Plugin firstly, and click this again.")
        return;
    
    # get maya location:
    melCommand = "getenv MAYA_LOCATION"
    mayaInstallLocation = mel.eval(melCommand)
    
    # test location readable
    if not os.access(mayaInstallLocation, os.R_OK):
        cmds.confirmDialog(t = "Error", m = "We cannot access your maya installation place.")
        return
    
    # test location writable
    if not os.access(mayaInstallLocation, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "We cannot write files on your maya installation place:\n" +\
                                            mayaInstallLocation)
        return
    
    # test maya bin
    mayaBin = mayaInstallLocation + "/bin"
    if not os.access(mayaBin, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "We cannot access bin folder in your Maya installation place:\n" +\
                                            mayaBin)
        return
    
    # test maya architecture
    aMayaBinFile = mayaBin + "/libapi_memory.dll"
    mayaArc = 32
    if os.access(aMayaBinFile, os.R_OK):
        mayaArc = 32
    else:
        mayaArc = 64
        
    
    # create module directory:
    mayaModulePath = mayaInstallLocation + "/modules"
    try:
        if not os.access(mayaInstallLocation + "/modules", os.R_OK):
            os.makedirs(mayaInstallLocation + "/modules")
    except:
        cmds.confirmDialog(t = "Error", m = "We cannot create module folder in your maya installation place:\n" +\
                                            mayaInstallLocation + \
                                            "\nFor Windows 7, please turn off UAC until installation finished")
        return
        
    # promptUser specify miarmy location:
    miarmyLocation = cmds.fileDialog(m = 0, dm = "*.config")
    
    if miarmyLocation == "":
        cmds.confirmDialog(t = "Abort", m = "Abort by user.")
        return
    
    miarmyInstallLocation = miarmyLocation.split("/Miarmy-Link-Maya")[0]
    miarmyModule = miarmyInstallLocation + "/maya"
    miarmyModuleStr = miarmyModule.replace("/", "\\")
    
    if not os.access(miarmyModuleStr, os.R_OK):
        cmds.confirmDialog(t = "Error", m = "We cannot access your Miarmy install location:\n" +\
                                            miarmyModule)
        return
    
    # create miarmy module and write info:
    miarmyModuleInfo = "+ Miarmy 1.2 " + miarmyModuleStr
    try:
        f = open(mayaModulePath + "/MiarmyForMaya.txt", "w")
        f.write(miarmyModuleInfo)
        f.flush()
        f.close()
    except:
        cmds.confirmDialog(t = "Error", m = "We cannot write module file to your maya installation place:\n" +\
                                            mayaModulePath + \
                                            "\nFor Windows 7, please turn off UAC until installation finished")
        return
    
    # choose x86 or x64
    if mayaArc == 32:
        choice = cmds.confirmDialog(t = "Question", m = "We detect you are using 32bit Maya, are you sure?", b = ["Yes", "No, 64bit Maya", "Cancel"])
        if choice == "No, 64bit Maya":
            choice2 = cmds.confirmDialog(t = "Question", m = "Are you sure you are using 64bit Maya?", b = ["Yes", "No", "Cancel"])
            if choice2 == "Yes":
                mayaArc = 64
            elif choice2 == "Cancel":
                cmds.confirmDialog(t = "Note", m = "Installation not complete.")
                return
        elif choice == "Cancel":
            cmds.confirmDialog(t = "Note", m = "Installation not complete.")
            return
    else:
        choice = cmds.confirmDialog(t = "Question", m = "We detect you are using 64bit Maya, are you sure?", b = ["Yes", "No, 32bit Maya", "Cancel"])
        if choice == "No, 32bit Maya":
            choice2 = cmds.confirmDialog(t = "Question", m = "Are you sure you are using 64bit Maya?", b = ["Yes", "No", "Cancel"])
            if choice2 == "Yes":
                mayaArc = 32
            elif choice2 == "Cancel":
                cmds.confirmDialog(t = "Note", m = "Installation not complete.")
                return
        elif choice == "Cancel":
            cmds.confirmDialog(t = "Note", m = "Installation not complete.")
            return
    
    # get miarmy bin:
    if mayaArc == 32:
        miarmyBin = miarmyInstallLocation + "/bin/win32"
    else:
        miarmyBin = miarmyInstallLocation + "/bin/win64"
    
    if not os.access(miarmyBin, os.R_OK):
        cmds.confirmDialog(t = "Error", m = "We cannot access bin folder in your Miarmy unzip location:\n" +\
                                            miarmyBin)
        return
    
    # copy dll to miarmy bin to maya bin
    copied = False
    allDLLs = os.listdir(miarmyBin)
    if allDLLs != [] and allDLLs != None:
        for i in range(len(allDLLs)):
            try:
                shutil.copyfile(miarmyBin + "/" + allDLLs[i], mayaBin + "/" + allDLLs[i])
            except:
                # running, cannot copy, exist
                pass
            copied = True
            
    if not copied:
        cmds.confirmDialog(t = "Error", m = "No files copied, please download Miarmy again.\n")
        return
    
    #setup 3delight shaders and
    if delightConfigWin(miarmyInstallLocation):
        cmds.confirmDialog(t = "Success", m = "Miarmy Installation Complete. Please restart Maya.")
        cmds.confirmDialog(t = "Note", m = "If you have your own 3delight, you should remove Basefount Provided 3Delight, Miarmy > Remove 3Delight")
    else:
        cmds.confirmDialog(t = "3Delight Failed", m = "3Delight not setup correctly, re-install 3delight then re-link Miarmy")
        cmds.confirmDialog(t = "Success", m = "Except Renderer, Miarmy can work properly now. Please restart Maya.")

def McdUnlinkMiarmy():
    # unload plugin:
    aa = cmds.pluginInfo("MiarmyDebugx64", q= True, l = True)
    bb = cmds.pluginInfo("MiarmyExpressForMaya2011x64", q= True, l = True)
    cc = cmds.pluginInfo("MiarmyExpressForMaya2012x64", q= True, l = True)
    dd = cmds.pluginInfo("MiarmyExpressForMaya2011x86", q= True, l = True)
    ee = cmds.pluginInfo("MiarmyExpressForMaya2012x86", q= True, l = True)
    
    if aa or bb or cc or dd or ee:
        cmds.confirmDialog(t = "Faild", m = "Please unload Miarmy firstly, and try again.")
        return;
    
    stat = cmds.confirmDialog(t = "Question", m = "Are you sure to unlink Miarmy from this Maya?", b = ["Yes", "Cancel"])
    if stat != "Yes":
        return
    
    
    # get maya location:
    melCommand = "getenv MAYA_LOCATION"
    mayaInstallLocation = mel.eval(melCommand)
    
    # test location readable
    if not os.access(mayaInstallLocation, os.R_OK):
        cmds.confirmDialog(t = "Error", m = "We cannot access your maya installation place.")
        return
    
    # test location writable
    if not os.access(mayaInstallLocation, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "We cannot write files on your maya installation place:\n" +\
                                            mayaInstallLocation)
        return
    
    mayaBin = mayaInstallLocation + "/bin"
    delightDll = mayaBin + "/3Delight.dll"
    if os.access(delightDll, os.R_OK):
        if not os.access(delightDll, os.W_OK):
            cmds.confirmDialog(t = "Error", m = "We cannot delete files for you, please manually delete 3delight.dll in Maya bin folder")
            return;
        # delete delightDll
        try:
            os.remove(delightDll)
        except:
            cmds.confirmDialog(t = "Error", m = "We cannot delete files for you, please manually delete 3delight.dll in Maya bin folder")
            return;
            
        
    mayaModulePath = mayaInstallLocation + "/modules" # MiarmyForMaya
    moduleFile = mayaModulePath + "/MiarmyForMaya.txt"
    if os.access(moduleFile, os.R_OK):
        if not os.access(moduleFile, os.W_OK):
            cmds.confirmDialog(t = "Error", m = "We cannot delete files for you, please manually delete MiarmyForMaya.txt in Maya module folder")
            return;
        # delete moduleFile
        try:
            os.remove(moduleFile)
        except:
            cmds.confirmDialog(t = "Error", m = "We cannot delete files for you, please manually delete MiarmyForMaya.txt in Maya module folder")
            return
    
    
    cmds.confirmDialog(t = "Success", m = "Miarmy Un-link Complete. Please restart Maya.")
    
def McdGetSelectedBrainVarNames():
    r = mel.eval("McdSimpleCommand -exe 10")
    return r
    
def McdGetSelectedAgentVarNames():
    r = mel.eval("McdSimpleCommand -exe 11")
    return r
    
def McdGetSelectedBrainVarValues():
    r = mel.eval("McdSimpleCommand -exe 14")
    return r;
    
def McdGetSelectedAgentVarValues():
    r = mel.eval("McdSimpleCommand -exe 15")
    return r;
    
def McdCheckRendererStatus():
    # ################################################
    # check maya bin, the 3delight version
    # check the DELIGHT
    # check shader path and shaderers DL_SHADERS_PATH
    # check display path DL_DISPLAYS_PATH
    # ################################################
    sysPlatform = platform.system()
    
    errorFlag = []
    # 0: 3Delight in Maya bin folder with wrong version
    # 1: not install 3delight yet
    # 2: install wrong version of 3delight
    # 3: not have shader path, re-install with shader
    # 4: have shader path but no shaders, please compile them
    # 5: didnt setup DL_DISPLAYS_PATH
    
    # get maya location:
    melCommand = "getenv MAYA_LOCATION"
    mayaInstallLocation = mel.eval(melCommand)
    # test location readable
    if not os.access(mayaInstallLocation, os.R_OK):
        cmds.confirmDialog(t = "Error", m = "We cannot access your maya installation place.")
    else:
        # test maya bin
        if sysPlatform == "Windows":
            mayaBin = mayaInstallLocation + "/bin"
            
            if os.access(mayaBin + "/3Delight.dll", os.R_OK):
                # test size:
                dlBin = os.path.getsize(mayaBin + "/3Delight.dll")
                if dlBin < 7000000:
                    errorFlag.append(0)
                    
        elif sysPlatform == "Linux":
            mayaBin = mayaInstallLocation + "/lib"
            
            if os.access(mayaBin + "/lib3delight.so", os.R_OK):
                # test size:
                dlBin = os.path.getsize(mayaBin + "/lib3delight.so")
                if dlBin < 5000000:
                    errorFlag.append(0)
                
                
    # check the DELIGHT
    dlpath = os.getenv("DELIGHT")
    if dlpath == None or dlpath == "":
        errorFlag.append(1)
    else:
        if sysPlatform == "Windows":
            if os.access(dlpath + "/bin/3Delight.dll", os.R_OK):
                dlBin = os.path.getsize(dlpath + "/bin/3Delight.dll")
                if dlBin < 6000000:
                    errorFlag.append(2)
            else:
                errorFlag.append(1)
        # elif sysPlatform == "Linux":
        # ignore linux
                
    # check the Shaders:
    dlshaderpath = os.getenv("DL_SHADERS_PATH")
    if dlshaderpath == None or dlshaderpath == "":
        errorFlag.append(3)
    else:
        if sysPlatform == "Windows":
            dlshaderpath = dlshaderpath.split(".:")[-1]
            if not os.access(dlshaderpath + "/McdTxtPlastic.sdl", os.R_OK):
                errorFlag.append(4)
        else:
            dlshaderpath = dlshaderpath.split(":")[-1]
            if not os.access(dlshaderpath + "/McdTxtPlastic.sdl", os.R_OK):
                errorFlag.append(4)
    
    # check display it:
    dldpath = os.getenv("DL_DISPLAYS_PATH")
    if dldpath == None or dldpath == "":
        errorFlag.append(5)
    
    if errorFlag == []:
        cmds.confirmDialog(t = "Note", m = "Seems everything is fine.");
        return
    
    # 0: 3Delight in Maya bin folder with wrong version
    # 1: not install 3delight yet
    # 2: install wrong version of 3delight
    # 3: not have shader path, re-install with shader
    # 4: have shader path but no shaders, please compile them
    # 5: didnt setup DL_DISPLAYS_PATH
    
    errorLogs = "We detected following errors from your machine:\n\n"
    if 0 in errorFlag:
        errorLogs += "* 3Delight in Maya bin folder with wrong version.\n"
    if 1 in errorFlag:
        errorLogs += "* Cannot find DELIGHT env path, maybe you didn't install 3Delight 10.\n"
    if 2 in errorFlag:
        errorLogs += "* Maybe you installed wrong version of 3delight, please install version 10.\n"
    if 3 in errorFlag:
        errorLogs += "* Cannot find shader evn path, please re-install 3delight 10 firstly.\n"
    if 4 in errorFlag:
        errorLogs += "* Cannot find specific shaders in shader path, please compile them.\n"
    if 5 in errorFlag:
        errorLogs += "* Cannot find display path, plase re-install 3delight 10 firstly.\n"
        
    cmds.confirmDialog(t = "Question", m = errorLogs);
    
def McdCompileShaders():
    # ###################################
    # find shader source
    # find DL_SHADERS_PATH
    # test writable
    # try to compile
    # check is success
    # ###################################
    
    melCmd = "getenv MAYA_MODULE_PATH;"
    modulePaths = mel.eval(melCmd)
    if modulePaths.find(';') > 0:
        modulePathList = modulePaths.split(';')
    else:
        modulePathList = modulePaths.split(':')
    if modulePathList == [] or modulePathList == None:
        cmds.confirmDialog(t = "Error", m = "Cannot find your maya module path")
        return
        
    gotIt = False
    MiarmyModulePath = ""
    for i in range(len(modulePathList)):
        if os.access(modulePathList[i], os.R_OK):
            allFiles = os.listdir(modulePathList[i])
            if allFiles != [] and allFiles != None:
                for j in range(len(allFiles)):
                    if allFiles[j] == "MiarmyForMaya.txt":
                        MiarmyModulePath = modulePathList[i] + "/MiarmyForMaya.txt"
                        gotIt = True
                        break
                    if allFiles[j] == "MiarmyForMaya.module":
                        MiarmyModulePath = modulePathList[i] + "/MiarmyForMaya.module"
                        gotIt = True
                        break
        if gotIt == True:
            break
    
    if not os.access(MiarmyModulePath, os.R_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot find MiarmyForMaya.txt file")
        return

    f = open(MiarmyModulePath)
    contents = f.read()
    f.close()
    
    if contents.find("+ Miarmy Any ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy Any ")[-1]
    elif contents.find("+ Miarmy 1.5 ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy 1.5 ")[-1]
    elif contents.find("+ Miarmy 2.0 ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy 2.0 ")[-1]
    elif contents.find("+ Miarmy 2.5 ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy 2.5 ")[-1]
    elif contents.find("+ Miarmy 3.0 ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy 3.0 ")[-1]
    elif contents.find("+ Miarmy 3.5 ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy 3.5 ")[-1]
    elif contents.find("+ Miarmy 4.0 ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy 4.0 ")[-1]
    else:
        cmds.confirmDialog(t = "Error", m = "Contents in MiarmyForMaya file is incorrect, please check installation manual.")
        return
    
    MiarmyInstallPlace = MiarmyInstallPlace.replace("\\", "/")
    MiarmyInstallPlace = MiarmyInstallPlace.replace("\r", "")
    MiarmyInstallPlace = MiarmyInstallPlace.replace("\n", "")
    
    if not os.access(MiarmyInstallPlace, os.R_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot find Miarmy install place in MiarmyForMaya.txt")
        return
    
    MiarmyInstallRawList = MiarmyInstallPlace.split("/")
    if MiarmyInstallRawList == [] or MiarmyInstallRawList == None:
        cmds.confirmDialog(t = "Error", m = "Miarmy installation place error")
        return
        
    MiarmyInstallPath = ""
    for i in range(len(MiarmyInstallRawList)-1):
        MiarmyInstallPath += MiarmyInstallRawList[i] + "/"
        
    MiarmyShaderPath = MiarmyInstallPath + "shaders/src"
    
    if not os.access(MiarmyShaderPath, os.R_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot solve out shader code path")
        return
        
    allShaderSource = os.listdir(MiarmyShaderPath)
    if allShaderSource == [] or allShaderSource == None:
        cmds.confirmDialog(t = "Error", m = "Cannot find shader source code.")
        return
    
    # find shaderpath:
    dlshaderpath = os.getenv("DL_SHADERS_PATH")
    if dlshaderpath == None or dlshaderpath == "":
        cmds.confirmDialog(t = "Error", m = "Cannot find shader path of 3delight, please install 3delight 10.")
        return
    
    dlshaderpath = dlshaderpath.split(".:")[-1]
    dlshaderpath = dlshaderpath.replace("\\", "/")
    if not os.access(dlshaderpath, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "3delight shader path is not writable.")
        return
    
    
    # try to compile:
    commandStr = 'shaderdl -d "'
    disPath = dlshaderpath + '" "'
    
    for i in range(len(allShaderSource)):
        shader = MiarmyShaderPath + '/' + allShaderSource[i] + '"'
        sysCmdRaw = commandStr + disPath + shader
        sysCmd = sysCmdRaw.replace("\\", "/")
        os.popen(sysCmd).read()
        
    # check success:
    success = True
    for i in range(len(allShaderSource)):
        shaderCompiled = allShaderSource[i].replace(".sl", ".sdl")
        print dlshaderpath + "/" + shaderCompiled
        if not os.access(dlshaderpath + "/" + shaderCompiled, os.R_OK):
            success = False
            break
    
    if not success:
        cmds.confirmDialog(t = "Error", m = "Cannot done compile, unknown error.")
    else:
        cmds.confirmDialog(t = "Complete", m = "Compilation Successful.")
    
def McdRemoveDelight():
    stat = cmds.confirmDialog(t = "Question", m = "If you have your own 3delight installed, you should remove Basefount provided FREE version of 3Delight.\n" + \
                     "32bit Miarmy need 32bit 3Delight\n64bit Miarmy need 64bit 3Delight",\
                     b = ["Remove Basefount Provided 3Delight.dll", "Decide Later"])
    if stat == "Remove Basefount Provided 3Delight.dll":
        # unload plugin:
        aa = cmds.pluginInfo("MiarmyDebugx64", q= True, l = True)
        bb = cmds.pluginInfo("MiarmyExpressForMaya2011x64", q= True, l = True)
        cc = cmds.pluginInfo("MiarmyExpressForMaya2012x64", q= True, l = True)
        dd = cmds.pluginInfo("MiarmyExpressForMaya2011x86", q= True, l = True)
        ee = cmds.pluginInfo("MiarmyExpressForMaya2012x86", q= True, l = True)
        
        if aa or bb or cc or dd or ee:
            cmds.confirmDialog(t = "Faild", m = "Please unload Miarmy firstly, and try again.")
            return;
        
        
        # get maya location:
        melCommand = "getenv MAYA_LOCATION"
        mayaInstallLocation = mel.eval(melCommand)
        
        # test location readable
        if not os.access(mayaInstallLocation, os.R_OK):
            cmds.confirmDialog(t = "Error", m = "We cannot access your maya installation place.")
            return
        
        # test location writable
        if not os.access(mayaInstallLocation, os.W_OK):
            cmds.confirmDialog(t = "Error", m = "We cannot write files on your maya installation place:\n" +\
                                                mayaInstallLocation)
            return
        
        mayaBin = mayaInstallLocation + "/bin"
        delightDll = mayaBin + "/3Delight.dll"
        if os.access(delightDll, os.R_OK):
            if not os.access(delightDll, os.W_OK):
                cmds.confirmDialog(t = "Error", m = "We cannot delete files for you, please manually delete 3delight.dll in Maya bin folder")
                return;
            # delete delightDll
            try:
                os.remove(delightDll)
            except:
                cmds.confirmDialog(t = "Error", m = "We cannot delete files for you, please manually delete 3delight.dll in Maya bin folder")
                return;
        
        
        cmds.confirmDialog(t = "Success", m = "Free version of 3Delight Un-link Complete.")    
    
def McdExportMiarmyAll():
    globalNode = mel.eval("McdSimpleCommand -exe 2;")
    cmds.select(globalNode)
    cmds.select("Miarmy_Contents", add = True)
    
def McdExportAgent():
    if isReferenceScene():
        cmds.confirmDialog(t = "Abort", m = "Not available in referenced scene.")
        return
    
    currentFileName = cmds.file(q = True, sn = True)
    if currentFileName == [] or currentFileName == None or currentFileName == "":
        cmds.confirmDialog(t = "Abort", m = "Please save your current scene before exporting.")
        return
    
    agentGrp = cmds.ls(sl = True)
    if agentGrp == [] or agentGrp == None:
        cmds.confirmDialog(t = "Abort", m = "Please select Agent Group Node")
        return
    
    if cmds.nodeType(agentGrp[0]) != "McdAgentGroup":
        cmds.confirmDialog(t = "Abort", m = "Please select Agent Group Node")
        return
    
    exportNode = agentGrp[0]
    
    stat = cmds.promptDialog(t = "Question", m = "Please specify the export name",
                    button = ["Export", "Cancel"], \
                    defaultButton = "Export", cancelButton = "Cancel", dismissString = "Cancel")
    
    if stat != "Export":
        return
    
    exportName = cmds.promptDialog(query = True, text = True)
    
    if not CheckStringIsValid(exportName):
        cmds.confirmDialog(t = "Abort", m = "Invalid input.")
        return
    
    folderName = os.path.dirname(currentFileName)
    if not os.access(folderName, os.W_OK):
        cmds.confirmDialog(t = "Abort", m = "Cannot write to \"" + folderName + "\"")
        return
    
    # exporting ----------------------------------------------------------------
    exportFile = folderName + "/" + exportName + ".ma"
    
    allParents = cmds.listRelatives(exportNode, p = True, c = False, f = True)
    if allParents == [] or allParents == None:
        try:
            cmds.file(exportFile, op = "v=0", typ = "mayaAscii", pr = 1, es = 1)
        except:
            pass
    else:
        parentNode = allParents[0]
        cmds.parent(exportNode, w = True)
        try:
            cmds.file(exportFile, op = "v=0", typ = "mayaAscii", pr = 1, es = 1)
        except:
            pass
        cmds.parent(exportNode, parentNode)
        
def duplicateCamAndParentLook():
    
    selObj = cmds.ls(sl = True)
    if selObj == [] or selObj == None:
        cmds.confirmDialog(t = "Error", m = "Please select one agent firstly.")
        return;
    
    cmds.select(clear = True)
    
    try:
        perspCam = cmds.ls("perspShape", type = "camera")[0]
        aa = cmds.duplicate(perspCam, n = "agentCam")
        cmds.parent(aa, selObj[0])
        
        cmds.lookThru(aa)
    except:
        pass

def listAllAgentGroups():
    allAgtGrp = []
    
    allAgtGrpRaw = cmds.ls(type = "McdAgentGroup")
    if McdIsBlank(allAgtGrpRaw):
        return allAgtGrp
    
    for i in range(len(allAgtGrpRaw)):
        allChild = cmds.listRelatives(allAgtGrpRaw[i], c = True, p = False, f = True)
        if McdIsBlank(allChild):
            continue
        for j in range(len(allChild)):
            if allChild[j].find("OriginalAgent") >= 0:
                allJoints = cmds.listRelatives(allChild[j], c = True, p = False, f = True)
                if McdIsBlank(allJoints):
                    continue
                for k in range(len(allJoints)):
                    if cmds.nodeType(allJoints[k]) == "joint":
                        allAgtGrp.append(allAgtGrpRaw[i])
    
    return allAgtGrp

def McdFromAgentToAgentGroup(verbose = False):
    selObjs = cmds.ls(sl = True)
    if McdIsBlank(selObjs):
        cmds.confirmDialog(t = "Error", m = "Please select at least one agent firstly.")
        return;
    
    allAgentGroups = listAllAgentGroups()
    if McdIsBlank(allAgentGroups):
        cmds.confirmDialog(t = "Error", m = "No agent group contains original agent")
        return;
    
    allAgentTids = []
    for i in range(len(allAgentGroups)):
        tid = cmds.getAttr(allAgentGroups[i] + ".tid")
        allAgentTids.append(tid)
    
    allSelAgents = []
    for i in range(len(selObjs)):
        thisAgent = ""
        if cmds.nodeType(selObjs[i]) == "McdAgent":
            thisAgent = selObjs[i]
        if thisAgent == "":
            allChild = cmds.listRelatives(selObjs[i], c = True, p = False, f = True)
            if McdIsBlank(allChild):
                continue
            for j in range(len(allChild)):
                if cmds.nodeType(allChild[j]) == "McdAgent":
                    thisAgent = allChild[j]
                    
        allSelAgents.append(thisAgent)
        
    result = []
    for i in range(len(allSelAgents)):
        aTid = cmds.getAttr(allSelAgents[i] + ".tid")
        for j in range(len(allAgentTids)):
            if aTid == allAgentTids[j]:
                result.append(allAgentGroups[j])
        
    if verbose:
        cmds.confirmDialog(t = "Error", m = "Please check result in script editor")
        print result
        
    return result
        
        
def McdFromAgentToPlace(verbose = False):
    selObjs = cmds.ls(sl = True)
    if McdIsBlank(selObjs):
        cmds.confirmDialog(t = "Error", m = "Please select at least one agent firstly.")
        return;
    
    allPlaceNodes = cmds.ls(type = "McdPlace")
    
    allPlacePlid = []
    for i in range(len(allPlaceNodes)):
        plid = cmds.getAttr(allPlaceNodes[i] + ".plid")
        allPlacePlid.append(plid)
    
    allSelAgents = []
    for i in range(len(selObjs)):
        thisAgent = ""
        if cmds.nodeType(selObjs[i]) == "McdAgent":
            thisAgent = selObjs[i]
        if thisAgent == "":
            allChild = cmds.listRelatives(selObjs[i], c = True, p = False, f = True)
            if McdIsBlank(allChild):
                continue
            for j in range(len(allChild)):
                if cmds.nodeType(allChild[j]) == "McdAgent":
                    thisAgent = allChild[j]
                    
        allSelAgents.append(thisAgent)
        
    result = []
    for i in range(len(allSelAgents)):
        plid = cmds.getAttr(allSelAgents[i] + ".plid")
        plaid = cmds.getAttr(allSelAgents[i] + ".plaid")
        for j in range(len(allPlacePlid)):
            if plid == allPlacePlid[j]:
                result.append(allPlaceNodes[j])
                result.append(plaid)
        
    if verbose:
        cmds.confirmDialog(t = "Error", m = "Please check result in script editor")
        print result
        
    return result
        
def BakeRBDObjects():
    # read selection, first rbd obj, then rbd emitter
    # go the the last frame
    # fetch the rbd data
    # if exist rbd,
    #   duplicate instance
    #   for each frame put and keyframe
    
    ##################################################
    # read selection, first rbd obj, then rbd emitter
    selObjs = cmds.ls(sl = True)
    if len(selObjs) != 2:
        cmds.confirmDialog(t = "Error", m = "Please select an RBD emitter then select an mesh object.")
        return
    
    if cmds.nodeType(selObjs[1]) != "transform":
        cmds.confirmDialog(t = "Error", m = "Please select an RBD emitter then select an mesh object.")
        return
    
    allChildren = getAllChildren(selObjs[1])
    if MIsBlank(allChildren):
        cmds.confirmDialog(t = "Error", m = "Please select an RBD emitter then select an mesh object.")
        return
    
    if cmds.nodeType(allChildren[0]) != "mesh":
        cmds.confirmDialog(t = "Error", m = "Please select an RBD emitter then select an mesh object.")
        return
        
    startFrame = int(cmds.playbackOptions(q =True, min = True))
    endFrame = int(cmds.playbackOptions(q =True, max = True))
    
    cmds.currentTime(endFrame)    
    fetchResult = mel.eval("McdSimpleCommand -exe 35;")
    if fetchResult == None:
        cmds.confirmDialog(t = "Error", m = "Please select an RBD emitter then select an mesh object.")
        return
    
    rbdObj = selObjs[0]
    
    nbRBD = int(fetchResult[0])
    stat = cmds.confirmDialog(t = "Bake RBD Emitter", m = "The RBD bake information:\n" + \
                                            "Start Frame " + str(startFrame) + "\n" + \
                                            "End Frame: " + str(endFrame) + "\n" + \
                                            "It will duplicate " + str(nbRBD) + " of object instances, we recommend save your scene before continue.", \
                                            b = ["Continue", "Cancel"])
    if stat == "Cancel":
        return
    
    
    # //////////////////////////////////////////////////////////////////////////
    # start deal with:
    autoKeyState = cmds.autoKeyframe( q = True, state = True)
    cmds.autoKeyframe( e = True, state = False)
    
    # create a inventory
    rbd = cmds.ls("McdRBDInstanceGrp")
    if MIsBlank(rbd):
        cmds.createNode("transform", n = "McdRBDInstanceGrp")
    
    
    cmds.progressWindow( title = "Instancing", progress = 0, \
                       min = 0, \
                       max = nbRBD, \
                       status = "Instancing:", isInterruptable = True )
    
    try:
        # duplicate instance
        allInstances = []
        for i in range(nbRBD):
            newInstance = cmds.instance(selObjs[1])
            allInstances.append(newInstance)
            cmds.parent(newInstance, "McdRBDInstanceGrp")
            
            cmds.progressWindow( edit = True, progress = i)
    except:
        cmds.progressWindow( endProgress=1 )
        pass
    
    cmds.progressWindow( endProgress=1 )
        
    
    
    # for each frame put and keyframe
    nbFrame = endFrame - startFrame + 1
    
    maxVis = -1
    for i in range(nbFrame):
        cmds.currentTime(startFrame + i)
        
        cmds.select(rbdObj)
        fetchResult = mel.eval("McdSimpleCommand -exe 35;")
        nbRBD = int(fetchResult[0])
        
        for j in range(nbRBD):
            cmds.setAttr(allInstances[j][0] + ".t", fetchResult[1 + j*6    ], fetchResult[1 + j*6 + 1], fetchResult[1 + j*6 + 2])
            cmds.setAttr(allInstances[j][0] + ".r", fetchResult[1 + j*6 + 3], fetchResult[1 + j*6 + 4], fetchResult[1 + j*6 + 5])
            
            nbKey = cmds.setKeyframe(allInstances[j][0], at = "r")
            nbKey = cmds.setKeyframe(allInstances[j][0], at = "t")
            
            if j > maxVis:
                cmds.setAttr(allInstances[j][0] + ".v", 1)
                nbKey = cmds.setKeyframe(allInstances[j][0], at = "v")
                
        maxVis = nbRBD - 1
        
        
        if i == 0:
            for j in range(len(allInstances)):
                cmds.setAttr(allInstances[j][0] + ".v", 0)
                nbKey = cmds.setKeyframe(allInstances[j][0], at = "v")
    
    cmds.autoKeyframe( e = True, state = autoKeyState)
        
def McdHideListAdd():
    allAgents = cmds.ls(sl = True)
    
    if MIsBlank(allAgents):
        cmds.confirmDialog(t = "Error", m = "Please select some agents");
        return
    
    globalNode = McdGetMcdGlobalNode()
    
    for i in range(len(allAgents)):
        aid = cmds.getAttr(allAgents[i] + ".agentId")
        cmds.setAttr(globalNode + ".hideList[" + str(aid) + "]", 1)
    
    cmds.setAttr(globalNode + ".hideList[0]", 1)
    
    cmds.confirmDialog(t = "Success", m = "For checking details please run following python:\n" + \
                  "cmds.getAttr('McdGlobal1.hideList')");
    

def McdHideListClear():
    allAgents = cmds.ls(type = "McdAgent")
    
    if MIsBlank(allAgents):
        cmds.confirmDialog(t = "Error", m = "Please firstly place the agent out");
        return
    
    globalNode = McdGetMcdGlobalNode()
    
    for i in range(len(allAgents)):
        cmds.setAttr(globalNode + ".hideList[" + str(i+1) + "]", 0)
    
    cmds.setAttr(globalNode + ".hideList[0]", 0)
    
    cmds.confirmDialog(t = "Success", m = "For checking details please run following python:\n" + \
                  "cmds.getAttr('McdGlobal1.hideList')");
        
def McdCheckShaderForMD3():
    # find all agent geo -------------------------------------------------------
    allGeoGrp = cmds.ls("*Geometry_*")
    allGeoGrpRef = cmds.ls("*:Geometry_*")
    allGeoGrp.extend(allGeoGrpRef)
    if McdIsBlank(allGeoGrp):
        return
    allGeoGrpList = []
    for i in range(len(allGeoGrp)):
        geoGrpParent = cmds.listRelatives(allGeoGrp[i], p = True, c = False)
        if McdIsBlank(geoGrpParent):
            continue
        if cmds.nodeType(geoGrpParent[0]) == "McdAgentGroup":
            allGeoGrpList.append(allGeoGrp[i])
    
    allGeos = []
    for i in range(len(allGeoGrpList)):
        allSubNodes = cmds.listRelatives(allGeoGrpList[i], c = True, p = False, ad = True, path = True)
        if McdIsBlank(allSubNodes):
            continue
        for j in range(len(allSubNodes)):
            if cmds.nodeType(allSubNodes[j]) == "mesh":
                if not cmds.getAttr(allSubNodes[j] + ".intermediateObject"):
                    allGeos.append(allSubNodes[j])
    if allGeos == []:
        return
    
    haveProblem = []
    for i in range(len(allGeos)):
        allConns = cmds.listConnections(allGeos[i], s = False, d = True)
        if MIsBlank(allConns):
            haveProblem.append(allGeos[i])
            continue
        sgnode = ""
        for j in range(len(allConns)):
            if cmds.nodeType(allConns[j]) == "shadingEngine":
                sgnode = allConns[j]
                break
        if sgnode == "":
            haveProblem.append(allGeos[i])
            continue
        
        ctgeo = False
        allConns2 = cmds.listConnections(sgnode, s = False, d = True, sh = True)

        if MIsBlank(allConns2):
            continue
        for j in range(len(allConns2)):
            if allConns2[j] == allGeos[i]:
                haveProblem.append(allGeos[i])


    if haveProblem == []:
        cmds.confirmDialog(t = "Success", m = "Maybe no problem, if have, please contact us.");
    else:
        cmds.confirmDialog(t = "Problem Detected", m = "Some geometries need fix shader.\nSee script editor in details!");
        print "***********************************************"
        print "- Geometry Need Assign Shader in Object Level -"
        for i in range(len(haveProblem)):
            print haveProblem[i]
        print "***********************************************"
    
        
        
def clearBUILDfolder():
    buildPath = "D:/Users/Yeah YANG/Documents/Visual Studio 2008/Projects/Miarmy20Debug64/Miarmy20Debug64/BUILD";
        
    allSub = os.listdir(buildPath)
    for i in range(len(allSub)):
        subDir = buildPath + "/" + allSub[i]
        try:
            allInFiles = os.listdir(subDir)
            for j in range(len(allInFiles)):
                if allInFiles[j].find(".o") > 0 or allInFiles[j].find(".so") > 0:
                    delFile = subDir + "/" + allInFiles[j]
                    try:
                        os.remove(delFile)
                        print "remove: " + delFile
                    except:
                        print "cannot remove: " + delFile
        except:
            pass
        
        
        
        
        
        
        
        
        
        
    
    
    

    
    
    
    
    