## +
## ===================================================================
## Copyright(C) 2010 - 2012 Basefount Technology (Hong Kong) Limited.
## and/or its licensors.  All rights reserved.
##
## The coded instructions, statements, computer programs, and/or
## related material (collectively the "Data") in these files contain
## unpublished information proprietary to Basefount Technology
## (Hong Kong) Limitd. ("Basefount") and/or its licensors, which is
## protected by Hong Kong copyright law and by international treaties.
##
## The Data is provided for use exclusively by You. You have the right 
## to use, modify, and incorporate this Data into other products for 
## purposes authorized by the Basefount software license agreement, 
## without fee.
##
## The copyright notices in the Software and this entire statement, 
## including the above license grant, this restriction and the 
## following disclaimer, must be included in all copies of the 
## Software, in whole or in part, and all derivative works of 
## the Software, unless such copies or derivative works are solely 
## in the form of machine-executable object code generated by a 
## source language processor.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
## BASEFOUNT DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR
## IMPLIED WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES
## OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
## PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR 
## TRADE PRACTICE. IN NO EVENT WILL BASEFOUNT AND/OR ITS LICENSORS 
## BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL, 
## DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF BASEFOUNTAIN 
## AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY 
## OR PROBABILITY OF SUCH DAMAGES.
##
## ===================================================================
## -

## +
## ===================================================================
##  Module Name: McdRender.py
##
##  Description:
##    Rendering Scene
##
##  Special Thanks:
##    Edgar Pina from Missing Frame (edgar@missingframevfx.com)
##
## ===================================================================


import maya.cmds as cmds
import maya.mel as mel
from McdGeneral import *
from McdSimpleCmd import *
import Mcd3DelightRMFunction as renderFun
import os
import platform
import commands

def McdForgroundRender():
    ########################################
    # check is enable mesh drive
    # confirm from user
    # open render view
    # update render window for rendering
    # get the rendered image name
    # change the rendered image name
    # finished and report output images dir
    #########################################
    
    useMeshDrive = False
    try:
        globalNode = mel.eval("McdSimpleCommand -execute 2")
        if cmds.getAttr(globalNode + ".enableMeshDrv") == 1:
            useMeshDrive = True
    except:
        pass
    if not useMeshDrive:
        stat = cmds.confirmDialog(t = "Error", m = "Cannot render agents by RenderView without Mesh Drive enable.\n" + \
                                            "Are you continue?", b = ["Yes", "No"])
        if stat == "No":
            return;
    
    commandd = 'RenderViewWindow'
    mel.eval(commandd);
    commandd = 'tearOffPanel "Render View" "renderWindowPanel" true;'
    mel.eval(commandd);
    
    # get start and end frame:
    startFrame = cmds.playbackOptions(q = True, min = True)
    endFrame = cmds.playbackOptions(q = True, max = True)
    try:
        brainNode = cmds.ls(type = "McdBrain")[0]
        solveBegin = cmds.getAttr(brainNode + ".startTime")
    except:
        solveBegin = startFrame
    
    stat = cmds.confirmDialog(t = "Save Confirm", m = "Please Save you scene before render.\n" + \
                                                    "Are you want to render you scene in foreground by RenderView?\n" + \
                                                    "According to Maya Render Settings\n" + \
                                                    "Start Frame: " + str(int(startFrame)) + "\n" \
                                                    "End Frame: " + str(int(endFrame)), \
                                                b = ["Yes", "No"])
    if stat == "No":
        return
    
    imagesDir = cmds.workspace( expandName ="images" )
    if not os.access(imagesDir, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "The following path:\n" + imagesDir + "\nis not writable.")
        return
    
    allFiles = os.listdir(imagesDir)
    miarmyOutputFolderCount = 0
    if allFiles != [] and allFiles != None:
        for i in range(len(allFiles)):
            if allFiles[i].find("MiarmyOutputFolder_") == 0:
                miarmyOutputFolderCount += 1
                
    print miarmyOutputFolderCount
    if miarmyOutputFolderCount < 10:
        outputDir = imagesDir + "/MiarmyOutputFolder_0" + str(miarmyOutputFolderCount)
    else:
        outputDir = imagesDir + "/MiarmyOutputFolder_" + str(miarmyOutputFolderCount)
    
    for i in range(10):
        if os.access(outputDir, os.R_OK):
            outputDir += "_"
        else:
            break
    os.mkdir(outputDir)
    if not os.access(outputDir, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot create following folder:\n" + outputDir)
        return
    
    
    # reference:
    # catch(eval(renderWindowSaveImageCallback ("renderView", $concatFilename, `getAttr defaultRenderGlobals.imageFormat`)));
    # renderWindowSaveImageCallback "renderView" "d:/abc/kkk.iff" "iff"
    
    currentFrame = startFrame
    if solveBegin < startFrame:
        currentFrame = solveBegin
        
    totalFrame = endFrame - currentFrame + 1

    # progress window
    counter = 0
    totalCount = totalFrame
    #cmds.progressWindow( title = "Rendering", progress = 0, \
    #                   min = 0, max = 100, \
    #                   status = "Rendering", isInterruptable = True )

    for i in range(totalFrame):
        # set time:
        cmds.currentTime(currentFrame)
        
        # render image:
        if currentFrame >= startFrame:
            commandd = "RenderIntoNewWindow;"
            mel.eval(commandd)
        
            # figure image name:
            if currentFrame < 10:
                imageName = "image.000" + str(int(currentFrame)) + ".iff"
            elif currentFrame < 100:
                imageName = "image.00"  + str(int(currentFrame)) + ".iff"
            elif currentFrame < 1000:
                imageName = "image.0"   + str(int(currentFrame)) + ".iff"
                
            imagePath = outputDir + "/" + imageName
            
            imageSaveOutCmd = 'renderWindowSaveImageCallback "renderView" "' + imagePath + '" "iff"'
            try:
                mel.eval(imageSaveOutCmd)
            except:
                pass
        
        currentFrame += 1
        
        ## /////////////////////////////////////////////////////
        #if cmds.progressWindow( query = True, isCancelled = True ):
        #    break
        counter += 1
        #amount = float(counter) / float(totalCount) * 100.0
    #    cmds.progressWindow( edit = True, progress = amount)
    #cmds.progressWindow( endProgress=1 )
        
    # report render path:
    cmds.confirmDialog(t = "Complete", m = "Images located:\n" + outputDir)
    
    

def McdRenderBegin(renderMode, archiveMode = 0, batchMode = 0, exp_0_normal_1_ribOnly_2_ppOnly = 0):
    # set McdGlobal archive Mode
    
    renderCamList = McdRenderPreCheck(renderMode, batchMode)
    
    if renderMode == -1:
        # preview:--------------------------------------------------------------
        renderFun.McdTransformTexture()
        McdRenderToFramebufferBegin()
    else:        
        # batch image or Rib: --------------------------------------------------
        if batchMode == 0:
            if exp_0_normal_1_ribOnly_2_ppOnly == 0:
                renderFun.McdTransformTexture()
        
        globalNode = mel.eval("McdSimpleCommand -execute 2")
        
        
        if renderMode == 1:
            if cmds.getAttr(globalNode + ".procPrim"):
                if exp_0_normal_1_ribOnly_2_ppOnly != 1:
                    McdExportProcPrimAssets()
        
        if exp_0_normal_1_ribOnly_2_ppOnly == 2:
            return;
        
        cmds.setAttr(globalNode + ".renderMode", renderMode)
        cmds.setAttr(globalNode + ".archiveMode", archiveMode)
        cmds.setAttr(globalNode + ".framebuf", 0)
        cmds.setAttr(globalNode + ".rmAttrList[5]", 0)
        
        if archiveMode == 1:
            if batchMode == 0:
                stat = cmds.confirmDialog(t = "Question", m = "Do you want to disable culling when exporting archive?", \
                                 b = ["Yes", "No"])
                if stat == "Yes":
                    cmds.setAttr(globalNode + ".rmAttrList[5]", 1)
                
        
        startFrame = cmds.getAttr(globalNode + ".startFrame")
        endFrame = cmds.getAttr(globalNode + ".endFrame")
        isEnableCache = cmds.getAttr(globalNode + ".enableCache")
        if endFrame - startFrame < 0:
            if batchMode == 0:
                cmds.confirmDialog(t = "Error", m = "Please check your render frame.")
            raise Exception("Please check your render frame.")
        
        brainNode = mel.eval("McdSimpleCommand -execute 3")
        solverFrame = cmds.getAttr(brainNode + ".startTime")
        solverFrame -= 1
        if solverFrame > startFrame:
            solverFrame = startFrame
        
        if (solverFrame > endFrame):
            return
        
        # from solverFrame to endFrame:
        totalFrame = int(endFrame - solverFrame + 1);
        
        # progress window
        if batchMode == 0:
            counter = 0
            totalCount = totalFrame
            cmds.progressWindow( title = "Rendering", progress = 0, \
                              min = 0, max = 100, \
                              status = "Rendering", isInterruptable = True )

        for i in range(totalFrame):
            
            if (i > 2):
                if isEnableCache and solverFrame < startFrame:
                    solverFrame +=1
                    continue
                else:
                    cmds.currentTime(int(solverFrame))
            else:
                cmds.currentTime(int(solverFrame))
            
            if solverFrame >= startFrame:
                # deal with batch render, canbe multi cams
                for i in range(len(renderCamList)):
                    # auto fill camera name:
                    cmds.setAttr(globalNode + ".camera", renderCamList[i], type = "string")
                    mel.eval("McdRenderCmd;")
                
            
            solverFrame += 1
            
            if batchMode == 0:
                ## /////////////////////////////////////////////////////
                if cmds.progressWindow( query = True, isCancelled = True ):
                    break
                counter += 1
                amount = float(counter) / float(totalCount) * 100.0
                cmds.progressWindow( edit = True, progress = amount )
                
        if batchMode == 0:
            cmds.progressWindow( endProgress=1 )
    
    # agent return to start pos
    oAgentResume()
        
def McdRenderToFramebufferBegin():
    globalNode = mel.eval("McdSimpleCommand -execute 2")
    cmds.setAttr(globalNode + ".renderMode", 0)
    cmds.setAttr(globalNode + ".archiveMode", 0)
    cmds.setAttr(globalNode + ".framebuf", 1)
    cmds.setAttr(globalNode + ".rmAttrList[5]", 0)
    
    mel.eval("McdRenderCmd;")
    
def McdRenderPreCheck(renderMode, batchMode = 0):
    # check mesh drive
    useMeshDrive = False
    try:
        globalNode = cmds.ls(type = "McdGlobal")[0]
        if cmds.getAttr(globalNode + ".enableMeshDrv") == 1:
            useMeshDrive = True
    except:
        pass
    
    if useMeshDrive:
        cmds.confirmDialog(t = "Error", m = "Cannot render by 3delight with Mesh Drive enable.\n" + \
                                            "Please try to use maya methods.")
        raise
    
    # check shader, if not exist, recompile:
    if batchMode == 0:
        if (renderMode != 1):
            checkShaderOrRecompile()
    
    if batchMode == 0:
        # check uv exist:
        noUVGeo = []
        allGeoTransform = []
        allGeo = cmds.ls(type = "mesh", long = True)
        if allGeo != [] and allGeo != None:
            for i in range(len(allGeo)):
                if cmds.getAttr(allGeo[i] + ".intermediateObject") == 1:
                    continue;
                currentParents = cmds.listRelatives(allGeo[i], p = True, path = True)
                if currentParents != None and currentParents != []:
                    if currentParents[0] not in allGeoTransform:
                        allGeoTransform.append(currentParents[0])
    
        if allGeoTransform != []:
            for i in range(len(allGeoTransform)):
                firstUV = cmds.polyEditUV(allGeoTransform[i] + ".map[0]", q = True)
                if firstUV == None:
                    noUVGeo.append(allGeoTransform[i])
        
        if noUVGeo != []:
            cmds.confirmDialog(t = "Fatal Error", m = "Contain geometry dont have UVs, system select them for you.\n" + \
                                                    "Just click CreateUVs > Planar Mapping can solve this.")
            cmds.select(noUVGeo)
            raise
    
    
    
    renderCamList = []
    
    # check camera:
    allCams = cmds.ls(type = "camera")
    for i in range(len(allCams)):
        if cmds.getAttr(allCams[i] + ".renderable") == 1:
            renderCamList.append(allCams[i])
    
    
    if renderMode != -1:
        if renderCamList == []:
            if batchMode == 0:
                cmds.confirmDialog(t = "Error", m = "No camera is renderable.")
            raise Exception("No camera is renderable.")
        
        # check "|" stange name
        for i in range(len(renderCamList)):
            if renderCamList[i].find('|') >= 0:
                if batchMode == 0:
                    cmds.confirmDialog(t = "Error", m = "Some renderable cams have same names, please modify them\nSystem select one for you.")
                    cmds.select(renderCamList[i])
                raise Exception("Same name of cameras detected.")
            
    
    # check spot light:
    allLights = cmds.ls(type = "spotLight")
    if allLights == [] or allLights == None:
        if batchMode == 0:
            stat = cmds.confirmDialog(t = "Warning", m = "No spot light in scene. Are you continue?", b = ["Yes", "Cancel"])
            if stat != "Yes":
                raise Exception("Break by user")
            
    # check shadow res:
    no2PowerLightList = McdCheckShadowResolution()
    if no2PowerLightList != []:
        stat = cmds.confirmDialog(t = "Warning", m = "Shadow Map resolution should be:" + \
                                "\n2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192" + \
                                "\nOtherwise, renderman may un-stable, are you continue?", b = ["Yes", "Cancel"])
        if stat != "Yes":
            cmds.select(no2PowerLightList)
            cmds.pickWalk(d = "up")
            return
    
    # check is global exist
    globalNode = mel.eval("McdSimpleCommand -execute 2")
    if globalNode == "_NULL_":
        cmds.confirmDialog(t = "Error", m = "Please click the Miarmy > Miarmy Ready for creating McdGlobal node")
        raise Exception("No McdGlobal node.")
        
    
    # check path:
    folderPath = cmds.getAttr(globalNode + ".outputFolder");
    picsPath = cmds.getAttr(globalNode + ".outputPics");
    ribsPath = cmds.getAttr(globalNode + ".outputRibs");
    
    if folderPath == "" or folderPath == None:
        
        # relative path, set default:
        dScene = cmds.file(q = True, sceneName = True)
        if dScene == "" or dScene == None:
            dScene = "untitled"
        else:
            dScene = dScene.split("/")[-1]
            dScene = os.path.splitext(dScene)[0]
            
        if picsPath == "" or picsPath == None:
            picsPath = dScene
        if ribsPath == "" or ribsPath == None:
            ribsPath = dScene
            
        imagesDir = cmds.workspace( expandName ="images" ) + "/"
        folderPath = imagesDir
        
        cmds.setAttr(globalNode + ".outputFolder", folderPath, type = "string");
        cmds.setAttr(globalNode + ".outputPics", picsPath, type = "string");
        cmds.setAttr(globalNode + ".outputRibs", ribsPath, type = "string");
        
    # check access:
    access = os.access(folderPath, os.R_OK)
    if access == False:
        stat = cmds.confirmDialog(t = "Note", m = "Output folder not exist, would you like to create it?", b = ["Yes", "Cancel"])
        if stat == "Yes":
            try:
                if folderPath.find(":") < 0:
                    cmds.confirmDialog(t = "Error", m = "Cannot create relative directory.")
                    raise Exception("Cannot create relative directory.")
                os.makedirs(folderPath)
            except:
                cmds.confirmDialog(t = "Error", m = "Cannot create:\n" + folderPath + "\nRe set your render output settings.")
                raise Exception("Output folder error.")
            
    else:
        writable = os.access(folderPath, os.W_OK)
        if writable == False:
            cmds.confirmDialog(n = "Error", m = folderPath + "\nAbove path is not writable for your machine.")
            raise Exception("Write data, denied.")
            
    # make extra path for each camera:
    for i in range(len(renderCamList)):
        access = os.access(folderPath + "/rib/" + renderCamList[i], os.R_OK)
        if not access:
            os.makedirs(folderPath + "/rib/" + renderCamList[i])
            
        access = os.access(folderPath + "/beauty/" + renderCamList[i], os.R_OK)
        if not access:
            os.makedirs(folderPath + "/beauty/" + renderCamList[i])
            
        access = os.access(folderPath + "/shadow/" + renderCamList[i], os.R_OK)
        if not access:
            os.makedirs(folderPath + "/shadow/" + renderCamList[i])
            
        access = os.access(folderPath + "/shadowMap/" + renderCamList[i], os.R_OK)
        if not access:
            os.makedirs(folderPath + "/shadowMap/" + renderCamList[i])
            
        access = os.access(folderPath + "/occlusion/" + renderCamList[i], os.R_OK)
        if not access:
            os.makedirs(folderPath + "/occlusion/" + renderCamList[i])
            
        access = os.access(folderPath + "/light/" + renderCamList[i], os.R_OK)
        if not access:
            os.makedirs(folderPath + "/light/" + renderCamList[i])
            
        access = os.access(folderPath + "/rtshadow/" + renderCamList[i], os.R_OK)
        if not access:
            os.makedirs(folderPath + "/rtshadow/" + renderCamList[i])    
            
        access = os.access(folderPath + "/depth/" + renderCamList[i], os.R_OK)
        if not access:
            os.makedirs(folderPath + "/depth/" + renderCamList[i])
        
        access = os.access(folderPath + "/color/" + renderCamList[i], os.R_OK)
        if not access:
            os.makedirs(folderPath + "/color/" + renderCamList[i])
            
        access = os.access(folderPath + "/normal/" + renderCamList[i], os.R_OK)
        if not access:
            os.makedirs(folderPath + "/normal/" + renderCamList[i])
        
    if batchMode == 0:
        if CheckStringIsValid(picsPath) == False:
            cmds.confirmDialog(t = "Error", m = picsPath + "\nPicture name is invalid.")
            raise Exception("Output picture name is invalid")
            
        if CheckStringIsValid(ribsPath) == False:
            cmds.confirmDialog(t = "Error", m = ribsPath + "\nRIB file name is invalid.")
            raise Exception("Output RIB file name is invalid")
        
        
    # return renderCamList
    return renderCamList


def McdCheckShadowResolution():
    no2PowerLightList = []
    
    not2Power = False

    allLights = cmds.ls(type = "spotLight")
    if allLights != [] and allLights != None:
        for i in range(len(allLights)):
            useShadMap = cmds.getAttr(allLights[i] + ".useDepthMapShadows")
            if useShadMap == 1:
                mapRes = cmds.getAttr(allLights[i] + ".dmapResolution")
                if not McdCheck2Power(mapRes):
                    not2Power = True
                    no2PowerLightList.append(allLights[i])
        

    allLights = cmds.ls(type = "directionalLight")
    if allLights != [] and allLights != None:
        for i in range(len(allLights)):
            useShadMap = cmds.getAttr(allLights[i] + ".useDepthMapShadows")
            if useShadMap == 1:
                mapRes = cmds.getAttr(allLights[i] + ".dmapResolution")
                if not McdCheck2Power(mapRes):
                    not2Power = True
                    no2PowerLightList.append(allLights[i])


    allLights = cmds.ls(type = "pointLight")
    if allLights != [] and allLights != None:
        for i in range(len(allLights)):
            useShadMap = cmds.getAttr(allLights[i] + ".useDepthMapShadows")
            if useShadMap == 1:
                mapRes = cmds.getAttr(allLights[i] + ".dmapResolution")
                if not McdCheck2Power(mapRes):
                    not2Power = True
                    no2PowerLightList.append(allLights[i])


    allLights = cmds.ls(type = "volumeLight")
    if allLights != [] and allLights != None:
        for i in range(len(allLights)):
            useShadMap = cmds.getAttr(allLights[i] + ".useDepthMapShadows")
            if useShadMap == 1:
                mapRes = cmds.getAttr(allLights[i] + ".dmapResolution")
                if not McdCheck2Power(mapRes):
                    not2Power = True
                    no2PowerLightList.append(allLights[i])


    allLights = cmds.ls(type = "areaLight")
    if allLights != [] and allLights != None:
        for i in range(len(allLights)):
            useShadMap = cmds.getAttr(allLights[i] + ".useDepthMapShadows")
            if useShadMap == 1:
                mapRes = cmds.getAttr(allLights[i] + ".dmapResolution")
                if not McdCheck2Power(mapRes):
                    not2Power = True
                    no2PowerLightList.append(allLights[i])
                    
    return no2PowerLightList
    
def McdCheck2Power(inValue):
    # 16 32 64 128 256 512 1024 2048 4096 8192
    if inValue == 16 or inValue == 32 or \
                inValue == 64 or \
                inValue == 128 or \
                inValue == 256 or \
                inValue == 512 or \
                inValue == 1024 or \
                inValue == 2048 or \
                inValue == 4096 or \
                inValue == 8192:
        return True
    
    return False
    
def checkShaderOrRecompile():
    # ###################################
    # find DL_SHADERS_PATH
    # check shaders existance
    # if exist return
    # find shader source
    # test writable
    # try to compile
    # check is success
    # ###################################
    
    # find shaderpath:
    dlshaderpath = os.getenv("DL_SHADERS_PATH")
    if dlshaderpath == None or dlshaderpath == "":
        cmds.confirmDialog(t = "Error", m = "Cannot find shader path of 3delight, please install 3delight 10.")
        raise
    
    dlshaderpath = dlshaderpath.split(".:")[-1]
    dlshaderpath = dlshaderpath.replace("\\", "/")
    sysName = platform.system()
    if sysName == "Windows":
        shaderPathList = dlshaderpath.split(";")
    else:
        shaderPathList = dlshaderpath.split(":")
        
    gotShader = False
    gotShaderPath = ""
    for i in range(len(shaderPathList)):
        if os.access(shaderPathList[i], os.R_OK):
            allShaders = os.listdir(shaderPathList[i])
            if allShaders != []:
                if ("McdBumpy.sdl" in allShaders) and \
                    ("McdDOF.sdl" in allShaders) and \
                    ("McdGatherAO.sdl" in allShaders) and\
                    ("McdSpotlightInv.sdl" in allShaders) and\
                    ("McdTxtPlastic.sdl" in allShaders) and\
                    ("McdConstant.sdl" in allShaders):
                    gotShader = True
                    break
                else:
                    gotShaderPath = shaderPathList[i]
                    #break we want the last place defined in DL_SHADERS_PATH or we won't check every path
            else:
                gotShaderPath = shaderPathList[i]
                #break we want the last place defined in DL_SHADERS_PATH or we won't check every path
                
    if gotShader:
        return
    
    stat = cmds.confirmDialog(t = "Question", m = "We didn't find Miarmy shader in your shader path, compile them now ??", b = ["Yes", "No"])
    if stat != "Yes":
        return
    
    if not os.access(gotShaderPath, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Can't write on:\n" + gotShaderPath)
        return
        
    # find shader source code:
    melCmd = "getenv MAYA_MODULE_PATH;"
    modulePaths = mel.eval(melCmd)
    if modulePaths.find(';') > 0:
        modulePathList = modulePaths.split(';')
    else:
        modulePathList = modulePaths.split(':')
    if modulePathList == [] or modulePathList == None:
        cmds.confirmDialog(t = "Error", m = "Cannot find your maya module path")
        return
        
    gotIt = False
    MiarmyModulePath = ""
    for i in range(len(modulePathList)):
        if os.access(modulePathList[i], os.R_OK):
            allFiles = os.listdir(modulePathList[i])
            if allFiles != [] and allFiles != None:
                for j in range(len(allFiles)):
                    if allFiles[j] == "MiarmyForMaya.txt":
                        MiarmyModulePath = modulePathList[i] + "/MiarmyForMaya.txt"
                        gotIt = True
                        break
                    if allFiles[j] == "MiarmyForMaya.module":
                        MiarmyModulePath = modulePathList[i] + "/MiarmyForMaya.module"
                        gotIt = True
                        break
        if gotIt == True:
            break
    
    if not os.access(MiarmyModulePath, os.R_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot find MiarmyForMaya file")
        return

    f = open(MiarmyModulePath)
    contents = f.read()
    f.close()
    
    if contents.find("+ Miarmy Any ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy Any ")[-1]
    elif contents.find("+ Miarmy 1.5 ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy 1.5 ")[-1]
    elif contents.find("+ Miarmy 2.0 ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy 2.5 ")[-1]
    elif contents.find("+ Miarmy 2.5 ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy Any ")[-1]
    elif contents.find("+ Miarmy 3.0 ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy 3.0 ")[-1]
    elif contents.find("+ Miarmy 3.5 ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy 3.5 ")[-1]
    elif contents.find("+ Miarmy 4.0 ") == 0:
        MiarmyInstallPlace = contents.split("+ Miarmy 4.0 ")[-1]
    else:
        cmds.confirmDialog(t = "Error", m = "Contents in MiarmyForMaya file is incorrect, please check installation manual.")
        return
        
    MiarmyInstallPlace = MiarmyInstallPlace.replace("\\", "/")
    MiarmyInstallPlace = MiarmyInstallPlace.replace("\r", "")
    MiarmyInstallPlace = MiarmyInstallPlace.replace("\n", "")
    
    if not os.access(MiarmyInstallPlace, os.R_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot find Miarmy install place in MiarmyForMaya.txt")
        return
    
    MiarmyInstallRawList = MiarmyInstallPlace.split("/")
    if MiarmyInstallRawList == [] or MiarmyInstallRawList == None:
        cmds.confirmDialog(t = "Error", m = "Miarmy installation place error")
        return
        
    MiarmyInstallPath = ""
    for i in range(len(MiarmyInstallRawList)):
        if MiarmyInstallRawList[i] == "maya":
            break
        MiarmyInstallPath += MiarmyInstallRawList[i] + "/"
        
    MiarmyShaderPath = MiarmyInstallPath + "shaders/src"
    
    if not os.access(MiarmyShaderPath, os.R_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot solve out shader code path")
        return
        
    allShaderSource = os.listdir(MiarmyShaderPath)
    if allShaderSource == [] or allShaderSource == None:
        cmds.confirmDialog(t = "Error", m = "Cannot find shader source code.")
        return
    
    
    delightPath = os.getenv("DELIGHT")
    if delightPath == "" or delightPath == None:
        cmds.confirmDialog(t = "Error", m = "Cannot find DELIGHT path.")
        return
    
    if platform.system() == "Darwin":
        # try to compile:
        commandStr = delightPath + '/bin/shaderdl -d "'
        disPath = gotShaderPath + '" "'
        
        for i in range(len(allShaderSource)):
            if allShaderSource[i].endswith('.sl'):
                shader = MiarmyShaderPath + '/' + allShaderSource[i] + '"'
                sysCmdRaw = commandStr + disPath + shader
                sysCmd = sysCmdRaw.replace("\\", "/")
                print sysCmd
                os.popen(sysCmd)
        
    else:
        # try to compile:
        commandStr = 'shaderdl -d "'
        disPath = gotShaderPath + '" "'
        
        for i in range(len(allShaderSource)):
            if allShaderSource[i].endswith('.sl'):
                shader = MiarmyShaderPath + '/' + allShaderSource[i] + '"'
                sysCmdRaw = commandStr + disPath + shader
                sysCmd = sysCmdRaw.replace("\\", "/")
                os.popen(sysCmd).read()

    # check success:
    success = True
    for i in range(len(allShaderSource)):
        if allShaderSource[i].endswith('.sl'):
            shaderCompiled = allShaderSource[i].replace(".sl", ".sdl")
            compiled_shader = gotShaderPath + "/" + shaderCompiled
            compiled_shader = compiled_shader.replace("\r", "")
            compiled_shader = compiled_shader.replace("\n", "")
            MPrint(compiled_shader)
            if not os.access(compiled_shader, os.R_OK):
                success = False
                break
    
    if not success:
        cmds.confirmDialog(t = "Error", m = "Cannot done compile, unknown error.")
    else:
        cmds.confirmDialog(t = "Complete", m = "Compilation Successful.")
    
def McdExportProcPrimAssets():
    
    globalNode = McdListMcdGlobal()
        
    exportFolder = cmds.getAttr(globalNode + ".outputFolder")
    if exportFolder == None:
        cmds.confirmDialog(t = "IO Error", m = "Please specify right path in Miarmy Render Global")
    
    exportFolder += "/ProcPrimAssets"
    
    if not os.access(exportFolder, os.W_OK):
        try:
            os.mkdir(exportFolder)
        except:
            cmds.confirmDialog(t = "IO Error", m = exportFolder + " not writable, please specify right path in Miarmy Render Global ")
            return
    
    # get how many folders needed
    allAgentGrpNodes = cmds.ls(type = "McdAgentGroup")
    print allAgentGrpNodes;
    
    # create sub folders
    if allAgentGrpNodes == [] or allAgentGrpNodes == None:
        cmds.confirmDialog(t = "Abort", m = "Nothing to export.")
        return
        
    for i in range(len(allAgentGrpNodes)):
        if not os.access(exportFolder + "/McdAgentType" + str(i), os.W_OK):
            os.mkdir(exportFolder + "/McdAgentType" + str(i))
        if not os.access(exportFolder + "/McdAgentType" + str(i) + "/McdGeoFiles", os.W_OK):    
            os.mkdir(exportFolder + "/McdAgentType" + str(i) + "/McdGeoFiles")


    mel.eval("McdRMPPExportCmd;")
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

