## +
## ===================================================================
## Copyright(C) 2010 - 2012 Basefount Technology (Hong Kong) Limited.
## and/or its licensors.  All rights reserved.
##
## The coded instructions, statements, computer programs, and/or
## related material (collectively the "Data") in these files contain
## unpublished information proprietary to Basefount Technology
## (Hong Kong) Limitd. ("Basefount") and/or its licensors, which is
## protected by Hong Kong copyright law and by international treaties.
##
## The Data is provided for use exclusively by You. You have the right 
## to use, modify, and incorporate this Data into other products for 
## purposes authorized by the Basefount software license agreement, 
## without fee.
##
## The copyright notices in the Software and this entire statement, 
## including the above license grant, this restriction and the 
## following disclaimer, must be included in all copies of the 
## Software, in whole or in part, and all derivative works of 
## the Software, unless such copies or derivative works are solely 
## in the form of machine-executable object code generated by a 
## source language processor.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
## BASEFOUNT DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR
## IMPLIED WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES
## OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
## PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR 
## TRADE PRACTICE. IN NO EVENT WILL BASEFOUNT AND/OR ITS LICENSORS 
## BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL, 
## DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF BASEFOUNTAIN 
## AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY 
## OR PROBABILITY OF SUCH DAMAGES.
##
## ===================================================================
## -

## +
## ===================================================================
##  Module Name: McdRenderVRFunctions.py
##
##  Description:
##    eal with V-Ray Renderer stuffs
##
## ===================================================================
## -

import os
import shutil
import maya.cmds as cmds
import maya.mel as mel
from McdGeneral import *
    
def McdVRSetupCurrentFrame():
    # clear exist contents;
    # read export path name from MGlobal
    # read export file name from MGlobal
    # check availablity
    # create extra path
    # execute
    # clear time link
    # parenting
    allAgents = cmds.ls(type = "McdAgent")
    if allAgents == [] or allAgents == None:
        cmds.confirmDialog(t = "Error", m = 'Please Place your agents firstly.')
        return
    
    allRenderGlobals = cmds.ls(type = "renderGlobals")
    if allRenderGlobals == None or allRenderGlobals == []:
        return;
    
    try:
        globalNode = mel.eval("McdSimpleCommand -exe 2;")
        if globalNode == "_NULL_":
            raise
    except:
        cmds.confirmDialog(t = "Error", m = "Cannot find Miarmy Global Node, please create it in Miarmy > Miarmy Ready")
        return;
    
    # read export path name from MGlobal
    outputPath = cmds.getAttr(globalNode + ".outputVRFolder")
    # read export file name from MGlobal
    outputName = cmds.getAttr(globalNode + ".outputVRName")
    
    # check availablity
    if outputPath == None:
        cmds.confirmDialog(t = "Error", m = "Cannot write vrmesh file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    if not os.access(outputPath, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write vrmesh file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    
    # create extra path
    try:
        os.makedirs(outputPath + "/" + outputName)
    except:
        pass
    
    if not os.access(outputPath + "/" + outputName, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write vrmesh file to disk, specify right path in: \nMiarmy > Render Global > Other Renders ab")
        return;       
 
    
    # clear exist contents:
    askClear = False
    nodes1 = cmds.ls("VRProxyAgent*", type = "VRayMesh")
    nodes2 = cmds.ls("VRProxyAgent*", type = "VRayMeshMaterial")
    nodes3 = cmds.ls("VRProxyAgent*", type = "transform")
    
    if nodes1 != [] and nodes1 != None:
        askClear = True
        
    if nodes3 != [] and nodes3 != None:
        askClear = True
        
    if nodes2 != [] and nodes2 != None:
        askClear = True
        
    stat = ""
    if askClear:
        stat = cmds.confirmDialog(t = "Question", m = "Do you want to delete exist proxy and create new ones?", b = ["Yes", "No", "Cancel"])
        if stat == "Yes":
            McdVRClearVRNodes()
            # execute
            # example: McdRenderExportCmd -r 1 -idx 1 -filePath "d:/abc/abc" -fileName "testing"
            melCmd = 'McdRenderExportCmd -r 1 -idx 1 -filePath "' + outputPath + '" -fileName "' + outputName + '"'
            mel.eval(melCmd)
        elif stat == "No":
            # example: McdRenderExportCmd -r 1 -idx 0 -filePath "d:/abc/abc" -fileName "testing"
            melCmd = 'McdRenderExportCmd -r 1 -idx 0 -filePath "' + outputPath + '" -fileName "' + outputName + '"'
            mel.eval(melCmd)
            
    else:
        # execute
        # example: McdRenderExportCmd -r 1 -idx 1 -filePath "d:/abc/abc" -fileName "testing"
        melCmd = 'McdRenderExportCmd -r 1 -idx 1 -filePath "' + outputPath + '" -fileName "' + outputName + '"'
        mel.eval(melCmd)

    McdVROptimize()

def McdVRSetupAllFrame():
    # clear exist contents;
    # read export path name from MGlobal
    # read export file name from MGlobal
    # check availablity
    # create extra path
    # execute
    # clear time link
    # parenting
    allAgents = cmds.ls(type = "McdAgent")
    if allAgents == [] or allAgents == None:
        cmds.confirmDialog(t = "Error", m = 'Please Place your agents firstly.')
        return
    
    allRenderGlobals = cmds.ls(type = "renderGlobals")
    if allRenderGlobals == None or allRenderGlobals == []:
        return;
    
    try:
        globalNode = mel.eval("McdSimpleCommand -exe 2;")
        if globalNode == "_NULL_":
            raise
    except:
        cmds.confirmDialog(t = "Error", m = "Cannot find Miarmy Global Node, please create it in Miarmy > Miarmy Ready")
        return;
    
    # read export path name from MGlobal
    outputPath = cmds.getAttr(globalNode + ".outputVRFolder")
    # read export file name from MGlobal
    outputName = cmds.getAttr(globalNode + ".outputVRName")
    
    # check availablity
    if outputPath == None:
        cmds.confirmDialog(t = "Error", m = "Cannot write vrmesh file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    if not os.access(outputPath, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write vrmesh file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;
    
    # create extra path
    try:
        os.makedirs(outputPath + "/" + outputName)
    except:
        pass
    
    if not os.access(outputPath + "/" + outputName, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "Cannot write vrmesh file to disk, specify right path in: \nMiarmy > Render Global > Other Renders Tab")
        return;       
 
    minFrame = cmds.playbackOptions(q = True, min = True)
    maxFrame = cmds.playbackOptions(q = True, max = True)
    nbFrame = int(maxFrame - minFrame + 1)
    
    stat = cmds.confirmDialog(t = "Note", m = "Export .vrmesh file from " + str(minFrame) + " to " + str(maxFrame) + "\n" + \
                                     "We recommend you save your sence before exporting, continue?", b = ["Proceed", "Cancel"])
    
    if stat == "Cancel":
        return;

    # always clear:
    McdVRClearVRNodes()

    # execute
    # example: McdRenderExportCmd -r 11 -filePath "d:/abc/abc" -fileName "testing"
    melCmd = 'McdRenderExportCmd -r 11 -filePath "' + outputPath + '" -fileName "' + outputName + '"'
    mel.eval(melCmd)
    
    McdVROptimize()
    
def McdVRClearVRNodes():
    # VRayMesh
    # VRayMeshMaterial
    # transform    
    
    haveSomeErrors = False;
    
    # VRayMesh
    nodes = cmds.ls("VRProxyAgent*", type = "VRayMesh")
    if nodes != [] and nodes != None:
        for i in range(len(nodes)):
            try:
                cmds.delete(nodes[i])
            except:
                haveSomeErrors = True
    
    # VRayMeshMaterial
    nodes = cmds.ls("VRProxyAgent*", type = "VRayMeshMaterial")
    if nodes != [] and nodes != None:
        for i in range(len(nodes)):
            try:
                cmds.delete(nodes[i])
            except:
                haveSomeErrors = True
                
    # transform
    nodes = cmds.ls("VRProxyAgent*", type = "transform")
    if nodes != [] and nodes != None:
        for i in range(len(nodes)):
            try:
                cmds.delete(nodes[i])
            except:
                haveSomeErrors = True
                
    # shadingEngine:
    nodes = cmds.ls("VRProxyAgent*", type = "shadingEngine")
    if nodes != [] and nodes != None:
        for i in range(len(nodes)):
            try:
                cmds.delete(nodes[i])
            except:
                haveSomeErrors = True
                
    if haveSomeErrors:
        cmds.confirmDialog(t = "Warning", m = "Some nodes cannot be deleted.")
        
    
        
def McdVRClearVRMesh():
    # read export path name from MGlobal
    # read export file name from MGlobal
    # check availablity
    # create extra path
    # execute
    # create box and naming it to McdMRRenderDummy
    # link this to MR contents
    
    try:
        globalNode = mel.eval("McdSimpleCommand -exe 2;")
        if globalNode == "_NULL_":
            raise
    except:
        cmds.confirmDialog(t = "Error", m = "Cannot find Miarmy Global Node, please create it in Miarmy > Miarmy Ready")
        return;
    
    # read export path name from MGlobal
    outputPath = cmds.getAttr(globalNode + ".outputMIFolder")
    # read export file name from MGlobal
    outputName = cmds.getAttr(globalNode + ".outputMIName")
    
    stat = cmds.confirmDialog(t = "Question", m = "Are you sure remove all contents at:\n" + \
                                            outputPath + "/" + outputName, b = ["Sure", "No"])
    if stat == "No":
        return
    
    try:
        shutil.rmtree(outputPath + "/" + outputName)
    except:
        pass
    
    
def McdVROptimize():    
    # delete useless time conversion
    # 1. delete connections
    # 2. establish new connections
    # 3. delete conversion nodes;
    
    # find all mesh and parent to first one
    # 1. find all vrmesh nodes
    # 2. parent all shapes to first transform
    # 3. delete the rest of them
    
    # delete useless time conversion
    # 1. delete connections
    firstConvertPlug = ""
    vrmeshes = cmds.ls("VRProxyAgent*", type = "VRayMesh")
    if vrmeshes != [] and vrmeshes != None:
        unitCnvt = cmds.listConnections(vrmeshes[0], s = True, d = False, p = True)
        if unitCnvt != [] and unitCnvt != None:
            firstConvertPlug = unitCnvt[0]
            if cmds.nodeType(firstConvertPlug) == "timeToUnitConversion":
            
                for i in range(len(vrmeshes)):
                    cnvt = cmds.listConnections(vrmeshes[i], s = True, d = False, p = True)
                    if cnvt != [] and cnvt != None:
                        if cnvt[0] != firstConvertPlug:
                            try:
                                cmds.disconnectAttr(cnvt[0], vrmeshes[i] + ".currentFrame")
                            except:
                                pass
                            # 2. establish new connections
                            try:
                                cmds.connectAttr(firstConvertPlug, vrmeshes[i] + ".currentFrame")
                            except:
                                pass
                            # 3. delete conversion nodes;
                            try:
                                cmds.delete(cnvt[0].split(".")[0])
                            except:
                                pass
    
    # find all mesh and parent to first one
    # 1. find all vrmesh nodes
    vrmeshes = cmds.ls("VRProxyAgent*", type = "mesh")
    if vrmeshes != [] and vrmeshes != None:
        firstTransform = cmds.listRelatives(vrmeshes[0], p = True)[0]
        # 2. parent all shapes to first transform
        for i in range(len(vrmeshes)):
            currentTrans = cmds.listRelatives(vrmeshes[i], p = True)[0]
            if currentTrans != firstTransform:
                try:
                    cmds.parent(vrmeshes[i], firstTransform, r = True, s = True)
                    # 3. delete the rest of them
                    cmds.delete(currentTrans)
                except:
                    pass
                
    
def McdVRReplaceShader():
    selObj = cmds.ls(sl = True)
    if selObj == [] or selObj == None:
        cmds.confirmDialog(t = "Error", m = "Please select a shader firstly.")
        return;
    
    allConns = cmds.listConnections(selObj[0], s = False, d = True, p = True)
    if allConns == [] or allConns == None:
        cmds.confirmDialog(t = "Error", m = "Please select a shader firstly.")
        return;
    
    shaderNode = ""
    for i in range(len(allConns)):
        if allConns[i].find("surfaceShader") > 0:
            shaderNode = selObj[0]
            break;
            
    if shaderNode == "":
        cmds.confirmDialog(t = "Error", m = "Please select a shader firstly.")
        return;
    
    vrmtls = cmds.ls("VRProxyAgent*", type = "VRayMeshMaterial")
    if vrmtls != None and vrmtls != []:
        for i in range(len(vrmtls)):
            allConns = cmds.listConnections(vrmtls[i], s = True, d = False, p = True)
            if allConns != [] and allConns != None:
                nbShaders = 0;
                for j in range(len(allConns)):
                    if allConns[j].find("outColor") > 0:
                        nbShaders += 1
                if nbShaders > 0:
                    for j in range(nbShaders):
                        try:
                            cmds.connectAttr(shaderNode + ".outColor", vrmtls[i] + ".shaders[" + str(j) + "]", f = True)
                        except:
                            pass
    

def VRRandomTexture():
    # find all agent geo
    # find all shaders
    # for each shader:
    #     test is this can be randmize
    #     if can: find all obj relative with this shader
    #         duplicate shaders node based on number
    
    # find all agent geo -------------------------------------------------------
    allGeoGrp = cmds.ls("*Geometry_*")
    allGeoGrpRef = cmds.ls("*:Geometry_*")
    allGeoGrp.extend(allGeoGrpRef)
    if McdIsBlank(allGeoGrp):
        return
    allGeoGrpList = []
    for i in range(len(allGeoGrp)):
        geoGrpParent = cmds.listRelatives(allGeoGrp[i], p = True, c = False)
        if McdIsBlank(geoGrpParent):
            continue
        if cmds.nodeType(geoGrpParent[0]) == "McdAgentGroup":
            allGeoGrpList.append(allGeoGrp[i])
    
    allGeos = []
    for i in range(len(allGeoGrpList)):
        allSubNodes = cmds.listRelatives(allGeoGrpList[i], c = True, p = False, ad = True, path = True)
        if McdIsBlank(allSubNodes):
            continue
        for j in range(len(allSubNodes)):
            if cmds.nodeType(allSubNodes[j]) == "mesh":
                if not cmds.getAttr(allSubNodes[j] + ".intermediateObject"):
                    allGeos.append(allSubNodes[j])
    if allGeos == []:
        return
    
    # find all shaders ---------------------------------------------------------
    allShdGrp = []
    for i in range(len(allGeos)):
        allConns = cmds.listConnections(allGeos[i], d = True, s = False)
        if McdIsBlank(allConns):
            continue
        for j in range(len(allConns)):
            if cmds.nodeType(allConns[j]) == "shadingEngine":
                if allConns[j] not in allShdGrp:
                    allShdGrp.append(allConns[j])
    if allShdGrp == []:
        return
        
    allShaders = []
    for i in range(len(allShdGrp)):
        allConns = cmds.listConnections(allShdGrp[i], s = True, d = False, p = True)
        if McdIsBlank(allConns):
            continue
        for j in range(len(allConns)):
            if allConns[j].find(".outColor") > 0:
                shaderName = allConns[j].split(".outColor")[0]
                if shaderName not in allShaders:
                    allShaders.append(shaderName)                
    if allShaders == []:
        return

    # for each shaders: --------------------------------------------------------
    for i in range(len(allShaders)):
        # test is this can be randmize
        # find outColor node, "file" node --------------------------------------
        currentShader = allShaders[i]
        allConns = cmds.listConnections(currentShader, d = False, s = True, p = True)
        if McdIsBlank(allConns):
            continue
        allFileRaw = []
        for j in range(len(allConns)):
            if allConns[j].find(".outColor") > 0:
                allFileRaw.append(allConns[j].split(".outColor")[0])
        if allFileRaw == []:
            continue
        
        fileNodeColor = "" # file node connect agaist with color attribute
        for j in range(len(allFileRaw)):
            allConns2 = cmds.listConnections(allFileRaw[j], d = True, s = False, p = True)
            for k in range(len(allConns2)):
                if allConns2[k].find(".color") > 0:
                    fileNodeColor = allFileRaw[j]
                    break
            if fileNodeColor != "":
                break;
        if fileNodeColor == "":
            continue

        # --- we have:
        # 1. fileNodeColor
        # 2. currentShader
        # find file path, and test randomizable? -------------------------------
        texMaster = cmds.getAttr(fileNodeColor + ".fileTextureName")
        if texMaster == None:
            print "# # Error: texture path not set."
            continue
        if not os.access(texMaster, os.R_OK):
            print "# # Error: texture path not correct."
            continue
        #                                                               # d:/abc/bbb/kkk_ggg_0.jpg
        dirName = os.path.dirname(texMaster)                            # d:/abc/bbb
        baseName = os.path.basename(texMaster)                          # kkk_ggg_0.jpg
            
        baseNameExt = baseName.split(".")[-1]                           # jpg
        baseNamePre = baseName.split("." + baseNameExt)[0]              # kkk_ggg_0
        lastUS = baseNamePre.rfind("_")
        if lastUS <= 0:
            continue
        baseNamePrePre = baseNamePre[0 : lastUS]                        # kkk_ggg
        baseNamePreIdStr = baseNamePre[lastUS+1 : len(baseNamePre)]     # 0
        
        if not baseNamePreIdStr.isdigit():
            continue
        
        baseNamePreId = int(baseNamePreIdStr)
        baseNamePreIdStr = str(baseNamePreId)
        
        newPath = dirName + "/" + baseNamePrePre + "_" + baseNamePreIdStr + "." + baseNameExt
        if not os.access(newPath, os.R_OK):
            continue
        
        allPaths = []
        while(True):
            baseNamePreId +=1
            baseNamePreIdStr = str(baseNamePreId)
            newPath = dirName + "/" + baseNamePrePre + "_" + baseNamePreIdStr + "." + baseNameExt
            
            if not os.access(newPath, os.R_OK):
                break
        
            allPaths.append(newPath)
            
        if allPaths == []:
            continue
        
        # duplicate shaders:
        allNewShaders = []
        for n in range(len(allPaths)):
            newShader = cmds.duplicate(currentShader, un = True)[0] #input connection
            
            # from new shader find file connect to color:
            
            allConnsNew = cmds.listConnections(newShader, d = False, s = True, p = True)
            if McdIsBlank(allConnsNew):
                continue
            allFileRawNew = []
            for j in range(len(allConnsNew)):
                if allConnsNew[j].find(".outColor") > 0:
                    allFileRawNew.append(allConnsNew[j].split(".outColor")[0])
            if allFileRawNew == []:
                continue
            
            fileNodeColorNew = "" # file node connect agaist with color attribute
            for j in range(len(allFileRawNew)):
                allConns2New = cmds.listConnections(allFileRawNew[j], d = True, s = False, p = True)
                for k in range(len(allConns2New)):
                    if allConns2New[k].find(".color") > 0:
                        fileNodeColorNew = allFileRawNew[j]
                        break
                if fileNodeColorNew != "":
                    break;
            if fileNodeColorNew == "":
                continue
            
            cmds.setAttr(fileNodeColorNew + ".fileTextureName", allPaths[n], type = "string")
            allNewShaders.append(newShader)
        
        
        # if can:
        # find all obj relative with this shader
        selPlugs = cmds.listConnections(currentShader, s = False, d = True, p = True, type = "VRayMeshMaterial")
        if McdIsBlank(selPlugs):
            continue
        
        exePlugs = []
        selObjs = []
        for i in range(len(selPlugs)):
            selObjs.append(selPlugs[i].split(".")[0])
            exePlugs.append(selPlugs[i])

        if McdIsBlank(selObjs):
            continue
        
        exeObjs = []
        for j in range(len(selObjs)):
            if not McdIsAgentGeo(selObjs[j]):
                exeObjs.append(selObjs[j])
                
        if exeObjs == []:
            continue
        
        for j in range(len(exeObjs)):
            # select random shader
            min = 0
            max = len(allNewShaders) + 1
            
            seed = int((float(i) + 0.797) * 1.71 + (float(j) + 0.877) * 1.77)
            randNum = int(McdSolveASeedMinMax(seed, 11.457, min, max))
            
            if randNum >= max - 1:
                continue
            
            cmds.connectAttr(allNewShaders[randNum] + ".outColor", exePlugs[j], force = True)

    
    
    
    

    
    
    
    
    


