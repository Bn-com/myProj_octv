## Copyright(C) 2010 - 2012 Basefount Technology (Hong Kong) Limited.
## and/or its licensors.  All rights reserved.
##
## The coded instructions, statements, computer programs, and/or
## related material (collectively the "Data") in these files contain
## unpublished information proprietary to Basefount Technology
## (Hong Kong) Limitd. ("Basefount") and/or its licensors, which is
## protected by Hong Kong copyright law and by international treaties.
##
## The Data is provided for use exclusively by You. You have the right 
## to use, modify, and incorporate this Data into other products for 
## purposes authorized by the Basefount software license agreement, 
## without fee.
##
## The copyright notices in the Software and this entire statement, 
## including the above license grant, this restriction and the 
## following disclaimer, must be included in all copies of the 
## Software, in whole or in part, and all derivative works of 
## the Software, unless such copies or derivative works are solely 
## in the form of machine-executable object code generated by a 
## source language processor.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
## BASEFOUNT DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR
## IMPLIED WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES
## OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
## PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR 
## TRADE PRACTICE. IN NO EVENT WILL BASEFOUNT AND/OR ITS LICENSORS 
## BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL, 
## DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF BASEFOUNT 
## AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY 
## OR PROBABILITY OF SUCH DAMAGES.
##
## ===================================================================
## -

## +
## ===================================================================
##  Module Name: McdActionEditorGUI
##
##  Description:
##    For editing McdAction node
##
## ===================================================================
## -

import maya.cmds as cmds
from McdGeneral import *
from McdActionEditorGUI import *


def setupOmState(value, chan):
    cmds.menuItem(label = "block")
    cmds.menuItem(label = "speed")
    if value == 0:
        cmds.optionMenu(chan + "Stat_om", e = True, v = "block")
    else:
        cmds.optionMenu(chan + "Stat_om", e = True, v = "speed")


def actExitSetupPreview(index, startFrame, endFrame, length):
    stri = str(index)

    if startFrame > endFrame:
        startFrame = endFrame

    startPos = int(float(startFrame) / float(length) * 120.0)
    if startPos < 1:
        startPos = 1
    endPos = int(float(endFrame) / float(length) * 120.0)
    if endPos <1:
        endPos = 1
    if endPos >117:
        endPos = 117
    middlePos = endPos - startPos
    if middlePos <1:
        middlePos = 1
    enPos = 118 - endPos;
        
    cmds.columnLayout("actPreviewBar_rl" + stri)
    cmds.rowColumnLayout("actPreviewBarChild_rcl" + stri, nc = 3, cw = [(1, startPos),(2, middlePos),(3, enPos)])
    cmds.text(l = "", bgc = [.5, .7, .9])
    cmds.text(l = "exit", align = "center", bgc = [ 1,  1,  1])
    cmds.text(l = "", bgc = [.5, .7, .9])
    cmds.setParent("..")
    cmds.setParent("..")
    
def actExitUpdatePreview(index):
    stri = str(index)
    startFrame = cmds.floatField("actSF_ff" + stri, q = True, v = True)
    endFrame = cmds.floatField("actEF_ff" + stri, q = True, v = True)
    length = cmds.intField("actLength_if", q = True, v = True)
    
    if startFrame > endFrame:
        startFrame = endFrame

    startPos = int(float(startFrame) / float(length) * 120.0)
    if startPos < 1:
        startPos = 1
    endPos = int(float(endFrame) / float(length) * 120.0)
    if endPos <1:
        endPos = 1
    if endPos >117:
        endPos = 117
    middlePos = endPos - startPos
    if middlePos <1:
        middlePos = 1
    enPos = 118 - endPos;
    
    cmds.deleteUI("actPreviewBarChild_rcl" + stri)
    
    cmds.rowColumnLayout("actPreviewBarChild_rcl" + stri, p = "actPreviewBar_rl" + stri,\
                        nc = 3, cw = [(1, startPos),(2, middlePos),(3, enPos)])
    cmds.text(l = "", bgc = [.5, .7, .9])
    cmds.text(l = "exit",align = "center", bgc = [ 1,  1,  1])
    cmds.text(l = "", bgc = [.5, .7, .9])
    cmds.setParent("..")
    
    
def setSingleNumericAttr(option, control, nodeName, attrName):
    #option: bool, int, float
    if option == 0:
        qValue = cmds.checkBox(control, q= True, v = True)
        cmds.setAttr(nodeName + "." + attrName, qValue)
        if control == "actenpb_cb":
            cmds.select(nodeName)
    elif option == 1:
        qValue = cmds.intField(control, q= True, v = True)
        
        if attrName == "entryMax":
            lenth = cmds.getAttr(nodeName + ".length")
            if qValue > (50):
                stat = cmds.confirmDialog(t = "Warning", m = "This value should not be too big, better less than: " \
                                        + "50%", b = ["Set anyway", "Cancel"])
                if stat == "Cancel":
                    cmds.intField(control, e= True, v = 0)
                    cmds.setAttr(nodeName + "." + attrName, 0)
                else:
                    setValue = int(float(qValue) * 0.01 * lenth)
                    cmds.setAttr(nodeName + "." + attrName, setValue)
            else:
                setValue = int(float(qValue) * 0.01 * lenth)
                cmds.setAttr(nodeName + "." + attrName, setValue)
        elif attrName == "entryMin":
            lenth = cmds.getAttr(nodeName + ".length")
            setValue = int(float(qValue) * 0.01 * lenth)
            cmds.setAttr(nodeName + "." + attrName, setValue)
        else:
            cmds.setAttr(nodeName + "." + attrName, qValue)
            
    elif option == 2:
        qValue = cmds.floatField(control, q= True, v = True)
        cmds.setAttr(nodeName + "." + attrName, qValue)
    elif option == 3:
        qValue = cmds.textField(control, q = True, tx = True)
        cmds.setAttr(nodeName + "." + attrName, qValue, type = "string")



def setIndexNumericAttr(option, index, control, nodeName, attrName):
    stri = str(index)
    if option == 0:
        qValue = cmds.checkBox(control + stri, q= True, v = True)
        cmds.setAttr(nodeName + "." + attrName + "[" + stri + "]", qValue)
    elif option == 1:
        qValue = cmds.intField(control + stri, q= True, v = True)
        cmds.setAttr(nodeName + "." + attrName + "[" + stri + "]", qValue)
    elif option == 2:
        qValue = cmds.floatField(control + stri, q= True, v = True)
        cmds.setAttr(nodeName + "." + attrName + "[" + stri + "]", qValue)
        
    if attrName == "exitStartFrame" or attrName == "exitEndFrame":
        actExitUpdatePreview(index)
        
def setIKLockAttr(index, control, nodeName, attrName):
    ikid = cmds.getAttr(nodeName + ".ikid")
    strid = str(ikid)
    stri = str(index)
    
    qValue = cmds.floatField(control + stri, q= True, v = True)
    
    if attrName == "IKLockIns1Root":
        cmds.setAttr(nodeName + "." + attrName + "[" + strid + "].IKLockIns1[" + stri + "]", qValue)
    if attrName == "IKLockIns2Root":
        cmds.setAttr(nodeName + "." + attrName + "[" + strid + "].IKLockIns2[" + stri + "]", qValue)
        
    if attrName == "IKLockOuts1Root":
        cmds.setAttr(nodeName + "." + attrName + "[" + strid + "].IKLockOuts1[" + stri + "]", qValue)
    if attrName == "IKLockOuts2Root":
        cmds.setAttr(nodeName + "." + attrName + "[" + strid + "].IKLockOuts2[" + stri + "]", qValue)
        
    actIKLockUpdatePreview(index)

def setPercentNumericAttr(option, control, nodeName, attrName, dLength):
    
    #option: bool, int, float
    if option == 1:
        qValue = cmds.intField(control, q= True, v = True)
        if qValue >100:
            qValue = 100
        if qValue <0:
            qValue = 0
        qValueF = float(qValue) / 100.0
        cmds.setAttr(nodeName + "." + attrName, qValueF)
    elif option == 2:
        qValue = cmds.floatField(control, q= True, v = True)
        if control == "actCyF_ff":
            if qValue > 33:
                qValue = 33
                cmds.floatField(control, e= True, v = 33)
        
        if qValue >100:
            qValue = 100
        if qValue <0:
            qValue = 0
        qValue /= 100.0
        
        if control == "actCyF_ff":
            cmds.text("cycleFrame", e = True, l = str(int(dLength * qValue)))
            
        elif control == "actEyR_ff":
            cmds.text("inFrame", e = True, l = str(int(dLength * qValue)))
            
        else:
            cmds.text("outFrame", e = True, l = str(int(dLength - dLength * qValue)))
        
        cmds.setAttr(nodeName + "." + attrName, qValue)

def setPercentNumericAttrCommon(option, control, nodeName, attrName):
    #option: bool, int, float
    if option == 1:
        qValue = cmds.intField(control, q= True, v = True)
        if qValue >100:
            qValue = 100
        if qValue <0:
            qValue = 0
        qValueF = float(qValue) / 100.0
        cmds.setAttr(nodeName + "." + attrName, qValueF)
    elif option == 2:
        qValue = cmds.floatField(control, q= True, v = True)
        if qValue >100:
            qValue = 100
        if qValue <0:
            qValue = 0
        qValue /= 100.0
        cmds.setAttr(nodeName + "." + attrName, qValue)


def om_act_chnState(channelName, control, nodeName, attrName):
    qValue = cmds.optionMenu(channelName + "Stat_om", q = True, v = True)
    setValue = 0
    if qValue == "speed":
        setValue = 1
    cmds.setAttr(nodeName + "." + attrName, setValue)
    
def autoFillAgentData(actNode):
    stat = cmds.confirmDialog(t = "Agent Speed Type:", m = "Which type of agent speed you will apply?", \
                                                        b = ["Static", "Locomotion(Z+)", "Locomotion", "Climb", "Turning", "Ramp", "Cancel"])
    
    if stat == "Static":
        cmds.setAttr(actNode + ".txState", 0)
        cmds.setAttr(actNode + ".tyState", 0)
        cmds.setAttr(actNode + ".tzState", 0)
        cmds.setAttr(actNode + ".rxState", 0)
        cmds.setAttr(actNode + ".ryState", 0)
        cmds.setAttr(actNode + ".rzState", 0)
        cmds.optionMenu("TxStat_om", e = True, v = "block")
        cmds.optionMenu("TyStat_om", e = True, v = "block")
        cmds.optionMenu("TzStat_om", e = True, v = "block")
        cmds.optionMenu("RxStat_om", e = True, v = "block")
        cmds.optionMenu("RyStat_om", e = True, v = "block")
        cmds.optionMenu("RzStat_om", e = True, v = "block")
        
    elif stat == "Locomotion(Z+)":
        cmds.setAttr(actNode + ".txState", 0)
        cmds.setAttr(actNode + ".tyState", 0)
        cmds.setAttr(actNode + ".tzState", 1) # tz
        cmds.setAttr(actNode + ".rxState", 0)
        cmds.setAttr(actNode + ".ryState", 0)
        cmds.setAttr(actNode + ".rzState", 0)
        cmds.optionMenu("TxStat_om", e = True, v = "speed")
        cmds.optionMenu("TyStat_om", e = True, v = "block")
        cmds.optionMenu("TzStat_om", e = True, v = "speed")
        cmds.optionMenu("RxStat_om", e = True, v = "block")
        cmds.optionMenu("RyStat_om", e = True, v = "block")
        cmds.optionMenu("RzStat_om", e = True, v = "block")
        
    elif stat == "Locomotion":
        cmds.setAttr(actNode + ".txState", 1) # tx
        cmds.setAttr(actNode + ".tyState", 0)
        cmds.setAttr(actNode + ".tzState", 1) # tz
        cmds.setAttr(actNode + ".rxState", 0)
        cmds.setAttr(actNode + ".ryState", 0)
        cmds.setAttr(actNode + ".rzState", 0)
        cmds.optionMenu("TxStat_om", e = True, v = "speed")
        cmds.optionMenu("TyStat_om", e = True, v = "block")
        cmds.optionMenu("TzStat_om", e = True, v = "speed")
        cmds.optionMenu("RxStat_om", e = True, v = "block")
        cmds.optionMenu("RyStat_om", e = True, v = "block")
        cmds.optionMenu("RzStat_om", e = True, v = "block")
        
    elif stat == "Climb":
        cmds.setAttr(actNode + ".txState", 0)
        cmds.setAttr(actNode + ".tyState", 1) # ty
        cmds.setAttr(actNode + ".tzState", 1) # tz
        cmds.setAttr(actNode + ".rxState", 0)
        cmds.setAttr(actNode + ".ryState", 0)
        cmds.setAttr(actNode + ".rzState", 0)
        cmds.optionMenu("TxStat_om", e = True, v = "block")
        cmds.optionMenu("TyStat_om", e = True, v = "speed")
        cmds.optionMenu("TzStat_om", e = True, v = "speed")
        cmds.optionMenu("RxStat_om", e = True, v = "block")
        cmds.optionMenu("RyStat_om", e = True, v = "block")
        cmds.optionMenu("RzStat_om", e = True, v = "block")
        
    elif stat == "Turning":
        cmds.setAttr(actNode + ".txState", 1) # tx
        cmds.setAttr(actNode + ".tyState", 0)
        cmds.setAttr(actNode + ".tzState", 1) # tz
        cmds.setAttr(actNode + ".rxState", 0)
        cmds.setAttr(actNode + ".ryState", 1) # ry
        cmds.setAttr(actNode + ".rzState", 0)
        cmds.optionMenu("TxStat_om", e = True, v = "speed")
        cmds.optionMenu("TyStat_om", e = True, v = "block")
        cmds.optionMenu("TzStat_om", e = True, v = "speed")
        cmds.optionMenu("RxStat_om", e = True, v = "block")
        cmds.optionMenu("RyStat_om", e = True, v = "speed")
        cmds.optionMenu("RzStat_om", e = True, v = "block")
        
    elif stat == "Ramp":
        cmds.setAttr(actNode + ".txState", 1) # tx
        cmds.setAttr(actNode + ".tyState", 1) # tx
        cmds.setAttr(actNode + ".tzState", 1) # tz
        cmds.setAttr(actNode + ".rxState", 1) # ry
        cmds.setAttr(actNode + ".ryState", 0)
        cmds.setAttr(actNode + ".rzState", 0)
        cmds.optionMenu("TxStat_om", e = True, v = "speed")
        cmds.optionMenu("TyStat_om", e = True, v = "speed")
        cmds.optionMenu("TzStat_om", e = True, v = "speed")
        cmds.optionMenu("RxStat_om", e = True, v = "speed")
        cmds.optionMenu("RyStat_om", e = True, v = "block")
        cmds.optionMenu("RzStat_om", e = True, v = "block")
    
    if stat != "Cancel":
        cmds.confirmDialog(t = "Rebuild Needed", m = "rebuild it, in order to make it work, click \"rebuild\"")
    


def rebuildAgentData():
    stat = cmds.confirmDialog(t = "Question", m = "Would you like to re-build agent transform data according to the agent data channel?" +
                                                "\nThe previous data will be cleared and cannot be undone.",
                            b = ["Yes", "Cancel"])
    if stat == "Yes":
        mel.eval("McdSetAgentDataCmd;")
        

def rotateAgentData():
    trnX = cmds.floatField("actRotADTX", q = True, v = True)
    trnY = cmds.floatField("actRotADTY", q = True, v = True)
    trnZ = cmds.floatField("actRotADTZ", q = True, v = True)
    rotX = cmds.floatField("actRotADRX", q = True, v = True)
    rotY = cmds.floatField("actRotADRY", q = True, v = True)
    rotZ = cmds.floatField("actRotADRZ", q = True, v = True)
    stat = cmds.confirmDialog(t = "Question", m = "Would you like to fix agent transform data according to following scheme:" +
                                                "\n\n     Translate: X: " + str(trnX) + "  Y: " + str(trnY) + "  Z: " + str(trnZ) + 
                                                  "\n     Rotate: X: "    + str(rotX) + "  Y: " + str(rotY) + "  Z: " + str(rotZ) + 
                                                "\n\nThe previous data will be cleared and cannot be undone.",
                            b = ["Yes", "Cancel"])
    if stat == "Yes":
        rotX_Rad = rotX * 0.017453
        rotY_Rad = rotY * 0.017453
        rotZ_Rad = rotZ * 0.017453
        mel.eval("McdFixAgentDataCmd -snx " + str(rotX_Rad) + " -sny " + str(rotY_Rad) + " -snz " + str(rotZ_Rad) + \
                                  " -mvx " + str(trnX) + " -mvy " + str(trnY) + " -mvz " + str(trnZ) + ";")
        mel.eval("McdSetAgentDataCmd;")


def setExitAction(index, nodeName):
    stri = str(index)
    exitName = cmds.textField("actExit" + stri, q = True, tx = True)
    exitNamePrune = exitName.split(" ")[0]
    cmds.setAttr(nodeName + ".exitChoices[" + stri + "]", exitNamePrune, type = "string")


def initIKSlot(actNode, i):
    stri = str(i)
    dIKActive = cmds.getAttr(actNode + ".ikActive[" + stri + "]")
    dIKName = cmds.getAttr(actNode + ".ikName[" + stri + "]")
    dIKLevel = cmds.getAttr(actNode + ".ikLevel[" + stri + "]")
    stri60 = str(i*6  )
    stri61 = str(i*6+1)
    stri62 = str(i*6+2)
    dIKCurve1 = cmds.getAttr(actNode + ".ikDataRoot[2].ikData[" + stri60 + "]")
    dIKCurve2 = cmds.getAttr(actNode + ".ikDataRoot[2].ikData[" + stri61 + "]")
    dIKCurve3 = cmds.getAttr(actNode + ".ikDataRoot[2].ikData[" + stri62 + "]")
    
    # ik slot:
    cmds.text(l = stri)
    cmds.floatField("ik_act" + stri, v = dIKActive, \
                cc = 'setSingleNumericAttr(2, "ik_act' + stri + '", "'+actNode+'", "ikActive[' + stri + ']")')
    cmds.textField("ik_name" + stri, tx = dIKName, \
                cc = 'setSingleNumericAttr(3, "ik_name' + stri + '", "'+actNode+'", "ikName[' + stri + ']")')
    cmds.intField("ik_level" + stri, v = dIKLevel, \
                cc = 'setSingleNumericAttr(1, "ik_level' + stri + '", "'+actNode+'", "ikLevel[' + stri + ']")')
    
    if dIKCurve1 == 0 and dIKCurve2 == 0 and dIKCurve3 == 0:
        cmds.text("ikd" + stri, l = "n/a")
        cmds.text("ird" + stri, l = "n/a")
    else:
        cmds.text("ikd" + stri, l = "available")
        cmds.text("ird" + stri, l = "available")
        
    cmds.button(l = "Create", c = 'createIKData("' + actNode + '", ' + stri + ')')
    cmds.button(l = "Focus", c = "changeIKFocus(\"" + actNode + "\", " + stri + ")")
    

def changeIKFocus(actNode, i):
    cmds.setAttr(actNode + ".ikid", i)
    cmds.text("ikFocus", e = True, l = "IK Lock: " + str(i))
    strid = str(i)
    
    # change the ik lock data:
    for k in range(4):
        stri = str(k)
        i_1 = cmds.getAttr(actNode + ".IKLockIns1Root[" +strid+ "].IKLockIns1[" +stri+ "]")
        i_2 = cmds.getAttr(actNode + ".IKLockIns2Root[" +strid+ "].IKLockIns2[" +stri+ "]")
        o_1 = cmds.getAttr(actNode + ".IKLockOuts1Root[" +strid+ "].IKLockOuts1[" +stri+ "]")
        o_2 = cmds.getAttr(actNode + ".IKLockOuts2Root[" +strid+ "].IKLockOuts2[" +stri+ "]")
        
        # update data
        cmds.floatField("ik_li1" + stri, e = True, v = i_1)
        cmds.floatField("ik_li2" + stri, e = True, v = i_2)
        cmds.floatField("ik_lo1" + stri, e = True, v = o_1)
        cmds.floatField("ik_lo2" + stri, e = True, v = o_2)
        
        # update preview:
        actIKLockUpdatePreview(k)
        
    


def createIKData(actNode, i):
    selObjs = cmds.ls(sl = True, long = True)
    if selObjs == None or selObjs == []:
        try:
            cmds.select(actNode)
        except:
            cmds.confirmDialog(t = "Error", m = "Please select the action node firstly")
    
    # mark ikid:
    changeIKFocus(actNode, i)

    melCmd = "McdSetIKDataCmd -om 0;"
    if mel.eval(melCmd):
        cmds.text("ikd" + str(i), e = True, l = "available")
        cmds.text("ird" + str(i), e = True, l = "available")
    else:
        cmds.confirmDialog(t = "Create Failure", m = "Maybe you need fill the right name of IK handle")


def initIKLockSlot(actNode, i, dLength):
    stri = str(i)
    dIKID = cmds.getAttr(actNode + ".ikid")
    strid = str(dIKID)
    
    dIKLockIn1 = cmds.getAttr(actNode + ".IKLockIns1Root[" + strid + "].IKLockIns1[" + stri + "]")
    dIKLockIn2 = cmds.getAttr(actNode + ".IKLockIns2Root[" + strid + "].IKLockIns2[" + stri + "]")
    dIKLockOut1 = cmds.getAttr(actNode + ".IKLockOuts1Root[" + strid + "].IKLockOuts1[" + stri + "]")
    dIKLockOut2 = cmds.getAttr(actNode + ".IKLockOuts2Root[" + strid + "].IKLockOuts2[" + stri + "]")
    
    if (i == 0):
        cmds.button(l = "Autofill", c = "fromIKDataAutofillLockData(\"" + actNode + "\")")
    else:
        cmds.text(l = "")
    
    # ik slot:
    cmds.floatField("ik_li1" + stri, v = dIKLockIn1, max = dLength, \
                cc = 'setIKLockAttr(' + stri + ', "ik_li1", "'+actNode+'", "IKLockIns1Root")')
    cmds.floatField("ik_li2" + stri, v = dIKLockIn2, max = dLength, \
                cc = 'setIKLockAttr(' + stri + ', "ik_li2", "'+actNode+'", "IKLockIns2Root")')
    cmds.floatField("ik_lo1" + stri, v = dIKLockOut1, max = dLength, \
                cc = 'setIKLockAttr(' + stri + ', "ik_lo1", "'+actNode+'", "IKLockOuts1Root")')
    cmds.floatField("ik_lo2" + stri, v = dIKLockOut2, max = dLength, \
                cc = 'setIKLockAttr(' + stri + ', "ik_lo2", "'+actNode+'", "IKLockOuts2Root")')
    
    cmds.text(l = "0")
    actIKLockSetupPreview(stri, dIKLockIn1, dIKLockIn2, dIKLockOut1, dIKLockOut2)
    cmds.text(l = str(dLength))
        
    cmds.button(l = "Left", c = "moveCurrentIKData(\"" +actNode+ "\", " +stri+ ", " +strid+ ", -1)")
    cmds.button(l = "Right", c = "moveCurrentIKData(\"" +actNode+ "\", " +stri+ ", " +strid+ ", 1)")
    cmds.button(l = "Shorten", c = "prelongIKData(\"" +actNode+ "\", " +stri+ ", " +strid+ ", -1)")
    cmds.button(l = "Prelong", c = "prelongIKData(\"" +actNode+ "\", " +stri+ ", " +strid+ ", 1)")
    cmds.button(l = "clear", c = "prelongIKData(\"" +actNode+ "\", " +stri+ ", " +strid+ ", 0)")
    

def actIKLockSetupPreview(stri, i_1, i_2, o_1, o_2):
    length = cmds.intField("actLength_if", q = True, v = True)
    fLength = float(length)
    
    if i_1 > i_2:
        i_2 = i_1
        
    if i_2 > o_1:
        o_1 = i_2
        
    if o_1 > o_2:
        o_2 = o_1
        
    pos1 = int(i_1 / fLength * 200.0)
    pos2 = int((i_2 - i_1) / fLength * 200.0)
    pos3 = int((o_1 - i_2) / fLength * 200.0)
    pos4 = int((o_2 - o_1) / fLength * 200.0)
    
    if pos1 <= 0:
        pos1 = 1
    if pos2 <= 0:
        pos2 = 1
    if pos3 <= 0:
        pos3 = 1
    if pos4 <= 0:
        pos4 = 1
        
    pos5 = 200 - pos4

    cmds.columnLayout("actPreviewBar_ikl" + stri)
    cmds.rowColumnLayout("actPreviewBarChild_iklc" + stri, p = "actPreviewBar_ikl" + stri,\
                        nc = 5, cw = [(1, pos1),(2, pos2),(3, pos3),(4, pos4),(5, pos5)])
    cmds.text(l = "", bgc = [.5, .7, .9])
    cmds.text(l = "in", bgc = [.8, .8, .3])
    cmds.text(l = "lock",align = "center", bgc = [ .8,  0.2,  0.2])
    cmds.text(l = "out", bgc = [.8, .8, .3])
    cmds.text(l = "", bgc = [.5, .7, .9])
    cmds.setParent("..")
    cmds.setParent("..")

def actIKLockUpdatePreview(index):
    
    stri = str(index)
    
    i_1 = cmds.floatField("ik_li1" + stri, q = True, v = True)
    i_2 = cmds.floatField("ik_li2" + stri, q = True, v = True)
    o_1 = cmds.floatField("ik_lo1" + stri, q = True, v = True)
    o_2 = cmds.floatField("ik_lo2" + stri, q = True, v = True)
    
    length = cmds.intField("actLength_if", q = True, v = True)
    fLength = float(length)
    
    if i_1 > i_2:
        i_2 = i_1
        
    if i_2 > o_1:
        o_1 = i_2
        
    if o_1 > o_2:
        o_2 = o_1
        
    pos1 = int(i_1 / fLength * 200.0)
    pos2 = int((i_2 - i_1) / fLength * 200.0)
    pos3 = int((o_1 - i_2) / fLength * 200.0)
    pos4 = int((o_2 - o_1) / fLength * 200.0)
    
    if pos1 <= 0:
        pos1 = 1
    if pos2 <= 0:
        pos2 = 1
    if pos3 <= 0:
        pos3 = 1
    if pos4 <= 0:
        pos4 = 1
        
    pos5 = 200 - pos4
    
    cmds.deleteUI("actPreviewBarChild_iklc" + stri)
    
    cmds.rowColumnLayout("actPreviewBarChild_iklc" + stri, p = "actPreviewBar_ikl" + stri,\
                        nc = 5, cw = [(1, pos1),(2, pos2),(3, pos3),(4, pos4),(5, pos5)])
    cmds.text(l = "", bgc = [.5, .7, .9])
    cmds.text(l = "in", bgc = [.8, .8, .3])
    cmds.text(l = "lock",align = "center", bgc = [ .8,  0.2,  0.2])
    cmds.text(l = "out", bgc = [.8, .8, .3])
    cmds.text(l = "", bgc = [.5, .7, .9])
    cmds.setParent("..")

def moveCurrentIKData(actNode, index, ikid, moveVal):
    ikid2 = cmds.getAttr(actNode + ".ikid")
    strid = str(ikid2)
    stri = str(index)
    
    i_1 = cmds.floatField("ik_li1" + stri, q = True, v = True)
    i_2 = cmds.floatField("ik_li2" + stri, q = True, v = True)
    o_1 = cmds.floatField("ik_lo1" + stri, q = True, v = True)
    o_2 = cmds.floatField("ik_lo2" + stri, q = True, v = True)
    
    length = cmds.intField("actLength_if", q = True, v = True)
    fLength = float(length)
    
    i_1 += moveVal
    i_2 += moveVal
    o_1 += moveVal
    o_2 += moveVal
    
    cmds.floatField("ik_li1" + stri, e = True, v = i_1)
    cmds.floatField("ik_li2" + stri, e = True, v = i_2)
    cmds.floatField("ik_lo1" + stri, e = True, v = o_1)
    cmds.floatField("ik_lo2" + stri, e = True, v = o_2)
    
    if i_1 > i_2:
        i_2 = i_1
        
    if i_2 > o_1:
        o_1 = i_2
        
    if o_1 > o_2:
        o_2 = o_1
        
    pos1 = int(i_1 / fLength * 200.0)
    pos2 = int((i_2 - i_1) / fLength * 200.0)
    pos3 = int((o_1 - i_2) / fLength * 200.0)
    pos4 = int((o_2 - o_1) / fLength * 200.0)
    
    if pos1 <= 0:
        pos1 = 1
    if pos2 <= 0:
        pos2 = 1
    if pos3 <= 0:
        pos3 = 1
    if pos4 <= 0:
        pos4 = 1
        
    pos5 = 200 - pos4
    
    cmds.deleteUI("actPreviewBarChild_iklc" + stri)
    
    cmds.rowColumnLayout("actPreviewBarChild_iklc" + stri, p = "actPreviewBar_ikl" + stri,\
                        nc = 5, cw = [(1, pos1),(2, pos2),(3, pos3),(4, pos4),(5, pos5)])
    cmds.text(l = "", bgc = [.5, .7, .9])
    cmds.text(l = "in", bgc = [.8, .8, .3])
    cmds.text(l = "lock",align = "center", bgc = [ .8,  0.2,  0.2])
    cmds.text(l = "out", bgc = [.8, .8, .3])
    cmds.text(l = "", bgc = [.5, .7, .9])
    cmds.setParent("..")
    
    i_1 = cmds.floatField("ik_li1" + stri, q = True, v = True)
    i_2 = cmds.floatField("ik_li2" + stri, q = True, v = True)
    o_1 = cmds.floatField("ik_lo1" + stri, q = True, v = True)
    o_2 = cmds.floatField("ik_lo2" + stri, q = True, v = True)
    
    cmds.setAttr(actNode + ".IKLockIns1Root[" +strid+ "].IKLockIns1[" +stri+ "]", i_1)
    cmds.setAttr(actNode + ".IKLockIns2Root[" +strid+ "].IKLockIns2[" +stri+ "]", i_2)
    cmds.setAttr(actNode + ".IKLockOuts1Root[" +strid+ "].IKLockOuts1[" +stri+ "]", o_1)
    cmds.setAttr(actNode + ".IKLockOuts2Root[" +strid+ "].IKLockOuts2[" +stri+ "]", o_2)
    
    
def prelongIKData(actNode, index, ikid, moveVal):

    ikid2 = cmds.getAttr(actNode + ".ikid")
    strid = str(ikid2)
    stri = str(index)
    
    if moveVal != 0:
        i_1 = cmds.floatField("ik_li1" + stri, q = True, v = True)
        i_2 = cmds.floatField("ik_li2" + stri, q = True, v = True)
        o_1 = cmds.floatField("ik_lo1" + stri, q = True, v = True)
        o_2 = cmds.floatField("ik_lo2" + stri, q = True, v = True)
    else:
        i_1 = 0
        i_2 = 0
        o_1 = 0
        o_2 = 0
    
    length = cmds.intField("actLength_if", q = True, v = True)
    fLength = float(length)
    
    #i_1 += moveVal
    # i_2 += moveVal
    o_1 += moveVal
    o_2 += moveVal
    
    cmds.floatField("ik_li1" + stri, e = True, v = i_1)
    cmds.floatField("ik_li2" + stri, e = True, v = i_2)
    cmds.floatField("ik_lo1" + stri, e = True, v = o_1)
    cmds.floatField("ik_lo2" + stri, e = True, v = o_2)
    
    if i_1 > i_2:
        i_2 = i_1
        
    if i_2 > o_1:
        o_1 = i_2
        
    if o_1 > o_2:
        o_2 = o_1
        
    pos1 = int(i_1 / fLength * 200.0)
    pos2 = int((i_2 - i_1) / fLength * 200.0)
    pos3 = int((o_1 - i_2) / fLength * 200.0)
    pos4 = int((o_2 - o_1) / fLength * 200.0)
    
    if pos1 <= 0:
        pos1 = 1
    if pos2 <= 0:
        pos2 = 1
    if pos3 <= 0:
        pos3 = 1
    if pos4 <= 0:
        pos4 = 1
        
    pos5 = 200 - pos4
    
    cmds.deleteUI("actPreviewBarChild_iklc" + stri)
    
    cmds.rowColumnLayout("actPreviewBarChild_iklc" + stri, p = "actPreviewBar_ikl" + stri,\
                        nc = 5, cw = [(1, pos1),(2, pos2),(3, pos3),(4, pos4),(5, pos5)])
    cmds.text(l = "", bgc = [.5, .7, .9])
    cmds.text(l = "in", bgc = [.8, .8, .3])
    cmds.text(l = "lock",align = "center", bgc = [ .8,  0.2,  0.2])
    cmds.text(l = "out", bgc = [.8, .8, .3])
    cmds.text(l = "", bgc = [.5, .7, .9])
    cmds.setParent("..")
    
    i_1 = cmds.floatField("ik_li1" + stri, q = True, v = True)
    i_2 = cmds.floatField("ik_li2" + stri, q = True, v = True)
    o_1 = cmds.floatField("ik_lo1" + stri, q = True, v = True)
    o_2 = cmds.floatField("ik_lo2" + stri, q = True, v = True)
    
    cmds.setAttr(actNode + ".IKLockIns1Root[" +strid+ "].IKLockIns1[" +stri+ "]", i_1)
    cmds.setAttr(actNode + ".IKLockIns2Root[" +strid+ "].IKLockIns2[" +stri+ "]", i_2)
    cmds.setAttr(actNode + ".IKLockOuts1Root[" +strid+ "].IKLockOuts1[" +stri+ "]", o_1)
    cmds.setAttr(actNode + ".IKLockOuts2Root[" +strid+ "].IKLockOuts2[" +stri+ "]", o_2)
    

def fromIKDataAutofillLockData(actionNode):
    # speed
    hRatio = 10.0
    stat = cmds.promptDialog(t = "Height Ratio Threshold", m = "When the joint height less \"X\"% than maxinum height, lock down ik\nPlease specify that \"X\"", \
                    button = ["OK", "Default 10%", "Cancel"], \
                    defaultButton = "OK", cancelButton = "Cancel", dismissString = "Cancel")
    if stat == "OK":
        try:
            hRatio = float(cmds.promptDialog(query = True, text = True))
        except:
            hRatio = 10.0
    if stat == "Cancel":
        return;
    
    ikid = cmds.getAttr(actionNode + ".ikid")
    strikid = str(ikid * 6 + 1)
    nbFrame = cmds.getAttr(actionNode + ".length")
    # format: aaa_action.ikDataRoot[ikid].ikData[frame]
    hRatio /= 100.0
    
    heightListTemp = []
    for i in range(nbFrame):
        stri = str(i)
        a = cmds.getAttr(actionNode + ".ikDataRoot[" + stri + "].ikData[ " + strikid + " ]")
        heightListTemp.append(a)
        
    hMax = -100000
    hMin = 100000
    for i in range(nbFrame):
        if heightListTemp[i] > hMax:
            hMax = heightListTemp[i]
        if heightListTemp[i] < hMin:
            hMin = heightListTemp[i]
    
    threshold = ((hMax - hMin) * hRatio) + hMin
    
    # extend to 3 time length!
    heightList = []
    for j in range(3):
        for i in range(len(heightListTemp)):
            heightList.append(heightListTemp[i])
            
    print heightList
    
    startPoints = []
    endPoints = []
    addMode = False
    passCount = 0
    for i in range(len(heightList)-2):
        if passCount > 0:
            passCount -= 1
            continue
        
        if heightList[i] < threshold:
            next1 = heightList[i + 1]
            next2 = heightList[i + 2]
            if next1 < threshold and next2 < threshold:
                addMode = True
                startPoints.append(i)
            
        if addMode:
            accumulater = 3
            while(1):
                if i + accumulater > nbFrame * 3 - 1:
                    break;
                
                if heightList[i + accumulater] < threshold:
                    accumulater += 1
                else:
                    break
            endPoints.append(i + accumulater)
            passCount = accumulater - 1
            addMode = False
        
    min = nbFrame
    max = 2 * nbFrame - 1
        
    sSets = []
    eSets = []
    smoothSets = []
        
    for i in range(len(endPoints)):
        sframe = startPoints[i]
        eframe = endPoints[i]
        
        if sframe < min and eframe < min:
            continue
        if sframe > max and eframe > max:
            continue
        if sframe >= min and eframe <= max:
            # in range
            sSets.append(sframe)
            eSets.append(eframe)
            smoothSets.append((eframe - sframe) / 2 + 1)
            continue
        if sframe < min and eframe > min:
            sSets.append(nbFrame)
            eSets.append(eframe)
            smoothSets.append((eframe - sframe) / 2 + 1)
            # from end to 
            continue
        if sframe < max and eframe > max:
            sSets.append(sframe)
            eSets.append(2 * nbFrame - 1)
            smoothSets.append(0)
            continue
    
    for i in range(len(sSets)):
        sSets[i] -= nbFrame
        eSets[i] -= nbFrame
        
        #print sSets[i]
        #print eSets[i]
        #print smoothSets[i]
    
        # fill value ---------------------------------------------------------------
        strid = str(ikid)
        stri = str(i)
        
        length = cmds.intField("actLength_if", q = True, v = True)
        fLength = float(length)
        
        i_1 = sSets[i]
        i_2 = sSets[i]
        o_1 = eSets[i]
        o_2 = eSets[i] + smoothSets[i]
        
        cmds.floatField("ik_li1" + stri, e = True, v = i_1)
        cmds.floatField("ik_li2" + stri, e = True, v = i_2)
        cmds.floatField("ik_lo1" + stri, e = True, v = o_1)
        cmds.floatField("ik_lo2" + stri, e = True, v = o_2)
        
        if i_1 > i_2:
            i_2 = i_1
            
        if i_2 > o_1:
            o_1 = i_2
            
        if o_1 > o_2:
            o_2 = o_1
            
        pos1 = int(i_1 / fLength * 200.0)
        pos2 = int((i_2 - i_1) / fLength * 200.0)
        pos3 = int((o_1 - i_2) / fLength * 200.0)
        pos4 = int((o_2 - o_1) / fLength * 200.0)
        
        if pos1 <= 0:
            pos1 = 1
        if pos2 <= 0:
            pos2 = 1
        if pos3 <= 0:
            pos3 = 1
        if pos4 <= 0:
            pos4 = 1
            
        pos5 = 200 - pos4
        
        cmds.deleteUI("actPreviewBarChild_iklc" + stri)
        
        cmds.rowColumnLayout("actPreviewBarChild_iklc" + stri, p = "actPreviewBar_ikl" + stri,\
                            nc = 5, cw = [(1, pos1),(2, pos2),(3, pos3),(4, pos4),(5, pos5)])
        cmds.text(l = "", bgc = [.5, .7, .9])
        cmds.text(l = "in", bgc = [.8, .8, .3])
        cmds.text(l = "lock",align = "center", bgc = [ .8,  0.2,  0.2])
        cmds.text(l = "out", bgc = [.8, .8, .3])
        cmds.text(l = "", bgc = [.5, .7, .9])
        cmds.setParent("..")
        
        i_1 = cmds.floatField("ik_li1" + stri, q = True, v = True)
        i_2 = cmds.floatField("ik_li2" + stri, q = True, v = True)
        o_1 = cmds.floatField("ik_lo1" + stri, q = True, v = True)
        o_2 = cmds.floatField("ik_lo2" + stri, q = True, v = True)
        
        cmds.setAttr(actionNode + ".IKLockIns1Root[" +strid+ "].IKLockIns1[" +stri+ "]", i_1)
        cmds.setAttr(actionNode + ".IKLockIns2Root[" +strid+ "].IKLockIns2[" +stri+ "]", i_2)
        cmds.setAttr(actionNode + ".IKLockOuts1Root[" +strid+ "].IKLockOuts1[" +stri+ "]", o_1)
        cmds.setAttr(actionNode + ".IKLockOuts2Root[" +strid+ "].IKLockOuts2[" +stri+ "]", o_2)
        
def McdExpandExitNum(actionNode, modNum):
    exitNum = cmds.getAttr(actionNode + ".exitNum")
    exitNum += modNum
    cmds.setAttr(actionNode + ".exitNum", exitNum)
    
    cmds.select(actionNode)
    
    
def McdExpandIKNum(actionNode, modNum):
    exitNum = cmds.getAttr(actionNode + ".nbIK")
    exitNum += modNum
    cmds.setAttr(actionNode + ".nbIK", exitNum)
    
    cmds.select(actionNode)
        
def McdTrimAction(actionNode):
    trimIn = cmds.intField("trim_act_in", q = True, v = True)
    trimOut = cmds.intField("trim_act_out", q = True, v = True)
    
    indexIn = trimIn - 1
    indexOut = trimOut - 1
    
    if indexOut <= indexIn:
        cmds.confirmDialog(t = "Abort", m = "Trim range max is less/equal than min")
        return
    
    actLen = cmds.getAttr(actionNode + ".length")
    
    if trimIn > actLen or trimOut > actLen:
        cmds.confirmDialog(t = "Abort", m = "Out of range, fill trim again")
        return
    
    totalFrame = indexOut - indexIn + 1
    
    if totalFrame >= actLen:
        cmds.confirmDialog(t = "Abort", m = "Trim range " + str(totalFrame) + " is equal or greater with action length")
        return
    
    moveToFront = indexIn # means 0 -> 0 indexIn
    
    stat = cmds.confirmDialog(t = "Warning", m = "Trim and create new action from " + str(trimIn) + " to " + str(trimOut) + ". \n" +\
                                                "The new action will be " + str(totalFrame) + " frames.\n" + \
                                                "This process cannot be undone, we suggest you save your action node. Continue?",\
                                                b = ["Yes", "No"])
    
    if stat != "Yes":
        return
    
    for i in range(totalFrame):
        # migrate frame <i + moveToFront> contents to frame <i>
        oldIndex = i + moveToFront
        newIndex = i
        
        # action data
        actionData = cmds.getAttr(actionNode + ".actionDataArray[" + str(oldIndex) + "].actionData")
        for j in range(len(actionData[0])):
            strj = str(j)
            cmds.setAttr(actionNode + ".actionDataArray[" + str(newIndex) + "].actionData[" + strj + "]", actionData[0][j])
        
        # root org data
        rootOrgDataTemp = cmds.getAttr(actionNode + ".rootOrgData[" + str(oldIndex * 6 + 0) + "]")
        cmds.setAttr(actionNode + ".rootOrgData[" + str(newIndex * 6 + 0) + "]", rootOrgDataTemp)
        
        rootOrgDataTemp = cmds.getAttr(actionNode + ".rootOrgData[" + str(oldIndex * 6 + 1) + "]")
        cmds.setAttr(actionNode + ".rootOrgData[" + str(newIndex * 6 + 1) + "]", rootOrgDataTemp)
        
        rootOrgDataTemp = cmds.getAttr(actionNode + ".rootOrgData[" + str(oldIndex * 6 + 2) + "]")
        cmds.setAttr(actionNode + ".rootOrgData[" + str(newIndex * 6 + 2) + "]", rootOrgDataTemp)
        
        rootOrgDataTemp = cmds.getAttr(actionNode + ".rootOrgData[" + str(oldIndex * 6 + 3) + "]")
        cmds.setAttr(actionNode + ".rootOrgData[" + str(newIndex * 6 + 3) + "]", rootOrgDataTemp)
        
        rootOrgDataTemp = cmds.getAttr(actionNode + ".rootOrgData[" + str(oldIndex * 6 + 4) + "]")
        cmds.setAttr(actionNode + ".rootOrgData[" + str(newIndex * 6 + 4) + "]", rootOrgDataTemp)
        
        rootOrgDataTemp = cmds.getAttr(actionNode + ".rootOrgData[" + str(oldIndex * 6 + 5) + "]")
        cmds.setAttr(actionNode + ".rootOrgData[" + str(newIndex * 6 + 5) + "]", rootOrgDataTemp)
        
        
    #exit range:
    exitData = cmds.getAttr(actionNode + ".exitStartFrame")
    for j in range(len(exitData[0])):
        strj = str(j)
        exitCurrentData = exitData[0][j]
        exitCurrentData -= moveToFront
        if exitCurrentData <= 0.5:
            exitCurrentData = 0.0
        if exitCurrentData >= totalFrame:
            exitCurrentData = totalFrame - 1
            
        cmds.setAttr(actionNode + ".exitStartFrame[" + strj + "]", exitCurrentData)
        
    exitData = cmds.getAttr(actionNode + ".exitEndFrame")
    for j in range(len(exitData[0])):
        strj = str(j)
        exitCurrentData = exitData[0][j]
        exitCurrentData -= moveToFront
        if exitCurrentData <= 0.5:
            exitCurrentData = 0.0
        if exitCurrentData >= totalFrame:
            exitCurrentData = totalFrame - 1
            
        cmds.setAttr(actionNode + ".exitEndFrame[" + strj + "]", exitCurrentData)
            
    # length
    cmds.setAttr(actionNode + ".length", totalFrame)
    
    # rebuild
    cmds.select(actionNode)
    mel.eval("McdSetAgentDataCmd;")
 
        
def mcd_on_blend(actNode):
    ids = cmds.textScrollList("blendlist_tsl", q = True, sii = True)
    if MIsBlank(ids):
        return
    
    for i in range(len(ids)):
        cmds.setAttr(actNode + ".blendList[" + str(ids[i]-1) + "]", 1)
        
    reDrawBlendList(actNode)
    
def mcd_off_blend(actNode):
    ids = cmds.textScrollList("blendlist_tsl", q = True, sii = True)
    if MIsBlank(ids):
        return
    
    for i in range(len(ids)):
        cmds.setAttr(actNode + ".blendList[" + str(ids[i]-1) + "]", 0)
        
    reDrawBlendList(actNode)
    
def reDrawBlendList(actNode):
    i = 0;
    boneStringSet = []
    while(1):
        currentBoneName = cmds.getAttr(actNode + ".boneNameList[" + str(i) + "]")
        if currentBoneName == None or currentBoneName == "":
            break
        if cmds.getAttr(actNode + ".blendList[" + str(i) + "]") == 1:
            currentBoneName = "*       " + currentBoneName
        else:
            currentBoneName = "        " + currentBoneName
        boneStringSet.append(currentBoneName)
        i += 1;
            
    cmds.columnLayout(adj = True)
    cmds.textScrollList("blendlist_tsl", e= True, ra = True)
    cmds.textScrollList("blendlist_tsl", e = True, append = boneStringSet)
    
def McdCloneIKSetup():
    allRawSels = cmds.ls(sl = True)
    
    if MIsBlank(allRawSels):
        cmds.confirmDialog(t = "Abort", m = "Please select multiply action nodes.")
        return
    
    allActions = []
    for i in range(len(allRawSels)):
        if cmds.nodeType(allRawSels[i]) == "McdAction":
            allActions.append(allRawSels[i])
            
    if len(allActions) <= 1:
        cmds.confirmDialog(t = "Abort", m = "Please select multiply action nodes.")
        return
    
    actRoot = allActions[0]
    
    for i in range(len(allActions)):
        if i == 0:
            continue
        
        # clone begin:
        cmds.select(allActions[i])
        
        ikid = 0
        while True:
            strikid = str(ikid)
            nbIK = cmds.getAttr(actRoot + ".nbIK")
            ikName = cmds.getAttr(actRoot + ".ikName[" + strikid + "]")
            ikLevel = cmds.getAttr(actRoot + ".ikLevel[" + strikid + "]")
            
            if ikName == None or ikName == "":
                break
            
            cmds.setAttr(allActions[i] + ".nbIK", nbIK)
            cmds.setAttr(allActions[i] + ".ikid", ikid)
            cmds.setAttr(allActions[i] + ".ikName[" + strikid + "]", ikName, type = "string")
            cmds.setAttr(allActions[i] + ".ikLevel[" + strikid + "]", ikLevel)
            
            melCmd = "McdSetIKDataCmd -om 0;"
            mel.eval(melCmd)
            
            ikid += 1
        
        

def McdIKLockAllSetup():
    
    actionNode = cmds.textField("ActionNodeName11", q = True, tx = True)
    
    stat = cmds.confirmDialog(t = "Warning", m = "You will auto fill and it will overwrite if exist, continue? \n\n" + actionNode, \
                    button = ["Yes", "Cancel"], \
                    defaultButton = "Yes", cancelButton = "Cancel", dismissString = "Cancel")
    
    if stat == "Cancel":
        return
    
    hRatio = 10.0
    stat = cmds.promptDialog(t = "Height Ratio Threshold", m = "When the joint height less \"X\"% than maxinum height, lock down ik\nPlease specify that \"X\"", \
                    button = ["OK", "Default 10%", "Cancel"], \
                    defaultButton = "OK", cancelButton = "Cancel", dismissString = "Cancel")
    if stat == "OK":
        try:
            hRatio = float(cmds.promptDialog(query = True, text = True))
        except:
            hRatio = 10.0
    if stat == "Cancel":
        return;
    
    ikid = 0
    while True:
        strikid = str(ikid)
        
        ikName = cmds.getAttr(actionNode + ".ikName[" + strikid + "]")
        if ikName == None or ikName == "":
            break
        
        cmds.setAttr(actionNode + ".ikid", ikid)
        fromIKDataAutofillLockData2(actionNode, hRatio)
        
        ikid += 1
    
def fromIKDataAutofillLockData2(actionNode, hRatio):
    # speed
    
    ikid = cmds.getAttr(actionNode + ".ikid")
    strikid = str(ikid * 6 + 1)
    nbFrame = cmds.getAttr(actionNode + ".length")
    # format: aaa_action.ikDataRoot[ikid].ikData[frame]
    hRatio /= 100.0
    
    heightListTemp = []
    for i in range(nbFrame):
        stri = str(i)
        a = cmds.getAttr(actionNode + ".ikDataRoot[" + stri + "].ikData[ " + strikid + " ]")
        heightListTemp.append(a)
        
    hMax = -100000
    hMin = 100000
    for i in range(nbFrame):
        if heightListTemp[i] > hMax:
            hMax = heightListTemp[i]
        if heightListTemp[i] < hMin:
            hMin = heightListTemp[i]
    
    threshold = ((hMax - hMin) * hRatio) + hMin
    
    # extend to 3 time length!
    heightList = []
    for j in range(3):
        for i in range(len(heightListTemp)):
            heightList.append(heightListTemp[i])
            
    
    startPoints = []
    endPoints = []
    addMode = False
    passCount = 0
    for i in range(len(heightList)-2):
        if passCount > 0:
            passCount -= 1
            continue
        
        if heightList[i] < threshold:
            next1 = heightList[i + 1]
            next2 = heightList[i + 2]
            if next1 < threshold and next2 < threshold:
                addMode = True
                startPoints.append(i)
            
        if addMode:
            accumulater = 3
            while(1):
                if i + accumulater > nbFrame * 3 - 1:
                    break;
                
                if heightList[i + accumulater] < threshold:
                    accumulater += 1
                else:
                    break
            endPoints.append(i + accumulater)
            passCount = accumulater - 1
            addMode = False
        
    min = nbFrame
    max = 2 * nbFrame - 1
        
    sSets = []
    eSets = []
    smoothSets = []
        
    for i in range(len(endPoints)):
        sframe = startPoints[i]
        eframe = endPoints[i]
        
        if sframe < min and eframe < min:
            continue
        if sframe > max and eframe > max:
            continue
        if sframe >= min and eframe <= max:
            # in range
            sSets.append(sframe)
            eSets.append(eframe)
            smoothSets.append((eframe - sframe) / 2 + 1)
            continue
        if sframe < min and eframe > min:
            sSets.append(nbFrame)
            eSets.append(eframe)
            smoothSets.append((eframe - sframe) / 2 + 1)
            # from end to 
            continue
        if sframe < max and eframe > max:
            sSets.append(sframe)
            eSets.append(2 * nbFrame - 1)
            smoothSets.append(0)
            continue
    
    for i in range(len(sSets)):
        sSets[i] -= nbFrame
        eSets[i] -= nbFrame
        
        #print sSets[i]
        #print eSets[i]
        #print smoothSets[i]
    
        # fill value ---------------------------------------------------------------
        strid = str(ikid)
        stri = str(i)
        
        length = cmds.intField("actLength_if", q = True, v = True)
        fLength = float(length)
        
        i_1 = sSets[i]
        i_2 = sSets[i]
        o_1 = eSets[i]
        o_2 = eSets[i] + smoothSets[i]
        
        cmds.floatField("ik_li1" + stri, e = True, v = i_1)
        cmds.floatField("ik_li2" + stri, e = True, v = i_2)
        cmds.floatField("ik_lo1" + stri, e = True, v = o_1)
        cmds.floatField("ik_lo2" + stri, e = True, v = o_2)
        
        if i_1 > i_2:
            i_2 = i_1
            
        if i_2 > o_1:
            o_1 = i_2
            
        if o_1 > o_2:
            o_2 = o_1
            
        pos1 = int(i_1 / fLength * 200.0)
        pos2 = int((i_2 - i_1) / fLength * 200.0)
        pos3 = int((o_1 - i_2) / fLength * 200.0)
        pos4 = int((o_2 - o_1) / fLength * 200.0)
        
        if pos1 <= 0:
            pos1 = 1
        if pos2 <= 0:
            pos2 = 1
        if pos3 <= 0:
            pos3 = 1
        if pos4 <= 0:
            pos4 = 1
            
        pos5 = 200 - pos4
        
        cmds.deleteUI("actPreviewBarChild_iklc" + stri)
        
        cmds.rowColumnLayout("actPreviewBarChild_iklc" + stri, p = "actPreviewBar_ikl" + stri,\
                            nc = 5, cw = [(1, pos1),(2, pos2),(3, pos3),(4, pos4),(5, pos5)])
        cmds.text(l = "", bgc = [.5, .7, .9])
        cmds.text(l = "in", bgc = [.8, .8, .3])
        cmds.text(l = "lock",align = "center", bgc = [ .8,  0.2,  0.2])
        cmds.text(l = "out", bgc = [.8, .8, .3])
        cmds.text(l = "", bgc = [.5, .7, .9])
        cmds.setParent("..")
        
        i_1 = cmds.floatField("ik_li1" + stri, q = True, v = True)
        i_2 = cmds.floatField("ik_li2" + stri, q = True, v = True)
        o_1 = cmds.floatField("ik_lo1" + stri, q = True, v = True)
        o_2 = cmds.floatField("ik_lo2" + stri, q = True, v = True)
        
        cmds.setAttr(actionNode + ".IKLockIns1Root[" +strid+ "].IKLockIns1[" +stri+ "]", i_1)
        cmds.setAttr(actionNode + ".IKLockIns2Root[" +strid+ "].IKLockIns2[" +stri+ "]", i_2)
        cmds.setAttr(actionNode + ".IKLockOuts1Root[" +strid+ "].IKLockOuts1[" +stri+ "]", o_1)
        cmds.setAttr(actionNode + ".IKLockOuts2Root[" +strid+ "].IKLockOuts2[" +stri+ "]", o_2)
    
    
    
    
    
    
    
    
    
    
    
    