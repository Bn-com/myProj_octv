// ===========================================================================
// Copyright 2016 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================

//
//  Description:
//      This script initializes the Channel Box and Layer Editor.  
//      Initialization involves determining the initial preferences, 
//      creating the UI and setting the initial visibility.
//

// Description:  
//      Take the original array, reverse the order of the
//      array.   Return the new array.
//

if( !`exists passesTabSetDefaultPrecomp` )
{
	eval("source \"createMayaRenderPassTab.mel\"");
}

proc string [] reverseArray(string $originalArray[])
{
	string $newArray[] = $originalArray;
	int $newArrayLength = size($newArray);
	int $halfLength = $newArrayLength/2;
	int $i;
	for ($i = 0; $i <$halfLength; $i++)
	{
		string $tmpLayer = $newArray[$i];
		int $j = $newArrayLength - $i -1;
		$newArray[$i] = $newArray[$j];
		$newArray[$j] = $tmpLayer;
	}
	return $newArray;
}


//////////////////////////////////////////////////////////////////////////////
// ANIMATION LAYER SPECIFIC METHODS
//////////////////////////////////////////////////////////////////////////////
global proc string[] getSelectedAnimLayer(string $toolName)
{
	string $list[] = `treeView -query -selectItem ($toolName+"animLayerEditor")`;

	return $list;
}

global proc deselectAnimLayers(string $toolName, string $layers[])
{
	for($layer in $layers)
		treeView -e -selectItem $layer false ($toolName+"animLayerEditor");
}

proc string[] getKeyableAttribute(string $object)
{
	return `listAttr -keyable -multi $object`;
}

proc int isBestLayer(string $layer, string $bestLayers[], int $recursive)
//
//	Description:
//		return 1 if $layer is a best layer.
//		return 2 if on of the $layer children is a best layer.
//		return 0 if $layer and children are not a best layer
//
//	Arguments:
//		$layer - The name of the layer to check
//		$bestLayers - List of the best layers.
//		$recursive - Do we look for children
//
{
	for($bestLayer in $bestLayers)
	{
		if($bestLayer == $layer)
		{
			return 1;
		}
	}

	if($recursive)
	{
		string $childrens[] = `animLayer -query -children $layer`;

		for($children in $childrens)
		{
			if(isBestLayer($children, $bestLayers, true))
			{
				return 2;
			}
		}
	}
	return 0;
}


proc string[] getBestLayers(string $selected[])
{
	string $bestLayers[];
	$bestLayers = `animLayer -q -bestAnimLayer`;

	return $bestLayers;
}

global proc int isAffectedLayer(string $layer, string $affectedLayers[], int $recursive)
//
//	Description:
//		return 1 if $layer is an affected layer.
//		return 2 if one of the $layer children is an affected layer.
//		return 0 if $layer and children are not an affected layer
//
//	Arguments:
//		$layer - The name of the layer to check
//		$affectedLayers - List of the affected layers.
//		$recursive - Do we look for children
//
{
	for($affectedLayer in $affectedLayers)
	{
		if($affectedLayer == $layer)
		{
			return 1;
		}
	}

	if($recursive)
	{
		string $childrens[] = `animLayer -query -children $layer`;

		for($children in $childrens)
		{
			if(isAffectedLayer($children, $affectedLayers, true))
			{
				return 2;
			}
		}
	}
	return 0;
}

global proc string[] getAffectedLayers(string $selected[])
{
	string $affectedLayers[];
	$affectedLayers = `animLayer -q -afl`;
	
	return $affectedLayers;
}


proc AddLayerToDisplayArray(string $layer, string $layerArray[])
{
	$layerArray[size($layerArray)] = $layer;

}

global proc buildAnimLayerArrayRecursive(string $layer, string $layerArray[])
{
	
	string $children[] = `animLayer -query -children $layer`;

	int $iter = 0;

	for(; $iter < size($children); $iter++)
	{
		AddLayerToDisplayArray($children[$iter], $layerArray);
		buildAnimLayerArrayRecursive($children[$iter],$layerArray);
	}
	
}


global proc string[] buildAnimLayerArray()
{
	string $lRootLayer = `animLayer -q -root`;
	string $layerArray[];

	if( $lRootLayer != "")
	{
		AddLayerToDisplayArray($lRootLayer, $layerArray);
		buildAnimLayerArrayRecursive( $lRootLayer, $layerArray);
	}

	return $layerArray;
}

global proc animLayerWarnNonEmptyAccChange( string $layers[] )
{
    // Print a warning message if some layers contains animation
    // Should be called when accumulation modes are changes

	string $nonEmptyLayers;

	for( $layer in $layers )
	{
		if ( size( `animLayer -q -attribute $layer`) > 0 )
		{
			if( size( $nonEmptyLayers ) > 0 )
			{
				$nonEmptyLayers += ", ";
			}
			$nonEmptyLayers += $layer;
		}
	}

	if( size( $nonEmptyLayers ) > 0 )
	{
		string $wrn=(uiRes("m_layerEditor.kLayersNotEmptyWarning"));
		print `format -s $nonEmptyLayers $wrn`;
	}
}

	
global proc openFloatingAnimLayerEditor()
{
	if (`window -exists AnimationLayerEditorWindow` == false) 
	{ 
		string $animationLayersEditor = (uiRes("m_layerEditor.kAnimationLayersEditor"));
		string $window = `window AnimationLayerEditorWindow`;
		window -edit -title $animationLayersEditor $window; 
		createAnimLayerEditor($window, "AnimationLayerEditor"); 
		showWindow $window; 
	}
}

global proc updateAddButtons()
{
	global string $gLEAddButtons[];
	int $numButtons = size($gLEAddButtons);
	int $i = 0;
	int $layerAvailable = layerAvailable();
	while( $i < $numButtons ){
		symbolButton -e -enable $layerAvailable $gLEAddButtons[$i];
		$i++;
	}
}


global proc createAnimLayerEditor(string $parentLayout, string $toolName )
{
	global string $gLEAddButtons[];
	layerInitialiseParameterDefaults();

	string $layersMenu			= (uiRes("m_layerEditor.kAnimLayers"));
	string $zeroKeyAnimLayer	  = (uiRes("m_layerEditor.kZeroKeyAnimLayer"));
	string $zeroWeightAnimLayer   = (uiRes("m_layerEditor.kZeroWeightAnimLayer"));
	string $fullWeightAnimLayer   = (uiRes("m_layerEditor.kFullWeightAnimLayer"));
	string $createEmptyLayer	  = (uiRes("m_layerEditor.kCreateEmptyAnimLayer"));
	string $createLayer		   = (uiRes("m_layerEditor.kCreateAnimLayer"));
	string $moveSelectionUp	   = (uiRes("m_layerEditor.kMoveSelectionUpButton2"));
	string $moveSelectionDown	 = (uiRes("m_layerEditor.kMoveSelectionDownButton2"));

	string $optionsMenu		   = (uiRes("m_layerEditor.kOptionsAnimLayers"));
	string $keyButton			 = (uiRes("m_layerEditor.kKeyAnimLayers"));

	string $animLayersShowMenuStr = (uiRes("m_layerEditor.kAnimLayersShowMenu"));
	string $animLayersHelpMenuStr = (uiRes("m_layerEditor.kAnimLayersHelpMenu"));
	
	setParent $parentLayout;
	menuBarLayout $toolName;

	global float $gOldFloat; // Used for storing the original Weight value at the beginning of a transaction (in order to push the good value when the transaction wil be enabled

	//	Create "Layers" pulldown menu
	//
	$editMenuForAnimLayers = `menu -label $layersMenu -allowOptionBoxes true`;
	menu -edit -postMenuCommand ("layerEditorBuildAnimLayerMenu(\"" + $editMenuForAnimLayers + "\", \"" + $toolName + "\")") $editMenuForAnimLayers;

	$editMenuForOptionsAnimLayers = `menu -label $optionsMenu -allowOptionBoxes true`;
	menu -edit -postMenuCommand ( "layerEditorBuildAnimOptionMenu " + $editMenuForOptionsAnimLayers ) $editMenuForOptionsAnimLayers;
	
	$showMenuForAnimLayers = `menu -label $animLayersShowMenuStr -allowOptionBoxes true`;
	menu -edit -postMenuCommand ( "layerEditorBuildAnimShowMenu " + $showMenuForAnimLayers ) $showMenuForAnimLayers;

	$helpMenuForAnimLayers = `menu -label $animLayersHelpMenuStr -allowOptionBoxes false`;
	menu -edit -postMenuCommand ("layerEditorBuildAnimHelpMenu "+ $helpMenuForAnimLayers ) $helpMenuForAnimLayers;
	
	int $selectionKey = `optionVar -exists animLayerSelectionKey` ? `optionVar -query animLayerSelectionKey` : 1;

	$AnimLayerFormLayout = `formLayout`;

	string $lanimLayerWeightTextName = $toolName + "WeightText";
	string $lanimLayerWeightFieldName = $toolName + "WeightField";
	string $lanimLayerWeightSliderName = $toolName + "WeightSlider";
	string $lanimLayerWeightButtonName = $toolName + "WeightButton";
	string $lanimLayerMoveUpButtonName = $toolName + "MoveUpButton";
	string $lanimLayerMoveDownButtonName = $toolName + "MoveDownButton";

	$zeroKeyAnimLayerButton	= `symbolButton -image "zeroKey.png"  -annotation $zeroKeyAnimLayer`;
	$zeroWeightAnimLayerButton = `symbolButton -image "keyZeroWeight.png"  -annotation $zeroWeightAnimLayer`;
	$fullWeightAnimLayerButton = `symbolButton -image "keyFullWeight.png"  -annotation $fullWeightAnimLayer`;
	$emptyAnimLayerButton	  = `symbolButton -image "newLayerEmpty.png"  -annotation $createEmptyLayer`;
	$selectedAnimLayerButton   = `symbolButton -image "newLayerSelected.png"  -annotation $createLayer`;
	if( size($gLEAddButtons) == 0 ){
		$gLEAddButtons[0] = $emptyAnimLayerButton;
		$gLEAddButtons[1] = $selectedAnimLayerButton;
	}
	$moveSelectionUpButton	 = `symbolButton -image "moveLayerUp.png"  -annotation $moveSelectionUp $lanimLayerMoveUpButtonName`;
	$moveSelectionDownButton   = `symbolButton -image "moveLayerDown.png"  -annotation $moveSelectionDown $lanimLayerMoveDownButtonName`;
	$animLayerWeightText	   = `text -label (uiRes("m_layerEditor.kWeightAnimLayer")) $lanimLayerWeightTextName`;
	$animLayerWeightField	  = `floatField -width 40 -precision 3 -maxValue 1.0 -minValue 0.0 -value 1.0 $lanimLayerWeightFieldName`;
	$animLayerWeightSlider	 = `floatSlider -maxValue 1.0 -minValue 0.0 -step 0.01 -value 1.0 $lanimLayerWeightSliderName`;
	$animLayerWeightButton	 = `button -label $keyButton $lanimLayerWeightButtonName`;

	// control to display animation layer, this control is temporary and should be change to something else
	// to help this change we have created a layer of interaction between basic UI control and this high level editor
	// see function:
	//	rebuildAnimLayerEditor()
	//  getSelectedAnimLayer();
	$buttonsOnRight	= `optionVar -exists animLayerButtonsOnRight` ? `optionVar -query animLayerButtonsOnRight` : 0;
	$reverseLayerStack = `optionVar -exists animLayerReverseLayerStack` ? `optionVar -query animLayerReverseLayerStack` : 1;
	$animLayerEditor   = `treeView -parent $AnimLayerFormLayout -numberOfButtons 4 -abr $buttonsOnRight -rto $reverseLayerStack ($toolName+"animLayerEditor")`;

	treeView -edit -selectCommand "animLayerEditorOnSelect" $animLayerEditor;
	treeView -edit -pressCommand 4 ("animLayerGhostCallBack \""+$animLayerEditor+"\"") -pressCommand 3 "animLayerMuteCallBack" -pressCommand 2 "animLayerSoloCallBack" -pressCommand 1 "animLayerLockCallBack" $animLayerEditor;
	treeView -edit -rightPressCommand 4 "animLayerGhostRightCallBack" $animLayerEditor;
	treeView -edit -expandCollapseCommand "animLayerExpandCollapseCallback" $animLayerEditor;
	treeView -edit -dragAndDropCommand "animLayerDragAndDropCallback" $animLayerEditor;
	treeView -edit -editLabelCommand "animLayerEditLabelCallback" $animLayerEditor;
	
	$animLayerPopupMenu  = `popupMenu -button 3 -allowOptionBoxes true -parent $animLayerEditor`;
	treeView -edit
		-contextMenuCommand ("layerEditorBuildPopupMenu \""+$toolName+ "\" \""+$animLayerPopupMenu+"\" ")
		$animLayerEditor;

	formLayout	-e
			-attachForm  $zeroKeyAnimLayerButton "top" 1
			-attachForm  $zeroKeyAnimLayerButton "left" 2
			-attachNone  $zeroKeyAnimLayerButton "bottom"
			-attachNone  $zeroKeyAnimLayerButton "right"

			-attachForm  $zeroWeightAnimLayerButton "top" 1
			-attachControl $zeroWeightAnimLayerButton "left" 1 $zeroKeyAnimLayerButton
			-attachNone  $zeroWeightAnimLayerButton "bottom"
			-attachNone  $zeroWeightAnimLayerButton "right"

			-attachForm  $fullWeightAnimLayerButton "top" 1
			-attachControl $fullWeightAnimLayerButton "left" 1 $zeroWeightAnimLayerButton
			-attachNone  $fullWeightAnimLayerButton "bottom"
			-attachNone  $fullWeightAnimLayerButton "right"

			-attachForm  $selectedAnimLayerButton "top" 1
			-attachForm  $selectedAnimLayerButton "right" 2
			-attachNone  $selectedAnimLayerButton "bottom"
			-attachNone  $selectedAnimLayerButton "left"

			-attachForm $emptyAnimLayerButton "top" 1
			-attachControl $emptyAnimLayerButton "right" 1 $selectedAnimLayerButton
			-attachNone $emptyAnimLayerButton "bottom"
			-attachNone $emptyAnimLayerButton "left"

			-attachForm $moveSelectionDownButton "top" 1
			-attachControl $moveSelectionDownButton "right" 4 $emptyAnimLayerButton
			-attachNone $moveSelectionDownButton "bottom"
			-attachNone $moveSelectionDownButton "left"

			-attachForm $moveSelectionUpButton "top" 1
			-attachControl $moveSelectionUpButton "right" 1 $moveSelectionDownButton
			-attachNone $moveSelectionUpButton "bottom"
			-attachNone $moveSelectionUpButton "left"

			-attachForm $animLayerWeightText "left" 2
			-attachNone $animLayerWeightText "right"
			-attachNone $animLayerWeightText "top"
			-attachForm $animLayerWeightText "bottom" 2

			-attachControl $animLayerWeightField "left" 2 $animLayerWeightText
			-attachNone $animLayerWeightField "right"
			-attachNone $animLayerWeightField "top"
			-attachForm $animLayerWeightField "bottom" 2

			-attachForm $animLayerWeightButton "right" 2
			-attachNone $animLayerWeightButton "left"
			-attachNone $animLayerWeightButton "top"
			-attachForm $animLayerWeightButton "bottom" 2

			-attachControl $animLayerWeightSlider "left" 2 $animLayerWeightField
			-attachControl $animLayerWeightSlider "right" 2 $animLayerWeightButton
			-attachNone $animLayerWeightSlider "top"
			-attachForm $animLayerWeightSlider "bottom" 2

			-attachForm $animLayerEditor "left" 2 
			-attachForm $animLayerEditor "right" 4
			-attachControl $animLayerEditor "top" 2 $selectedAnimLayerButton
			-attachControl $animLayerEditor "bottom" 2 $animLayerWeightField
		$AnimLayerFormLayout;

	//						  //
	// End of Anim layer tab.   //
	//						  //

	if( !`runTimeCommand -exists EmptyAnimLayer` ) 
	{
		runTimeCommand -default true
			-command "layerEditorCreateAnimLayer( false, false);updateAddButtons()"
			-category   ("Editors.Animation Layer")
			EmptyAnimLayer;
	}

	if( !`runTimeCommand -exists SelectedAnimLayer` ) 
	{
		runTimeCommand -default true
			-command "layerEditorCreateAnimLayer( true, false);updateAddButtons()"
			-category   ("Editors.Animation Layer")
			SelectedAnimLayer;
	}

	string $lMoveLayerUpCommand   = "layerEditorMoveAnimItem(\""+$toolName+"\", true);";
	string $lMoveLayerDownCommand = "layerEditorMoveAnimItem(\""+$toolName+"\", false);";

	string $lZeroKeyCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
							   layerEditorZeroKeyAnimLayer($lLayers)";

		string $lZeroWeightKeyCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
							   layerEditorZeroWeightKeyAnimLayer($lLayers)";

		string $lFullWeightKeyCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
							   layerEditorFullWeightKeyAnimLayer($lLayers)";

	string $lFieldWeightCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
								   float $lValue = `floatField -query -value \""+$animLayerWeightField+"\"`; \
								   floatSlider -edit -value $lValue \""+$animLayerWeightSlider+"\"; \
								   layerEditorWeightAnimLayer($lLayers, $lValue)";

	string $lSliderWeightDrag =	 "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\");"
								   +"float $lValue = `floatSlider -query -value \""+$animLayerWeightSlider+"\"`;"
								   +"if (`undoInfo -q -swf` == 1) {"
								   +"	$gOldFloat = $lValue;"
								   +"	undoInfo -swf off;"
								   +"	refresh -su 1;"
								   +"	currentTime -e `currentTime -q`;" // MAYA-36993, forcing refresh due to potentially inconsistent DG state after keying
								   +"	refresh -su 0;"
								   +"};"
								   +"floatField -edit -value $lValue \""+$animLayerWeightField+"\";"
								   +"layerEditorWeightAnimLayerNoForcedRefresh($lLayers, $lValue)";

	string $lSliderWeightCommand =   "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\");"
									+"float $lValue = `floatSlider -query -value \""+$animLayerWeightSlider+"\"`;"
									+"if (`undoInfo -q -swf` == 0) {"
									+"	layerEditorWeightAnimLayerNoForcedRefresh($lLayers, $gOldFloat );"
									+"	undoInfo -swf on;"
									+"};"
									+"floatField -edit -value $lValue \""+$animLayerWeightField+"\";"
									+"layerEditorWeightAnimLayerNoForcedRefresh($lLayers, $lValue)";

	string $lKeyWeightCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
								 layerEditorKeyWeightAnimLayer($lLayers)";
		
	int $layerAvailable = layerAvailable();

	symbolButton -edit -enable $layerAvailable -command ("EmptyAnimLayer") $emptyAnimLayerButton;
	symbolButton -edit -enable $layerAvailable -command ("SelectedAnimLayer") $selectedAnimLayerButton;
	symbolButton -edit -command ($lZeroKeyCommand) $zeroKeyAnimLayerButton;
		symbolButton -edit -command ($lZeroWeightKeyCommand) $zeroWeightAnimLayerButton;
		symbolButton -edit -command ($lFullWeightKeyCommand) $fullWeightAnimLayerButton;
	symbolButton -edit -command ($lMoveLayerUpCommand) $moveSelectionUpButton;
	symbolButton -edit -command ($lMoveLayerDownCommand) $moveSelectionDownButton;
	
	floatField -edit -changeCommand ($lFieldWeightCommand) $animLayerWeightField;
	floatSlider -edit -dragCommand ($lSliderWeightDrag) -changeCommand $lSliderWeightCommand $animLayerWeightSlider;
	button -edit -command ($lKeyWeightCommand) $animLayerWeightButton;

	scriptJob -compressUndo true -permanent -parent $parentLayout -event animLayerRebuild ("rebuildAnimLayerEditor(\""+$toolName+"\")");
	scriptJob -compressUndo true -permanent -parent $parentLayout -event animLayerRefresh ("updateEditorFeedbackAnimLayers(\""+$toolName+"\")");
	scriptJob -compressUndo true -permanent -parent $parentLayout -event animLayerAnimationChanged ("onAnimLayersAnimationChanged(\""+$toolName+"\")");
	scriptJob -compressUndo true -permanent -parent $parentLayout -event animLayerLockChanged ("onAnimLayersLockChanged(\""+$toolName+"\")");
	scriptJob -compressUndo true -permanent -parent $parentLayout -event animLayerBaseLockChanged ("onAnimLayersBaseLockChanged(\""+$toolName+"\")");
	scriptJob -compressUndo true -permanent -parent $parentLayout -event animLayerGhostChanged ("updateEditorFeedbackAnimLayers(\""+$toolName+"\")");

	// The following callback are used to keep the visual feedback of the best layer sync with the system
	// This feedback can change based on many predicate; current scene selection change, anim layer's preferred flag change
	scriptJob -compressUndo true -permanent -parent $parentLayout -event SelectionChanged ("updateAnimLayerEditor(\""+$toolName+"\")");

	scriptJob -permanent -parent $parentLayout -event deleteAll ("rebuildAnimLayerEditor(\""+$toolName+"\")");
	scriptJob -permanent -parent $parentLayout -event NewSceneOpened ("rebuildAnimLayerEditor(\""+$toolName+"\")");
	scriptJob -permanent -parent $parentLayout -event SceneOpened ("rebuildAnimLayerEditor(\""+$toolName+"\")");
	
	rebuildAnimLayerEditor($toolName);
}

global proc layerEditorBuildAnimLayerMenu(string $parent, string $toolName)
{
	setParent -menu $parent;

	string $rootLayer = `animLayer -q -root`;
	string $selectedAnimLayers[]=getSelectedAnimLayer($toolName); 	
		
	int $foundRootLayer = 0;
	for ($layer in $selectedAnimLayers)
	{
		if($layer == $rootLayer)
			$foundRootLayer = 1;
	}

	string $layerString = "{";
	for ($layer in $selectedAnimLayers)
	{
		$layerString+="\""+$layer+"\",";
	}
	$layerString=(substring ($layerString,1,(size($layerString) - 1)));  // get rid of trailing ","
	
	$layerString+="}";

	global string $gAddObjectsMenuItemForAnimLayers;
	global string $gAddObjectsOptionsMenuItemForAnimLayers;
	global string $gRemoveObjectsMenuItemForAnimLayers;
	global string $gSelectObjectsMenuItemForAnimLayers;
	global string $gSelectBranchMenuItemForAnimLayers;
	global string $gSelectLayerNodeMenuItemForAnimLayers;
	global string $gExportLayerMenuItemForAnimLayers;
	global string $gExportBranchMenuItemForAnimLayers;
	global string $gMememberShipMenuItemForAnimLayers;
	global string $gAttributeEditorMenuItemForAnimLayers;
	global string $gDeleteSelectedLayerMenuItemForAnimLayers;
	global string $gDeleteEmptyLayersMenuItemForAnimLayers;
	global string $gDeleteMenuItemForAnimLayers;
	global string $gLayerModeMenuItemForAnimLayers;
	global string $gLayerRotationAccMenuItemForAnimLayers;
	global string $gLayerScaleAccMenuItemForAnimLayers;
	global string $gNewEmptyMenuItemForAnimLayers;
	global string $gNewFromSelectedMenuItemForAnimLayers;
	global string $gNewEmptyOverrideMenuItemForAnimLayers;
	global string $gNewOverrideFromSelectedMenuItemForAnimLayers;
	global string $gDuplicateLayerMenuItemForAnimLayers;
	global string $gDuplicateLayerNoAnimMenuItemForAnimLayers;
	
	int $layerAvailable = layerAvailable();
	if( `menu -q -ni $parent` != 0 ) {
		//
		//  Menu is built already 
		//
		menuItem -edit -enable (!$foundRootLayer) $gAddObjectsMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gAddObjectsOptionsMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gRemoveObjectsMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gSelectObjectsMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gSelectBranchMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gSelectLayerNodeMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gExportLayerMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gExportBranchMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gMememberShipMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gAttributeEditorMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gDeleteSelectedLayerMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gDeleteEmptyLayersMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gDeleteMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gLayerModeMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gLayerRotationAccMenuItemForAnimLayers;
		menuItem -edit -enable (!$foundRootLayer) $gLayerScaleAccMenuItemForAnimLayers;
		menuItem -edit -enable $layerAvailable $gNewEmptyMenuItemForAnimLayers;
		menuItem -edit -enable $layerAvailable $gNewFromSelectedMenuItemForAnimLayers;
		menuItem -edit -enable $layerAvailable $gNewEmptyOverrideMenuItemForAnimLayers;
		menuItem -edit -enable $layerAvailable $gNewOverrideFromSelectedMenuItemForAnimLayers;
		menuItem -edit -enable $layerAvailable $gDuplicateLayerMenuItemForAnimLayers;
		menuItem -edit -enable $layerAvailable $gDuplicateLayerNoAnimMenuItemForAnimLayers;
		return;
	}

	string $createEmptyLayer		  = uiRes("m_layerEditor.kCreateEmptyAnimLayer");
	string $createLayer			   = uiRes("m_layerEditor.kCreateAnimLayer");
	string $createEmptyOverrideLayer  = (uiRes("m_layerEditor.kCreateEmptyOverrideAnimLayer"));
	string $createOverrideLayer	   = (uiRes("m_layerEditor.kCreateOverrideAnimLayer"));
	string $createLayerOptionsMenuStr = (uiRes("m_layerEditor.kCreateLayerOptions"));
	string $addSelectedObjects		= (uiRes("m_layerEditor.kAddSelectedObjectsAnimLayer"));
	string $removeSelectedObjects	 = (uiRes("m_layerEditor.kRemoveSelectedObjectsAnimLayer"));
	string $selectObjects			 = (uiRes("m_layerEditor.kSelectObjectsAnimLayer"));
	string $deleteSelectedLayers	  = (uiRes("m_layerEditor.kDeleteAnimLayer"));
	string $packageAnimLayerObjects   = (uiRes("m_layerEditor.kPackageAnimLayerObjects"));

	int $passthroughMode = `optionVar -exists animLayerDefaultPassthroughMode` ? `optionVar -query animLayerDefaultPassthroughMode` : 1;
	int $rotationMode = `optionVar -exists animLayerDefaultRotationMode` ? `optionVar -query animLayerDefaultRotationMode` : 0;
	int $scaleMode = `optionVar -exists animLayerDefaultScaleMode` ? `optionVar -query animLayerDefaultScaleMode` : 1;
	
	string $lLayerListCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); ";
	string $lSelectionCommand = "string $lSelection[]=`ls -selection`;";

	$gNewEmptyMenuItemForAnimLayers = `menuItem -label $createEmptyLayer`;
	$gNewFromSelectedMenuItemForAnimLayers = `menuItem -label $createLayer`;
	$gNewEmptyOverrideMenuItemForAnimLayers = `menuItem -label $createEmptyOverrideLayer`;
	$gNewOverrideFromSelectedMenuItemForAnimLayers = `menuItem -label $createOverrideLayer`;
	menuItem -label $createLayerOptionsMenuStr -subMenu true -tearOff true;
		menuItem -label (uiRes("m_layerEditor.kAnimLayerCreateLayerPassthrough"))
			 -checkBox $passthroughMode
			 -command ("optionVar -intValue animLayerDefaultPassthroughMode #1");
		menuItem -divider true;
		radioMenuItemCollection;
		menuItem -label (uiRes("m_layerEditor.kAnimLayerCreateLayerEulerRotation"))
			 -radioButton ($rotationMode == 0)
			 -command ("optionVar -intValue animLayerDefaultRotationMode 0");
		menuItem -label (uiRes("m_layerEditor.kAnimLayerCreateLayerQuaternionRotation"))
			 -radioButton ($rotationMode== 1)
			 -command ("optionVar -intValue animLayerDefaultRotationMode 1");
		radioMenuItemCollection;
		menuItem -divider true;
		menuItem -label (uiRes("m_layerEditor.kAnimLayerCreateLayerScaleMultiply"))
			 -radioButton ($scaleMode == 1)
			 -command ("optionVar -intValue animLayerDefaultScaleMode 1");
		menuItem -label (uiRes("m_layerEditor.kAnimLayerCreateLayerScaleAdditive"))
			 -radioButton ($scaleMode == 0)
			 -command ("optionVar -intValue animLayerDefaultScaleMode 0");
	setParent -m ..;

	menuItem -divider true;
	
	$gAddObjectsMenuItemForAnimLayers = `menuItem -label $addSelectedObjects`;
	$gAddObjectsOptionsMenuItemForAnimLayers = `menuItem -optionBox true -annotation (uiRes("m_layerEditor.kAnimLayerAddSelectedObjectsOptions"))`;
	$gRemoveObjectsMenuItemForAnimLayers = `menuItem -label $removeSelectedObjects`;
	menuItem -label (uiRes("m_layerEditor.kExtractSelectedObjectsAnimLayerRC2"))
				 -command ($lLayerListCommand+$lSelectionCommand+"layerEditorExtractObjectsAnimLayer($lSelection, $lLayers )");
	$gSelectObjectsMenuItemForAnimLayers = `menuItem -label $selectObjects`;
	menuItem -divider true;
	
	$gDuplicateLayerMenuItemForAnimLayers = `menuItem -label (uiRes("m_layerEditor.kDuplicateAnimLayer"))`;
	$gDuplicateLayerNoAnimMenuItemForAnimLayers = `menuItem -label (uiRes("m_layerEditor.kDuplicateAnimLayerNoAnim"))`;
	menuItem -label (uiRes("m_layerEditor.kMergeSelectedAnimLayerRC2"))
			 -command ($lLayerListCommand+"layerEditorMergeAnimLayer( $lLayers, 0 )");
  	menuItem -optionBox true
				 -command ($lLayerListCommand+"layerEditorMergeAnimLayer( $lLayers, 1 )");
	menuItem -divider true;

	$extractBaseLayerSelectedMenuItemForAnimLayers = `menuItem -label (uiRes("m_layerEditor.kExtractBaseLayerSelected"))`;
	$extractBaseLayerAllMenuItemForAnimLayers = `menuItem -label (uiRes("m_layerEditor.kExtractBaseLayerAll"))`;

	menuItem -divider true;
	menuItem -label (uiRes("m_layerEditor.kSelectAllAnimLayers"))
		-command ("setSelectedForAllLayers(1)");
	
		
	$gSelectBranchMenuItemForAnimLayers = `menuItem -label (uiRes("m_layerEditor.kSelectBranchAnimLayers"))
		-enable (!$foundRootLayer)
		-command ($lLayerListCommand + "for ($target in $lLayers){setSelectedLayerRecursive($target, 1, 0 );}")`;
	
	string $lSelectLayerNodeCommand = $lLayerListCommand + "string $lCmd = \"select -replace -noExpand \"; for ($target in $lLayers){ $lCmd+= $target + \" \"; }; evalEcho( $lCmd ); ";

	$gSelectLayerNodeMenuItemForAnimLayers = `menuItem -label (uiRes("m_layerEditor.kSelectAnimLayer2"))
				 -enable (!$foundRootLayer)
				 -command ($lSelectLayerNodeCommand)`;

	
	menuItem -divider true;

	$gExportLayerMenuItemForAnimLayers = `menuItem -label (uiRes("m_layerEditor.kAnimLayersExport"))
			 -enable (!$foundRootLayer)
			 -command ($lLayerListCommand+"animLayersExport($lLayers,0)")`;
	
	$gExportBranchMenuItemForAnimLayers = `menuItem -label (uiRes("m_layerEditor.kAnimLayersExportBranch2"))
			 -enable (!$foundRootLayer)
			 -command ($lLayerListCommand+"animLayersExport($lLayers,1)")`;
			 
	menuItem -divider true;
	

	$gMememberShipMenuItemForAnimLayers = `menuItem -label (uiRes("m_layerEditor.kRelationshipAnimLayer"))
			 -enable (!$foundRootLayer)
			 -command ($lLayerListCommand+"relationshipEditor( \"animLayers\", $lLayers, {} );")`;

	$gAttributeEditorMenuItemForAnimLayers = `menuItem -label (uiRes("m_layerEditor.kAttributeEditorAnimLayer"))
			 -enable (!$foundRootLayer)
			 -command ($lLayerListCommand+"select -replace -noExpand $lLayers; editSelected();")`;

	menuItem -divider true;

	$gDeleteMenuItemForAnimLayers = `menuItem -label $deleteSelectedLayers`;

	$gDeleteSelectedLayerMenuItemForAnimLayers = `menuItem -label (uiRes("m_layerEditor.kEmptyAnimLayers2"))
				-enable (!$foundRootLayer)
				-command ($lLayerListCommand+" for ($layer in $lLayers) evalEcho( \"animLayer -edit -removeAllAttributes \"+$layer );")`;
	$gDeleteEmptyLayersMenuItemForAnimLayers = `menuItem -label (uiRes("m_layerEditor.kDeleteEmptyAnimLayers2"))
				-enable (!$foundRootLayer)
				-command ("deleteEmptyAnimLayers()")`;
		
		
	menuItem -divider true;

	string $layerModeLabel=(uiRes("m_layerEditor.kLayerModeAnimLayer2"));
	$gLayerModeMenuItemForAnimLayers =`menuItem -label $layerModeLabel -subMenu true`;
	setParent -menu ..;
	
	string $layerRotationAccLabel = (uiRes("m_layerEditor.kLayerRotationAccAnimLayer2"));
	string $layerScaleAccLabel = (uiRes("m_layerEditor.kLayerScalingAccAnimLayer2"));
	$gLayerRotationAccMenuItemForAnimLayers = `menuItem -label $layerRotationAccLabel -subMenu true`; 
	setParent -menu ..;
	$gLayerScaleAccMenuItemForAnimLayers = `menuItem -label $layerScaleAccLabel -subMenu true`; 	
	setParent -menu ..;

	
	menuItem -edit -pmc ("layerModeSubMenu(\""+$gLayerModeMenuItemForAnimLayers+"\",\""+$toolName+"\")") -enable (!$foundRootLayer) $gLayerModeMenuItemForAnimLayers;
	
	menuItem -edit -pmc ("layerRotationAccSubMenu(\""+$gLayerRotationAccMenuItemForAnimLayers+"\",\""+$toolName+"\")") -enable (!$foundRootLayer) $gLayerRotationAccMenuItemForAnimLayers;
	menuItem -edit -pmc ("layerScaleAccSubMenu(\""+$gLayerScaleAccMenuItemForAnimLayers+"\",\""+$toolName+"\")") -enable (!$foundRootLayer) $gLayerScaleAccMenuItemForAnimLayers;



		
	menuItem -divider true;
	menuItem -label $packageAnimLayerObjects -command ("packageAnimLayerObjects") ;
	
	menuItem -divider true;

	string $lEmptyOverrideLayerCommand =  "string $lLayer = layerEditorCreateAnimLayer( false, true);";		 

	string $lSelectedOverrideLayerCommand =  "string $lLayer = layerEditorCreateAnimLayer( true, true);";			


	string $lSelectObjectCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
									layerEditorSelectObjectAnimLayer($lLayers)";

	string $lDuplicateLayerCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
								 layerEditorCopyAnimLayer($lLayers)";

	string $lDuplicateLayerNoAnimCommand =	"string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
										layerEditorCopyAnimLayerNoAnim($lLayers)";

	string $lExtractBaseLayerSelectedCommand = "string $lSelection[]=`ls -selection`; \
												layerEditorExtractObjectsSingleAnimLayer($lSelection, \"\")";

	string $lExtractBaseLayerAllCommand = "string $lSelection[]=`ls`; \
										   layerEditorExtractObjectsSingleAnimLayer($lSelection, \"\")";

	string $lAddSelectedCommand = "string $lSelection[]=`ls -selection`; \
								   string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
								   layerEditorAddObjectsAnimLayer($lSelection, $lLayers,0)";

	string $lAddSelectedOptionsCommand = "string $lSelection[]=`ls -selection`; \
								   string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
								   layerEditorAddObjectsAnimLayer($lSelection, $lLayers,1)";	   

	string $lRemoveSelectedCommand = "string $lSelection[]=`ls -selection`; \
									  string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
									  layerEditorRemoveObjectsAnimLayer($lSelection, $lLayers)";

	string $lDeleteLayerCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
								   deselectAnimLayers(\""+$toolName+"\", $lLayers); \
								   layerEditorDeleteAnimLayer($lLayers)";

	menuItem -edit -enable $layerAvailable -command ("EmptyAnimLayer") $gNewEmptyMenuItemForAnimLayers;
	menuItem -edit -enable $layerAvailable -command ("SelectedAnimLayer") $gNewFromSelectedMenuItemForAnimLayers;
	menuItem -edit -enable $layerAvailable -command ($lEmptyOverrideLayerCommand) $gNewEmptyOverrideMenuItemForAnimLayers;
	menuItem -edit -enable $layerAvailable -command ($lSelectedOverrideLayerCommand) $gNewOverrideFromSelectedMenuItemForAnimLayers;

	menuItem -edit -command ($lSelectObjectCommand) -enable (!$foundRootLayer) $gSelectObjectsMenuItemForAnimLayers;
	menuItem -edit -enable $layerAvailable -command ($lDuplicateLayerCommand) $gDuplicateLayerMenuItemForAnimLayers;
	menuItem -edit -enable $layerAvailable -command ($lDuplicateLayerNoAnimCommand) $gDuplicateLayerNoAnimMenuItemForAnimLayers;
	menuItem -edit -command ($lExtractBaseLayerSelectedCommand) $extractBaseLayerSelectedMenuItemForAnimLayers;
	menuItem -edit -command ($lExtractBaseLayerAllCommand) $extractBaseLayerAllMenuItemForAnimLayers;

	menuItem -edit -command ($lAddSelectedCommand) -enable (!$foundRootLayer) $gAddObjectsMenuItemForAnimLayers;
	menuItem -edit -command ($lAddSelectedOptionsCommand) -enable (!$foundRootLayer) $gAddObjectsOptionsMenuItemForAnimLayers;
	menuItem -edit -command ($lRemoveSelectedCommand) -enable (!$foundRootLayer) $gRemoveObjectsMenuItemForAnimLayers;
	menuItem -edit -command ($lDeleteLayerCommand) -enable (!$foundRootLayer) $gDeleteMenuItemForAnimLayers;
}

global proc layerModeSubMenu(string $layerModeMenu, string $toolName)
{
	string $lLayerListCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); ";
	setParent -menu $layerModeMenu;
	menu -edit -deleteAllItems $layerModeMenu;
	string $layers[]=getSelectedAnimLayer($toolName);
	
	int $overrideMode = 0;
	int $passthroughMode = 0;
	
	int $enabled = 0;
	if ( size($layers)  )
	{
		$enabled = 1;
		$overrideMode = `animLayer -query -override $layers[0]`;
		$passthroughMode = `animLayer -query -passthrough $layers[0]`;
	}
	string $additiveCommand = ($lLayerListCommand + "for($layer in $lLayers) evalEcho( \"animLayer -edit -override 0 \"+$layer ); animLayerWarnNonEmptyAccChange($lLayers);");
	menuItem -checkBox (($overrideMode?0:1) && $enabled) -label (uiRes("m_layerEditor.kAdditiveAnimLayer2")) -enable $enabled
	 	-command ($additiveCommand);
	
	string $overrideCommand = ($lLayerListCommand + "for($layer in $lLayers) evalEcho( \"animLayer -edit -override 1 \"+$layer); animLayerWarnNonEmptyAccChange($lLayers);");
	menuItem -checkBox ($overrideMode && $enabled) -label (uiRes("m_layerEditor.kOverrideAnimLayer2")) -enable $enabled
		-command ($overrideCommand);
	
	menuItem  -divider true;
	
	string $passthroughCommand = ($lLayerListCommand+"for($layer in $lLayers) evalEcho( \"animLayer -edit -passthrough "+ !$passthroughMode +" \"+$layer); animLayerWarnNonEmptyAccChange($lLayers);");
	menuItem -checkBox (($passthroughMode?1:0) && $enabled) -enable $overrideMode -label (uiRes("m_layerEditor.kPassthroughAnimLayer2"))
			 -command ($passthroughCommand);
	
}

global proc layerRotationAccSubMenu(string $layerAccumulationMenu, string $toolName)
{
	string $lLayerListCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); ";
	setParent -menu $layerAccumulationMenu;
	menu -edit -deleteAllItems $layerAccumulationMenu;
	string $quatCommand = ($lLayerListCommand+ "for($layer in $lLayers) evalEcho( \"setAttr \"+$layer+\".rotationAccumulationMode 1\"); animLayerWarnNonEmptyAccChange($lLayers);");
	string $eulerCommand = ($lLayerListCommand +"for($layer in $lLayers) evalEcho( \"setAttr \"+$layer+\".rotationAccumulationMode 0\"); animLayerWarnNonEmptyAccChange($lLayers);");

	string $layers[]=getSelectedAnimLayer($toolName);
	
	int $rotInterpolationMode = 0;
	int $enabled = 0;
	if ( size($layers)  )
	{
		$enabled = 1;
		$rotInterpolationMode = `getAttr ($layers[0]+".rotationAccumulationMode")`;
	}
	
	
	menuItem -checkBox (($rotInterpolationMode?0:1) && $enabled)  -label (uiRes("m_layerEditor.kEulerAnimLayer2")) -enable $enabled
		-command ($eulerCommand);
		
	menuItem -checkBox ($rotInterpolationMode && $enabled)  -label (uiRes("m_layerEditor.kQuatAnimLayer2")) -enable $enabled
		 -command ($quatCommand);
			 	
}

global proc layerScaleAccSubMenu(string $layerAccumulationMenu, string $toolName)
{
	string $lLayerListCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); ";
	setParent -menu $layerAccumulationMenu;
	menu -edit -deleteAllItems $layerAccumulationMenu;
	string $scaleMultiplyCommand = ($lLayerListCommand +"for($layer in $lLayers) evalEcho( \"setAttr \"+$layer+\".scaleAccumulationMode 1\"); animLayerWarnNonEmptyAccChange($lLayers);");
	string $scaleAdditiveCommand = ($lLayerListCommand +"for($layer in $lLayers) evalEcho( \"setAttr \"+$layer+\".scaleAccumulationMode 0\"); animLayerWarnNonEmptyAccChange($lLayers);");
	
	string $layers[]=getSelectedAnimLayer($toolName);

	
	int $scaleInterpolationMode = 0;
	int $enabled = 0;
	if ( size($layers)  )
	{
		$enabled = 1;
		$scaleInterpolationMode = `getAttr ($layers[0]+".scaleAccumulationMode")`;
	}
	
	menuItem -checkBox ($scaleInterpolationMode && $enabled)  -label (uiRes("m_layerEditor.kScaleMultiplyAnimLayer2")) -enable $enabled
			 -command ($scaleMultiplyCommand);
		
	menuItem -checkBox (($scaleInterpolationMode?0:1) && $enabled)  -label (uiRes("m_layerEditor.kScaleAdditiveAnimLayer2")) -enable $enabled
			 -command ($scaleAdditiveCommand);
	
}


proc updateEditorFeedbackAnimLayer(string $toolName, string $indentLayer, string $bestLayers[], string $affectedLayers[])
{
	string $layer = $indentLayer;
	string $rootLayer = `animLayer -q -root`;
	string $outMute = $layer + ".outMute";
	string $parentMute = $layer + ".parentMute";
	string $solo = $layer + ".solo";
	string $siblingSolo = $layer + ".siblingSolo";
	string $selected = $layer + ".selected";
	string $collapse = $layer + ".collapse";
	string $override = $layer + ".override";
	string $ghost 	 = $layer + ".ghost";
	
	string $animLayerLockTooltip = (uiRes("m_layerEditor.kAnimLayerLockTooltip"));
	string $animLayerSoloTooltip = (uiRes("m_layerEditor.kAnimLayerSoloTooltip"));
	string $animLayerMuteTooltip = (uiRes("m_layerEditor.kAnimLayerMuteTooltip"));
	string $animLayerGhostTooltip = (uiRes("m_layerEditor.kAnimLayerGhostTooltip"));


	if(!`treeView -itemExists $indentLayer -q ($toolName+"animLayerEditor")`) {
		return;
	}

	int $outMuteValue = 0;
	if($rootLayer != $layer)
	{
		$outMuteValue = `getAttr $outMute`;
	}
	int $parentMuteValue = `getAttr $parentMute`;
	int $soloValue = `getAttr $solo`;
	int $siblingSoloValue = `getAttr $siblingSolo`;
	int $selectedValue = `getAttr $selected`;
	int $collapseValue = (`getAttr $collapse`)? 0 : 1;
	int $lockValue = `animLayer -query -lock $layer`;
	int $overrideValue = `getAttr $override`;
	int $ghostValue = `getAttr $ghost`;

	int $siblingSoloValueCumul = 0;

	if($soloValue == 0 && $outMute != 0)
	{
		$siblingSoloValueCumul = $siblingSoloValue;
	}

	string $lIconMute = ($outMuteValue != 0 ? "Mute_ON.png" : "Mute_OFF.png" );
	string $lIconSolo = ($soloValue != 0 ? "Solo_ON.png" : "Solo_OFF.png" );
	string $lIconLock = ( $lockValue ? "Lock_ON.png" : "Lock_OFF.png" );
	string $lIconGhost = ( $ghostValue ? "Ghost_ON.png" : "Ghost_OFF.png" );

		treeView -edit -image $indentLayer 4 $lIconGhost -image $indentLayer 3 $lIconMute -image $indentLayer 2 $lIconSolo -image $indentLayer 1 $lIconLock ($toolName+"animLayerEditor");
		treeView -edit -buttonStyle $indentLayer 4 "3StateButton" -buttonStyle $indentLayer 3 "2StateButton" -buttonStyle $indentLayer 2 "2StateButton" -buttonStyle $indentLayer 1 "2StateButton" ($toolName+"animLayerEditor");
		treeView -edit -buttonTooltip $indentLayer 4 $animLayerGhostTooltip -buttonTooltip $indentLayer 3 $animLayerMuteTooltip -buttonTooltip $indentLayer 2 $animLayerSoloTooltip -buttonTooltip $indentLayer 1 $animLayerLockTooltip ($toolName+"animLayerEditor");

	
	// make the ghost icon the layer's ghost color and have it use the color as transparency if ghost is ON. Otherwise, use default color.
	// The only way to achieve that is to use 3StateButton and toggle the transparencyOverride based on the ghostValue (also refer to animLayerGhostCallback).
	// (Note that we may need to change this mel script if the button behavior changes in future)
	string $plug = $indentLayer + ".ghostColor";
	int $ghostColorIndex = `getAttr $plug`;
	float $rgb[] = `colorIndex -q ($ghostColorIndex-1)`;
	
	treeView -edit -buttonTransparencyColor $indentLayer 4 $rgb[0] $rgb[1] $rgb[2] ($toolName+"animLayerEditor");
	treeView -edit -buttonTransparencyOverride $indentLayer 4 $ghostValue ($toolName+"animLayerEditor");
	
	int $recursive = `animLayer -query -collapse $layer`;

		if($rootLayer == $layer)
	{
		treeView -edit -enableButton $indentLayer 3 false ($toolName+"animLayerEditor");
		treeView -edit -buttonVisible $indentLayer 2 false ($toolName+"animLayerEditor");
		treeView -edit -buttonVisible $indentLayer 3 false ($toolName+"animLayerEditor");
	}

	treeView -edit -buttonState $indentLayer 3 ($outMuteValue == 0 ? "buttonUp" : "buttonDown" ) -buttonState $indentLayer 2 ($soloValue == 0 ? "buttonUp" : "buttonDown" )-buttonState $indentLayer 1 ($lockValue == 0 ? "buttonUp" : "buttonDown" ) ($toolName+"animLayerEditor");

	// clear any border from Right click
	treeView -edit -borderHighlite $indentLayer 0 ($toolName+"animLayerEditor");
	

	// Highlite the selection
		treeView -edit -selectItem $indentLayer $selectedValue ($toolName+"animLayerEditor");
	
	if($selectedValue)
	{
		global string $gSelectedAnimLayers[];
		$gSelectedAnimLayers[size($gSelectedAnimLayers)] = $indentLayer;
	}
	
	//set font color
	if($outMuteValue != 0 )
	{
			treeView -edit -textColor $indentLayer 0.4 0.4 0.4 ($toolName+"animLayerEditor");
	}
	else if ($selectedValue)
	{
		treeView -edit -textColor $indentLayer 1.0 1.0 1.0 ($toolName+"animLayerEditor");
	}
	else 
	{
		treeView -edit -textColor $indentLayer 0.8 0.8 0.8 ($toolName+"animLayerEditor");
	}
		
	//set font face (bold, italic,etc.  0=none 1=bold 2= italic)
	if($overrideValue)
	{
			treeView -edit -fontFace $indentLayer 1 ($toolName+"animLayerEditor");
	}
	else
	{
		treeView -edit -fontFace $indentLayer 0 ($toolName+"animLayerEditor");
	}
		
	treeView -edit -expandItem $indentLayer $collapseValue ($toolName+"animLayerEditor");
	
	int $affectedLayer = isAffectedLayer($layer, $affectedLayers, $recursive);
	if( $affectedLayer == 1) // This layer is an affected layer
	{   
		treeView -edit -ornamentColor $layer 0.8 0.4 0.4 ($toolName+"animLayerEditor");
				treeView -edit -ornament $layer 1 0 3 ($toolName+"animLayerEditor");
	}
	else if( $affectedLayer == 2) // A child is an affected layer
	{
				treeView -edit -ornamentColor $layer 0.8 0.4 0.4 ($toolName+"animLayerEditor");
				treeView -edit -ornament $layer 1 1 3 ($toolName+"animLayerEditor");
	}
		else	//layer does not affect selected objects 
	{
		treeView -edit -ornament $layer 0 0 5 ($toolName+"animLayerEditor");
	}
	int $bestLayer = isBestLayer($layer, $bestLayers, $recursive);
	if( $bestLayer == 1) // This layer is a best layer
	{
		treeView -edit -ornamentColor $layer 0.478 1.0 0.478 ($toolName+"animLayerEditor");
		treeView -edit -ornament $layer 1 0 5 ($toolName+"animLayerEditor");
	}
	else if($bestLayer == 2) // One of his children is a best layer
	{
				treeView -edit -ornamentColor $layer 0.478 1.0 0.478 ($toolName+"animLayerEditor");
				treeView -edit -ornament $layer 1 1 5 ($toolName+"animLayerEditor");
	}

	// Disable the Mute button if the layer is muted because of a parent mute or solo
	if($rootLayer != $layer)
	{
		if( ($siblingSoloValue && !$soloValue) || $parentMuteValue )
		{
			treeView -edit -enableButton $indentLayer 3 false ($toolName+"animLayerEditor");
		}
		else
		{
			treeView -edit -enableButton $indentLayer 3 true ($toolName+"animLayerEditor");
		}
	}
}

global proc onAnimLayersAnimationChanged(string $toolName)
{
	string $allSnapShotNodes[] = `ls -type snapshot`;
	for($node in $allSnapShotNodes) 
	{
		int $currVal = `getAttr ($node+".nodeState")`;
		if ($currVal == 2) {
			setAttr ($node+".nodeState") 0;
		} else {
			setAttr ($node+".nodeState") 2;
		}
		refresh;
		setAttr ($node+".nodeState") $currVal;
	}
}

global proc onAnimLayersBaseLockChanged(string $toolName)
{
	if(`optionVar -q animLayerLockCurves`)
	{
		string $rootLayer = `animLayer -q -root`;
		if( $rootLayer != "" )
		{
			// Refresh the template state of all the layers of the scene
			$locked = `animLayer -q -lock $rootLayer`;
			string $curves[] = `ls -type animCurve`;

			for($curve in $curves) 
			{
				catchQuiet( `setAttr -l $locked ($curve+".ktv")` );
			}
		}
		// Reset the templated state of the Layer associated curves
		onAnimLayersLockChanged($toolName);
	}
}


global proc onAnimLayersLockChanged(string $toolName)
{
	if(`optionVar -q animLayerLockCurves`)
	{
		// The refresh the templated state of all the layer associated curves
		string $layerArray[] = buildAnimLayerArray();
		
		for($layer in $layerArray)
		{
			$locked = `animLayer -q -lock $layer`;
			string $curves[] = `animLayer -query -animCurves $layer`;
			for($curve in $curves) {
				setAttr -l $locked ($curve+".ktv");
			}
		}
				global string $gPlayBackSlider;
				timeControl -edit -forceRefresh $gPlayBackSlider;
	}
	updateEditorFeedbackAnimLayers($toolName);
	
}


global proc updateEditorFeedbackAnimLayers(string $toolName)
{
	string $selected[] = `ls -selection -objectsOnly`;
	string $layerArray[] = buildAnimLayerArray();

	global string $gSelectedAnimLayers[];
	clear $gSelectedAnimLayers;

	// Do not call useless method if there no layer in the scene
	if( size( $layerArray ))
	{
		string $bestLayers[] = getBestLayers($selected);
		string $affectedLayers[] = getAffectedLayers($selected);

		for ($layer in $layerArray) 
		{
			updateEditorFeedbackAnimLayer($toolName, $layer, $bestLayers, $affectedLayers);
		}
	}

	string $selectedLayers[] = getSelectedAnimLayer($toolName);
	string $lanimLayerWeightTextName = $toolName + "WeightText";
	string $lanimLayerWeightFieldName = $toolName + "WeightField";
	string $lanimLayerWeightSliderName = $toolName + "WeightSlider";
	string $lanimLayerWeightButtonName = $toolName + "WeightButton";

	int $lEnableWeightWidget = false;
	float $weightValue = 1.0;

	string $lanimLayerMoveUpButtonName = $toolName + "MoveUpButton";
	string $lanimLayerMoveDownButtonName = $toolName + "MoveDownButton";
	if( size($selectedLayers) > 1)
	{
		symbolButton -edit -enable 0 $lanimLayerMoveUpButtonName;
		symbolButton -edit -enable 0 $lanimLayerMoveDownButtonName;
	}
	else
	{
		symbolButton -edit -enable 1 $lanimLayerMoveUpButtonName;
		symbolButton -edit -enable 1 $lanimLayerMoveDownButtonName;
	}

	if( size( $selectedLayers ))
	{
		if ( (`objExists $selectedLayers[0]`) && (`objectType $selectedLayers[0]` == "animLayer"))
		{
			string $lParent = `animLayer -q -parent $selectedLayers[0]`;

			// Fake a root node if parent is the Base Layer
			if( $lParent != "")
			{
				$lEnableWeightWidget = true;
			}
		}
	}

	if( $lEnableWeightWidget )
	{
		string $weightValueName = $selectedLayers[0]+".weight";
		$weightValue = `getAttr $weightValueName`;
			
		text -edit -enable true $lanimLayerWeightTextName;
		floatField -edit -enable true $lanimLayerWeightFieldName;
		floatSlider -edit -enable true $lanimLayerWeightSliderName;
		button -edit -enable true $lanimLayerWeightButtonName;
		
		floatField -edit -value $weightValue $lanimLayerWeightFieldName;
		floatSlider -edit -value $weightValue $lanimLayerWeightSliderName;

		// Register a callback that will update the widget value
		scriptJob -compressUndo true -parent $toolName -replacePrevious -attributeChange $weightValueName ("animLayerEditorUpdateWeightSJ( \""+$toolName+"\" , \""+$weightValueName+"\" )");

	}
	else
	{
		text -edit -enable false $lanimLayerWeightTextName;
		floatField -edit -enable false $lanimLayerWeightFieldName;
		floatSlider -edit -enable false $lanimLayerWeightSliderName;
		button -edit -enable false $lanimLayerWeightButtonName;

		floatField -edit -value $weightValue $lanimLayerWeightFieldName;
		floatSlider -edit -value $weightValue $lanimLayerWeightSliderName;

		// register a dummy event in order to disable any valid temporary scriptjob
		scriptJob -compressUndo true -parent $toolName -replacePrevious -event angularToleranceChanged "animLayerEditorDoNothingSJ";
	}

	if(`exists updateActiveAnimLayerField`)
		updateActiveAnimLayerField("", {});

}

global proc animLayerEditorDoNothingSJ()
{

}

global proc animLayerEditorUpdateWeightSJ( string $pTool, string $pWeightAttribute )
{
	string $weightValueName = $pWeightAttribute;
	float $weightValue = `getAttr $weightValueName`;
					
	floatField -edit -value $weightValue ($pTool+"WeightField");
	floatSlider -edit -value $weightValue ($pTool+"WeightSlider");
}


global proc setPreferredForAllLayers(int $preferred)
{
	string $layers[] = `ls -type animLayer`;
	for($layer in $layers)
	{
		animLayer -edit -preferred $preferred $layer;
	}
}

global proc setSelectedForAllLayers(int $selected)
{
	string $layers[] = `ls -type animLayer`;
	for($layer in $layers)
	{
		animLayer -edit -selected $selected $layer;
	}
}

global proc setSelectedLayerRecursive(string $layer, int $selected, int $skipRoot )
{
	string $children[] = `animLayer -query -children $layer`;
	int $selectionKey = `optionVar -exists animLayerSelectionKey` ? `optionVar -query animLayerSelectionKey` : 1;

	if( !$skipRoot )
	{
		animLayer -edit -selected $selected $layer;
		if(!$selected) {
			animLayer -edit -preferred false $layer;
		}
		else {
			if( $selectionKey )
			{
				animLayer -edit -preferred true $layer;
			}
		}
	}
	
	int $iter = 0;
	for(; $iter < size($children); $iter++)
	{
	   setSelectedLayerRecursive($children[$iter], $selected, false );
	}
}

proc setLockedLayerRecursive( string $layer, int $locked, int $skipRoot )
{
	int $doChilds = true;

	if( !$skipRoot )
	{
		int $outMuteValue = `getAttr ($layer + ".outMute")`;

		if( $locked )
		{
			if( $outMuteValue )
			{
				evalEcho( "animLayer -edit -lock true " + $layer );
			}
			else
			{
				$doChilds = false;
			}
		}
		else
		{
			if( !$outMuteValue )
			{
				evalEcho( "animLayer -edit -lock false "+ $layer );
			}
			else
			{
				$doChilds = false;
			}
		}
	}

	if( $doChilds )
	{
		string $children[] = `animLayer -query -children $layer`;

		int $iter = 0;
		for(; $iter < size($children); $iter++)
		{
			setLockedLayerRecursive($children[$iter], $locked, false );
		}
	}
}

global proc animLayerMuteCallBack(string $item,int $buttonState)
{
	string $layer = $item;
	string $rootLayer = `animLayer -q -root`;
	if ($layer != $rootLayer)
	{
		int $mute = $buttonState;
		evalEcho( "animLayer -edit -mute " + $mute + " "+ $layer );

		int $muteLock = `optionVar -exists animLayerMuteLock` ? `optionVar -query animLayerMuteLock` : 1;

		if( $muteLock ) { 
			setLockedLayerRecursive( $layer, $mute, false );
		}
	
		animLayer -forceUIRefresh;

		// MAYA-36993, forcing refresh due to potentially inconsistent DG state after keying
		currentTime -e `currentTime -q`;
	}
}

proc pruneListForAlreadyGhostedObjects(string $inList[],string $outList[])
{
	$outList = {};
	for($inItem in $inList) {
		int $alreadyGhosted = 0;
		if(`objectType -isa shape $inItem` == 1 ||
		   `objectType -isa joint $inItem` == 1) {
		   string $ghostPlug = $inItem + ".ghosting";
		   $alreadyGhosted = `getAttr $ghostPlug`;   
		}
		else if(`objectType -isType transform $inItem` == 1) {
			string $rels[];
			$rels = `listRelatives -pa $inItem`;
			for($rel in $rels) {
				string $ghostPlug = $rel + ".ghosting";
				$alreadyGhosted = `getAttr $ghostPlug`;   
				if($alreadyGhosted)
					break;
			}
		}
		
		if(!$alreadyGhosted)
			$outList[size($outList)] = $inItem;
	}
}

global proc animLayerGhostCallBack(string $animLayerEditor, string $item,int $buttonState)
{
	string $layer = $item;

	string $ghostPlug = $layer + ".ghost";
	int $ghostValue = `getAttr $ghostPlug`;

	// Toggle the ghost value and toggle the transparencyOverride.
	// Note that we ignore the buttonState value. 
	if($ghostValue == 0)
		$ghostValue = 1;
	else
		$ghostValue = 0;
	treeView -edit -buttonTransparencyOverride $layer 4 $ghostValue $animLayerEditor;
		
	setAttr $ghostPlug $ghostValue;

	if($ghostValue == 1)
	{

		int $ghostOption = `optionVar -exists animLayerGhostOption` ? `optionVar -query animLayerGhostOption` : 1;

		if(!`exists doGhostList`) {
			source doGhost.mel;
		}

		if($ghostOption == 1) { //auto ghost current selection
			string $curSel[] = `ls -sl`;
			string $ghostSel[];
			pruneListForAlreadyGhostedObjects($curSel,$ghostSel);
			if(size($ghostSel) > 0) {

				//		Version 4
				//		 [0]		  $enable: enable or disable ghosts
				//		 [1]		  $hierarchy: whether to ghost the hierarchy below the selected object
				//		 [2]		  $ghostControl: ghostControl attribute value for ghosted objects
				//		 [3]		  $pre: ghostPreSteps attribute value for ghosted objects
				//		 [4]		  $post: ghostPostSteps attribute value for ghosted objects
				//		 [5]		  $stepSize: ghostStepSize attribute value for ghosted objects
				//		 [6]		  $frames: ghostFrames attribute value for ghosted objects
				//		 [7]		  $start: ghostRangeStart attribute value for ghosted objects
				//		 [8]		  $end: ghostRangeEnd attribute value for ghosted objects
				//		 [9]		  $useGhostDriver: whether to use first object's keys to ghost the rest of the objects
				//		 [10]		 $ghostGeometry: whether to ghost geometry
				//		 [11]		 $ghostLocator: whether to ghost locator
				//		 [12]		 $ghostJoint: whether to ghost joint
				//		 [13]		 $ghostEverythingElse: whether to ghost objects other than geometry, locator, and joint				

				doGhostList "3" { "1", "1", "2", "0", "0", "1", " 3 1 10 20", "1", "24", "0", "1", "1", "1", "0"} $ghostSel ;

			}
		}
		else if($ghostOption == 2) {//auto ghost layer members
			
			string $objectsToGhost[];
			string $layerMembers[];
			
			string $attrs[] = `animLayer -query -attribute $layer`;
			for($attr in $attrs)
			{
				$layerMembers[size($layerMembers)] = `plugNode $attr`;
			}
			pruneListForAlreadyGhostedObjects($layerMembers,$objectsToGhost);
			
			if(size($objectsToGhost) > 0)
				doGhostList "3" { "1", "1", "2", "0", "0", "1", " 3 1 10 20", "1", "24", "0", "1", "1", "1", "0"} $objectsToGhost ;

		}
	
	}
	animLayer -forceUIRefresh;
}

global proc animLayerGhostRightCallBack(string $item,int $buttonState)
{
	global string $gColorPickerWindow = "";
	if(!`window -exists $gColorPickerWindow`) { 
		string $layer = $item;
		string $ghostColorPlug = $layer + ".ghostColor";
		colorIndexPicker($ghostColorPlug, 2, 24, 0, "", "" );
		animLayer -forceUIRefresh;
	}
}

global proc animLayerSoloCallBack(string $item,int $buttonState)
{
	string $layer = $item;
	string $rootLayer = `animLayer -q -root`;
	if ($layer != $rootLayer)
	{
		int $solo = $buttonState;

		evalEcho( "animLayer -edit -solo " + $solo +" " +$layer );

		int $muteLock = `optionVar -exists animLayerMuteLock` ? `optionVar -query animLayerMuteLock` : 1;

		if( $muteLock ) { 

			string $parentLayer = `animLayer -q -parent $layer`;

			if($parentLayer != "")
			{
				setLockedLayerRecursive( $parentLayer, $solo, true );
				setLockedLayerRecursive( $layer, !$solo, false );
			}
			else
			{
				// Base Layer special case
				setLockedLayerRecursive( $layer, $solo, true );
			}
		}
	}
	animLayer -forceUIRefresh;
}

global proc animLayerLockCallBack(string $item,int $buttonState)
{
	string $layer = $item;

	evalEcho( "animLayer -edit -lock " + $buttonState + " " + $layer );
	animLayer -forceUIRefresh;
}

global proc animLayerDragAndDropCallback(string $dropItems[],string $oldParents[],int $oldIndexes[],
										 string $newParent,int $newIndex[],string $newItemPrev,string $newItemNext)
{
	string $prevLayer = "";
	string $layer = $newItemPrev;
	string $newParentLayer = $newParent;
	for($layerIndex = 0; $layerIndex < size($dropItems); $layerIndex++)
	{
	$prevLayer = $layer;
	$layer = $dropItems[$layerIndex];
	
	if( $prevLayer != "" )
	{
		string $prevLayerParent = `animLayer -q -parent $prevLayer`;

		if( $prevLayerParent == "")
		{
		$prevLayer = "";
		}
	}

	if( $newParentLayer != "" && $oldParents[$layerIndex] != $newParent)
	{
		//reparent operation		
		evalEcho( "animLayer -edit -parent " + $newParentLayer + " " + $layer );
	}

	//reorder operation
	if( $prevLayer != "")
	{
		evalEcho( "animLayer -edit -moveLayerAfter " + $prevLayer +" "+ $layer );
	}
	else if($newItemNext !="") 
	{
		string $nextLayer = $newItemNext;
		evalEcho( "animLayer -edit -moveLayerBefore " + $nextLayer +" "+ $layer );
	}
	}
	animLayer -forceUIRefresh;
}

global proc layerEditorMoveAnimItem(string $toolName, int $up)
//
//	Description
//		Move current animation layer up or down in the tree
//		when user presses reorder buttons
//
{
	string $layers[] = getSelectedAnimLayer($toolName);
	if(size($layers) > 1)
		return;
	string $layer = $layers[0];
	int $reversed = `optionVar -query animLayerReverseLayerStack`;
	string $tool = $toolName + "animLayerEditor";

	if($reversed)
		$up = !$up;
	if($layer != "")
	{
		int $layerIndex = `treeView -itemIndex $layer -query $tool`;
		int $newIndex = $layerIndex + ($up ? -1 : 1);
		string $parent = `animLayer -query -parent $layer`;
		if($parent == `animLayer -query -root`)
			$newIndex--;
		string $children[] = `animLayer -query -children $parent`;
		int $treeSize = size($children);
		if($newIndex < 0 || $newIndex >= $treeSize)
			return;
		if(! $up)
			evalEcho( "animLayer -edit -moveLayerAfter "+ $children[$newIndex] + " "+ $layer );
		else
			evalEcho( "animLayer -edit -moveLayerBefore " + $children[$newIndex] +" "+$layer );
	}
	
	rebuildAnimLayerEditor($toolName);
}

global proc string animLayerEditLabelCallback(string $item,string $newLabel)
{
	// If the user attempts to rename the animation layer to the empty string
	// and an object is selected, this object will be renamed AnimLayer# and the
	// animation layer will be set to blank. To avoid these situations, we store
	// the set of currently selected objects and deselect everything.
	string $selected[] = `ls -sl`;
	select -cl;
	
	// Next we proceed with the rename logic, but only do so ...
	string $newLayerName;
	string $layer = $item;
	string $newItem = "";
	
	// ... if the name has actually changed and if the layer name is different
	//	 from the base animation layer.
	if($layer != $newLabel && $layer != `animLayer -q -root`) {
		
		// Assuming this holds, we issue the rename command and store the name
		// of the new item.
		string $cmd = `format -s $layer -s $newLabel "rename ^1s ^2s"`;
		if(!catch( $newLayerName = evalEcho($cmd)))
			$newItem = $newLayerName;
	}

	// Lastly, we re-select scene objects and refresh the UI
	if (size($selected))
		select -r $selected;

	animLayer -forceUIRefresh;

	return $newItem;
}

global proc animLayerExpandCollapseCallback(string $item,int $expand)
{
	string $layer = $item;
	
	string $children[] = `animLayer -query -children $layer`;
	
	if(size($children)) { 					
	int $collapse = !$expand;
	int $selected = `animLayer -query -selected $layer`;

	animLayer -edit -collapse $collapse $layer; 

	int $selectOnCollapse = `optionVar -exists animLayerSelectOnCollapse` ? `optionVar -query animLayerSelectOnCollapse` : 1;

	if( $collapse && $selectOnCollapse ){ 
		setSelectedLayerRecursive($layer, $selected, true ); 
	}
	}
}

global proc updateAnimLayerEditor(string $toolName)
{
	$filterLayers = `optionVar -exists animLayerFilterActive` ? `optionVar -query animLayerFilterActive` : 0;
	if($filterLayers)
		rebuildAnimLayerEditor($toolName);
	else
		updateEditorFeedbackAnimLayers($toolName);
}

global proc rebuildAnimLayerEditor(string $toolName)
{
	string $selected[] = `ls -selection -objectsOnly`;
	string $layerArray[] = buildAnimLayerArray();
	string $bestLayers[] = getBestLayers($selected);
	string $affectedLayers[] = getAffectedLayers($selected);

	global string $gSelectedAnimLayers[];
	clear $gSelectedAnimLayers;

	string $indentLayer;
	string $layer;

	// Remove all old layer stuff
	treeView -edit -removeAll ($toolName+"animLayerEditor");

	//	Get the current array of layer buttons.
	//	

	for ($indentLayer in $layerArray) 
	{
			int $lIsBaseLayer = false;

			$layer = $indentLayer;

			string $parentLayer = `animLayer -q -parent $layer`;
			if($parentLayer != "")
			{
				string $grandParentLayer = `animLayer -q -parent $parentLayer`;

				// Fake a root node if parent is the Base Layer
				if( $grandParentLayer == "")
				{
					$parentLayer = "";
				}
			}
			else
			{
				$lIsBaseLayer = true;
			}
				
			treeView -edit -addItem $indentLayer $parentLayer ($toolName+"animLayerEditor");

			// update display label and remove namespace if requested 
			int $showNamespace  = `optionVar -exists animLayerShowNamespace` ? `optionVar -query animLayerShowNamespace` : 1;

			string $name = displayLabel( $showNamespace, $indentLayer);
		
			treeView -edit -displayLabel $indentLayer $name ($toolName+"animLayerEditor");

			
			$filterLayers = `optionVar -exists animLayerFilterActive` ? `optionVar -query animLayerFilterActive` : 0;
			if($filterLayers)
			{
				int $visible = isAffectedLayer($indentLayer, $affectedLayers, 0);
				treeView -edit -itemVisible $indentLayer $visible ($toolName+"animLayerEditor");
			}

			treeView -edit -image $indentLayer 1 "Mute_OFF.png" -image $indentLayer 2 "Solo_OFF.png" -image $indentLayer 3 "Lock_OFF.png" ($toolName+"animLayerEditor");

			if( $lIsBaseLayer )
			{
				treeView -edit -enableButton $indentLayer 3 false ($toolName+"animLayerEditor");
			}
			
			$buttonsOnRight = `optionVar -exists animLayerButtonsOnRight` ? `optionVar -query animLayerButtonsOnRight` : 0;
			$reverseLayerStack = `optionVar -exists animLayerReverseLayerStack` ? `optionVar -query animLayerReverseLayerStack` : 1;
			treeView -edit -attachButtonRight $buttonsOnRight -reverseTreeOrder $reverseLayerStack ($toolName+"animLayerEditor");

			updateEditorFeedbackAnimLayer($toolName, $indentLayer, $bestLayers, $affectedLayers);

	}
	
	if(`exists updateActiveAnimLayerField`)
		updateActiveAnimLayerField("", {});
	updateAddButtons();
}

global proc int animLayerEditorOnSelect(string $item,int $itemSelected)
{
	
	string $layer = $item;
	int $selected = `animLayer -query -selected $layer`;
	int $collapse = `animLayer -query -collapse $layer`;
	int $selectOnCollapse = `optionVar -exists animLayerSelectOnCollapse` ? `optionVar -query animLayerSelectOnCollapse` : 1;
	int $selectionKey = `optionVar -exists animLayerSelectionKey` ? `optionVar -query animLayerSelectionKey` : 1;
	global string $gSelectedAnimLayers[];

	if( $itemSelected /*&& !$selected*/ ) {
		animLayer -edit -selected true $layer;
	int $found = 0;
	for($selLayer in $gSelectedAnimLayers)
	{
		if($selLayer == $item) {
			$found = 1;
			break;
		}
	}
	if(!$found)
		$gSelectedAnimLayers[size($gSelectedAnimLayers)] = $layer;
	
		 selectionConnection -edit -select $item animLayerHighlightList;
		
		if( $selectionKey )
		{
			animLayer -edit -preferred true $layer;
		}
						
		if($collapse && $selectOnCollapse )
		{
			setSelectedLayerRecursive($layer, true, true );
		}
	}
	else if(!$itemSelected && $selected) {
		animLayer -edit -selected false $layer; 
		animLayer -edit -preferred false $layer;
				
		string $newSelectedLayers[];
		int $found = 0;
		for($loopLayer in $gSelectedAnimLayers)
		{
			if($loopLayer != $item)
			{
				$newSelectedLayers[size($newSelectedLayers)] = $loopLayer;
			}
		}
		$gSelectedAnimLayers = $newSelectedLayers;
		
		selectionConnection -edit -deselect $item animLayerHighlightList;

		if($collapse && $selectOnCollapse )
		{
			setSelectedLayerRecursive($layer, false, true );
		}
	}

	return true;
}


// This function will return all the layer found in a scene that are not
// in the layers array
proc string[] getExclusiveLayerSet(string $layers[])
{
	string $allLayers[] = `ls -type animLayer`;
	string $return[];
	int $count = 0;
	for($layer in $allLayers)
	{
		int $found = false;
		for($child in $layers)
		{
			if ($child == $layer )
			{
				$found = true;
				break;
			}
		}

		// Add this layer has a potentiel parent if not found in childLayers
		// array and this layer is not a root layer
		if(!$found && size(`animLayer -query -parent $layer`))
		{
			$return[$count++] = $layer;
		}
	}
	return $return;
}

global proc layerInitialiseParameterDefaults()
{
	// Since Parameters can be read different location we correcly initialize the defaults here 
	// in that unique single location

	if( !`optionVar -exists animLayerSelectionKey` )
	{
		optionVar -intValue "animLayerSelectionKey" 1;
	}

	if( !`optionVar -exists animLayerMuteLock` )
	{
		optionVar -intValue "animLayerMuteLock" 1;
	}

	if( !`optionVar -exists animLayerSelectOnCollapse` )
	{
		optionVar -intValue "animLayerSelectOnCollapse" 1;
	}
	
	if( !`optionVar -exists animLayerFilterOptions` )
	{
		// 1 == all affecting
		// 2 == active
		// 3 == selected
		// 4 == active and selected
		optionVar -intValue "animLayerFilterOptions" 1;
	}
	
	if( !`optionVar -exists animLayerButtonsOnRight` )
	{
		optionVar -intValue "animLayerButtonsOnRight" 0;
	}
	
	if( !`optionVar -exists animLayerReverseLayerStack` )
	{
		optionVar -intValue "animLayerReverseLayerStack" 1;
	}
	
	if( !`optionVar -exists animLayerLockCurves` )
	{
		optionVar -intValue "animLayerLockCurves" 1;
	}
	
	if( !`optionVar -exists animLayerDefaultPassthroughMode` )
	{
		optionVar -intValue "animLayerDefaultPassthroughMode" 1;
	}
	
	if( !`optionVar -exists animLayerDefaultRotationMode` )
	{
		//0 for euler, 1 for quaternion
		optionVar -intValue "animLayerDefaultRotationMode" 0;
	}
	
	if( !`optionVar -exists animLayerDefaultScaleMode` )
	{
		//1 for multiply, 0 for additive
		optionVar -intValue "animLayerDefaultScaleMode" 1;
	}
	
	if( !`optionVar -exists animLayerFilterActive` )
	{
		optionVar -intValue "animLayerFilterActive" 0;
	}
	
	if( !`optionVar -exists animLayerGhostOption` )
	{
		optionVar -intValue "animLayerGhostOption" 1;
	}
}

global proc layerEditorBuildAnimOptionMenu( string $parentMenu )
{
	int $selectionKey = `optionVar -exists animLayerSelectionKey` ? `optionVar -query animLayerSelectionKey` : 1;
	int $muteLock = `optionVar -exists animLayerMuteLock` ? `optionVar -query animLayerMuteLock` : 1;
	int $selectOnCollapse = `optionVar -exists animLayerSelectOnCollapse` ? `optionVar -query animLayerSelectOnCollapse` : 1;
	int $buttonsOnRight = `optionVar -exists animLayerButtonsOnRight` ? `optionVar -query animLayerButtonsOnRight` : 0;
	int $programmerReverseLayerStack = `optionVar -exists animLayerReverseLayerStack` ? `optionVar -query animLayerReverseLayerStack` : 1;
	int $lockCurves = `optionVar -exists animLayerLockCurves` ? `optionVar -query animLayerLockCurves` : 1;
	int $filterActive = `optionVar -exists animLayerFilterActive` ? `optionVar -query animLayerFilterActive` : 0;
	int $makeNewLayersCurrent = `optionVar -exists animLayerMakeNewLayersCurrent` ? `optionVar -query animLayerMakeNewLayersCurrent` : 0;
	int $insertNewLayersAfterCurrent = `optionVar -exists animLayerInsertNewAfterCurrent` ? `optionVar -query animLayerInsertNewAfterCurrent` : 0;
	int $animLayerGhostOption = `optionVar -exists animLayerGhostOption` ? `optionVar -query animLayerGhostOption` : 1;
	
	

	menu -edit -deleteAllItems $parentMenu;
	setParent -menu $parentMenu;

	menuItem -label (uiRes("m_layerEditor.kSelectionKeyAnimLayersA")) -checkBox ($selectionKey==2) -command ("optionVar -intValue animLayerSelectionKey 2; setPreferredForAllLayers(false); setSelectedForAllLayers(false);");
	menuItem -label (uiRes("m_layerEditor.kSelectionKeyAnimLayersB")) -checkBox ($selectionKey==0) -command ("optionVar -intValue animLayerSelectionKey 0; setPreferredForAllLayers(false); setSelectedForAllLayers(false);");
	menuItem -label (uiRes("m_layerEditor.kSelectionKeyAnimLayersC")) -checkBox ($selectionKey==1) -command ("optionVar -intValue animLayerSelectionKey 1; setPreferredForAllLayers(false); setSelectedForAllLayers(false);");

	menuItem -divider true;
	
	menuItem -label (uiRes("m_layerEditor.kAnimLayerMakeNewLayersCurrent")) -checkBox $makeNewLayersCurrent -command ("optionVar -intValue animLayerMakeNewLayersCurrent #1;");
	menuItem -label (uiRes("m_layerEditor.kAnimLayerInsertNewAfterCurrent")) -checkBox $insertNewLayersAfterCurrent -command ("optionVar -intValue animLayerInsertNewAfterCurrent #1;");
	menuItem -label (uiRes("m_layerEditor.kSelectOnCollapse")) -checkBox $selectOnCollapse -command ("optionVar -intValue animLayerSelectOnCollapse #1;");
	menuItem -divider true;

	menuItem -label (uiRes("m_layerEditor.kMuteLockAnimLayers")) -checkBox $muteLock -command ("optionVar -intValue animLayerMuteLock #1;");
	menuItem -label (uiRes("m_layerEditor.kLockCurves")) -checkBox $lockCurves -command ("optionVar -intValue animLayerLockCurves #1;");
	menuItem -divider true;
	
	menuItem -label (uiRes("m_layerEditor.kButtonsOnRight")) -checkBox $buttonsOnRight -command ("optionVar -intValue animLayerButtonsOnRight #1; animLayer -forceUIRebuild;");
	menuItem -label (uiRes("m_layerEditor.kReverseLayerStack")) -checkBox ($programmerReverseLayerStack==0) -command ("int $rev = #1; if($rev ==0) $rev = 1; else $rev = 0; optionVar -intValue animLayerReverseLayerStack $rev; animLayer -forceUIRebuild;");
	menuItem -divider true;
	
	menuItem -label (uiRes("m_layerEditor.kGhostSelected")) -checkBox ($animLayerGhostOption == 1) -command ("optionVar -intValue animLayerGhostOption 1;");
	menuItem -label (uiRes("m_layerEditor.kGhostLayerObjects")) -checkBox ($animLayerGhostOption == 2) -command ("optionVar -intValue animLayerGhostOption 2;");
	menuItem -label (uiRes("m_layerEditor.kGhostNone")) -checkBox ($animLayerGhostOption == 0) -command ("optionVar -intValue animLayerGhostOption 0;");
	
}

global proc layerEditorBuildAnimShowMenu( string $parentMenu )
{
	// 1 == all affecting
	// 2 == active
	// 3 == selected
	// 4 == active and selected
	int $filterOptions = `optionVar -exists animLayerFilterOptions` ? `optionVar -query animLayerFilterOptions` : 1;
	
	menu -edit -deleteAllItems $parentMenu;
	setParent -menu $parentMenu;
	
	int $filterActive = `optionVar -exists animLayerFilterActive` ? `optionVar -query animLayerFilterActive` : 0;
	
	menuItem -label (uiRes("m_layerEditor.kAllAffectingLayers")) -checkBox $filterActive -command ("optionVar -intValue animLayerFilterActive 1; animLayer -forceUIRebuild;");
	menuItem -label (uiRes("m_layerEditor.kAllLayers")) -checkBox ($filterActive==0) -command ("optionVar -intValue animLayerFilterActive 0; animLayer -forceUIRebuild;");
	menuItem -divider true;

	menuItem -label (uiRes("m_layerEditor.kAnimLayersShowMenuOtherAnimToolsOpt")) -subMenu true;
	radioMenuItemCollection;
	menuItem -label (uiRes("m_layerEditor.kAnimLayerFilterOptionsAllAffecting"))
		-radioButton ($filterOptions == 1)
		-command ("optionVar -intValue animLayerFilterOptions 1")
		animLayerFilterOptionsAllAffectingItem;
	menuItem -label (uiRes("m_layerEditor.kAnimLayerFilterOptionsActive"))
		-radioButton ($filterOptions == 2)
		-command ("optionVar -intValue animLayerFilterOptions 2")
		animLayerFilterOptionsActiveItem;
	menuItem -label (uiRes("m_layerEditor.kAnimLayerFilterOptionsSelected"))
		-radioButton ($filterOptions == 3)
		-command ("optionVar -intValue animLayerFilterOptions 3")
		animLayerFilterOptionsSelectedItem;
	menuItem -label (uiRes("m_layerEditor.kAnimLayerFilterOptionsActiveAndSelected"))
		-radioButton ($filterOptions == 4)
		-command ("optionVar -intValue animLayerFilterOptions 4")
		animLayerFilterOptionsActiveAndSelectedItem;
				
	setParent -m ..;

	menuItem  -divider true;
	int $showNamespace  = `optionVar -exists animLayerShowNamespace` ? `optionVar -query animLayerShowNamespace` : 1;

	menuItem -checkBox $showNamespace -label (uiRes("m_layerEditor.kAnimLayerShowNameSpaces"))
			 -command ("optionVar -intValue animLayerShowNamespace " + ($showNamespace?"0":"1" ) + ";  animLayer -forceUIRebuild;");

	menuItem  -divider true;

	string $floatingLayersEditor = (uiRes("m_layerEditor.kFloatingAnimLayer"));
	string $lFloatingWindowCommand = "openFloatingAnimLayerEditor()";
	$floatingWindowMenuItemForAnimLayers = `menuItem -label $floatingLayersEditor`;
	menuItem -edit -command ($lFloatingWindowCommand) $floatingWindowMenuItemForAnimLayers;

}

global proc layerEditorBuildAnimHelpMenu( string $parentMenu)
{
	menu -edit -deleteAllItems $parentMenu;
	setParent -menu $parentMenu;
	menuItem -ltVersion 2017 -label (uiRes("m_layerEditor.kAnimLayersHelpItem"))
	-command "showHelp AnimationLayers";
	setParent -m ..;
}

global proc int layerEditorBuildPopupMenu(string $toolName, string $parentMenu, string $item)
{
	popupMenu -edit -deleteAllItems $parentMenu;
	string $layers[]=getSelectedAnimLayer($toolName); 
	int $clickedIsSelected=0;
	for ($selected in $layers)
	{
		if ($selected == $item)
		{
			$clickedIsSelected = 1;
			break;
		}
	}
	int $popupMenu = 0;
	if( size($layers)  && $clickedIsSelected )
	{
		layerEditorAnimLayersPopup($layers,$toolName,$parentMenu,0);
		$popupMenu = 1;
	}
	else if ($item != "")
	{
		$tool = $toolName +"animLayerEditor";
		treeView -edit -borderHighliteColor $item 0 0 0 $tool;
		treeView -edit -borderHighlite $item 1 $tool;
		animLayer -forceUIRefresh;
		string $targetLayers[];
		$targetLayers[0]=$item;
		layerEditorAnimLayersPopup($targetLayers,$toolName,$parentMenu,1);
		$popupMenu = 1;
}
	return $popupMenu;
}

proc int animLayersIsOneLocked(string $layers[])
{
	int $locked = 0;
	for ($layer in $layers)
	{
		int $lockValue = `animLayer -query -lock $layer`;
		if ($lockValue)
		{
			$locked = $lockValue;
			break; 
		}
	}
	return $locked;
}

proc int animLayersIsOneMuted(string $layers[])
{
	int $muted = 0;
	for ($layer in $layers)
	{
		string $outMute = $layer+".outMute";
		int $muteValue = `getAttr $outMute`;
		if ($muteValue)
		{
			$muted = $muteValue;
			break;
		}
	}
	return $muted;
}

proc int animLayersIsOneSoloed(string $layers[])
{
	int $soloed = 0;
	for ($layer in $layers)
	{
		string $solo = $layer + ".solo";
		int $soloValue = `getAttr $solo`;
		if ($soloValue)
		{
			$soloed = $soloValue;
			break;
		}
	}
	return $soloed;
}


global proc layerEditorAnimLayersPopup(string $layers[], string $toolName, string $parentMenu, int $outline)
{
		int $singleLayer = 1;
		if (size($layers) > 1)
		{
			$singleLayer = 0;
		}
		int $rotInterpolationMode = `getAttr ($layers[0]+".rotationAccumulationMode")`;
		int $scaleInterpolationMode = `getAttr ($layers[0]+".scaleAccumulationMode")`;
		int $overrideMode = `animLayer -query -override $layers[0]`;
		int $passthroughMode = `animLayer -query -passthrough $layers[0]`;
		string $override = $layers[0] + ".override";
		string $rootLayer = `animLayer -q -root`;
		int $overrideValue = `getAttr $override`;
		
		int $soloValue= animLayersIsOneSoloed($layers);
		int $lockValue= animLayersIsOneLocked($layers);
		int $outMuteValue= animLayersIsOneMuted($layers);
		
		string $layerString = "{";
		
		int $foundRootLayer = 0;
		for ($layer in $layers)
		{
			$layerString+="\""+$layer+"\",";
			if($layer == $rootLayer)
				$foundRootLayer = 1;
		}
		
		$layerString=(substring ($layerString,1,(size($layerString) - 1)));  // get rid of trailing ","
		
		$layerString+="}";

		string $lSelectionCommand = "string $lSelection[]=`ls -selection`;";
		string $lDuplicateLayerCommand = "string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
								 layerEditorCopyAnimLayer($lLayers)";
		string $lDuplicateLayerNoAnimCommand =	"string $lLayers[]=getSelectedAnimLayer(\""+$toolName+"\"); \
										layerEditorCopyAnimLayerNoAnim($lLayers)";

		setParent -menu $parentMenu;

		menuItem -label (uiRes("m_layerEditor.kAddSelectedObjectsAnimLayerRC"))
				 -enable (!$foundRootLayer)
				 -command ($lSelectionCommand+"string $layers[]="+$layerString+"; layerEditorAddObjectsAnimLayer($lSelection, $layers, 0)");

		$addObjectsOptionsMenuItemForAnimLayers = `menuItem -optionBox true -annotation (uiRes("m_layerEditor.kAnimLayerAddSelectedObjectsOptions2"))`;
		string $lAddSelectedOptionsCommand = "string $lSelection[]=`ls -selection`; \
								   string $layers[]="+$layerString+"; layerEditorAddObjectsAnimLayer($lSelection, $layers,1)";
		menuItem -edit -command ($lAddSelectedOptionsCommand) -enable (!$foundRootLayer) $addObjectsOptionsMenuItemForAnimLayers;

		menuItem -label (uiRes("m_layerEditor.kRemoveSelectedObjectsAnimLayerRC"))
				 -enable (!$foundRootLayer)
				 -command ($lSelectionCommand+"string $layers[]="+$layerString+"; layerEditorRemoveObjectsAnimLayer($lSelection, $layers )");

		menuItem -label (uiRes("m_layerEditor.kExtractSelectedObjectsAnimLayerRC"))
				 -command ($lSelectionCommand+"string $layers[]="+$layerString+"; layerEditorExtractObjectsAnimLayer($lSelection, $layers )");

		menuItem -label (uiRes("m_layerEditor.kSelectObjectsAnimLayerRC"))
				 -enable (!$foundRootLayer)
				 -command ("string $layers[]="+$layerString+"; layerEditorSelectObjectAnimLayer($layers)");

		menuItem -divider true;
		
		menuItem -label (uiRes("m_layerEditor.kDuplicateAnimLayers"))				
				-command ($lDuplicateLayerCommand);
				
		menuItem -label (uiRes("m_layerEditor.kDuplicateAnimLayersNoAnim"))				
				-command ($lDuplicateLayerNoAnimCommand);

		menuItem -label (uiRes("m_layerEditor.kMergeSelectedAnimLayerRC"))
				 -command ("string $layers[]="+$layerString+"; layerEditorMergeAnimLayer( $layers, 0 )");

		menuItem -optionBox true
				 -command ("string $layers[]="+$layerString+"; layerEditorMergeAnimLayer( $layers, 1 )");

		menuItem -divider true;
				
		string $lockCommand = "string $lLayers[]="+$layerString+";for ($layer in $lLayers){animLayerLockCallBack($layer,"+($lockValue?0:1)+");}";
		string $muteCommand = "string $lLayers[]="+$layerString+";for ($layer in $lLayers){animLayerMuteCallBack($layer,"+($outMuteValue?0:1)+");}";
		string $soloCommand = "string $lLayers[]="+$layerString+";for ($layer in $lLayers){animLayerSoloCallBack($layer,"+($soloValue?0:1)+");}";

		menuItem -checkBox ($lockValue?1:0) -label (uiRes("m_layerEditor.kLockRMBitem")) 
			-command $lockCommand;
				
		menuItem -checkBox ($outMuteValue?1:0) -label (uiRes("m_layerEditor.kMuteRMBitem")) 
			-enable (!$foundRootLayer)
			-command $muteCommand;
				
		menuItem -checkBox ($soloValue?1:0) -label (uiRes("m_layerEditor.kSoloRMBitem")) 
			-enable (!$foundRootLayer)
			-command $soloCommand;
		
		string $lExclusiveSoloCommand ="string $layers[]="+$layerString+"; layerEditorExclusiveSoloAnimLayer($layers);";

		menuItem -label (uiRes("m_layerEditor.kExclusiveSoloAnimLayer"))
				 -enable (!$foundRootLayer)
				 -command ($lExclusiveSoloCommand);
		
		menuItem -divider true;
		
		menuItem -label (uiRes("m_layerEditor.kSelectAllAnimLayers2"))
			-command ("setSelectedForAllLayers(1)");
	
		
		menuItem -label (uiRes("m_layerEditor.kSelectBranchAnimLayers2"))
			-enable (!$foundRootLayer)
			-command ("string $layers[]="+$layerString+"; for ($target in $layers){setSelectedLayerRecursive($target, 1, 0 );}");

		string $lSelectLayerNodeCommand = "string $layers[]="+$layerString+";string $lCmd = \"select -replace -noExpand \"; for ($target in $layers){ $lCmd+= $target + \" \"; }; evalEcho( $lCmd ); ";

		menuItem -label (uiRes("m_layerEditor.kSelectAnimLayer"))
			 -enable (!$foundRootLayer)
			 -command ($lSelectLayerNodeCommand);
		
		
		menuItem -divider true;

		menuItem -label (uiRes("m_layerEditor.kAnimLayersExportLayer"))
			 -enable (!$foundRootLayer)
			 -command ("string $layers[]="+$layerString+"; animLayersExport($layers,0)");
			 
		menuItem -label (uiRes("m_layerEditor.kAnimLayersExportBranch"))
			 -enable (!$foundRootLayer)
			 -command ("string $layers[]="+$layerString+"; animLayersExport($layers,1)");
			 
		menuItem -divider true;

		menuItem -label (uiRes("m_layerEditor.kRelationshipAnimLayerRC"))
				 -enable (!$foundRootLayer)
				 -command ("string $layers[]="+$layerString+"; relationshipEditor( \"animLayers\", $layers, {} );");

		menuItem -label (uiRes("m_layerEditor.kAttributeEditorAnimLayerRC"))
				 -enable (!$foundRootLayer)
				 -command ("string $layers[]="+$layerString+"; select -replace -noExpand $layers; editSelected();");
		
		menuItem -divider true;
		
		menuItem -label (uiRes("m_layerEditor.kDeleteAnimLayerRC"))
				 -enable (!$foundRootLayer)
				 -command ("string $layers[]="+$layerString+"; deselectAnimLayers(\""+$toolName+"\", $layers); layerEditorDeleteAnimLayer($layers)");
		
		menuItem -label (uiRes("m_layerEditor.kEmptyAnimLayers"))
				-enable (!$foundRootLayer)
				-command ("string $layers[]="+$layerString+"; for ($layer in $layers) evalEcho( \"animLayer -edit -removeAllAttributes \"+$layer );");
		menuItem -label (uiRes("m_layerEditor.kDeleteEmptyAnimLayers"))
				-enable (!$foundRootLayer)
				-command ("deleteEmptyAnimLayers()");
		
		menuItem -divider true;



		string $lSelectCommand = "string $layers[]="+$layerString+"; select -replace -noExpand $layers;";

       	string $lWarningCheckSubCommand = " animLayerWarnNonEmptyAccChange($layers) ;";


		string $quatCommand = ("string $layers[]="+$layerString+"; for($layer in $layers) evalEcho( \"setAttr \"+$layer+\".rotationAccumulationMode 1\");"+$lWarningCheckSubCommand);
		string $eulerCommand = ("string $layers[]="+$layerString+"; for($layer in $layers) evalEcho( \"setAttr \"+$layer+\".rotationAccumulationMode 0\");"+$lWarningCheckSubCommand);
				
		string $scaleMultiplyCommand = ("string $layers[]="+$layerString+"; for($layer in $layers) evalEcho( \"setAttr \"+$layer+\".scaleAccumulationMode 1\");"+$lWarningCheckSubCommand);
		string $scaleAdditiveCommand = ("string $layers[]="+$layerString+"; for($layer in $layers) evalEcho( \"setAttr \"+$layer+\".scaleAccumulationMode 0\");"+$lWarningCheckSubCommand);

		string $overrideCommand = ("string $layers[]="+$layerString+"; for($layer in $layers) evalEcho( \"animLayer -edit -override 1 \"+$layer );"+$lWarningCheckSubCommand);
		string $additiveCommand = ("string $layers[]="+$layerString+"; for($layer in $layers) evalEcho( \"animLayer -edit -override 0 \"+$layer );"+$lWarningCheckSubCommand);
		string $passthroughCommand = ("string $layers[]="+$layerString+"; for($layer in $layers) evalEcho( \"animLayer -edit -passthrough "+ !$passthroughMode +" \"+$layer);"+$lWarningCheckSubCommand);

		menuItem -label (uiRes("m_layerEditor.kLayerModeAnimLayer")) -enable (!$foundRootLayer) -subMenu true;

		menuItem -checkBox ($overrideMode?0:1) -label (uiRes("m_layerEditor.kAdditiveAnimLayer"))
				 -enable (!$foundRootLayer)
				 -command ($additiveCommand);

		menuItem -checkBox $overrideMode -label (uiRes("m_layerEditor.kOverrideAnimLayer"))
				 -enable (!$foundRootLayer)
				 -command ($overrideCommand);
		
		menuItem  -divider true;

		menuItem -checkBox ($passthroughMode?1:0) -enable ($overrideMode && !$foundRootLayer) -label (uiRes("m_layerEditor.kPassthroughAnimLayer"))
				 -command ($passthroughCommand);

		setParent -menu ..;

		menuItem -label (uiRes("m_layerEditor.kLayerRotationAccAnimLayer")) -enable (!$foundRootLayer) -subMenu true;

		menuItem -checkBox ($rotInterpolationMode?0:1) -label (uiRes("m_layerEditor.kEulerAnimLayer"))
				 -enable (!$foundRootLayer)
				 -command ($eulerCommand);
		
		menuItem -checkBox $rotInterpolationMode -label (uiRes("m_layerEditor.kQuatAnimLayer"))
				 -enable (!$foundRootLayer)
				 -command ($quatCommand);

		setParent -menu ..;

		menuItem -label (uiRes("m_layerEditor.kLayerScaleAccAnimLayer")) -enable (!$foundRootLayer) -subMenu true;
		
		menuItem -checkBox $scaleInterpolationMode -label (uiRes("m_layerEditor.kScaleMultiplyAnimLayer"))
				 -enable (!$foundRootLayer)
				 -command ($scaleMultiplyCommand);
		
		menuItem -checkBox ($scaleInterpolationMode?0:1) -label (uiRes("m_layerEditor.kScaleAdditiveAnimLayer"))
				 -enable (!$foundRootLayer)
				 -command ($scaleAdditiveCommand);
		
	
}

global proc string layerEditorCreateAnimLayer( int $addSelection , int $createOverrideLayer)
{
	string $animLayerCmd = "animLayer ";
	$animLayerCmd = $animLayerCmd + " " + "AnimLayer1";
	string $layer = evalEcho($animLayerCmd);
	
	int $passthroughMode = `optionVar -exists animLayerDefaultPassthroughMode` ? `optionVar -query animLayerDefaultPassthroughMode` : 1;
	int $rotationMode = `optionVar -exists animLayerDefaultRotationMode` ? `optionVar -query animLayerDefaultRotationMode` : 0;
	int $scaleMode = `optionVar -exists animLayerDefaultScaleMode` ? `optionVar -query animLayerDefaultScaleMode` : 1;
	int $makeNewLayersCurrent = `optionVar -exists animLayerMakeNewLayersCurrent` ? `optionVar -query animLayerMakeNewLayersCurrent` : 0;
	int $insertNewLayersAfterCurrent = `optionVar -exists animLayerInsertNewAfterCurrent` ? `optionVar -query animLayerInsertNewAfterCurrent` : 0;
	int $reverseLayerStack = `optionVar -exists animLayerReverseLayerStack` ? `optionVar -query animLayerReverseLayerStack` : 1;
	global string $gSelectedAnimLayers[];
	
	
	if($createOverrideLayer)
	{
		evalEcho( "animLayer -edit -override 1 " + $layer );
		evalEcho( "animLayer -edit -passthrough " + $passthroughMode +" "+ $layer );
	}
	
	evalEcho( "setAttr "+$layer+".rotationAccumulationMode " + $rotationMode );
	evalEcho( "setAttr "+$layer+".scaleAccumulationMode " + $scaleMode );
	
	if ( $insertNewLayersAfterCurrent && size($gSelectedAnimLayers) )
	{
		evalEcho( "animLayer -edit -moveLayerAfter "+$gSelectedAnimLayers[size($gSelectedAnimLayers)-1] +" "+ $layer );
	}
	if ( $makeNewLayersCurrent )
	{
		int $selectionKey = `optionVar -exists animLayerSelectionKey` ? `optionVar -query animLayerSelectionKey` : 1;
		if ( size($gSelectedAnimLayers) )
		{
			for ($lay in $gSelectedAnimLayers)
			{
				animLayer -edit -selected 0 $lay;
				animLayer -edit -preferred 0 $lay;
			}
		}
		animLayer -edit -selected 1 $layer;
		if( $selectionKey )
		{
				animLayer -edit -preferred true $layer;
		}
		   
	}
	
	if ($makeNewLayersCurrent || $addSelection )
	{
		string $lLayers[];
		$lLayers[0] = $layer;
		$gSelectedAnimLayers = $lLayers; 
	}
	
	if( $addSelection )
	{
		performAnimLayerAddObjects( 0 );
	}
	
	return $layer;
}

global proc layerEditorDeleteAnimLayer(string $layers[])
{
	// Care must be taken when deleting layer
	// because deleting a parent layer will also delete all the children layer
	// So if this function receive as input a layer array containning some parent and child layer
	// we must check if the layer still exists before try to delete it
	string $lRootLayer = `animLayer -q -root`;
	
  for($layer in $layers)
	{ 
		if( `animLayer -query -exists $layer` && `objectType $layer` == "animLayer" && 	($layer != $lRootLayer ))
		{
			evalEcho( "delete "+ $layer );
		}
	}
	updateAddButtons();
}

global proc animLayersExport(string $layers[], int $branch)
{
	string $rootLayer = `animLayer -q -root`;
	if ( size($layers) > 1)
	{
		error ((uiRes("m_layerEditor.kAnimLayerExportToManyLayers")));
	}
	else if($layers[0] == $rootLayer)
	{
		error ((uiRes("m_layerEditor.kAnimLayerCantExportRoot")));
	}
	else
	{
		string $exportLayers[];
		$exportLayers[0] = $layers[0];
		if ($branch)
		{
			buildAnimLayerArrayRecursive($layers[0],$exportLayers);
		}
		select -clear;
		for ($layer in $exportLayers)
		{				
			animLayer -e -writeBlendnodeDestinations $layer;
			string $layerCurves[] = `animLayer -q -animCurves $layer`;
			string $layerBlendNodes[] = `animLayer -q -blendNodes $layer`;
			select -add -noExpand $layer;
			for($curve in $layerCurves) {
				select -add $curve;
			}
			for($blendNode in $layerBlendNodes) {
				select -add $blendNode;
			}
		}
		string $exportTitle = (uiRes("m_layerEditor.kExportTo"));
		fileBrowser("animLayersSaveExportClbc", $exportTitle, "mayaBinary", 1);
	}
}

global proc animLayersSaveExportClbc(string $file, string $type)
{
	file -exportSelected -channels 0 -constructionHistory 0 -expressions 0 -constraints 0 -type $type $file;
}

proc int emptyAllTheWay(string $layer)
{
  // 0 is false
  // 1 is true
  int $result = 1;
  
  // if this layer has attributes, return false
  string $attributes[] = `animLayer -query -attribute $layer`;
  if( size($attributes) > 0 )
  {
	return 0;
  }
  
  // if this layer has children, then we go through them and do the same check
  string $layerChildren[] = `animLayer -query -children $layer`;
  for ($childLayer in $layerChildren)
  {
	if (!emptyAllTheWay($childLayer))
	{
	  // we don't need to look any further
	  return 0;
	}
  }
  
  return $result;
}

global proc deleteEmptyAnimLayers()
{
	string $lRootLayer = `animLayer -q -root`;

	$layers=buildAnimLayerArray();
	
	  string $layersToDelete[];
	string $layersNotDeleted[];
	for ($layer in $layers)
	{
		  if( $layer != $lRootLayer )
		  {
			  string $attributes[] = `animLayer -query -attribute $layer`;
			  // if( size($attributes)<1 )
			  // {
				// BUG 364292: we should actually check here if any 
				// descendants have children --RJ
				if ( emptyAllTheWay($layer) )
				{
					$layersToDelete[size($layersToDelete)]=$layer;
				 }
				 else
				 {
					$layersNotDeleted[size($layersNotDeleted)]=$layer;
				 }
			  // }
			  // else
			  // {
				  // $layersNotDeleted[size($layersNotDeleted)]=$layer;
			  // }
		  }
	  }
	if ( size($layersToDelete) < (size($layers)-1) )
	{
		  string $wrn=(uiRes("m_layerEditor.kLayersNotDeletedBecauseHaveObjects"));
		  for($notDeleted in $layersNotDeleted)
		  {
			  print `format -s $notDeleted $wrn`;
		  }
	}
	
	layerEditorDeleteAnimLayer($layersToDelete);
}

global proc packageAnimLayerObjects()
{
	string $layerArray[] = buildAnimLayerArray();
	for($layer in $layerArray) {
		evalEcho( "updateLayerContainer " + $layer );
	}
}

global proc layerEditorAddObjectsAnimLayer(string $objects[], string $layers[],int $showOptions)
{
	global string $gSelectedAnimLayers[];
	$gSelectedAnimLayers = $layers;
	if($showOptions)
		performAnimLayerAddObjects 1 ;
	else
		performAnimLayerAddObjects 0 ;
}

global proc string layerEditorExtractObjectsSingleAnimLayer(string $objects[], string $layer )
{
	// extract the attributes of the selected object from $layer and create an adjacent layer from these
	// parameters. 

	int $lIsBaseLayer = false;
	int $lTypeIsValid = true;
	string $lNewLayer = "";
	
	if( $layer == "" )
	{
		$lIsBaseLayer = true;
	}
	else
	{
		$lTypeIsValid = (`objectType $layer` == "animLayer");
	}


	if( $lIsBaseLayer || $lTypeIsValid )
	{
		string $parentLayer = "";

		if( !$lIsBaseLayer )
		{
			$parentLayer = `animLayer -q -parent $layer`;

			if($parentLayer == "")
			{
				$lIsBaseLayer = true;
			}
		}
		
		// Create a new Destination layer inplace
		if( $lIsBaseLayer )
		{
			string $lSelection[]=`ls -selection`;
			select -ne $objects;

			// Create a new Layer from the seelction
			$lNewLayer = layerEditorCreateAnimLayer( true, true );
			select -ne $lSelection; // Because the container commands clear the selection

			// Provided Layer name may be empty, get Base name
			$layer = `animLayer -q -parent $lNewLayer`;
		}
		else
		{
			// Copy the source layers (will also copy the layer attributes and properties)
			$lNewLayer = `animLayer -copyNoAnimation $layer "Layer"`;

			// Remove attributes that arent from selected models
			string $attributes[] = `animLayer -query -attribute $lNewLayer `;

			for($attribute in $attributes)
			{
				int $lKeepAttribute = false;

				for($object in $objects)
				{
					if( `plugNode $attribute` == $object )
					{
						$lKeepAttribute = true;
						break;
					}
				}

				if( !$lKeepAttribute )
				{
					animLayer -edit -removeAttribute $attribute $lNewLayer;
				}
			}
		}

		// Rename and reposition the new layer
		$lNewLayer = `rename $lNewLayer ($layer+"_extract")`;

				if( $lIsBaseLayer )
		{
						// New layer was created at the end of the stack
						string $rootLayer = `animLayer -q -parent $lNewLayer`;
						string $children[] = `animLayer -query -children $rootLayer`;

						if( size( $children ) > 1 )
						{
								animLayer -edit -moveLayerBefore $children[0] $lNewLayer;
						}
				}
				else
				{
					animLayer -edit -parent $parentLayer $lNewLayer;
					animLayer -edit -moveLayerAfter $layer $lNewLayer;
				}

				// Finally extract the animation 
				animLayer -edit -extractAnimation $layer $lNewLayer;
	}

	return $lNewLayer;
}

global proc layerEditorExtractObjectsAnimLayer(string $objects[], string $layers[])
{
	for($layer in $layers)
	{
		layerEditorExtractObjectsSingleAnimLayer( $objects, $layer );

	}
}

global proc layerEditorMergeAnimLayer(string $layers[], int $pOptions )
{
	global string $gSelectedAnimLayers[];
	$gSelectedAnimLayers = $layers;

	performAnimLayerMerge( $pOptions );
	updateAddButtons();
}

global proc layerEditorRemoveObjectsAnimLayer(string $objects[], string $layers[])
{
	for($layer in $layers)
	{
		if (`objectType $layer` == "animLayer")
		{
			string $attributes[] = `animLayer -query -attribute $layer`;
			for($attribute in $attributes)
			{
				for($object in $objects)
				{
					if( `plugNode $attribute` == $object )
					{
						evalEcho( "animLayer -edit -removeAttribute " + $attribute +" "+ $layer );
					}
				}
			}
		}
	}
}

global proc layerEditorCopyAnimLayer(string $layers[])
{
	for($layer in $layers)
	{
		if (`objectType $layer` == "animLayer")
		{
			$newLayer = $layer + "_copy";
			$newLayer = evalEcho( "animLayer -copy "+$layer +" "+$newLayer );
			evalEcho( "animLayer -edit -moveLayerAfter "+$layer+" "+ $newLayer );
		}
	}
}

global proc layerEditorCopyAnimLayerNoAnim(string $layers[])
{
	for($layer in $layers)
	{
		if (`objectType $layer` == "animLayer")
		{
			$newLayer = $layer + "_copy";
			$newLayer = evalEcho( "animLayer -copyNoAnimation "+$layer+" "+ $newLayer );
			evalEcho( "animLayer -edit -moveLayerAfter "+$layer+" "+ $newLayer );
		}
	}
}


global proc layerEditorSelectObjectAnimLayer(string $layers[])
{
	select -clear;
	for($layer in $layers)
	{
		if (`objectType $layer` == "animLayer")
		{
			if($layer == `animLayer -q -root`)
			{
				string $animLayers[];
				//Avoid the root node
				buildAnimLayerArrayRecursive($layer, $animLayers);
				layerEditorSelectObjectAnimLayer($animLayers);
				break; //Every layered object is already selected
			}
			else
			{
				string $attrs[] = `animLayer -query -attribute $layer`;
				for($attr in $attrs)
				{
					select -add `plugNode $attr`;
				}
			}
		}
	}
}


global proc layerEditorZeroKeyAnimLayer(string $layers[])
{
	performSetKeyframeArgList 2 {"0", "animationList","1"};
}

global proc layerEditorZeroWeightKeyAnimLayer(string $layers[])
{
		layerEditorWeightAnimLayer($layers, 0.0);
		layerEditorKeyWeightAnimLayer($layers);
}

global proc layerEditorFullWeightKeyAnimLayer(string $layers[])
{
		layerEditorWeightAnimLayer($layers, 1.0);
		layerEditorKeyWeightAnimLayer($layers);
}

global proc layerEditorWeightAnimLayerNoForcedRefresh(string $layers[], float $value)
{
	string $lRootLayer = `animLayer -q -root`;

	for($layer in $layers)
	{
		if (`objectType $layer` == "animLayer" && $layer != $lRootLayer)
		{
			evalEcho( "animLayer -edit -weight "+$value+" "+ $layer );
		}
	}
}

global proc layerEditorWeightAnimLayer(string $layers[], float $value)
{
	// MAYA-36993, forcing refresh due to potentially inconsistent DG state after keying
    refresh -su 1;	
	currentTime -e `currentTime -q`;
    refresh -su 0;	

	layerEditorWeightAnimLayerNoForcedRefresh($layers,  $value);
}

global proc layerEditorKeyWeightAnimLayer(string $layers[])
{
	for($layer in $layers)
	{
		if (`objectType $layer` == "animLayer")
		{
			evalEcho( "setKeyframe "+$layer+".weight" );
		}
	}
}


global proc layerEditorExclusiveSoloAnimLayer(string $layers[])
{
	string $allLayer[] = `ls -type animLayer`;
	for($layer in $allLayer)
	{
		evalEcho( "animLayer -edit -solo false "+$layer );
	}

	string $lRootLayer = `animLayer -q -root`;

	for($layer in $layers)
	{
		if( ($lRootLayer!=$layer) && ( `objectType $layer` == "animLayer"))
		{
			evalEcho( "animLayer -edit -solo true "+$layer );
		}
	}
}
//////////////////////////////////////////////////////////////////////////////
// RENDER LAYER SPECIFIC METHODS
//////////////////////////////////////////////////////////////////////////////

//////////////
// Global variables for render layer editor
//////////////
global float $gRenderLayerEditorSelectColorOne[];
global float $gRenderLayerEditorSelectColorTwo[];

$gRenderLayerEditorSelectColorOne[0] = 0.40;
$gRenderLayerEditorSelectColorOne[1] = 0.55;
$gRenderLayerEditorSelectColorOne[2] = 0.70;

$gRenderLayerEditorSelectColorTwo[0] = 0.29;
$gRenderLayerEditorSelectColorTwo[1] = 0.32;
$gRenderLayerEditorSelectColorTwo[2] = 0.34;

//////////////
// Utility functions for render layer editor
//////////////

global proc string[] getSelectedRenderItems(string $toolName, string $specified, int $type)
//
//	Description
//		Parse selected items from tree view to get either the layers ($type=0) or
//		the pass contribution maps ($type=1)
{
	string $list[];
	if ($specified == "") {
		string $temp[] = `treeView -query -selectItem ($toolName+"RenderLayerEditor")`;
		for ($item in $temp) {
			if (`objExists $item` && `nodeType $item` == "renderLayer") {
				if ($type == 0) {
					$list[size($list)] = $item;
				}
			} else if ($type == 1) {
				string $layerCont[] = parseLayerContMapIdent($item);
				string $map = $layerCont[1];
				if (`objExists $map` && `nodeType $map` == "passContributionMap") {
					$list[size($list)] = $map;
				}
			}
		}
		$list = stringArrayRemoveDuplicates($list);
	} else {
		$list[0] = $specified;
	}
	return $list;
}

global proc string[] buildRenderLayerArray()
//
//	Description
//		Get the render layers in order by displayOrder and
//		reverse to put in the list with defaultRenderLayer at
//		the bottom
{
	string $layers[];
  
	if (`objExists renderLayerManager`) {
		$layers = `listConnections renderLayerManager.renderLayerId`;

		$layers = sortLayers($layers);
		$layers = reverseArray($layers);
	}
	return $layers;
}

global proc string buildLayerContMapIdent(string $layer, string $map)
//
// Description
//		build identifier for pass contribution maps in the tree view
//
{
	return ($layer + "%" + $map);
}

global proc string[] parseLayerContMapIdent(string $ident)
//
//	Description
//		parse identifier for pass contribution maps <layername>%<mapname>
//		into string array: [0]=layer [1]=contribution map
{
	string $result[];
	string $buffer[];
	tokenize($ident, "%", $buffer);

	$result[0] = $buffer[0];
	$buffer[0] = "";
	$result[1] = stringArrayToString($buffer, "");

	return $result;
}

global proc renderLayerEditorValidateSelection(string $toolName, int $deselectNonCurrent)
//
//	Description
//		Run through all layers and ensure that the selection colour
//		is correct for each (active layer must be selected and
//		have the darker blue colour, every other layer must be
//		the lighter blue).
//
{
	if (!`objExists renderLayerManager`) {
	  return;
	}

	global float $gRenderLayerEditorSelectColorOne[];
	global float $gRenderLayerEditorSelectColorTwo[];

	string $allLayers[] = `listConnections renderLayerManager.renderLayerId`;
	string $currLayer = `editRenderLayerGlobals -q -currentRenderLayer`;
	string $treeControl = ($toolName + "RenderLayerEditor");

	for ($layer in $allLayers) {
		// make sure tree view has the item before updating, this
		// can be an issue at scene open as the tree view is being
		// built
		if (`treeView -itemExists $layer -q $treeControl`) {
			if ($layer == $currLayer) {
				treeView -edit
					-selectionColor $layer
						$gRenderLayerEditorSelectColorOne[0]
						$gRenderLayerEditorSelectColorOne[1]
						$gRenderLayerEditorSelectColorOne[2]
					-selectItem $layer 1
					$treeControl;
			} else {
				treeView -edit
					-selectionColor $layer
						$gRenderLayerEditorSelectColorTwo[0]
						$gRenderLayerEditorSelectColorTwo[1]
						$gRenderLayerEditorSelectColorTwo[2]
					$treeControl;
				if ($deselectNonCurrent) {
					treeView -edit
						-selectItem $layer 0
						$treeControl;
				}
			}
		}
	}
}

global proc string blendModeOptions_AttrToUI(int $attrVal)
//
//	Description
//		Given the attribute integer value for blend mode return
//		the localized UI string
//
{
	string $blendString;
	switch($attrVal) {
		case 1:
			$blendString = (uiRes("m_layerEditor.kNormalMode"));
			break;
		case 3:
			$blendString = (uiRes("m_layerEditor.kDarkenMode"));
			break;
		case 4:
			$blendString = (uiRes("m_layerEditor.kMultiplyMode"));
			break;
		case 7:
			$blendString = (uiRes("m_layerEditor.kLightenMode"));
			break;
		case 8:
			$blendString = (uiRes("m_layerEditor.kScreenMode"));
			break;
		case 11:
			$blendString = (uiRes("m_layerEditor.kOverlayMode"));
			break;
		default:
			$blendString = (uiRes("m_layerEditor.kNormalMode"));
			break;
	}
	return $blendString;
}

global proc int blendModeOptions_UIToAttr(string $ui)
//
//	Description
//		Given the localized UI string for a blend mode return
//		the attribute integer value
//
{
	int $result;

	if ($ui == (uiRes("m_layerEditor.kNormalMode"))) {
		$result = 1;
	} else if ($ui == (uiRes("m_layerEditor.kLightenMode"))) {
		$result = 7;
	} else if ($ui == (uiRes("m_layerEditor.kDarkenMode"))) {
		$result = 3;
	} else if ($ui == (uiRes("m_layerEditor.kMultiplyMode"))) {
		$result = 4;
	} else if ($ui == (uiRes("m_layerEditor.kScreenMode"))) {
		$result = 8;
	} else if ($ui == (uiRes("m_layerEditor.kOverlayMode"))) {
		$result = 11;
	} else {
		$result = 1;
	}

	return $result;
}

global proc int isNodeConnectedToContMap(string $obj, string $map, string $attr)
//
//	Description
//		Is the given dag node connected to the pass contribution map on the
//		given attribute
//
{
	string $dests[] = `connectionInfo -destinationFromSource ($obj + ".message")`;
	for ($d in $dests) {
		if (`plugNode $d` == $map) {
			string $currAttr = `plugAttr $d`;
			if (startsWith($currAttr, $attr)) {
				return true;
			}
		}
	}
	return false;
}

global proc alterNodeContMapConnection(
	string $obj,
	string $map,
	string $attr,
	int $connect)
//
//	Description
//		Connect/disconnect the object to the pass contribution map on the
//		specified attribute. Echos the command to the script editor
//
{
	int $connected = isNodeConnectedToContMap($obj, $map, $attr);

	if ($connect && !$connected) {
		evalEcho("connectAttr -na " + $obj + ".message " + $map + "." + $attr);

	} else if (!$connect && $connected) {
		evalEcho("disconnectAttr -na " + $obj + ".message " + $map + "." + $attr);

	}
}

global proc alterContMapConnectionsForParentsOfShape(
	string $shape,
	string $map,
	int $connect)
//
//	Description
//		Connect/disconnect all parent transforms of the shape to the give
//		pass contribution map. Checks for shape siblings.
//
{
	string $parents[] = `listRelatives -allParents -type "transform" $shape`;
	for ($p in $parents) {
		// if shape has visible siblings there may be issues, so give warning
		string $children[] = `listRelatives -children $p`;
		if (size($children) > 1) {
			int $visibleSibling = false;
			for ($c in $children) {
				if (!endsWith($shape, $c) &&
					`getAttr ($c + ".visibility")` &&
					!`getAttr ($c + ".intermediateObject")`)
				{
					$visibleSibling = true;
					break;
				}
			}
			if ($visibleSibling) {
				string $msg = (uiRes("m_layerEditor.kShapeSiblingWarn"));
				$msg = `format -s $shape $msg`;
				warning($msg);
			}
		}

		alterNodeContMapConnection($p, $map, "dagObjects", $connect);
	} 
}

global proc string displayLabelRenderLayer(int $showNamespace, string $layer)
//
//	Description:
//		Given a render layer name, and whether or not we want the namespace displayed,
//		return the appropriate label.
//
{
	string $label = $layer;
	string $tokens[];
	int $numTokens = `tokenize $layer ":" $tokens`;
	if ($tokens[$numTokens-1] == "defaultRenderLayer")
	{
		// Replace defaultRenderLayer by masterLayer.
		//
		int $nameLength = size($layer);
		if ($nameLength == 18)
		{
			return "masterLayer";
		}
		// The layer name might include the name space, say,
		// name_space:defaultRenderLayer.  We want to change
		// it to name_space:masterLayer. 
		// 
		int $position = $nameLength - 18; 
		$label = `substring $layer 1 $position` + "masterLayer";
	}

	return displayLabel($showNamespace, $layer);
}

global proc hookShaderOverride(string $layer, string $type, string $shader) 
//
//	Description
//		Cretaes a meterial override for the given layer. If $type if not
//		empty, create a new node of this type and uses it. If type is
//		empty, $shader is supposed to be a valid shader to be used.
//
{
	if ($type != "")
		$shader = `shadingNode -asShader $type`;

	string $shadingGroupArray[] = 
		`listConnections -source false -destination true 
		-type "shadingEngine" $shader`;

	// Create a shading group if non exist yet
	string $sg;
	if (size($shadingGroupArray) < 1) {
		$sg = `sets -renderable true -noSurfaceShader true
			-empty -name ($shader+"SG")`;
		
		defaultNavigation -connectToExisting
			-source $shader -destination $sg;
	} else {
		$sg = $shadingGroupArray[0];
	}
	connectAttr -f ($sg+".message") ($layer+".shadingGroupOverride");
}

global proc string[] getUnassociatedContMaps(string $layer)
{
	string $allContMaps[] = getSortedPassContributionMapList("");
	string $connectedContMaps[] = getSortedPassContributionMapList($layer);
	string $result[] = stringArrayRemove($connectedContMaps, $allContMaps);
	return $result;
}

//////////////
// Scriptjob callbacks for render layer editor
//////////////

global int $gLayerEditorCurrentLayerUpdateFromSelection = 0;
global proc layerEditorRenderLayerManagerChange(string $toolName)
//
//	Description:
//		This procedure is called whenever the user changes the active
//		render layer
//		Ensure the Layer Editor reflects the layer changes.
//
{
	// This procedure might be triggered by renderLayerEditorOnSelectionChanged
	// since that one can change the current render layer. In that case we
	// do not want to change any selections. However, if someone else changes
	// the current layer we want to deselect all other layers and only select
	// the new current layer. Hence the global variable.
	global int $gLayerEditorCurrentLayerUpdateFromSelection;
	renderLayerEditorValidateSelection($toolName,
		!$gLayerEditorCurrentLayerUpdateFromSelection);
	$gLayerEditorCurrentLayerUpdateFromSelection = 0;

	// update blend mode
	string $currLayer = `editRenderLayerGlobals -q -currentRenderLayer`;
	if ($currLayer != "") {
		int $blendMode = getAttr ($currLayer + ".psdBlendMode") ;
		optionMenu -edit
			-value `blendModeOptions_AttrToUI($blendMode)`
			LayerEditorBlendModeOptionMenu;
	}
}

//////////////
// Callbacks from treeView for render layer editor
//////////////

global proc string renderLayerEditorItemOnRename(string $oldName, string $newName)
//
//	Description
//		Called on user rename of items in tree view, both layers and contribution
//		maps. Returns the new identifier for the item in the tree view, or
//		an empty string if the item should not be renamed
//
{
	string $newItem = "";
	string $newItemName = $newName;
	string $layerCont[];

	int $isContMap = false;
	if (!`objExists $oldName`) {
		// might be a pass contribution map, parse string and check
		// to allow for rename
		$layerCont = parseLayerContMapIdent($oldName);
		if (`objExists $layerCont[0]` && `objExists $layerCont[1]`) {
			$isContMap = true;
			$oldName = $layerCont[1]; // rename the contribution map
		}
	}
	
	if ($newName != $oldName) {
		if (!catch($newItemName = rename($oldName, $newName))) {
			if ($isContMap) {
				$newItem = buildLayerContMapIdent($layerCont[0], $newItemName);
			} else {
				$newItem = $newItemName;
			}
		}
	}

	return $newItem;
}

global proc renderLayerEditorOnSelectionChanged(string $toolName)
//
//	Description
//		When the user has triggered a selection change, check the selected
//		items and update the current render layer if necessary
//
{
	string $selectedItems[] = `treeView -query -selectItem ($toolName+"RenderLayerEditor")`;
	string $currLayer = `editRenderLayerGlobals -q -currentRenderLayer`;
	global int $gLayerEditorCurrentLayerUpdateFromSelection;

	// current render layer is not in the selection, thus we must change the
	// current render layer
	if (!stringArrayContains($currLayer, $selectedItems)) {
		if (size($selectedItems) > 0) {
			// there is a selection, choose the first selected render
			// layer, or if there are only contribution maps selected,
			// choose the parent layer for the first selected map
			string $bestItem = "";
			int $canReuseCurrLayer = 0;
			for ($item in $selectedItems) {
				if (`objExists $item` && `nodeType $item` == "renderLayer") {
					$bestItem = $item;
					break; // found a layer, we can stop now
				} else if ($bestItem == "") {
					// take the layer of the first selected contribution map,
					// but don't choose the current layer (unless there are
					// no other choices
					string $layerCont[] = parseLayerContMapIdent($item);
					string $layer = $layerCont[0];
					if ($layer == $currLayer) {
						// there is a contribution map still selected for the
						// current layer, so it may be the best choice to
						// not change the current layer, however we should still
						// look for a better layer
						$canReuseCurrLayer = 1;
					} else if (`objExists $layer` && `nodeType $layer` == "renderLayer") {
						$bestItem = $layer;
					}
				}		
			}

			// set the new render layer, fall back to default if none found
			if ($bestItem != "") {
				$gLayerEditorCurrentLayerUpdateFromSelection = 1;
				catch(`editRenderLayerGlobals -currentRenderLayer $bestItem`);
			} else if (!$canReuseCurrLayer) {
				// only choose default if the current layer is not a better choice
				$gLayerEditorCurrentLayerUpdateFromSelection = 1;
				catch(`editRenderLayerGlobals -currentRenderLayer defaultRenderLayer`);
			}
		} else {
			// no selection, just use the default render layer
			$gLayerEditorCurrentLayerUpdateFromSelection = 1;
			catch(`editRenderLayerGlobals -currentRenderLayer defaultRenderLayer`);
		}
	}

	renderLayerEditorValidateSelection($toolName, 0);
}

global proc layerEditorRenderLayerOnDragDrop(
	string $toolName,
	string $dropItems[],
	string $oldParents[],
	int $oldIndexes[],
	string $newParent,
	int $newIndexes[],
	string $newItemPrev,
	string $newItemNext)
//
//	Description
//		Called on drag and drop of layers within the editor
//		Handle reordering
//
{
	for($dropItem in $dropItems) {
		if (`objExists $dropItem` && `nodeType $dropItem` == "renderLayer") {
			string $treeControl = ($toolName + "RenderLayerEditor");
			string $layers[] = `listConnections renderLayerManager.renderLayerId`;
			int $maxIndex = size($layers)-1;

			int $defaultPosition = `treeView -itemIndex "defaultRenderLayer" -q $treeControl`;
			int $offset = ($defaultPosition == $maxIndex ? 0 : 1);
			for ($layer in $layers) {
				if ($layer != "defaultRenderLayer") {
					int $treeIndex = `treeView -itemIndex $layer -q $treeControl`;
					int $order = ($maxIndex - $treeIndex + $offset);
					if ($treeIndex > $defaultPosition) {
						$order += $offset;
					}
					setAttr ($layer + ".displayOrder") $order;
				}
			}

			// puts defaultRenderLayer back at the bottom if necessary
			if ($defaultPosition != $maxIndex ) {
				updateEditorRenderLayer($toolName);
			}
		}
	}
}

global proc renderLayerEditorRenderable(string $toolName, string $layer, string $state)
//
//	Description
//		Called on click of the renderable button on a render layer
//
{
	int $val = $state;
	setAttr ($layer + ".renderable") $val;
	updateEditorFeedbackRenderLayer($toolName, $layer);
}


global proc renderLayerEditorRecycleChange(string $toolName, string $layer, string $state)
//
//	Description
//		Called on click of the recycle button on a render layer
//
{
	int $isRendered = `getAttr ($layer + ".imageRendered")`;

	if ($isRendered) {
		int $recycle = `getAttr ($layer + ".recycleImage")`;
		
		if (0 == $recycle) $recycle = true;
		else $recycle = false;
			
		setAttr ($layer + ".recycleImage") $recycle;
	}

	updateEditorFeedbackRenderLayer($toolName, $layer);
}

global proc renderLayerEditorSettingsOverride(string $toolName, string $layer, string $state)
//
//	Description
//		Called on click of the render editor setting button
//		for a layer
//
{
	// clear tree view before switching render layers
	string $treeControl = ($toolName + "RenderLayerEditor");
	treeView -edit -clearSelection $treeControl;

	catch(`editRenderLayerGlobals -currentRenderLayer $layer`);
	unifiedRenderGlobalsWindow;
}

//////////////
// Other UI (non-treeView) callbacks for render layer editor
//////////////

global proc layerEditorMoveRenderItem(string $toolName, int $up)
//
//	Description
//		Move current render layer up or down in the selection list
//		when user presses reorder buttons
//
{
	string $currLayer = `editRenderLayerGlobals -q -currentRenderLayer`;
	if ($currLayer == "defaultRenderLayer") {
		return; // can't move the default renderlayer
	}
	int $currPos = `getAttr ($currLayer + ".displayOrder")`;
	int $offset = ($up ? 1 : -1);

	string $allLayers[] = `listConnections renderLayerManager.renderLayerId`;
	for ($layer in $allLayers) {
		int $layerPos = `getAttr ($layer + ".displayOrder")`;
		// don't move defaultRenderLayer
		if ($layerPos != 0) {
			if ($layerPos == $currPos+$offset) {
				setAttr ($layer + ".displayOrder") $currPos;
				setAttr ($currLayer + ".displayOrder") $layerPos;
				updateEditorRenderLayer($toolName);
				break;
			}
		}
	}
}

global proc layerBlendModeChanged(string $toolName)
//
//	Description
//		Called when the user changes the blend mode from the UI
//
{
	string $layers[] = getSelectedRenderItems($toolName, "", 0);
	int $blendMode = blendModeOptions_UIToAttr(`optionMenu -q -value LayerEditorBlendModeOptionMenu`);

	for ($layer in $layers) {
		setAttr ($layer + ".psdBlendMode") $blendMode;
		updateEditorFeedbackRenderLayer($toolName, $layer);
	}
}

global proc renderLayerEditorShowLayersMenu(string $toolName, string $menu)
//
//	Description:
//		Called on show of the Layers menu for Render layers
//
{
	string $selection[] = `ls -selection`;
	string $layerSelection[] = getSelectedRenderItems($toolName, "", 0);
	string $currentLayer = `editRenderLayerGlobals -q -currentRenderLayer`;
	int	$enable = false;

	string $layers[] = `listConnections renderLayerManager.renderLayerId`;
	int $numLayers = `size $layers`;

	//	Remove layers from the selection list.
	$selection = stringArrayRemove($layers, $selection);
	
	setParent -menu $menu;

	//	Delete layer. Enable if there is at least one layer selected.
	menuItem -edit -enable (size($layerSelection) > 0)
		LayerEditorEditMenuDeleteMenuItemForRenLayers;

	//	Select/remove objects in selected layer(s). Enable if there is at
	//	least one layer selected and there is at least one object in any of 
	//	those layers.
	$enable = false;
	for ($layer in $layerSelection) {
		string $layerContents[] = `editRenderLayerMembers -query $layer`;
		if (0 < size($layerContents)) {
			$enable = true;
			break;
		}
	}
	menuItem -edit -enable $enable LayerEditorEditMenuSelectObjectsMenuItemForRenLayers;
	if (0 == size($selection)) $enable = false; // need selected objects for remove
	menuItem -edit -enable $enable LayerEditorEditMenuRemoveObjectsMenuItemForRenLayers;

	//	Show Layer Attributes. Enable if there is a current layer.
	menuItem -edit -enable ("" != $currentLayer)
		LayerEditorEditMenuLayerAttributesMenuItemRenLayers;
}

global proc renderLayerEditorShowContributionMenu(string $toolName, string $menu)
//
//	Description:
//		This procedure is called whenever the user shows the Contribution menu.
//
{
	setParent -menu $menu;

	int $numContMaps = size(`ls -type passContributionMap`);
	menuItem -edit -enable ($numContMaps > 0)
		LayerEditorContMenuAssExistContMapMenuItem;
	if ($numContMaps > 0) {
		menu -edit -deleteAllItems LayerEditorContMenuAssExistContMapMenuItem;
		setParent -menu LayerEditorContMenuAssExistContMapMenuItem;
		string $layer = `editRenderLayerGlobals -q -currentRenderLayer`;
		string $maps[] = getUnassociatedContMaps($layer);
		for ($map in $maps) {
			menuItem -label $map
				-command ("renderLayerEditorAssocContMap " + $toolName + " {\"" + $layer + "\"} " + $map);
		}
		setParent -menu ..;
	}

	string $maps[] = getSelectedRenderItems($toolName, "", 1);
	int $enable = (size($maps) > 0);
//	menuItem -edit -enable $enable
//		LayerEditorContMenuMembershipContMapMenuItem;
	menuItem -edit -enable $enable
		LayerEditorContMenuAttributesContMapMenuItem;

	int $selSize = size(`ls -selection`);
	menuItem -edit -enable ($enable && $selSize > 0)
		LayerEditorContMenuAddItemsToContMapMenuItem;

	int $itemsInLayers = false;
	for ($map in $maps) {
		if ((size(`listConnections ($map + ".dagObjects")`) > 0) ||
					(size(`listConnections ($map + ".light")`) > 0)) {
			$itemsInLayers = true;
			break;
		}
	}

	menuItem -edit -enable ($itemsInLayers && $enable)
		LayerEditorContMenuSelectItemsInContMapMenuItem;
	menuItem -edit -enable ($itemsInLayers && $enable && $selSize > 0)
		LayerEditorContMenuRemoveItemsFromContMapMenuItem;
}

global proc renderLayerEditorShowOptionsMenu(string $menu)
//
//	Description:
//		This procedure is called whenever the user shows the Options menu.
//
{
	setParent -menu $menu;

	$value = `optionVar -query renderLayerCurrent`;
	menuItem -edit -checkBox $value LayerEditorOptionsMenuMakeCurrentMenuItemRenLayers;

	$value = `editRenderLayerGlobals -query -useCurrent`;
	menuItem -edit -checkBox $value
		-command "editRenderLayerGlobals -useCurrent #1"
		LayerEditorOptionsMenuUseCurrentMenuItemRenLayers;

	$value = `editRenderLayerGlobals -query -enableAutoAdjustments`;
	menuItem -edit -checkBox $value -enable true
		LayerEditorOptionsMenuAutoAdjustmentMenuItemRenLayers;

	menuItem -e -checkBox (`optionVar -q renderViewRenderAllLayers`)
		LayerEditorOptionsRenderAllLayersRenLayers;

	$value = `optionVar -query renderLayerShowNamespace`;
	menuItem -edit -checkBox $value LayerEditorOptionsMenuShowNamespaceMenuItemRenLayers;
}

global proc layerEditorCreateRenderLayer(int $contents)
//
//	Description:
//		Create a new render layer and update the editor to reflect
//	  the change.
//
//	Arguments:
//		$contents - 1 for empty, 2 for selected, etc.
//
{
	// If before we create the new layer, the only render layer
	// is the master render layer, then we make the master layer
	// non-renderable.
	string $layerArray[] = `listConnections renderLayerManager.renderLayerId`;
	if (size($layerArray) == 1 
		&& 0 == `getAttr ($layerArray[0] + ".identification")`) {
		setAttr ($layerArray[0]+".renderable") 0;
	}

	int $previous = `optionVar -q renderLayerContents`;
	optionVar -iv renderLayerContents $contents;
	performCreateRenderLayer 0;
	optionVar -iv renderLayerContents $previous;
}


global proc renderLayerEditorCopyLayer(string $toolName, string $inLayer)
//
// Description:
//  This procedure is called whenever the user wants to copy the
//  selected or specified layers.
//
{
	// Get the selected layers.
	string $layers[] = getSelectedRenderItems($toolName, $inLayer, 0);

	int $mode = 0;
	if (`optionVar -exists renderLayerCopyLayerMode`)
	{ 
		$mode = `optionVar -q renderLayerCopyLayerMode`;
	}

	// Mode 0: copy layers with input connections.
	// Mode 1: copy layers without input connections.
	//
	string $flag = "";
	if ($mode == 0)
	{
		$flag = " -inputConnections ";
	}

	string $layer;
	for ($layer in $layers)
	{
		eval("duplicate "+$flag+ $layer);
	}
}

global proc setRenderLayerCopyLayerMode(string $parent)
// 
// Description:  This procedure is called to set the copy
//  layer mode to the one user specified.
//
{
	setParent $parent;

	if (`radioButtonGrp -q -select copyRenderLayerWithInputConnectionsRadio`)
	{
		optionVar -intValue renderLayerCopyLayerMode 0;
	}
	else
	{
		optionVar -intValue renderLayerCopyLayerMode 1;
	}
}

global proc resetRenderLayerCopyLayerMode(string $parent)
// 
// Description:  This procedure is called to reset the copy layer
//	  mode to its default mode.
//
{
	setParent $parent;
	optionVar -intValue renderLayerCopyLayerMode 0; 
	radioButtonGrp -edit -select 1 copyRenderLayerWithInputConnectionsRadio;
}

global proc renderLayerEditorCopyLayerOptions(string $toolName)
//
// Description:
//  This procedure is called to get the options for copy layer.
//
{
	string $layout = getOptionBox();
	setParent $layout;
	setUITemplate -pushTemplate DefaultTemplate;
	waitCursor -state 1;

	string $parent = `columnLayout -adjustableColumn 1`;
	
	radioButtonGrp -numberOfRadioButtons 1 -label (uiRes("m_layerEditor.kCopyLayerMode"))
		-label1 (uiRes("m_layerEditor.kMembershipAndOverrides"))
		copyRenderLayerWithInputConnectionsRadio;

	radioButtonGrp -numberOfRadioButtons 1 
		-label1 (uiRes("m_layerEditor.kWithMembership"))
		-shareCollection copyRenderLayerWithInputConnectionsRadio
		copyRenderLayerWithInputConnectionsRadio2;

	int $mode = 0;
	if (`optionVar -exists renderLayerCopyLayerMode`)
	{ 
		$mode = `optionVar -q renderLayerCopyLayerMode`;
	}

	switch ($mode)
	{
		case 1:
			radioButtonGrp -e -select 1 copyRenderLayerWithInputConnectionsRadio2;
			break;
		default:
			radioButtonGrp -e -select 1 copyRenderLayerWithInputConnectionsRadio;
			break;
	}

	waitCursor -state 0;
	setUITemplate -popTemplate;

	string $applyBtn = getOptionBoxApplyBtn();
	button -edit 
		-command ("setRenderLayerCopyLayerMode "+$parent+
				  "; renderLayerEditorCopyLayer "+$toolName+" \"\"") 
		$applyBtn;
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit -command ("setRenderLayerCopyLayerMode "+$parent)
		$saveBtn;
	string $resetBtn = getOptionBoxResetBtn();
	button -edit -command ("resetRenderLayerCopyLayerMode "+$parent)
		$resetBtn;

	setOptionBoxTitle (uiRes("m_layerEditor.kCopyLayerOptions"));

	setOptionBoxHelpTag ("CopyLayerOptions");

	showOptionBox();
}

global proc renderLayerEditorDeleteLayer(string $toolName, string $inLayer)
//
//	Description:
//		Delete the specified layer or if no layer argument given then
//		delete all the selected layers.
//
{
	string $layers[] = getSelectedRenderItems($toolName, $inLayer, 0);

	// remove default layer from removal list
	$layers = stringArrayRemove({"defaultRenderLayer"}, $layers);

	// if we're deleting the current layer, switch current to default
	string $currentLayer = `editRenderLayerGlobals -q -currentRenderLayer`;
	for ($layer in $layers) {
		if ($layer == $currentLayer) {
			if(catch(evalEcho("editRenderLayerGlobals -currentRenderLayer defaultRenderLayer"))) {
				string $msg  = (uiRes("m_layerEditor.kCannotDeleteLayer"));
				string $msgDisp = `format -s $layer $msg `;
				warning ($msgDisp);
				$layers = stringArrayRemove({$layer}, $layers);
			}
			break;
		}
	}

	for ($layer in $layers) {
		catch(`evalEcho("delete "+$layer)`);
	}

	// Check if only one render layer is left.
	// If so, makes this only render layer renderable.
	//
	string $layerArray[] = `listConnections renderLayerManager.renderLayerId`;
	if (size($layerArray) == 1) {
		setAttr ($layerArray[0]+".renderable") 1;
	}

	// clean up invalid adjustment and
	// renderLayerManager.renderLayerId
	renderLayerCleanup();
	updateLayerOrderByType("Render");
}


global proc renderLayerEditorSelectObjects(string $toolName, string $layer)
//
//	Description:
//		Select the objects contained in the specified layer or if no 
//		layer argument given then select all the objects in the selected
//		layers.
//
{
	//	Clear the current object selection list.
	select -clear;
	string $layers[] = getSelectedRenderItems($toolName, $layer, 0);

	//	Add to the selection list the objects contained in each 
	//	selected layer.
	for ($item in $layers) {
		select -add `editRenderLayerMembers -fullNames -query $item`;
	}
}

global proc renderLayerEditorRemoveObjects(string $toolName, string $inLayer)
//
//	Description:
//		Remove the selected objects from the specified layer. If no layer
//	  argument given, remove the selected objects from all highlighted
//		render layers.
//
{
	string $selectedObjects = stringArrayToString(`ls -selection`, " ");
	if ($selectedObjects == "") {
		return;
	}

	string $layers[] = getSelectedRenderItems($toolName, $inLayer, 0);
	for ($layer in $layers) {
		evalEcho("editRenderLayerMembers -remove -noRecurse "+$layer+" "+$selectedObjects);
	}
}

global proc renderLayerEditorEmptyLayer(string $toolName, string $inLayer)
//
//	Description:
//		Remove the selected objects from the specified layer. If no layer
//	  argument given, remove the selected objects from all highlighted
//		render layers.
//
{
	string $layers[] = getSelectedRenderItems($toolName, $inLayer, 0);
	for ($layer in $layers) {
		string $objects = stringArrayToString(`editRenderLayerMembers -fullNames -query $layer`, " ");
		if ($objects != "") {
			evalEcho("editRenderLayerMembers -remove -noRecurse "+$layer+" "+$objects);
		}
	}
}

global proc renderLayerEditorAddObjects(string $toolName, string $inLayer)
//
//	Description:
//		Add the selected objects to the specified layer. If no layer
//	  argument given, add the selected objects to all highlighted
//		render layers.
//
{
	string $selectedObjects = stringArrayToString(`ls -selection`, " ");
	if ($selectedObjects == "") {
		return;
	}

	string $layers[] = getSelectedRenderItems($toolName, $inLayer, 0);
	for ($layer in $layers) {
		// all objects are already in default render layer
		if ($layer != "defaultRenderLayer") {
			evalEcho("editRenderLayerMembers -noRecurse "+$layer+" "+$selectedObjects);
		}
	}
}

global proc renderLayerEditorDeleteUnused(string $toolName)
//
//	Description:
//		Delete all layers that have nothing in them
//
{
	string $layerArray[] = `listConnections renderLayerManager.renderLayerId`;

	//	Determine the contents of each layer. Ignore default layers.
	//
	for ($layer in $layerArray) {
		//	Ignore default layers. Default layers have an id of 0.
		if (`getAttr ($layer + ".identification")` > 0) {
			string $layerContents[] = `editRenderLayerMembers -query $layer`;
			if (size($layerContents) == 0) {
				renderLayerEditorDeleteLayer($toolName, $layer);
			}
		}
	}
}

global proc renderLayerEditorLayerAttributes(string $layer)
//
//	Description:
//		Show the Attribute Editor for the specified layer or if
//		no layer argument given then use the current layer.
//
{
	//	Get the current layer if the argument is an empty string.
	//
	if ($layer == "") {
		$layer = `editRenderLayerGlobals -q -currentRenderLayer`;
	}

	if ($layer != "") {
		// select and edit layer
		select -replace $layer;
		editSelected();
	}
}

global proc renderLayerEditorMembership(string $toolName, string $layer)
//
//	Description:
//		Show the Relationship Editor for the specified layer or if
//		no layer argument given then use the layer selection.
//
{
	string $selection[] = getSelectedRenderItems($toolName, $layer, 0);
	relationshipEditor("renderLayers", $selection, {});
}

global proc renderLayerEditorAlterObjectsInContMap(
	string $toolName,
	string $layer,
	string $inMap,
	int $addObjects)
//
//	Description:
//		Add/remove the selected objects to/from the specified pass contribution
//		map or all selected maps if none is specified
//
{
	// add items to layer first
	if ($addObjects) {
		renderLayerEditorAddObjects($toolName, $layer);
	}

	string $maps[] = getSelectedRenderItems($toolName, $inMap, 1);
	for ($map in $maps) {
		string $selectedObjects[] = `ls -selection`;
		for ($obj in $selectedObjects) {
			if (`nodeType $obj` == "transform") {
				// always adjust transform connections
				alterNodeContMapConnection($obj, $map, "dagObjects", $addObjects);

				// if this transform has a light under it, alter the connection
				string $descendents[] = `listRelatives -allDescendents -type "light" $obj`;
				for ($node in $descendents) {
					alterNodeContMapConnection($node, $map, "light", $addObjects);
					// alter all parent transforms to account for light
					// instancing which isn't officially supported but we do
					// it anyway for completeness
					alterContMapConnectionsForParentsOfShape($node, $map, $addObjects);
				}
			} else {
				string $types[] = `nodeType -i $obj`;
				if (stringArrayContains("light", $types)) {
					alterNodeContMapConnection($obj, $map, "light", $addObjects);
					alterContMapConnectionsForParentsOfShape($obj, $map, $addObjects);
				} else if (stringArrayContains("shape", $types)) {
					alterContMapConnectionsForParentsOfShape($obj, $map, $addObjects);
				}
			}
		}
	}
}

global proc renderLayerEditorSelectObjectsInContMap(string $toolName, string $inMap)
//
//	Description:
//		Select the objects contained in the specified contribution map, or
//		all maps if none is specified
//
{
	//	Clear the current object selection list.
	select -clear;

	string $maps[] = getSelectedRenderItems($toolName, $inMap, 1);

	for ($map in $maps) {
		select -add `listConnections ($map + ".dagObjects")`;
		select -add `listConnections ($map + ".light")`;
	}
}


global proc renderLayerEditorEmptyContMap(string $map)
//
//	Description:
//		Remove all objects from specified contribution map
//
{
	string $connections[] = `listConnections -p true -c true ($map + ".dagObjects")`;
	int $num = size($connections);
	for ($i=0; $i<$num; $i+=2) {
		evalEcho("disconnectAttr " + $connections[$i+1] + " " + $connections[$i]);
	}

	$connections = `listConnections -p true -c true ($map + ".light")`;
	$num = size($connections);
	for ($i=0; $i<$num; $i+=2) {
		evalEcho("disconnectAttr " + $connections[$i+1] + " " + $connections[$i]);
	}
}

global proc renderLayerEditorAssocContMap(string $toolName, string $layers[], string $map)
//
//	Description
//		Associate contribution map with layers, if layers is empty then
//		associate with selected layers
//
{
	if (size($layers) == 0) {
		$layers = getSelectedRenderItems($toolName, "", 0);
	}

	for ($layer in $layers) {
		evalEcho("connectAttr -na " + $layer + ".passContributionMap " + $map + ".owner");
	}
	updateEditorRenderLayer($toolName);
}

global proc renderLayerEditorCreateContMap(string $toolName, string $inLayer, int $withSelected)
//
//	Description:
//		Create a new contribution map and associate with the layer, add
//		selected items to map if requested
//		If $inLayer is empty, associate with all selected layers
//
{
	string $layers[] = getSelectedRenderItems($toolName, $inLayer, 0);
	string $map = `createNode -skipSelect passContributionMap`;
	renderLayerEditorAssocContMap($toolName, $layers, $map);
	if ($withSelected) {
		for ($layer in $layers) {
			renderLayerEditorAlterObjectsInContMap($toolName, $layer, $map, 1);
		}
	}
}

global proc renderLayerEditorCopyContMap(string $toolName, string $inMap, string $inLayer)
//
//	Description:
//		This procedure is called whenever the user wants to copy the
//		selected or specified contribution maps.
//
{
	string $maps[] = getSelectedRenderItems($toolName, $inMap, 1);
	string $layers[] = getSelectedRenderItems($toolName, $inLayer, 0);
	for ($map in $maps) {
		string $newMap[] = evalEcho("duplicate -inputConnections " + $map);

		// Disconnect any layers that weren't selected to prevent
		// duplicates from showing up everywhere
		// Note that duplicate returns a string array, however in
		// this case only the first index will be valid
		string $connectedLayers[] = `listConnections -type renderLayer $newMap[0]`;
		for ($layer in $connectedLayers) {
			if (!stringArrayContains($layer, $layers)) {
				evalEcho("disconnectAttr -na " + $layer + ".passContributionMap " + $newMap[0] + ".owner");
			}
		}
	}

	updateEditorRenderLayer($toolName);
}

global proc renderLayerEditorDeleteContMap(string $toolName, string $map)
//
//	Description:
//		Delete the specified map or if no map argument given then
//		delete all the selected maps.
{
	string $maps[] = getSelectedRenderItems($toolName, $map, 1);

	for ($map in $maps) {
		// confirm delete if pass cont map is connected to multiple
		// render layers
		int $confirmDelete = true;
		if (1 < size(`listConnections -type renderLayer $map`)) {
			string $title = (uiRes("m_layerEditor.kConfirmPassContDel"));
			string $confirmString = (uiRes("m_layerEditor.kConfirmDelYes"));
			string $denyString = (uiRes("m_layerEditor.kConfirmDelNo"));
			string $message = (uiRes("m_layerEditor.kConfirmDelMsg"));
			$message = `format -s $map $message`;
			string $result = `confirmDialog	-title $title
				-button $confirmString
				-button $denyString
				-defaultButton $confirmString
				-message $message`;

			$confirmDelete = ($result == $confirmString);
		}

		if ($confirmDelete) {
			catch(`evalEcho("delete "+$map)`);
		}
	}

	updateEditorRenderLayer($toolName);
}

global proc renderLayerEditorDeleteUnusedContMaps(string $toolName)
//
//	Description:
//		Delete all maps that have nothing in them
//
{
	string $contMaps[] = `ls -type passContributionMap`;

	//	Determine the contents of each map
	for ($map in $contMaps) {
		int $used = ((size(`listConnections ($map + ".dagObjects")`) > 0) ||
						(size(`listConnections ($map + ".light")`) > 0));
		if (!$used) {
			renderLayerEditorDeleteContMap($toolName, $map);
		}
	}
}

global proc renderLayerEditorContMapMembership(string $toolName, string $map)
//
//	Description:
//		RLTODO: fill in whatever this is supposed to do, then enable menu
//				items at appropriate times
//
{
	string $maps[] = getSelectedRenderItems($toolName, $map, 1);
	// do something...probably
	//   relationshipEditor("passContributionMaps", $maps, {});
}

global proc renderLayerEditorContMapAttributes(string $toolName, string $map)
//
//	Description:
//		Show the Attribute Editor for the specified contribution map or if
//		no argument given then use the first selected map
//
{
	if ($map == "") {
		string $temp[] = getSelectedRenderItems($toolName, $map, 1);
		if (size($temp) > 0) {
			$map = $temp[0];
		}
	}

	if ($map != "") {
		select -replace $map;
		editSelected();
	}
}

global proc renderLayerEditorCreateAndAssignPass(
	string $layer,
	string $map,
	string $uiName,
	string $presetPath)
//
//	Description:
//		Create a new render pass using the given preset and assign it to the
//		given layer and pass contribution map
//
{
	if (`objExists $layer` && `nodeType $layer` == "renderLayer") {
		string $node = evalEcho("createNode renderPass");
		if(`filetest -e $presetPath`) {
			evalEcho("applyAttrPreset \"" + $node + "\" \"" + $presetPath + "\" 1");
		}
		string $passID = getAttr ($node + ".passID");
		string $newName = renderPassDefaultName($uiName, $passID);
		if ($newName != "") {
			$node = evalEcho("rename \"" + $node + "\" \"" + $newName +"\"");
		}

		if (`objExists $node` && `nodeType $node` == "renderPass") {
			connectAttr -nextAvailable ($layer + ".renderPass") ($node + ".owner");

			if (`objExists $map` && `nodeType $map` == "passContributionMap") {
				connectAttr -nextAvailable ($node + ".message ") ($map + ".renderPass");
			}
		}
	}
}

//////////////
// Update/creation methods for the render layer editor
//////////////

global proc updateEditorFeedbackRenderLayer(string $toolName, string $layer)
//
//	Description
//		Update aspects of a particular row in the layer editor that do not
//		require the full tree to be rebuilt
//
{
	string $treeControl = ($toolName + "RenderLayerEditor");

	// update buttons
	if (`getAttr ($layer + ".renderable")`) {
		treeView -edit
			-image $layer 1 "renderable.png"
			-buttonState $layer 1 "buttonDown"
			$treeControl;
	} else {
		treeView -edit
			-image $layer 1 "renderable_dim.png"
			-buttonState $layer 1 "buttonUp"
			$treeControl;
	}

	if (`getAttr ($layer + ".imageRendered")`) {
		if (`getAttr ($layer + ".recycleImage")`) {
			treeView -edit
				-enableButton $layer 2 1
				-image $layer 2 "recycle_green.png"
				$treeControl;
		} else {
			treeView -edit
				-enableButton $layer 2 1
				-image $layer 2 "recycle_red.png"
				$treeControl;
		}
	} else {
		treeView -edit
			-enableButton $layer 2 0
			-image $layer 2 "recycle_dim.png"
			$treeControl;
	}

	// For each render globals node, check if there is a connection
	// between the layer's adjustments plug and any node that matches
	// the type of the globals node
	// Do not do this for masterLayer as overrides there do not make sense
	string $imageName = "overrideSettings_dim.png";
	if ($layer != "defaultRenderLayer") {
		string $globalsNodes[] = `listRenderSettingNodes`;
		for ($node in $globalsNodes) {
			if (`objExists $node`) {
				string $type = `nodeType $node`;
				if (0 < size(`listConnections -type $type ($layer + ".adjustments")`)) {
					$imageName = "overrideSettings.png";
					break;
				}
			}
		}
	}
	treeView -edit
		-image $layer 3 $imageName
		$treeControl;

	// update display label
	$showNamespace = `optionVar -query renderLayerShowNamespace`;
	string $name = displayLabelRenderLayer($showNamespace, $layer);
	int $blendMode = `getAttr ($layer + ".psdBlendMode")`;
	string $suffix = " (" + `blendModeOptions_AttrToUI($blendMode)` + ")";
	treeView -edit
		-displayLabel $layer $name
		-displayLabelSuffix $layer $suffix
		$treeControl;
}

global proc updateEditorRenderLayer(string $toolName)
//
//	Description
//		Rebuild the treeView for the render layer editor based on the current
//		state of the layers and contribution maps
//
{
	global float $gRenderLayerEditorSelectColorTwo[];

	string $layerArray[] = buildRenderLayerArray();
	string $treeControl = ($toolName + "RenderLayerEditor");
	string $activeLayer = `editRenderLayerGlobals -q -currentRenderLayer`;
	 // save pass cont maps as they're found to attach script jobs later
	string $connectedPassContMaps[];

	// save expand collapse states
	int $expandStates[] = {};
	int $numLayers = size($layerArray);
	for ($i=0; $i<$numLayers; $i++) {
		string $layer = $layerArray[$i];
		if (`treeView -itemExists $layer -q $treeControl`) {
			$expandStates[$i] = `treeView -isItemExpanded $layer -q $treeControl`;
		} else {
			$expandStates[$i] = 0;
		}
	}

	// Remove all old layer stuff
	treeView -edit -removeAll $treeControl;

	// script job stuff
	int $firstScriptJob = true;
	string $editorUpdateScript = ("updateEditorRenderLayer(\\\"" + $toolName + "\\\")");
	$editorUpdateScript = ("evalDeferred -lowestPriority \"" + $editorUpdateScript + "\"");

	// populate tree view with all layers and contribution maps
	// also attach script jobs for layers to tree view
	for ($i=0; $i<$numLayers; $i++) {
		string $layer = $layerArray[$i];

		// add layer as top level then parent comp sets to it
		treeView -edit -addItem $layer "" $treeControl;
		string $passContrib[] = getSortedPassContributionMapList($layer);
		for ($passC in $passContrib) {
			string $ident = buildLayerContMapIdent($layer, $passC);
			treeView -edit -hideButtons -addItem $ident $layer $treeControl;
			treeView -edit
				-enableButton $ident 1 false
				-enableButton $ident 2 false
				-enableButton $ident 3 false
				-displayLabel $ident $passC
				-selectionColor $ident
					$gRenderLayerEditorSelectColorTwo[0]
					$gRenderLayerEditorSelectColorTwo[1]
					$gRenderLayerEditorSelectColorTwo[2]
				$treeControl;

			$connectedPassContMaps[size($connectedPassContMaps)] = $passC;
		}

		// edit per layer settings
		treeView -edit
			-buttonStyle $layer 1 "2StateButton"
			-buttonStyle $layer 2 "pushButton"
			-buttonStyle $layer 3 "pushButton"
			-selectItem $layer ($layer == $activeLayer)
			-expandItem $layer $expandStates[$i]
			-font $layer "boldLabelFont"
			$treeControl;

		// parent all script jobs for all layers to the tree view, but make
		// sure we replace the old ones on the first time
		string $layerUpdateScript = ("updateEditorFeedbackRenderLayer " + $toolName + " " + $layer);
		if ($firstScriptJob) {
			scriptJob -replacePrevious -parent $treeControl
				-attributeChange ($layer + ".renderable") $layerUpdateScript;
					
			$firstScriptJob = false;
		} else {
			scriptJob -parent $treeControl
				-attributeChange ($layer + ".renderable") $layerUpdateScript;
		}
		scriptJob -parent $treeControl
			-attributeChange ($layer + ".imageRendered") $layerUpdateScript;
		scriptJob -parent $treeControl
			-attributeChange ($layer + ".recycleImage") $layerUpdateScript;
		scriptJob -parent $treeControl
			-attributeChange ($layer + ".psdBlendMode") $layerUpdateScript;
		scriptJob -parent $treeControl -allChildren
			-attributeChange ($layer + ".adjustments") $layerUpdateScript;
		scriptJob -parent $treeControl
			-attributeChange ($layer + ".displayOrder") $editorUpdateScript;
		scriptJob -parent $treeControl
			-connectionChange ($layer + ".passContributionMap") $editorUpdateScript;
		scriptJob -parent $treeControl
			-nodeNameChanged $layer $editorUpdateScript;

		updateEditorFeedbackRenderLayer($toolName, $layer);
	}

	// Add rename script jobs for render pass contribution maps
	// Do it outside of layer loop to avoid duplicates
	$connectedPassContMaps = stringArrayRemoveDuplicates($connectedPassContMaps);
	for ($pcm in $connectedPassContMaps) {
		scriptJob -parent $treeControl
			-nodeNameChanged $pcm $editorUpdateScript;
	}
}

global proc string[] getSortedPassContributionMapList(string $layer)
{
	string $passContrib[] ;
	if("" == $layer) {
		$passContrib = `ls -type passContributionMap`;
	}
	else{
		$passContrib = `listConnections -type "passContributionMap" ($layer + ".passContributionMap")`;
	}
	$passContrib = `sort $passContrib`;
	return $passContrib;
}

global proc renderLayerEditorFloatingWindow()
//
//	Description
//		Create the floating window version of the render layer editor
//
{
	if (`window -exists RenderLayerEditorWindow` == false) { 
		string $renderLayerEditor = (uiRes("m_layerEditor.kRenderLayerEditor"));
		string $window = `window RenderLayerEditorWindow`;
		window -edit -title $renderLayerEditor $window; 
		createRenderLayerEditor($window, "RenderLayerEditor"); 
		showWindow $window;
	} else {
		showWindow RenderLayerEditorWindow;
	}
}

global proc createRenderLayerEditor(string $parentLayout, string $toolName)
//
//	Description
//		Build the render layer editor, with menus, header buttons and blend
//		mode UI, and the treeView showing the layers and pass contribution maps
//
//		This can be used to create multiple render layer editors, all that
//		is required is a parent layout and a unique name to identify
//		the render layer editor ($toolName)
//
//		Currently this function is used to create the main render layer
//		editor ($toolName=RenderLayerTab) and the floating render layer
//		editor ($toolName=RenderLayerEditor).
//
{
	// strings
	string $layersMenu				= uiRes("m_layerEditor.kLayers");

	string $optionsMenu				 = uiRes("m_layerEditor.kOptions");

	string $contMenu					= (uiRes("m_layerEditor.kContMenu"));

	string $helpMenu		  = uiRes("m_layerEditor.kHelp");
	string $renderLayersHelp  = (uiRes("m_layerEditor.kHelpRenderLayers"));

	//	Need a menu bar layout for the menus.
	setParent $parentLayout;
	menuBarLayout $toolName;

	//	Create "Layers" pulldown menu
	$editMenuForRenLayers = `menu -label $layersMenu -allowOptionBoxes true`;
	menu -e -postMenuCommand ("layerEditorBuildRenderLayerMenu(\"" + $editMenuForRenLayers + "\", \"" + $toolName + "\")") $editMenuForRenLayers;

	//	Create "Contribution" pulldown menu
	$contributionMenuForRenLayers = `menu -label $contMenu`;
	menu -e -postMenuCommand ("layerEditorBuildRenderContributionMenu(\"" + $contributionMenuForRenLayers + "\", \"" + $toolName  + "\")") $contributionMenuForRenLayers ;

	//	Create "Options" pulldown menu
	$optionsMenuForRenLayers = `menu -label $optionsMenu -allowOptionBoxes true`;
	menu -e -postMenuCommand ("layerEditorBuildRenderOptionMenu(\"" + $optionsMenuForRenLayers  + "\", \"" + $toolName  + "\")") $optionsMenuForRenLayers  ;

	// Create the help menu
	menu -label $helpMenu;
	menuItem -label $renderLayersHelp -command "showHelp RenderLayers";

	// form layout to hold buttons and treeView
	string $rlLayout = ($toolName + "RenderLayerFormLayout");
	formLayout $rlLayout;
		// Presently, I will have blend modes w.r.t PSD.
		int $blendModeOptions[] = {1, 7, 3, 4, 8, 11};
		string $blendModeOptionMenu = `optionMenu -cc ("layerBlendModeChanged " + $toolName) LayerEditorBlendModeOptionMenu`;
			int $index;
			for($index = 0; $index < size($blendModeOptions); $index++) {
				menuItem -label `blendModeOptions_AttrToUI($blendModeOptions[$index])`;
			}

		// move up/down buttons, create buttons
		string $moveSelectionUpButton = `symbolButton -image "moveLayerUp.png"  -annotation (uiRes("m_layerEditor.kMoveSelectionUpButton"))`;
		string $moveSelectionDownButton = `symbolButton -image "moveLayerDown.png"  -annotation (uiRes("m_layerEditor.kMoveSelectionDownButton"))`;
		string $emptyRenLayerButton = `symbolButton -image "newLayerEmpty.png"  -annotation (uiRes("m_layerEditor.kCreateEmptyLayerAnnot"))`;
		string $selectedRenLayerButton = `symbolButton -image "newLayerSelected.png"  -annotation (uiRes("m_layerEditor.kCreateLayerAssignObjects"))`;

	
	
	// the tree view
	string $treeControl = ($toolName + "RenderLayerEditor");
	treeView -numberOfButtons 3
		-parent $rlLayout
		-reverseTreeOrder false
		-attachButtonRight false
		-allowReparenting false
		-selectionChangedCommand ("renderLayerEditorOnSelectionChanged " + $toolName)
		-editLabelCommand "renderLayerEditorItemOnRename"
		-pressCommand 1 ("renderLayerEditorRenderable " + $toolName)
		-pressCommand 2 ("renderLayerEditorRecycleChange " + $toolName)
		-pressCommand 3 ("renderLayerEditorSettingsOverride " + $toolName)
		-dragAndDropCommand ("layerEditorRenderLayerOnDragDrop " + $toolName)
		$treeControl;

	// context menu for tree view
	string $renderLayerPopupMenu = `popupMenu -button 3 -parent $treeControl`;
	treeView -edit
		-contextMenuCommand ("renderLayerEditorBuildPopupMenu \""+$toolName+"\" \""+$renderLayerPopupMenu+"\" ")
		$treeControl;

	// attach controls
	formLayout	-e  
		-attachForm $blendModeOptionMenu "top" 5
		-attachForm $blendModeOptionMenu "left" 2
		-attachControl $blendModeOptionMenu "right" 20 $moveSelectionUpButton
		-attachNone $blendModeOptionMenu "bottom"

		-attachForm  $selectedRenLayerButton "top" 1
		-attachForm  $selectedRenLayerButton "right" 2
		-attachNone  $selectedRenLayerButton "bottom"
		-attachNone  $selectedRenLayerButton "left" 

		-attachForm $emptyRenLayerButton "top" 1
		-attachControl $emptyRenLayerButton "right" 1 $selectedRenLayerButton
		-attachNone $emptyRenLayerButton "bottom"
		-attachNone $emptyRenLayerButton "left"

		-attachForm $moveSelectionDownButton "top" 1
		-attachControl $moveSelectionDownButton "right" 4 $emptyRenLayerButton
		-attachNone $moveSelectionDownButton "bottom"
		-attachNone $moveSelectionDownButton "left"

		-attachForm $moveSelectionUpButton "top" 1
		-attachControl $moveSelectionUpButton "right" 1 $moveSelectionDownButton
		-attachNone $moveSelectionUpButton "bottom"
		-attachNone $moveSelectionUpButton "left"

		-attachForm $treeControl "left" 0
		-attachForm $treeControl "right" 0
		-attachControl $treeControl "top" 2 $blendModeOptionMenu
		-attachForm  $treeControl "bottom"	0
		$rlLayout;

	symbolButton -edit -command ("layerEditorCreateRenderLayer 1") $emptyRenLayerButton;
	symbolButton -edit -command ("layerEditorCreateRenderLayer 2") $selectedRenLayerButton ;
	symbolButton -edit -command ("layerEditorMoveRenderItem " + $toolName + " 1") $moveSelectionUpButton;
	symbolButton -edit -command ("layerEditorMoveRenderItem " + $toolName + " 0") $moveSelectionDownButton ;

	// script jobs
	scriptJob -permanent -parent $parentLayout -event renderLayerChange ("updateEditorRenderLayer " + $toolName);
	scriptJob -permanent -parent $parentLayout -event renderLayerManagerChange ("layerEditorRenderLayerManagerChange " + $toolName);

	//for bug 303190
	scriptJob -permanent -parent $parentLayout -event renderLayerChange passesTabSetDefaultPrecomp;
	scriptJob -permanent -parent $parentLayout -ac "defaultRenderLayer.precompTemplate" passesTabSetDefaultPrecomp;

	// build the layer editor
	updateEditorRenderLayer($toolName);
}

global proc layerEditorBuildRenderLayerMenu(string $parent, string $toolName)
{
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//  Menu is built already - just return
		//
		return;
	}

	menu -edit -postMenuCommand ("renderLayerEditorShowLayersMenu " + $toolName + " " + $parent) $parent;

	string $createEmptyLayer		  = uiRes("m_layerEditor.kCreateEmptyLayer");
	string $createLayerFromSelected   = (uiRes("m_layerEditor.kCreateLayerFromSelected"));
	string $duplicateLayer				 = (uiRes("m_layerEditor.kDuplicateLayer"));
	string $selectObjects			 = uiRes("m_layerEditor.kSelectObjectsInSelectedLayers");
	string $removeSelectedObjects	 = uiRes("m_layerEditor.kRemoveSelectedObjectsFromSelectedLayers");
	string $membership				= uiRes("m_layerEditor.kMembership");
	string $attributes				= uiRes("m_layerEditor.kAttributes");
	string $deleteSelectedLayers	  = uiRes("m_layerEditor.kDeleteSelectedLayers");
	string $deleteUnusedLayers		= uiRes("m_layerEditor.kDeleteUnusedLayers");
	string $floatingWindow			= (uiRes("m_layerEditor.kRenderFloating"));

	$newEmptyMenuItemForRenLayers = `menuItem -label $createEmptyLayer`;
	$newFromSelectedMenuItemForRenLayers = `menuItem -label $createLayerFromSelected`;

	menuItem -divider true;

	$duplicateLayerMenuItemForRenLayers = `menuItem -label $duplicateLayer`;
	$copyLayerOptionBoxForRenLayers = `menuItem -optionBox true`;

	menuItem -divider true;

	$selectObjectsMenuItemForRenLayers = 
		`menuItem -label $selectObjects
		LayerEditorEditMenuSelectObjectsMenuItemForRenLayers`;
	$removeObjectsMenuItemForRenLayers = 
		`menuItem -label $removeSelectedObjects
		LayerEditorEditMenuRemoveObjectsMenuItemForRenLayers`;

	menuItem -divider true;

	$membershipMenuItemForRenLayers = `menuItem -label $membership`;
	$layerAttributesMenuItemForRenLayers = `menuItem -label $attributes
		LayerEditorEditMenuLayerAttributesMenuItemRenLayers`;

	menuItem -divider true;

	$deleteMenuItemForRenLayers = `menuItem -label $deleteSelectedLayers
		LayerEditorEditMenuDeleteMenuItemForRenLayers`;
	$deleteUnusedMenuItemForRenLayers = `menuItem -label $deleteUnusedLayers`;

	menuItem -divider true;

	$floatingWindowMenuItemForRenLayers = `menuItem -label $floatingWindow
		LayerEditorEditMenuFloatingWindowMenuItemForRenLayers`;

	menuItem -edit -command ("layerEditorCreateRenderLayer 1") $newEmptyMenuItemForRenLayers;
	menuItem -edit -command ("layerEditorCreateRenderLayer 2") $newFromSelectedMenuItemForRenLayers;
	menuItem -edit -command ("renderLayerEditorCopyLayer " + $toolName + " \"\"") $duplicateLayerMenuItemForRenLayers; 
	menuItem -edit -command ("renderLayerEditorCopyLayerOptions " + $toolName) $copyLayerOptionBoxForRenLayers; 
	menuItem -edit -command ("renderLayerEditorSelectObjects " + $toolName + " \"\"") $selectObjectsMenuItemForRenLayers;
	menuItem -edit -command ("renderLayerEditorRemoveObjects " + $toolName + " \"\"") $removeObjectsMenuItemForRenLayers;
	menuItem -edit -command ("renderLayerEditorMembership " + $toolName + " \"\"") $membershipMenuItemForRenLayers;
	menuItem -edit -command ("renderLayerEditorLayerAttributes \"\"") $layerAttributesMenuItemForRenLayers;
	menuItem -edit -command ("renderLayerEditorDeleteLayer " + $toolName + " \"\"") $deleteMenuItemForRenLayers;
	menuItem -edit -command ("renderLayerEditorDeleteUnused " + $toolName) $deleteUnusedMenuItemForRenLayers;
	menuItem -edit -command ("renderLayerEditorFloatingWindow") $floatingWindowMenuItemForRenLayers;
}

global proc layerEditorBuildRenderContributionMenu(string $parent, string $toolName)
{
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//  Menu is built already - just return
		//
		return;
	}

	menu -edit -postMenuCommand ("renderLayerEditorShowContributionMenu " + $toolName + " " + $parent) $parent;

	string $createAssContMap			= (uiRes("m_layerEditor.kCreateAssContMap"));
	string $assExistContMap				= (uiRes("m_layerEditor.kAsscPassContMap"));
	string $copyContMap					= (uiRes("m_layerEditor.kCopyContMap"));
	string $selectObjectsInContMap		= (uiRes("m_layerEditor.kSelectObjInContMap"));
	string $addObjectsToContMap			= (uiRes("m_layerEditor.kAddObjToContMap"));
	string $removeObjectsFromContMap	= (uiRes("m_layerEditor.kRemoveObjFromContMap"));
	string $deleteContMaps				= (uiRes("m_layerEditor.kDeleteContMaps"));
	string $deleteUnusedContMaps		= (uiRes("m_layerEditor.kDeleteUnusedContMaps"));
	string $membership				= uiRes("m_layerEditor.kMembership");
	string $attributes				= uiRes("m_layerEditor.kAttributes");

	$createAssContMapMenuItem = `menuItem -label $createAssContMap
		LayerEditorContMenuCreateAssContMapMenuItem`;

	$assExistContMapMenuItem = `menuItem -label $assExistContMap -subMenu true
		LayerEditorContMenuAssExistContMapMenuItem`;
	setParent -menu ..;

	$copyContMapMenuItem = `menuItem -label $copyContMap
		LayerEditorContMenuCopyContMapMenuItem`;

	menuItem -divider true;

	$selectItemsInContMapMenuItem = `menuItem -label $selectObjectsInContMap
		LayerEditorContMenuSelectItemsInContMapMenuItem`;

	$addItemsToContMapMenuItem = `menuItem -label $addObjectsToContMap
		LayerEditorContMenuAddItemsToContMapMenuItem`;

	$removeItemsFromContMapMenuItem = `menuItem -label $removeObjectsFromContMap
		LayerEditorContMenuRemoveItemsFromContMapMenuItem`;

	menuItem -divider true;

	$deleteContMapMenuItem = `menuItem -label $deleteContMaps
		LayerEditorContMenuDeleteContMapMenuItem`;

	$deleteUnusedContMapMenuItem = `menuItem -label $deleteUnusedContMaps
		LayerEditorContMenuDeleteUnusedContMapMenuItem`;

	menuItem -divider true;

	$membershipContMapMenuItem = `menuItem -label $membership -enable false
		LayerEditorContMenuMembershipContMapMenuItem`;

	$attributesContMapMenuItem = `menuItem -label $attributes
		LayerEditorContMenuAttributesContMapMenuItem`;

	menuItem -edit -command ("renderLayerEditorCreateContMap " + $toolName + " \"\" 0") $createAssContMapMenuItem;
	menuItem -edit -command ("renderLayerEditorCopyContMap " + $toolName + " \"\" \"\"") $copyContMapMenuItem;
	menuItem -edit -command ("renderLayerEditorSelectObjectsInContMap " + $toolName + " \"\"") $selectItemsInContMapMenuItem;
	menuItem -edit -command ("renderLayerEditorAlterObjectsInContMap " + $toolName + " \"\" \"\" 1") $addItemsToContMapMenuItem;
	menuItem -edit -command ("renderLayerEditorAlterObjectsInContMap " + $toolName + " \"\" \"\" 0") $removeItemsFromContMapMenuItem;
	menuItem -edit -command ("renderLayerEditorDeleteContMap " + $toolName + " \"\"") $deleteContMapMenuItem;
	menuItem -edit -command ("renderLayerEditorDeleteUnusedContMaps " + $toolName) $deleteUnusedContMapMenuItem;
	menuItem -edit -command ("renderLayerEditorContMapMembership " + $toolName + " \"\"") $membershipContMapMenuItem;
	menuItem -edit -command ("renderLayerEditorContMapAttributes " + $toolName + " \"\"") $attributesContMapMenuItem;

	renderLayerEditorShowContributionMenu $toolName $parent;
}

global proc layerEditorBuildRenderOptionMenu(string $parent, string $toolName)
{
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//  Menu is built already - just return
		//
		return;
	}

	menu -edit -postMenuCommand ("renderLayerEditorShowOptionsMenu " + $parent) $parent;

	string $makeNewLayersCurrent		= uiRes("m_layerEditor.kMakeNewLayersCurrent");
	string $addNewObjectsToCurrentLayer = uiRes("m_layerEditor.kAddNewObjectsToCurrentLayer");
	string $autoOverrides			   = uiRes("m_layerEditor.kAutoOverrides");
	string $showNamespace			   = uiRes("m_layerEditor.kShowNamespace");
	string $renderAllLayers			 = (uiRes("m_layerEditor.kRenderAllLayers"));

	menuItem -checkBox false -label $makeNewLayersCurrent
		-command ("optionVar -intValue renderLayerCurrent #1;"
			+ "optionVar -intValue renderLayerCurrent #1;")
		LayerEditorOptionsMenuMakeCurrentMenuItemRenLayers;
	menuItem -checkBox false -label $addNewObjectsToCurrentLayer
		LayerEditorOptionsMenuUseCurrentMenuItemRenLayers;
	menuItem -checkBox false -label $autoOverrides
		-command ("editRenderLayerGlobals -enableAutoAdjustments #1")
		LayerEditorOptionsMenuAutoAdjustmentMenuItemRenLayers;
	menuItem -checkBox false -label $showNamespace
		-command ("optionVar -intValue renderLayerShowNamespace #1;updateEditorRenderLayer " + $toolName)
		LayerEditorOptionsMenuShowNamespaceMenuItemRenLayers;

	menuItem -divider true;

	menuItem -checkBox false -label $renderAllLayers
		-command "switchRenderAllLayers" 
		LayerEditorOptionsRenderAllLayersRenLayers;

	menuItem -optionBox true
		-command "switchRenderAllLayersOptBox";

}

global proc int renderLayerEditorBuildPopupMenu(string $toolName, string $parentMenu, string $item)
//
//	Description
//		Build context menus for layers and pass contribution maps
//
{
	popupMenu -edit -deleteAllItems $parentMenu;

	if (`objExists $item`) {
		if (`nodeType $item` == "renderLayer") {
			// Build layer context menu

			setParent -menu $parentMenu;

			menuItem -label ($item + "...")
				-command ("createLayerEditorQuickEditWindow {\"" + $item + "\"}");
			menuItem -divider true;
			menuItem -divider true;
			menuItem -divider true;
			
			string $selection[] = `ls -selection`;
			int $enable = (size($selection) > 0);
			menuItem -label (uiRes("m_layerEditor.kAddSelectedObjects"))
				-enable $enable
				-command ("renderLayerEditorAddObjects " + $toolName + " " + $item);
			menuItem -label (uiRes("m_layerEditor.kRemoveSelectedObjects"))
				-enable $enable
				-command ("renderLayerEditorRemoveObjects " + $toolName + " " + $item);

			string $layerContents[] = `editRenderLayerMembers -query $item`;
			$enable = (size($layerContents) > 0);
			menuItem -label (uiRes("m_layerEditor.kSelectObjsInLayer"))
				-enable $enable
				-command ("renderLayerEditorSelectObjects " + $toolName + " " + $item);

			menuItem -divider true;
			
			$enable = (size($layerContents) > 0);
			menuItem -label (uiRes("m_layerEditor.kEmptyRenderLayer"))
				-enable $enable
				-command ("renderLayerEditorEmptyLayer " + $toolName + " " + $item);

			menuItem -label (uiRes("m_layerEditor.kDuplicateLayer"))
				-command ("renderLayerEditorCopyLayer " + $toolName + " " + $item);

			menuItem -label (uiRes("m_layerEditor.kDeleteLayer"))
				-command ("renderLayerEditorDeleteLayer " + $toolName + " " + $item);

			menuItem -divider true;

			menuItem -label (uiRes("m_layerEditor.kOverrides")) -subMenu true;
				menuItem -label (uiRes("m_layerEditor.kRemoveRenderSettingOverrides"))
					-command ("deleteAllRenderSettingOverrides(\""+$item+"\")");

				menuItem -label (uiRes("m_layerEditor.kRemoveRenderFlagOverrides"))
					-command ("setAttr "+$item+".attributeOverrideScript -type \"string\" \"\"");

				string $connections[] = `listConnections -source true -destination false ($item+".shadingGroupOverride")`;
				menuItem -label (uiRes("m_layerEditor.kRemoveMaterialOverride"))
					-command ("disconnectAttr "+$connections[0]+".message "+ $item+".shadingGroupOverride");

				menuItem -divider true;

				if (!`exists nodeTypeNiceName`) {
					source "nodeTypeNiceName.mel";
				}

				menuItem -label (uiRes("m_layerEditor.kCreateNewMaterialOverride")) -subMenu true;
				
				string $excludedMaterialTypes[] = `callbacks -executeCallbacks -hook "provideClassificationStrings"`;
				string $excludedMaterialTypesAsString = "";
				for ($materialTypes in $excludedMaterialTypes) {
					$excludedMaterialTypesAsString = ($excludedMaterialTypesAsString + ":" + $materialTypes);
				}
		
				string $classification = "shader/surface";
				string $types[] = `listNodeTypes -ex $excludedMaterialTypesAsString $classification`;

				for ($type in $types) {
					// Check whether node should appear in this UI, based on
					// certain variables
					if (!shouldAppearInNodeCreateUI($type)) continue;
					string $typeString = `nodeTypeNiceName $type`;
					menuItem -label $typeString 
						-command ("hookShaderOverride(\"" + $item + "\",\"" + $type + "\", \"\")");
				}

				// Give third parties a chance to add menu items to the Render Layer Popup Menu
				callbacks -executeCallbacks -hook "addItemsToRenderLayerEditorPopupMenu" $item;
				
				setParent -menu ..;

				menuItem -label (uiRes("m_layerEditor.kAssignExistingMaterialOverride")) -subMenu true;
				$types = `listNodeTypes $classification`;
				for ($type in $types) {
					// Get a list of all material nodes which have the current node type
					string $material;
					string $materialArray[] = `ls -exactType $type`;

					for ( $material in $materialArray ) {
						menuItem -l $material 
							-command ("hookShaderOverride(\"" + $item + "\", \"\", \"" + $material + "\")");
					}
				}
				setParent -menu ..;
			setParent -menu ..;

			menuItem -divider true;

			menuItem -label (uiRes("m_layerEditor.kPassContMap")) -subMenu true;
				menuItem -label (uiRes("m_layerEditor.kCreateEmptyPassContMap"))
					-command ("renderLayerEditorCreateContMap " + $toolName + " " + $item + " 0");

				menuItem -label (uiRes("m_layerEditor.kCreatePassContMapAss"))
					-command ("renderLayerEditorCreateContMap " + $toolName + " " + $item + " 1");

				$enable = (size(`ls -type passContributionMap`) > 0);
				menuItem -label (uiRes("m_layerEditor.kAsscPassContMap")) -subMenu true
					-enable $enable;
				if ($enable) {
					string $maps[] = getUnassociatedContMaps($item);
					for ($map in $maps) {
						menuItem -label $map
							-command ("renderLayerEditorAssocContMap " + $toolName + " {\"" + $item + "\"} " + $map);
					}
				}
				setParent -menu ..;
			setParent -menu ..;

			$enable = (size(`renderPassRegistry -supportedRenderPasses`) > 0);
			menuItem -label (uiRes("m_layerEditor.kCreatePassMenu")) -subMenu true -enable $enable;
				if ($enable) {
					global string $gRenderPassPresetPath[];
					
					string $presetList[] = getRenderPassPresets();
					int $numPresets = size($presetList);

					for ($i=0; $i<$numPresets; $i++) {
						string $presetPath = $gRenderPassPresetPath[$i];
						string $name = $presetList[$i];
						menuItem -label $name
							-command ("renderLayerEditorCreateAndAssignPass " +
								$item + " \"\" \"" + $name + "\" \"" + $presetPath + "\"");
					}
				}
			setParent -menu ..;

			menuItem -divider true;
			
			menuItem -label (uiRes("m_layerEditor.kMembership"))
				-command ("renderLayerEditorMembership " + $toolName + " " + $item);
			menuItem -label (uiRes("m_layerEditor.kAttributes"))
				-command ("showEditor " + $item);

			return true;
		}
	} else {
		string $layerCont[] = parseLayerContMapIdent($item);
		string $layer = $layerCont[0];
		string $contMap = $layerCont[1];

		if (`objExists $layer` &&
			`nodeType $layer` == "renderLayer" &&
			`objExists $contMap` &&
			`nodeType $contMap` == "passContributionMap")
		{
			// Build pass contribution map context menu

			setParent -menu $parentMenu;

			menuItem -label ($contMap + "...")
				-command ("showEditor " + $contMap);
			menuItem -divider true;
			menuItem -divider true;
			menuItem -divider true;

			string $selection[] = `ls -selection`;
			int $enable = (size($selection) > 0);
			menuItem -label (uiRes("m_layerEditor.kAddSelectedObjects"))
				-enable $enable
				-command ("renderLayerEditorAlterObjectsInContMap " + $toolName + " " + $layer + " " + $contMap + " 1");

			menuItem -label (uiRes("m_layerEditor.kRemoveSelectedObjects"))
				-enable $enable
				-command ("renderLayerEditorAlterObjectsInContMap " + $toolName + " \"\" " + $contMap + " 0");

			$enable = ((size(`listConnections ($contMap + ".dagObjects")`) > 0) ||
						(size(`listConnections ($contMap + ".light")`) > 0));
			menuItem -label (uiRes("m_layerEditor.kSelectObjsInCompSet"))
				-enable $enable
				-command ("renderLayerEditorSelectObjectsInContMap " + $toolName + " " + $contMap);

			menuItem -divider true;

			menuItem -label (uiRes("m_layerEditor.kDeassociateCompSet"))
				-command ("disconnectAttr -na " + $layer + ".passContributionMap "
								+ $contMap + ".owner; updateEditorRenderLayer " + $toolName);

			menuItem -label (uiRes("m_layerEditor.kEmptyCompSet"))
				-command ("renderLayerEditorEmptyContMap " + $contMap);

			menuItem -label (uiRes("m_layerEditor.kDeleteCompSet"))
				-command ("renderLayerEditorDeleteContMap " + $toolName + " " + $contMap);

			menuItem -divider true;

			int $active = `getAttr ($contMap + ".active")`;
			menuItem -label (uiRes("m_layerEditor.kActivePCM"))
				-checkBox $active
				-command ("setAttr " + $contMap + ".active " + (!$active));

			menuItem -divider true;

			$enable = (size(`renderPassRegistry -supportedRenderPasses`) > 0);
			menuItem -label (uiRes("m_layerEditor.kCreatePassMenu")) -subMenu true -enable $enable;
				if ($enable) {
					global string $gRenderPassPresetPath[];
					
					string $presetList[] = getRenderPassPresets();
					int $numPresets = size($presetList);

					for ($i=0; $i<$numPresets; $i++) {
						string $presetPath = $gRenderPassPresetPath[$i];
						string $name = $presetList[$i];
						menuItem -label $name
							-command ("renderLayerEditorCreateAndAssignPass " +
								$layer + " " + $contMap + " \"" + $name + "\" \"" + $presetPath + "\"");
					}
				}
			setParent -menu ..;

			menuItem -divider true;

			menuItem -label (uiRes("m_layerEditor.kMembership"))
				-enable false
				-command ("renderLayerEditorContMapMembership " + $toolName + " " + $contMap);

			return true;
		}
	}
	return false;
}

//////////////////////////////////////////////////////////////////////////////
// COMMON METHODS
//////////////////////////////////////////////////////////////////////////////

global proc setLayerToMenuItems( string $parent, string $layers ){
//
//	Description:
//		Create the Set Layer Menu's child menuItems. The three menus
//		are almost identical so they are coded once with the following
//		arguments
//
//	Arguments:
//		$parent - The name of the parent menu
//		$layers - which layers to process: all, selected or onlySelected
//

	//Set All Layers
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}

	menuItem -label (uiRes("m_layerEditor.kVisible"))
		-annotation (uiRes("m_layerEditor.kVisibleAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".visibility\" 1")
		;
	menuItem -label (uiRes("m_layerEditor.kInvisible"))
		-annotation (uiRes("m_layerEditor.kInvisibleAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".visibility\" 0")
		;
	menuItem -label (uiRes("m_layerEditor.kVisiblePlayback"))
		-annotation (uiRes("m_layerEditor.kVisiblePlaybackAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".hideOnPlayback\" 0")
		;
	menuItem -label (uiRes("m_layerEditor.kInvisiblePlayback"))
		-annotation (uiRes("m_layerEditor.kInvisiblePlaybackAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".hideOnPlayback\" 1")
		;
	menuItem -divider true;

	menuItem -label (uiRes("m_layerEditor.kNormal"))
		-annotation (uiRes("m_layerEditor.kNormalAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".displayType\" 0")
		;
	menuItem -label (uiRes("m_layerEditor.kTemplate"))
		-annotation (uiRes("m_layerEditor.kTemplateAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".displayType\" 1")
		;
	menuItem -label (uiRes("m_layerEditor.kReference"))
		-annotation (uiRes("m_layerEditor.kReferenceAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".displayType\" 2")
		;
	menuItem -divider true;

	menuItem -label (uiRes("m_layerEditor.kFullDetail"))
		-annotation (uiRes("m_layerEditor.kFullDetailAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".levelOfDetail\" 0")
		;
	menuItem -label (uiRes("m_layerEditor.kBoundingBox"))
		-annotation (uiRes("m_layerEditor.kBoundingBoxAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".levelOfDetail\" 1")
		;
	menuItem -divider true;

	menuItem -label (uiRes("m_layerEditor.kShaded"))
		-annotation (uiRes("m_layerEditor.kShadedAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".shading\" 1")
		;
	menuItem -label (uiRes("m_layerEditor.kUnshaded"))
		-annotation (uiRes("m_layerEditor.kUnshadedAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".shading\" 0")
		;
	menuItem -divider true;

	menuItem -label (uiRes("m_layerEditor.kTextured"))
		-annotation (uiRes("m_layerEditor.kTexturedAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".texturing\" 1")
		;
	menuItem -label (uiRes("m_layerEditor.kUntextured"))
		-annotation (uiRes("m_layerEditor.kUntexturedAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".texturing\" 0")
		;
	menuItem -divider true;

	menuItem -label (uiRes("m_layerEditor.kPlaybackOn"))
		-annotation (uiRes("m_layerEditor.kPlaybackOnAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".playback\" 1")
		;
	menuItem -label (uiRes("m_layerEditor.kPlaybackOff"))
		-annotation (uiRes("m_layerEditor.kPlaybackOffAnnot"))
		-echoCommand true
		-c ("setLayerTo " + $layers + "\".playback\" 0")
		;
}

global proc layerEditorBuildDisplayLayerMenu(string $parent)
{
	// 1 == alphabetically
	// 0 == chronologically
	
	if( !`optionVar -exists displayLayerSortOptions` )
	{
		optionVar -intValue "displayLayerSortOptions" 0;
	}
	
	// we use chronological order by default
	int $sortOrder = `optionVar -exists displayLayerSortOptions` ? `optionVar -query displayLayerSortOptions` : 0;

	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//  Menu is built already - just return
		//
		return;
	}

	menu -edit -postMenuCommand ("layerEditorShowEditMenu " + $parent) $parent;

	string $createEmptyLayer		  = (uiRes("m_layerEditor.kCreateEmptyLayer"));
	string $createFromSelectedLayer   = (uiRes("m_layerEditor.kCreateFromSelected"));
	string $selectObjects			 = (uiRes("m_layerEditor.kSelectObjectsInSelectedLayers"));
	string $removeSelectedObjects	 = (uiRes("m_layerEditor.kRemoveSelectedObjectsFromSelectedLayers"));
	string $membership				= (uiRes("m_layerEditor.kMembership"));
	string $attributes				= (uiRes("m_layerEditor.kAttributes"));
	string $deleteSelectedLayers	  = (uiRes("m_layerEditor.kDeleteSelectedLayers"));
	string $deleteUnusedLayers		= (uiRes("m_layerEditor.kDeleteUnusedLayers"));

	$newEmptyMenuItemForDispLayers = `menuItem -label $createEmptyLayer`;
	$newFromSelectedMenuItemForDispLayers = `menuItem -label $createFromSelectedLayer`;

	menuItem -divider true;

	$selectObjectsMenuItemForDispLayers = `menuItem -label $selectObjects
		LayerEditorEditMenuSelectObjectsMenuItemForDispLayers`;
	$removeObjectsMenuItemForDispLayers = `menuItem -label $removeSelectedObjects
		LayerEditorEditMenuRemoveObjectsMenuItemForDispLayers`;

	menuItem -divider true;

	$membershipMenuItemForDispLayers = `menuItem -label $membership`;
	$layerAttributesMenuItemForDispLayers = `menuItem -label $attributes
		LayerEditorEditMenuLayerAttributesMenuItemDispLayers`;

	menuItem -divider true;

	$deleteMenuItemForDispLayers = `menuItem -label $deleteSelectedLayers
		LayerEditorEditMenuDeleteMenuItemForDispLayers`;
	$deleteUnusedMenuItemForDispLayers = `menuItem -label $deleteUnusedLayers`;

	menuItem -divider true;

	// set layers to menus
	$layerMenus = `menuItem -label (uiRes("m_layerEditor.kSetAllLayers")) -tearOff 1 -subMenu true "LayerEditorEditMenuSetAllLayersMenu"`;
	menuItem -e -postMenuCommand ("setLayerToMenuItems(\"" + $layerMenus + "\", \"all\")") -postMenuCommandOnce true $layerMenus;
	setParent -m ..;
	$layerMenus = `menuItem -label (uiRes("m_layerEditor.kSetSelectedLayers")) -tearOff 1 -subMenu true "LayerEditorEditMenuSetSelectedLayersMenu"`;
	menuItem -e -postMenuCommand ("setLayerToMenuItems(\"" + $layerMenus + "\", \"selected\")") -postMenuCommandOnce true $layerMenus;
	setParent -m ..;
	$layerMenus = `menuItem -label (uiRes("m_layerEditor.kSetOnlySelectedLayers")) -tearOff 1 -subMenu true "LayerEditorEditMenuSetOnlySelectedLayersMenu"`;
	menuItem -e -postMenuCommand ("setLayerToMenuItems(\"" + $layerMenus + "\", \"onlySelected\")") -postMenuCommandOnce true $layerMenus;
	setParent -m ..;

	menuItem -divider true;
	// sort layers option
	radioMenuItemCollection;
	menuItem -label (uiRes("m_layerEditor.kDisplayLayerSortOrderOptChrono"))
		-radioButton ($sortOrder == 0)
		-command ("optionVar -intValue displayLayerSortOptions 0; reorderLayers 0;")
		LayerEditorEditMenuSortChronoMenuItemDispLayers;
	menuItem -label (uiRes("m_layerEditor.kDisplayLayerSortOrderOptAlpha"))
		-radioButton ($sortOrder == 1)
		-command ("optionVar -intValue displayLayerSortOptions 1; reorderLayers 1;")
		LayerEditorEditMenuSortAlphaMenuItemDispLayers;

	menuItem -edit -command ("layerEditorCreateLayer 1") $newEmptyMenuItemForDispLayers;
	
	menuItem -edit -command ("layerEditorCreateLayer 2") $newFromSelectedMenuItemForDispLayers;

	menuItem -edit -command ("layerEditorSelectObjects \"\"") $selectObjectsMenuItemForDispLayers;
	
	menuItem -edit -command ("layerEditorRemoveObjects \"\"") $removeObjectsMenuItemForDispLayers;
	
	menuItem -edit -command ("layerEditorMembership \"\"") $membershipMenuItemForDispLayers;

	menuItem -edit -command ("layerEditorLayerAttributes \"\"") $layerAttributesMenuItemForDispLayers;
	
	menuItem -edit -command ("layerEditorDeleteLayer \"\"") $deleteMenuItemForDispLayers;
	
	menuItem -edit -command ("layerEditorSelectUnused;layerEditorDeleteLayer \"\"") $deleteUnusedMenuItemForDispLayers;
	
	layerEditorShowEditMenu($parent);
}

global proc layerEditorBuildDisplayOptionMenu(string $parent)
{
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//  Menu is built already - just return
		//
		return;
	}

	menu -edit -postMenuCommand ("layerEditorShowOptionsMenu " + $parent) $parent;

	string $makeNewLayersCurrent		= (uiRes("m_layerEditor.kMakeNewLayersCurrent"));
	string $addNewObjectsToCurrentLayer = (uiRes("m_layerEditor.kAddNewObjectsToCurrentLayer"));
	string $autoOverrides			   = (uiRes("m_layerEditor.kAutoOverrides"));
	string $showNamespace			   = (uiRes("m_layerEditor.kShowNamespace"));

	menuItem -checkBox false -label $makeNewLayersCurrent
		-command ("optionVar -intValue displayLayerCurrent #1;"
			+ "optionVar -intValue displayLayerCurrent #1;")
		LayerEditorOptionsMenuMakeCurrentMenuItemDispLayers;
	menuItem -checkBox false -label $addNewObjectsToCurrentLayer
		LayerEditorOptionsMenuUseCurrentMenuItemDispLayers;
	menuItem -checkBox false -label $autoOverrides
		-command ("editRenderLayerGlobals -enableAutoAdjustments #1")
		LayerEditorOptionsMenuAutoAdjustmentMenuItemDispLayers;
	menuItem -checkBox false -label $showNamespace
		-command ("optionVar -intValue displayLayerShowNamespace #1;updateLayerEditor;")
		LayerEditorOptionsMenuShowNamespaceMenuItemDispLayers;

	layerEditorShowOptionsMenu($parent);
}

proc createLayerEditor(string $parent)
//
//	Description:
//		Create the Layer Editor UI.
//
//	Arguments:
//		$parent - The parent layout. Must be a form layout.
//
{
	global string $gCurrentLayerEditor;

	//	Bail if the parent layout is not the expected type.
	//
	//	Option menu for displaying Display Layers versus Render Layers.
	//
	
	string $requiredType = "formLayout";

	if ($requiredType != `objectTypeUI $parent`) {
		string $errMsg  = (uiRes("m_layerEditor.kArgumentError"));
		string $errDisp = `format -s $requiredType $errMsg`;
		error ($errDisp);
		return;
	}
	setParent $parent;

	string $tabLayout = `tabLayout -scrollable false -tabsVisible true
		DisplayLayerUITabLayout`;

	$gCurrentLayerEditor = $parent;
	
	//
	//Strings needed for both Display and
	//Render Layer tabs
	//
	string $layersMenu				= (uiRes("m_layerEditor.kLayers")); 
	
	string $optionsMenu				 = (uiRes("m_layerEditor.kOptions"));
	
	string $helpMenu		  = (uiRes("m_layerEditor.kHelp"));
	string $displayLayersHelp = (uiRes("m_layerEditor.kHelpDisplayLayers"));
	
	//										//
	// Begin Display layer tab.				//
	//										//

	
	//	Need a menu bar layout for the menus.
	//
	setParent $tabLayout;
	string $menuBarLayout = `menuBarLayout DisplayLayerTab`;
	tabLayout -edit -tabLabel "DisplayLayerTab" (uiRes("m_layerEditor.kDisplay")) $tabLayout;

	//
	//	Create "Layers" pulldown menu
	//
	$editMenuForDispLayers = `menu -label $layersMenu -allowOptionBoxes true`;
	menu -e -postMenuCommand ("layerEditorBuildDisplayLayerMenu(\"" + $editMenuForDispLayers + "\")") -postMenuCommandOnce true $editMenuForDispLayers;

	//	Create "Options" pulldown menu
	//
	$optionsMenuForDispLayers = `menu -label $optionsMenu`;
	menu -e -postMenuCommand ("layerEditorBuildDisplayOptionMenu (\"" + $optionsMenuForDispLayers  + "\")") -postMenuCommandOnce true $optionsMenuForDispLayers;

	// Create the help menu
	menu -label $helpMenu;
	menuItem -label $displayLayersHelp -command "showHelp DisplayLayer";

	//	Create form layout for rest of editor.
	//
	$form = `formLayout`;

	//	Buttons for moving layers up/down
	//
	$moveDispLayerUp = `symbolButton -image "moveLayerUp.png"
		-annotation (uiRes("m_layerEditor.kMoveDispLayerUp")) moveDispLayerUp`;
	$moveDispLayerDown = `symbolButton -image "moveLayerDown.png"
		-annotation (uiRes("m_layerEditor.kMoveDispLayerDown")) moveDispLayerDown`;
	//	Button for creating new layers.
	//
	$emptyDispLayer = `symbolButton -image "newLayerEmpty.png"
		-annotation (uiRes("m_layerEditor.kCreateNewLayer")) emptyDispLayer`;
	$selectedDispLayer = `symbolButton -image "newLayerSelected.png"
		-annotation (uiRes("m_layerEditor.kCreateNewLayerSelected")) selectedDispLayer`;
	//	Tab layout with two children. One for display layers, the other
	//	for render layers.
	//
	setParent $form;
	
	scrollLayout 
		-horizontalScrollBarThickness 0 
		-backgroundColor 0.165 0.165 0.165
		DisplayLayerScrollLayout;
	gridLayout
		-allowEmptyCells	 false
		-autoGrow			true
		-numberOfColumns	 1
		-cellWidthHeight	 350 20
		LayerEditorDisplayLayerLayout;


	//									//
	//  End of Display layer tab.		//
	//									//
	if( !mayaHasRenderSetup() ) {
		createRenderLayerEditor($tabLayout, "RenderLayerTab");
		tabLayout -edit -tabLabel "RenderLayerTab" (uiRes("m_layerEditor.kRender")) $tabLayout;
	}
	createAnimLayerEditor($tabLayout, "AnimLayerTab");
	tabLayout -edit -tabLabel "AnimLayerTab" (uiRes("m_layerEditor.kAnimation")) $tabLayout;
	
	formLayout -edit
		-attachForm  $selectedDispLayer "top" 1
		-attachForm  $selectedDispLayer "right" 2
		-attachNone  $selectedDispLayer "bottom"
		-attachNone  $selectedDispLayer "left" 

		-attachForm $emptyDispLayer "top" 1
		-attachControl $emptyDispLayer "right" 1 $selectedDispLayer
		-attachNone $emptyDispLayer "bottom"
		-attachNone $emptyDispLayer "left"

		-attachForm $moveDispLayerDown "top" 1
		-attachControl $moveDispLayerDown "right" 4 $emptyDispLayer
		-attachNone $moveDispLayerDown "bottom"
		-attachNone $moveDispLayerDown "left"

		-attachForm $moveDispLayerUp "top" 1
		-attachControl $moveDispLayerUp "right" 1 $moveDispLayerDown
		-attachNone $moveDispLayerUp "bottom"
		-attachNone $moveDispLayerUp "left"

		-attachControl	 DisplayLayerScrollLayout	 "top"	1 $emptyDispLayer
		-attachForm	 DisplayLayerScrollLayout	 "left" 0
		-attachForm	 DisplayLayerScrollLayout	 "bottom" 0
		-attachForm	 DisplayLayerScrollLayout	 "right"  1
		
		$form;


	formLayout -edit
		-attachForm	 $tabLayout "top"   5
		-attachForm	 $tabLayout "left"   0
		-attachForm	 $tabLayout "bottom" 0
		-attachForm	 $tabLayout "right"  0
		$parent;
	
	//	Attach commands to menu items and buttons.
	//

	symbolButton -edit -command ("layerEditorMoveDisplayLayer 1") $moveDispLayerUp;
	symbolButton -edit -command ("layerEditorMoveDisplayLayer 0") $moveDispLayerDown;
	symbolButton -edit -command ("layerEditorCreateLayer 1") $emptyDispLayer;
	symbolButton -edit -command ("layerEditorCreateLayer 2") $selectedDispLayer;

	//	Attach script jobs for detecting when user creates new scene 
	//	or opens a scene.
	//
	scriptJob -permanent -parent $parent -event NewSceneOpened ("layerEditorNewScene");
	scriptJob -permanent -parent $parent -event SceneOpened ("layerEditorOpenScene");

	//	Attach a script job that detects creation/deletion of layer nodes.
	//
	scriptJob -permanent -parent $parent -event displayLayerChange ("layerEditorDisplayLayerChange");

	//	Attach a script job that detects change in active layer, so that we
	//	can be sure to keep layer editor in sync (if changed from script)
	//
	scriptJob -permanent -parent $parent -event displayLayerManagerChange ("layerEditorDisplayLayerManagerChange");
}

proc string getShortName(string $name)
//
//	Description:
//		Given a full path name to an object return the short name.
//
//	Arguments:
//		$name - Full path name to an object.
//
//	Returns:
//		The short name.
//
{
	string $result = "", $tokenArray[];
	int	$tokenCount;

	//	To get the short name from a long name tokenize the long name
	//	using "|" as the split character because that is the path
	//	separator. The short name is simply the last token.
	//
	$tokenCount = `tokenize $name "|" $tokenArray`;
	if (0 < $tokenCount) $result = $tokenArray[$tokenCount - 1];

	return $result;
}

proc int isValidName(string $name)
//
//	Description:
//		Determine if the given string is potentially a valid name.
//		Note that this procedure does not test to see if the name is
//		unique, it just tests the string characters.
//
//	  Check to ensure that the string does not begin with a number and
//	  is followed only by alphanumeric characters, underscores, and
//	  semi-colons (used for namespace).
//
//	Arguments:
//		$name - The name.
//
//	Returns:
//		True if the name is valid, false otherwise.
//
{
	int $result = false;

	if ("" != $name) {
		//
		//	Begins with letter or underscore, followed by
		//	letters, digits, or underscores.
		//
		string $regExpr = "([:a-zA-Z_]+)([[:a-zA-Z0-9_])*";
		string $temp = match($regExpr, $name);
		if ($temp == $name) {
			$result = true;
		}
	}

	return $result;
}

proc string getLayerDisplayType()
//
//	Description:
//		Return the current type of layer being displayed in the 
//		Layer Editor.
//
//	Returns:
//		"Display" or "Render" or "Anim"
//
{
	global string $gCurrentLayerEditor;

	//	Verify the current layer editor.
	//
	if ("" == $gCurrentLayerEditor) {
		error (uiRes("m_layerEditor.kNoLayerEditor"));
		return "";
	}

	//	Set the parent to the current layer editor. We can now use short
	//	names of our controls and be certain they reference the correct
	//	control.
	//
	setParent $gCurrentLayerEditor;

	//	Get the current type of layers being displayed.
	//
	string $type = `tabLayout -query -selectTab DisplayLayerUITabLayout`;

	//to match previous behavior, return just the name, not the full control name
	if ($type == "DisplayLayerTab") return "Display";
	else if ($type == "AnimLayerTab") return "Anim";
    else
	if($type == "RenderLayerTab") return "Render";

	return "Display";
}

global proc string [] getLayerSelection(string $type)
//
//	Description:
//		Return the current layer selection for the specified layer type.
//
//	Arguments:
//		$type - Valid values are: "Display", "Render", or
//				an emtpy string. In the case of an empty string the
//				current layer type displayed in the editor will be used.
//
//	Returns:
//		A string array containing the names of the selected layers.
//
{
	global string $gCurrentLayerEditor;

	string $selectionArray[];
	string $buttonLayout = "", $button, $buttonArray[];
	int	$index = 0;

	//	If type argument not specified then determine it.
	//
	if ("" == $type) {
		$type = getLayerDisplayType();
	}

	//	Set the parent to the current layer editor. We can now use short
	//	names of our controls and be certain they reference the correct
	//	control.
	//
	setParent $gCurrentLayerEditor;

	//	Get the correct layout of layer buttons depending on the type of
	//	layers currently being shown.
	//
	if ("Display" == $type) {
		//	Get all the buttons in the layout.
		//
		$buttonArray = `layout -query -childArray LayerEditorDisplayLayerLayout`;

		//	For each button check to see if it is selected.
		//
		for ($button in $buttonArray) {
			if ("Display" == $type && `layerButton -query -select $button`) {
				$selectionArray[$index++] = $button;
			}
		}
	} else {
		string $errMsg  = (uiRes("m_layerEditor.kInvalidLayerType"));
		string $errDisp = `format -s $type $errMsg `;
		error ($errDisp);
		return $selectionArray;
	}

	return $selectionArray;
}

proc string getCurrentLayer(string $type)
//
//	Description:
//		Return the current layer for the specified layer type.
//
//	Arguments:
//		$type - Valid values are: "Display", "Render", or
//				an emtpy string. In the case of an empty string the
//				current layer type displayed in the editor will be used.
//
//	Returns:
//		A string containing the name of the current layer.
//
{
	global string $gCurrentLayerEditor;

	string $currentLayer = "";
	string $buttonLayout = "", $button, $buttonArray[];

	//	If type argument not specified then determine it.
	//
	if ("" == $type) {
		$type = getLayerDisplayType();
	}

	//	Set the parent to the current layer editor. We can now use short
	//	names of our controls and be certain they reference the correct
	//	control.
	//
	setParent $gCurrentLayerEditor;

	//	Get the correct layout of layer buttons depending on the type of
	//	layers currently being shown.
	//
	if ("Display" == $type) {
		//	Get all the buttons in the layout.
		//
		$buttonArray = `layout -query -childArray LayerEditorDisplayLayerLayout`;

		//	For each button check to see if it is the current layer.
		//
		for ($button in $buttonArray) {
			if (("Display" == $type && `layerButton -query -current $button`)) {
				$currentLayer = $button;
				break;
			}
		}
	} else {
		string $errMsg  = uiRes("m_layerEditor.kInvalidLayerType");
		string $errDisp = `format -s $type $errMsg `;
		error ($errDisp);
	}

	return $currentLayer;
}

proc removeAllLayerButtons()
//
//	Description:
//		Remove all the layer buttons in the Layer Editor.
//
//		This method needs to be (and should only be) called when a scene is
//		opened or a new scene is created.
//
{
	global string $gCurrentLayerEditor;

	if ("" == $gCurrentLayerEditor) {
		error (uiRes("m_layerEditor.kNoLayerEditor"));
		return;
	}

	setParent $gCurrentLayerEditor;

	string $button, $buttonArray[], $buttonLayout;

	//	Delete all the display layer buttons.
	//
	$buttonLayout = "LayerEditorDisplayLayerLayout";
	$buttonArray = `layout -query -childArray $buttonLayout`;
	for ($button in $buttonArray) {
		$parentPath = "";
		if (`layerButton -q -ex $button`) {
			$parentPath = `layerButton -q -p $button`;
			$parentPath += "|";
		}
		deleteUI -control ($parentPath + $button);
	}
}


global proc layerEditorNewScene()
//
//	Description:
//		This procedure is called whenever the user creates a new scene.
//
//		Update the Layer Editor to reflect any layer changes.
//
{
	removeAllLayerButtons();
	updateLayerEditor();
	global string $gSelectedAnimLayers[] = {};
}

global proc layerEditorOpenScene()
//
//	Description:
//		This procedure is called whenever the user opens a new scene.
//
//		Update the Layer Editor to reflect any layer changes.
//
{
	removeAllLayerButtons();
	updateLayerOrderByType("Display");
	updateLayerOrderByType("Render");
	updateLayerEditor();
	global string $gSelectedAnimLayers[] = {};
}

global proc layerEditorDisplayLayerChange()
//
//	Description:
//		This procedure is called whenever the user creates or deletes
//		a display layer.
//
//		Update the Layer Editor to reflect the layer changes.
//
{
	updateLayersByType("Display");
}

global proc layerEditorDisplayLayerManagerChange()
//
//	Description:
//		This procedure is called whenever the user changes the active
//		display layer
//
//		Ensure the Layer Editor reflects the layer changes.
//
{
	// get current active layer
	string $currLayer = `editDisplayLayerGlobals -q -currentDisplayLayer`;
	
	// get active ui layer
	string $uiLayer = getCurrentLayer("Display");
	
	if (`layerButton -exists $uiLayer` && `layerButton -exists $currLayer`) {
		// turn off curr selected layer and turn on new layer
		layerButton -edit -current false -select false $uiLayer;
		layerButton -edit -current true -select true $currLayer;
	}
}

global proc layerEditorLayerButtonSelect(
	int	$modifiers,
	string $layerButton)
//
//	Description:
//		This procedure is called whenever the selects a layer in
//		the editor.
//
//	Arguments:
//		$modifiers   - The state of the mouse modifiers.
//
//		$layerButton - The name of the layer selected.
//
{
	global string $gCurrentLayerEditor;
	global int	$gLayerEditorLastButtonSelection;

	string $currentSelection[], $remove[], $orderArray[];
	string $item, $gridLayout;
	int	$select, $count = 0, $index, $startIndex, $endIndex;
	int	$selectionPosition;

	//	Get the type of layers currently displayed in the editor.
	//
	$type = getLayerDisplayType();

	//	Set the parent to the current layer editor. We can now use short
	//	names of our controls and be certain they reference the correct
	//	control.
	//
	setParent $gCurrentLayerEditor;

	//	Get the current layer selection.
	//
	$currentSelection = getLayerSelection($type);

	//	Get the layout containing the layer buttons.
	//
	if ("Display" == $type) {
		$gridLayout = "LayerEditorDisplayLayerLayout";
	}

	if (0 == $modifiers) {
		//
		//	No modifiers. Select the button and deselect any currently
		//	selected buttons. Also make the selected button the current
		//	layer.
		//
		if ("Display" == $type) {
			if (`layerButton -exists $layerButton`) {
				if (`objExists $layerButton`) {
					if (catch(`editDisplayLayerGlobals -currentDisplayLayer $layerButton`)) {
						//
						//	If there was an error then that means that the layer belongs
						//	to a layer in a referenced scene. Don't select the layer.
						//
						return;
					}
				}
				layerButton -edit -select true -current true $layerButton;
			}

		}

		//	Get the order array of layer buttons in the layout.
		//
		$orderArray = `gridLayout -query -gridOrder $gridLayout`;

		//	If the selected button is already selected then remove
		//	it from the list of buttons to deselect.
		//
		$remove[0] = $layerButton;
		$currentSelection = stringArrayRemove(
			$remove, $currentSelection);

		//	Deselect previously selected buttons.
		//
		for ($item in $currentSelection) {
			if ("Display" == $type) {
				layerButton -edit -select false $item;
			}
		}

		//	Make sure the previous current layer (if any) is reset.
		//
		for ($item in $orderArray) {
			if ("(null)" == $item) continue;
			if ($item != $layerButton) {

				if ("Display" == $type) {
					if (`layerButton -query -current $item`) {
						layerButton -edit -current false $item;
					}
				}
			}
		}

		//	Determine and save the position of the selected button.
		//	Need the position of this button for range selecting with
		//	the Shift modifier.
		//
		for ($index = 0; $index < size($orderArray); $index++) {
			if ($layerButton == $orderArray[$index]) {
				$gLayerEditorLastButtonSelection = $index;
				break;
			}
		}

	} else if (1 == $modifiers) {
		//
		//	Shift modifier. Select the range of buttons from the button
		//	that was just pressed to the last button pressed.
		//

		//	Determine the position of the selected button.
		//
		$orderArray = `gridLayout -query -gridOrder $gridLayout`;
		for ($index = 0; $index < size($orderArray); $index++) {
			if ($layerButton == $orderArray[$index]) {
				$selectionPosition = $index;
				break;
			}
		}

		$startIndex = $endIndex = 0;

		if ($selectionPosition <= $gLayerEditorLastButtonSelection) {
			$startIndex = $selectionPosition;
			$endIndex = $gLayerEditorLastButtonSelection;

		} else if ($selectionPosition > $gLayerEditorLastButtonSelection) {
			$startIndex = $gLayerEditorLastButtonSelection;
			$endIndex = $selectionPosition;
		}

		for ($index = 0; $index < size($orderArray); $index++) {
			if ("(null)" == $orderArray[$index]) continue;
			$select = false;
			if ($index >= $startIndex && $index <= $endIndex) $select = true;
			if ("Display" == $type) {
				layerButton -edit -select $select $orderArray[$index];
			}
		}

	} else if (4 == $modifiers) {
		//
		//	Ctrl modifier. Toggle the selection of the button.
		//
		if ("Display" == $type) {
			$select = `layerButton -query -select $layerButton`;
			layerButton -edit -select (!$select) $layerButton;
		}

		//	Is this layer also the current one? If it is then make the
		//	default layer current and mark this layer as no longer being
		//	current.
		//
		if ("Display" == $type) {
			if (`layerButton -exists $layerButton`) {
				if (`layerButton -query -current $layerButton`) {
					layerButton -edit -current false $layerButton;
					editDisplayLayerGlobals -currentDisplayLayer "defaultLayer";
				}
			}
		}
	}
}

global proc layerEditorQuickEditWindowSave(string $layerArray[])
//
//	Description:
//		This procedure is called when the user presses the Save button
//		or the layer is renamed in the Layer Edit window.
//
//		Take the edit window values and apply them to the layer(s).
//
//	Arguments:
//		$layerArray - The layer(s) being edited.
//
{
	global string $gCurrentLayerEditor;

	if (!`window -exists LayerEditorQuickEditWindow`) return;
	
	string $name, $layer, $layerType, $newName;
	int	$visible, $hideOnPlayback, $renderable, $colorIndex, $type;
	int	$layerCount;
	float $rgbColor[];
	int $useRGBColor;

	//	Determine the layer type.
	//
	$layer = $layerArray[0];
	$layerType = `objectType $layer`;

	$layerCount = size($layerArray);

	setParent LayerEditorQuickEditWindow;

	//	Determine the layer name from the edit window.
	//
	$name = `textFieldGrp -query -text NameField`;

	//	Get the layer attributes from the window according to the
	//	layer type.
	//
	if ("displayLayer" == $layerType) {
		$visible = `checkBoxGrp -query -value1 VisibleCheckBox`;
		$hideOnPlayback = `checkBoxGrp -query -value1 HideOnPlaybackCheckBox`;
		$type = `optionMenuGrp -query -select TypeOptionMenu`;
		$colorIndex = `palettePort -query -setCurCell ColorPalette`;

		$rgbColor = `colorSliderGrp -query -rgb LayerEditRGBSlider`;
		$useRGBColor = `optionMenuGrp -query -select layerEditObjectColorType` == 1 ? 0 : 1;
		
	} else if ("renderLayer" == $layerType) {
		$renderable = `checkBoxGrp -query -value1 RenderableCheckBox`;
	}

	if (1 == $layerCount) {
		//
		//	Only one layer edited.
		//
		if ($name == $layer) {
			//
			//	User has not changed name of object. Just apply the
			//	attributes.
			//
			string $command;
			if ("displayLayer" == $layerType) {
				setDisplayLayerVisibility($layer, $visible);
				setDisplayLayerHideOnPlayback($layer, $hideOnPlayback);
				$command += "setAttr " + $layer+".displayType " + ($type - 1);
				$command += "; ";
				$command += "setAttr " + $layer+".color " + $colorIndex;
				$command += "; ";
				$command += "setAttr " + $layer+".overrideColorRGB " + $rgbColor[0] + " " + $rgbColor[1] + " " + $rgbColor[2];
				$command += "; ";
				$command += "setAttr " + $layer+".overrideRGBColors " + $useRGBColor;
				$command += "; ";
			} else if ("renderLayer" == $layerType) {
				$command = "setAttr " + $layer+".renderable " + $renderable;
			}
			evalEcho($command);

		} else {
			//
			//	User has changed the name value.
			//
			//	Check for empty name or invalid name.
			//
			string $warning = (uiRes("m_layerEditor.kWarning"));
			string $ok = (uiRes("m_layerEditor.kOK"));
			string $dispStr,$dispMsg;
			if ("" == $name || !isValidName($name)) {
				$dispStr = (uiRes("m_layerEditor.kNameInvalid"));
				$dispMsg = `format -s $name $dispStr`;
				confirmDialog
					-title $warning
					-parent LayerEditorQuickEditWindow
					-button		$ok
					-defaultButton $ok
					-message $dispMsg;
				return;

			} else {
				//
				//	Name change. Must check if an object by that name already
				//	exists.
				//
				if (`objExists $name`) {
					$dispStr = (uiRes("m_layerEditor.kNameAlreadyExist"));
					$dispMsg = `format -s $name $dispStr`;
					confirmDialog
						-title $warning
						-parent LayerEditorQuickEditWindow
						-button		$ok
						-defaultButton $ok
						-message $dispMsg;
					return;

				} else {
					//
					//	Apply the attribute values.
					//
					string $command;
					if ("displayLayer" == $layerType) {
						setDisplayLayerVisibility($layer, $visible);
						setDisplayLayerHideOnPlayback($layer, $hideOnPlayback);
						$command += "setAttr " + $layer+".displayType " + ($type - 1);
						$command += "; ";
						$command += "setAttr " + $layer+".color " + $colorIndex;
						$command += "; ";
						$command += "setAttr " + $layer+".overrideColorRGB " + $rgbColor[0] + " " + $rgbColor[1] + " " + $rgbColor[2];
						$command += "; ";
						$command += "setAttr " + $layer+".overrideRGBColors " + $useRGBColor;
						$command += "; ";
					} else if ("renderLayer" == $layerType) {
						$command += "setAttr " + $layer+".renderable " + $renderable;
					}

					$command += "; ";

					//	Rename the layer object.
					//
					//	The renaming of the corresponding layer button will
					//	happen in the proc assigned with the button's
					//	-rc/renameCommand flag.
					//
					$command += "rename " + $layer + " " + $name;

					evalEcho($command);
				}
			}
		}

	} else {
		//
		//	More than one layer edited.
		//
		string $command;
		for ($layer in $layerArray) {
			if ($command != "") $command += "; ";
			if ("displayLayer" == $layerType) {
				setDisplayLayerVisibility($layer, $hideOnPlayback);
				setDisplayLayerHideOnPlayback($layer, $hideOnPlayback);
				$command += "setAttr " + $layer+".displayType " + ($type - 1);
				$command += "; ";
				$command += "setAttr " + $layer+".color " + $colorIndex;
				$command += "; ";
				$command += "setAttr " + $layer+".overrideColorRGB " + $rgbColor[0] + " " + $rgbColor[1] + " " + $rgbColor[2];
				$command += "; ";
				$command += "setAttr " + $layer+".overrideRGBColors " + $useRGBColor;
				$command += "; ";
			} else if ("renderLayer" == $layerType) {
				$command += "setAttr " + $layer+".renderable " + $renderable;
			}
		}
		evalEcho($command);
	}

	evalDeferred("deleteUI -window LayerEditorQuickEditWindow");
}

global proc updateLayerEditorColorType(string $objectColorType, string $colorPalette, string $rgbSlider)
{
	int $indexed = `optionMenuGrp -query -select $objectColorType` == 1;
	palettePort -edit -visible $indexed $colorPalette;
	colorSliderGrp -edit -visible ($indexed ? 0 : 1) $rgbSlider;
}

global proc createLayerEditorQuickEditWindow(string $layerArray[])
//
//	Description:
//		Create a quick edit window for the user to modify the layer
//		attributes.
//
//	Arguments:
//		$layerArray - The layer(s) to edit.
//
{
	string $window, $form, $body, $buttonForm;
	string $name, $nameField, $visibleCheckBox, $hideOnPlayBackCheckBox, $typeOptionMenu;
	string $colorLabel, $colorPalette, $saveButton, $cancelButton;
	string $renderableCheckBox, $layer, $layerType;
	string $windowTitle;
	string $objectColorType, $rgbSlider;
	float $rgbColor[];
	int $useRgbColor;
	
	int	$visible, $hideOnPlayback, $displayType, $colorIndex, $renderable, $index;
	int	$layerCount;

	//	Make sure an argument has been supplied.
	//
	$layerCount = size($layerArray);
	if (1 > $layerCount) {
		error (uiRes("m_layerEditor.kSupplyLayerArgument"));
		return;
	}

	$layer = $layerArray[0];

	//	Get the layer type.
	//
	$layerType = `objectType $layer`;

	//	Delete the window if it already exists.
	//
	if (`window -exists LayerEditorQuickEditWindow`) {
		deleteUI -window LayerEditorQuickEditWindow;
	}

	//	Create the window and the top level layout.
	//
	if (1 < $layerCount) $windowTitle = (uiRes("m_layerEditor.kEditLayers"));
	else $windowTitle = (uiRes("m_layerEditor.kEditLayer"));
	$window = `window -title $windowTitle -iconName $windowTitle LayerEditorQuickEditWindow`;
	$form = `formLayout`;
	
	//	Get the name of the first layer. If we are editing more than one 
	//	layer then construct a string that contains all the layer names. 
	//	It should look something like:
	//
	//	layer1, layer2, layer3...
	//
	//	Append ellispes if there are too many layers.
	//
	int $kNameDisplayLimit = 3;
	$name = $layer;
	if (1 < $layerCount) {
		for ($index = 1; ($index < $layerCount && $index < $kNameDisplayLimit); $index++) {
			$name += ", ";
			$name += $layerArray[$index];
		}
		if ($layerCount > $kNameDisplayLimit) {
			$name += "...";
		}
	}

	if ("displayLayer" == $layerType) {
		$visible = getDisplayLayerVisibility($layer);
		$hideOnPlayback = getDisplayLayerHideOnPlayback($layer);
		$displayType = `getAttr ($layer + ".displayType")`;
		$colorIndex = `getAttr ($layer + ".color")`;
		$rgbColor = `getAttr ($layer + ".overrideColorRGB")`;
		$useRgbColor = `getAttr ($layer + ".overrideRGBColors")`;
	} else if ("renderLayer" == $layerType) {
		$renderable = `getAttr ($layer + ".renderable")`;
	}

	// ----------------------------------------------------------------------
	//
	//	Body.
	//
	setParent $form;
	$body = `columnLayout -rowSpacing 4`;

	$nameField = `textFieldGrp -columnWidth 1 70 -label (uiRes("m_layerEditor.kName")) -text $name
		-editable (1 == $layerCount) NameField`;

	if ("displayLayer" == $layerType) {
		$typeOptionMenu = `optionMenuGrp -columnWidth 1 70 -label (uiRes("m_layerEditor.kDisplayType")) TypeOptionMenu`;
		menuItem -label (uiRes("m_layerEditor.kOptionNormal"));
		menuItem -label (uiRes("m_layerEditor.kOptionTemplate"));
		menuItem -label (uiRes("m_layerEditor.kOptionReference"));
		optionMenuGrp -edit -select ($displayType + 1) $typeOptionMenu;

		$visibleCheckBox = `checkBoxGrp -columnWidth 1 70 -numberOfCheckBoxes 1
					-label "" -label1 (uiRes("m_layerEditor.kCheckVisible"))
					-value1 $visible
					VisibleCheckBox`;

		$hideOnPlayBackCheckBox = `checkBoxGrp -columnWidth 1 70 -numberOfCheckBoxes 1
					-label "" -label1 (uiRes("m_layerEditor.kCheckHideOnPlayback"))
					-value1 $hideOnPlayback
					HideOnPlaybackCheckBox`;
					
		$objectColorType = `optionMenuGrp -cw 1 70 -cw 2 85 -label (uiRes("m_layerEditor.kColor")) layerEditObjectColorType`;
		menuItem -label (uiRes("m_layerEditor.kIndexed"));
		menuItem -label (uiRes("m_layerEditor.kRGB"));
		optionMenuGrp -edit -select ($useRgbColor ? 2 : 1) $objectColorType;

		rowLayout -numberOfColumns 2 -rowAttach 1 "top" 0 -columnAttach 2 "left" 0;
		
		text -width 70 -label "";
		
		int $cellHeight = 17, $cellWidth = 17;
		int $rows = 2, $columns = 16;
		columnLayout;
		$colorPalette = `palettePort 
			-dimensions	$columns $rows
			-width		 ($columns * $cellWidth)
			-height		($rows * $cellHeight)
			-transparent   0
			-topDown	   true
			-colorEditable false
			-setCurCell	$colorIndex
			ColorPalette`;
			
		$rgbSlider = `colorSliderGrp -cw 1 0 -cw 2 70 -visible false -label "" -rgb $rgbColor[0] $rgbColor[1] $rgbColor[2] LayerEditRGBSlider`;
		setParent ..; // columnLayout
		setParent ..; // rowLayout
		
		//	Fill in the colour palette with the color's mapped to the
		//	colour indecies.
		//
		float $colorComponentArray[];
		for ($index = 1; $index <= 31; $index++) {
			$colorComponentArray = `colorIndex -query $index`;
			palettePort -edit -rgbValue $index
				$colorComponentArray[0]
				$colorComponentArray[1]
				$colorComponentArray[2]
				$colorPalette;
		}

		//	Set the colour of the "transparent" cell to be a light grey.
		//	Note that the "transparent" cell really indicates "no colour
		//	assignment".
		//
		palettePort -edit -rgbValue 0 0.60 0.60 0.60 $colorPalette;

		string $cmd = "updateLayerEditorColorType " +
					  "\"" + $objectColorType + "\" " +
					  "\"" + $colorPalette + "\" " +
					  "\"" + $rgbSlider + "\"";

		optionMenuGrp -edit -changeCommand $cmd $objectColorType;
		updateLayerEditorColorType ($objectColorType, $colorPalette, $rgbSlider);
		
	} else if ("renderLayer" == $layerType) {
		$renderableCheckBox = `checkBoxGrp -numberOfCheckBoxes 1
			-label "" -label1 (uiRes("m_layerEditor.kRenderable"))
			-value1 $renderable
			RenderableCheckBox`;
	}

	// ----------------------------------------------------------------------
	//
	//	Buttons.
	//
	setParent $form;
	$buttonForm = `formLayout -parent $form`;

	//	Save button.
	//
	string $saveCommandStr = "layerEditorQuickEditWindowSave { ";
	for ($index = 0; $index < $layerCount; $index++) {
		$saveCommandStr += ("\"" + $layerArray[$index] + "\"");
		if ($index < ($layerCount - 1)) {
			$saveCommandStr += ", ";
		}
	}
	$saveCommandStr += " }";

	$saveButton = `button -label (uiRes("m_layerEditor.kSave")) -command ($saveCommandStr)`;

	//	Cancel button.
	//
	$cancelButton = `button -label (uiRes("m_layerEditor.kCancel"))
		-command ("deleteUI -window " + $window)`;

	formLayout -edit
		-attachForm	 $saveButton   "top"	0
		-attachForm	 $saveButton   "left"   0
		-attachForm	 $saveButton   "bottom" 0
		-attachPosition $saveButton   "right"  2 50

		-attachForm	 $cancelButton "top"	0
		-attachPosition $cancelButton "left"   2 50
		-attachForm	 $cancelButton "bottom" 0
		-attachForm	 $cancelButton "right"  0
		$buttonForm;

	formLayout -edit
		-attachForm	 $body		 "top"	4
		-attachForm	 $body		 "left"   4
		-attachControl  $body		 "bottom" 4 $buttonForm
		-attachForm	 $body		 "right"  4

		-attachNone	 $buttonForm   "top"
		-attachForm	 $buttonForm   "left"   4
		-attachForm	 $buttonForm   "bottom" 4
		-attachForm	 $buttonForm   "right"  4
		$form;

	showWindow $window;
}

global proc layerEditorLayerButtonRename(
	string $oldName,
	string $newName)
//
//	Description:
//		This procedure is called whenever a layer node is renamed.
//		It is necessary to also rename the corresponding layer button.
//
//	Arguments:
//		oldName - The old layer name.
//
//		newName - The new layer name.
//
{
	global string $gCurrentLayerEditor;

	setParent $gCurrentLayerEditor;
	renameUI $oldName $newName;

	//
	// Now re-label the control
	//

	if (`nodeType $newName` == "displayLayer") {
		$showNamespace = `optionVar -query displayLayerShowNamespace`;
		layerButton -edit -label (`displayLabel $showNamespace $newName `) $newName;
	}
}

//
//	Description:
//		Helper functions to get/set the layer visibility from the DAGObject attributes.
//		The layer visibility is handled like a 3 states variable in the UI, but
//		internally it's a 'visible' attribute and a 'hideOnPlayback' attribute.
//		
global proc int getDisplayLayerVisibility(string $layer)
{
	int $visible = `getAttr ($layer + ".visibility")`;
	int $hideOnPlayback = `getAttr ($layer + ".hideOnPlayback")`;

	if($visible) {
		if($hideOnPlayback) {
			return 2;
		}
		else {
			return 1;
		}
	}
	else {
		return 0;
	}
}

//
//	Description:
//		Helper functions to get the layer visibility on playback from the DAGObject attributes.
//		
global proc int getDisplayLayerHideOnPlayback(string $layer)
{
	int $hideOnPlayback = `getAttr ($layer + ".hideOnPlayback")`;
    return $hideOnPlayback;
}

global proc setDisplayLayerVisibility(string $layer, int $layerVisibility)
{
	setAttr ($layer + ".visibility") $layerVisibility;

	//Update layer button UI
	layerButton -edit -layerVisible $layerVisibility $layer;
}

global proc setDisplayLayerHideOnPlayback(string $layer, int $layerHideOnPlayback)
{
	setAttr ($layer + ".hideOnPlayback") $layerHideOnPlayback;

	//Update layer button UI
	layerButton -edit -layerHideOnPlayback $layerHideOnPlayback $layer;
}

global proc layerEditorLayerButtonVisibilityChange(string $layer)
//
//	Description:
//		This procedure is called whenever the user presses the visibility
//		indicator in a display layer button.
//
//		Toggle the visibility of the layer.
//
//	Arguments:
//		$layer - The layer.
//
{
	int $layerVisibility = getDisplayLayerVisibility($layer);
	setDisplayLayerVisibility($layer, !$layerVisibility);
}

global proc layerEditorLayerButtonHidePlaybackChange(string $layer)
//
//	Description:
//		This procedure is called whenever the user presses the hide on play back
//		indicator in a display layer button.
//
//		Toggle the hide on playback of the layer.
//
//	Arguments:
//		$layer - The layer.
//
{
	int $hideOnPlayback = getDisplayLayerHideOnPlayback($layer);
	setDisplayLayerHideOnPlayback($layer, !$hideOnPlayback);
}

global proc layerEditorLayerButtonTypeChange(string $layer)
//
//	Description:
//		This procedure is called whenever the user presses the type
//		indicator in a display layer button.
//
//		Cycle the type of the layer.
//
//		Current layer types are: Normal, Reference, and Template.
//
//	Arguments:
//		$layer - The layer.
//
{
	int $type = `getAttr ($layer + ".displayType")`;
	
	if (0 == $type) $type = 1;
	else if (1 == $type) $type = 2;
	else $type = 0;
		
	setAttr ($layer + ".displayType") $type;
}


global proc string [] layerEditorLayerButtonDrag(
	string $dragControl,
	int	$x, 
	int	$y, 
	int	$mods)
//
//	Description:
//		This procedure is called whenever the user begins a drag from
//		a layer button.
//
//		Set up a drag message so we can detect it on the drop callback.
//
//	Arguments:
//		$dragControl - The layer button where the drag occurred.
//
//		$x, $y	   - Location of the drag event.
//
//		$mods		- State of the mouse modifiers.
//
//	Returns:
//		A string array value representing the type of drag message.
//
{
	string $result[] = {"LayerButtonDragMessage"};
	return $result;
}

global proc layerEditorLayerButtonDrop(
	string $dragControl,
	string $dropControl, 
	string $messages[],
	int	$x, 
	int	$y, 
	int	$dragType)
//
//	Description:
//		This procedure is called whenever the user ends a drag from
//		a layer button to another layer button.
//
//		If the drag message is the correct type then reorder the
//		layer buttons.
//
//	Arguments:
//		$dragControl - The layer button where the drag occurred.
//
//		$dropControl - The layer button where the drop occurred.
//
//		$messages[]  - The drag messages corresponding to the event.
//
//		$x, $y	   - Location of the drag event.
//
//		$dragType	- Type of drag event.
//
{
	global string $gCurrentLayerEditor;

	string $type, $gridLayout = "";

	//	Get the type of layers currently displayed in the editor.
	//
	$type = getLayerDisplayType();

	//	Set the parent to the current layer editor. We can now use short
	//	names of our controls and be certain they reference the correct
	//	control.
	//
	setParent $gCurrentLayerEditor;

	if ("Display" == $type) {
		$gridLayout = "LayerEditorDisplayLayerLayout";

	}

	if ("LayerButtonDragMessage" == $messages[0]) {
		gridLayoutRowDragAndDrop($gridLayout, $dragControl, $dropControl);
	}
	
	updateLayerOrderByType($type);
}

global proc layerEditorShowEditMenu(string $menu)
//
//	Description:
//		This procedure is called whenever the user shows the Edit menu.
//
//		Update the enable state of the menu items to reflect the possible
//		options.
//
//	Arguments:
//		$menu - The menu.
//
{
	string $selection[] = `ls -selection`;
	string $layerSelection[] = getLayerSelection("");
	string $layerContents[], $remove[];
	string $currentLayer = getCurrentLayer("");
	string $type;
	int	$enable = false;
	
	$type = getLayerDisplayType();

	string $layers[];
	if ($type == "Display") {
		$layers = `ls -type displayLayer`;
	}
	
	//	Determine the number of selected layers
	//
	int $numLayers = `size $layers`;

	//	Remove layers from the selection list.
	//
	$selection = stringArrayRemove($layers, $selection);
	
	setParent -menu $menu;

	//	Delete layer. Enable if there is at least one layer selected.
	//
	$enable = false;
	if (0 < size($layerSelection)) $enable = true;
	if($type == "Display"){
		menuItem -edit -enable $enable LayerEditorEditMenuDeleteMenuItemForDispLayers;
	}

	//	Select objects in selected layer(s). Enable if there is at least
	//	one layer selected and there is at least one object in any of 
	//	those layers.
	//
	$enable = false;
	for ($layer in $layerSelection) {
		if ("Display" == $type) {
			$layerContents = `editDisplayLayerMembers -query $layer`;
		}
		if (0 < size($layerContents)) {
			$enable = true;
			break;
		}
	}
	if($type == "Display"){
		menuItem -edit -enable $enable LayerEditorEditMenuSelectObjectsMenuItemForDispLayers;
	}

	//	Remove objects from selected layer(s). Enable if there is at least
	//	one layer selected and there is at least one object in any of
	//	those layers.
	//
	$enable = false;
	for ($layer in $layerSelection) {
		if ("Display" == $type) {
			$layerContents = `editDisplayLayerMembers -query $layer`;
		}
		if (0 < size($layerContents)) {
			$enable = true;
			break;
		}
	}
	if($type == "Display"){
		//	Enable this item if there are selected objects.
		$enable = false;
		if (0 < size($selection)) $enable = true;
		menuItem -edit -enable $enable LayerEditorEditMenuRemoveObjectsMenuItemForDispLayers;
	}

	//	Set All Layers, Sort Alpha/Chrono,  
	//	Enable if more than 1 layer exists
	//
	$enable = false;
	if ($numLayers > 1) $enable = true;
	
	
	if($type == "Display"){
		menuItem -edit -enable $enable LayerEditorEditMenuSetAllLayersMenu;
		menuItem -edit -enable $enable LayerEditorEditMenuSortAlphaMenuItemDispLayers;
		menuItem -edit -enable $enable LayerEditorEditMenuSortChronoMenuItemDispLayers;
	}

	//	Set Selected Layers and Set Only Selected Layers
	//	Enable if there is a current layer
	$enable = false;
	if ("" != $currentLayer) $enable = true;
	
	// Presently it is there only for display layers.
	if($type == "Display"){
		menuItem -edit -enable $enable LayerEditorEditMenuSetSelectedLayersMenu;
		menuItem -edit -enable $enable LayerEditorEditMenuSetOnlySelectedLayersMenu;
	}

	//	Show Layer Attributes. Enable if there is a current layer.
	//
	$enable = false;
	if ("" != $currentLayer) $enable = true;
	menuItem -edit -enable $enable LayerEditorEditMenuLayerAttributesMenuItemDispLayers;
}

global proc layerEditorShowOptionsMenu(string $menu)
//
//	Description:
//		This procedure is called whenever the user shows the Options menu.
//
//		Update the state of the menu items.
//
//	Arguments:
//		$menu - The menu.
//
{
	setParent -menu $menu;

	$value = `optionVar -query displayLayerCurrent`;
	menuItem -edit -checkBox $value LayerEditorOptionsMenuMakeCurrentMenuItemDispLayers;

	string $type = getLayerDisplayType();
	if ($type == "Display") {
		$value = `editDisplayLayerGlobals -query -useCurrent`;
		menuItem -edit -checkBox $value
			-command "editDisplayLayerGlobals -useCurrent #1"
			 LayerEditorOptionsMenuUseCurrentMenuItemDispLayers;
		menuItem -edit -enable false
			LayerEditorOptionsMenuAutoAdjustmentMenuItemDispLayers;
	}

	$value = `optionVar -query displayLayerShowNamespace`;
	menuItem -edit -checkBox $value LayerEditorOptionsMenuShowNamespaceMenuItemDispLayers;
}

global proc layerEditorShowPopupMenu(string $menu, string $layerButton)
//
//	Description:
//		This procedure is called when the popup menu on layer buttons
//		is shown.
//
//		Create the menu items.
//
//	Arguments:
//		$menu  - The parent menu.
//
//		$layer - The full path name to the layer button.
//
{
	string $selection[] = `ls -selection`;
	string $layerContents[], $type, $layer;
	int	$enable = false;

	//	Get the current layer type.
	//
	$type = getLayerDisplayType();

	//	Get the short name of the layer from the layer button argument.
	//
	$layer = getShortName($layerButton);

	//	Get the contents of this layer.
	//
	if ("Display" == $type) {
		$layerContents = `editDisplayLayerMembers -query $layer`;
	}

	//	Remove layers from the selection list.
	//
	$remove = `ls -type displayLayer`;
	$selection = stringArrayRemove($remove, $selection);
	$remove = `listConnections renderLayerManager.renderLayerId`;
	$selection = stringArrayRemove($remove, $selection);
	
	//	Set the menu parent and delete all the items in the menu.
	//
	setParent -menu $menu;
	menu -edit -deleteAllItems $menu;

	//
	//	Now create the menu items...
	//

	// Layer name.
	//
	string $title = $layer + "...";
	menuItem -label $title -command ("createLayerEditorQuickEditWindow {\"" + $layer + "\"}");
	menuItem -divider true;
	menuItem -divider true;
	menuItem -divider true;

	//	Add selected objects to this layer. Enable if there is at least
	//	one object on the selection list.
	//
	$enable = false;
	if (0 < size($selection)) $enable = true;
	menuItem -label (uiRes("m_layerEditor.kAddSelectedObjects")) -enable $enable
		-command ("layerEditorAddObjects " + $layer);

	//	Remove selected objects from this layer. Enable if there is at least
	//	one object on the selection list.
	//
	$enable = false;
	if (0 < size($selection)) $enable = true;
	menuItem -label (uiRes("m_layerEditor.kRemoveSelectedObjects")) -enable $enable
		-command ("layerEditorRemoveObjects " + $layer);

	//	Select objects in this layer. Enable if this layer contains
	//	an object.
	//
	$enable = false;
	if (0 < size($layerContents)) $enable = true;
	menuItem -label (uiRes("m_layerEditor.kSelectObjects")) -enable $enable
		-command ("layerEditorSelectObjects " + $layer);

	// The menu items don't seem to apply for render layers. So making this active only for display layers.
	if($type == "Display"){
		menuItem -divider true;
		$layerMenus = `menuItem -label (uiRes("m_layerEditor.kSetAllLayers")) -tearOff 1 -subMenu true "LayerEditorEditMenuSetAllLayersMenu"`;
		menuItem -e -postMenuCommand ("setLayerToMenuItems(\"" + $layerMenus + "\", \"all\")") -postMenuCommandOnce true $layerMenus;
		setParent -m ..;
		$layerMenus = `menuItem -label (uiRes("m_layerEditor.kSetSelectedLayers")) -tearOff 1 -subMenu true "LayerEditorEditMenuSetSelectedLayersMenu"`;
		menuItem -e -postMenuCommand ("setLayerToMenuItems(\"" + $layerMenus + "\", \"selected\")") -postMenuCommandOnce true $layerMenus;
		setParent -m ..;
		$layerMenus = `menuItem -label (uiRes("m_layerEditor.kSetOnlySelectedLayers")) -tearOff 1 -subMenu true "LayerEditorEditMenuSetOnlySelectedLayersMenu"`;
		menuItem -e -postMenuCommand ("setLayerToMenuItems(\"" + $layerMenus + "\", \"onlySelected\")") -postMenuCommandOnce true $layerMenus;
		setParent -m ..;
	}

	menuItem -divider true;

	//	Empty the layer (remove all objects). Enable if this layer contains
	//	an object.
	//
	$enable = false;
	if (0 < size($layerContents)) $enable = true;
	menuItem -label (uiRes("m_layerEditor.kEmptyLayer")) -enable $enable
		-command ("layerEditorEmpty " + $layer);
	menuItem -label (uiRes("m_layerEditor.kDeleteLayer"))
		-command ("evalDeferred (\"layerEditorDeleteLayer " + $layer + "\")");
	menuItem -label (uiRes("m_layerEditor.kMembership"))
		-command ("layerEditorMembership " + $layer);
	menuItem -label (uiRes("m_layerEditor.kAttributes"))
		-command ("layerEditorLayerAttributes " + $layer);
}

global proc layerEditorCreateLayer(int $contents)
//
//	Description:
//		Create a new layer of the appropriate type and update the 
//		editor to reflect the change.
//
{
	global string $gCurrentLayerEditor;

	string $type, $createLayerCmd = "";
	string $newLayer, $layer, $currentSelection[];

	//	Get the type of layers currently displayed in the editor.
	//
	$type = getLayerDisplayType();

	//	Set the parent to the current layer editor. We can now use short
	//	names of our controls and be certain they reference the correct
	//	control.
	//
	setParent $gCurrentLayerEditor;

	if ("Display" == $type) {
		int $previous = `optionVar -q displayLayerContents`;
		optionVar -iv displayLayerContents $contents;
		performCreateDisplayLayer 0;
		optionVar -iv displayLayerContents $previous;
	}
	
	updateLayersByType($type);

	//	Select and make current the new layer if the option to do so is set.
	//
	if (`optionVar -query displayLayerCurrent`) {

		//	Deselect any selected layers.
		//
		$currentSelection = getLayerSelection($type);
		for ($layer in $currentSelection) {
			if ("Display" == $type) {
				layerButton -edit -select false -current false $layer;
			} 
		}

		//	Select and make current the new layer.
		//
		if ("Display" == $type) {
			$newLayer = `editDisplayLayerGlobals -query -currentDisplayLayer`;
			if (`layerButton -exists $newLayer`) {
				layerButton -edit -select true -current true $newLayer;
			}
		} 
	}

	if ("Display" == $type)
	{
		int $sortOrder = `optionVar -exists displayLayerSortOptions` ? `optionVar -query displayLayerSortOptions` : 0;
		// if sortOrder is alphabetical, we reorder it. if it's chronological, we don't 
		// reorder since it's chronological by default. 
		if ($sortOrder){
			reorderLayers $sortOrder;
		}
	}
}

global proc layerEditorDeleteLayer(string $inLayer)
//
//	Description:
//		Delete the specified layer or if no layer argument given then
//		delete all the selected layers.
//
//	Arguments:
//		$layer - The specific layer to delete, or an empty string to
//				 delete all selected layers.
//
{
	//	Get the type of layers currently displayed in the editor.
	//
	$type = getLayerDisplayType();

	//	Get the layers if the argument is an empty string.
	//
	string $layers[];
	if ("" == $inLayer) {
		//
		//	Get the highlighted layers.
		//
		$layers = getLayerSelection($type);
	}
	else {
		$layers[0] = $inLayer;
	}


	for ($layer in $layers)
	{
		//get all objects of the layer
		string $obj[] = `editDisplayLayerMembers -q -fn $layer`;
		// Try to delete the layer
		//
		if ( !catch( `evalEcho("delete "+$layer)` ) )
		{
			$parentPath = "";
			if (`layerButton -q -ex $layer`) {
				$parentPath = `layerButton -q -p $layer`;
				$parentPath += "|";
			}
			// If the layer was successfully deleted,
			// delete the layer button.
			//
			deleteUI -control ($parentPath + $layer);

			//Let's reset Drawing Overrides (disabled it) for each object of the layer
			for ($o in $obj){
				setAttr ($o + ".overrideEnabled") 0;
			}
		}
	}
	updateLayerOrderByType($type);
	updateLayersByType($type);
}

global proc layerEditorEditLayer(string $layer)
//
//	Description:
//		Edit the specified layer or if no layer argument given then
//		edit the selected layers.
//
//	Arguments:
//		$layer - The specific layer to edit, or an empty string to
//				 edit the selected layers.
//
{
	string $layerArray[];
	
	//	Get the layer selection if the argument is an empty string.
	//
	if ("" == $layer) {
		$layerArray = getLayerSelection("");

	} else {
		$layerArray[0] = $layer;
	}

	//	Show the layer edit window.
	//
	createLayerEditorQuickEditWindow($layerArray);
}

global proc layerEditorSelectObjects(string $layer)
//
//	Description:
//		Select the objects contained in the specified layer or if no 
//		layer argument given then select all the objects in the selected
//		layers.
//
//	Arguments:
//		$layer - The specific layer to select the objects from, or an empty 
//				 string to select all the objects from all selected layers.
//
{
	string $type, $item, $currentSelection[];

	//	Clear the current object selection list.
	//
	select -clear;

	//	Get the type of layers currently displayed in the editor.
	//
	$type = getLayerDisplayType();

	if ("" != $layer) {
		//
		//	Select the objects in the given layer.
		//
		if ("Display" == $type) {
			select -add `editDisplayLayerMembers -fullNames -query $layer`;
		}

	} else {
		//
		//	Get the selected layers.
		//
		$currentSelection = getLayerSelection($type);

		//	Add to the selection list the objects contained in each 
		//	selected layer.
		//
		for ($item in $currentSelection) {
			if ("Display" == $type) {
				select -add `editDisplayLayerMembers -fullNames -query $item`;
			}
		}
	}
}

global proc layerEditorAddObjects(string $inLayer)
//
//	Description:
//		Add the objects on the selection list to the specified layer. If
//		no layer argument is given, objects are added to all highlighted
//	  render layers, or the objects are added to the current display
//	  layer.
//
//	  This code may be invoked from either the RMB pop-up menu of the
//	  layer button in which case $inLayer will be specified, or from the
//	  "Layers" drop down menu, in which case $inLayer which be "".
//
//	Arguments:
//		$inLayer - The specific layer to add the objects to.
//
{
	//	Get the type of layers currently displayed in the editor.
	//
	string $type = getLayerDisplayType();

	//	Get the layers if the argument is an empty string.
	//
	string $layers[];
	if ("" == $inLayer) {
		if ($type == "Display") {
			$layers[0] = getCurrentLayer("");
		}
	}
	else {
		$layers[0] = $inLayer;
	}

	for ($layer in $layers) {
		if ("Display" == $type) {
			evalEcho("editDisplayLayerMembers -noRecurse "+$layer+" `ls -selection`");
		}
	}
}

global proc layerEditorRemoveObjects(string $inLayer)
//
//	Description:
//		Remove the selected objects from the specified layer. If no layer
//	  argument given, remove the selected objects from all highlighted
//		render layers.  As display layer membership is mutually exclusive,
//	  removing an object from one layer guarantees it will not be in
//	  another layer - no coding is needed to handle the multiple display
//	  layers.
//
//	  This code may be invoked from either the RMB pop-up menu of the
//	  layer button in which case $inLayer will be specified, or from the
//	  "Layers" drop down menu, in which case $inLayer which be "".
//
//	Arguments:
//		$inLayer - The specific layer to remove the objects from.
//
{
	//	Get the type of layers currently displayed in the editor.
	//
	$type = getLayerDisplayType();

	if ($type == "Display") {
		//
		//	Add all selected objects to the default layer.
		//
		evalEcho("editDisplayLayerMembers -noRecurse \"defaultLayer\" `ls -selection`");
	}
}

global proc layerEditorEmpty(string $inLayer)
//
//	Description:
//		Remove all the objects contained in the specified layer or if no 
//		layer argument given then remove all the objects in the selected
//		layers.
//
//	  This code may be invoked from either the RMB pop-up menu of the
//	  layer button in which case $inLayer will be specified, or from the
//	  "Layers" drop down menu, in which case $inLayer which be "".
//
//	Arguments:
//		$layer - The specific layer to remove the objects from, or an empty 
//				 string to remove all the objects from all selected layers.
//
{
	//	Get the type of layers currently displayed in the editor.
	//
	$type = getLayerDisplayType();

	string $layers[];
	if ("" == $inLayer) {
		//
		//	Get the highlighted layers.
		//
		$layers = getLayerSelection($type);
	}
	else {
		$layers[0] = $inLayer;
	}

	for ($layer in $layers) {
		if ("Display" == $type) {
			//	Add to the default layer all the objects in the selected
			//	layer(s).
			//
			evalEcho("editDisplayLayerMembers -noRecurse \"defaultLayer\""+
				"`editDisplayLayerMembers -fullNames -query "+$layer+"`");
		}
	}
}

global proc layerEditorSelectUnused()
//
//	Description:
//		Select all the layers that don't have any objects in them.
//
{
	global string $gCurrentLayerEditor;

	string $type, $layer, $layout;
	string $layerArray[], $layerContents[];
	string $selectArray[], $currentSelection[];
	int	$index;

	//	Get the type of layers currently displayed in the editor.
	//
	$type = getLayerDisplayType();

	//	Set the parent to the current layer editor. We can now use short
	//	names of our controls and be certain they reference the correct
	//	control.
	//
	setParent $gCurrentLayerEditor;

	//	Get the current layer selection.
	//
	$currentSelection = getLayerSelection($type);

	//	Get all layers of the appropriate type.
	//
	if ("Display" == $type) {
		$layerArray = `ls -type displayLayer`;
	}

	//	Determine the contents of each layer. Ignore default layers.
	//
	$index = 0;
	for ($layer in $layerArray) {

		//	Ignore default layers. Default layers have an id of 0.
		//
		if (0 < `getAttr ($layer + ".identification")`) {
			if ("Display" == $type) {
				$layerContents = `editDisplayLayerMembers -query $layer`;
			}
			if (0 == size($layerContents)) {
				//
				//	This layer has nothing in it. Add it to array.
				//
				$selectArray[$index++] = $layer;
			}
		}
	}

	//
	//	Deselect any selected layers.
	//
	for ($layer in $currentSelection) {
		if ("Display" == $type) {
			layerButton -edit -select false -current false $layer;
		}
	}

	//	Select all the unused layers.
	//
	for ($layer in $selectArray) {
		if ("Display" == $type) {
			layerButton -edit -select true $layer;
		}
	}
}

global proc layerEditorRemoveFromLayer()
//
//	Description:
//		Remove the selected objects from whatever layer they might be in.
//
{
	string $type, $object, $selection[], $remove[];

	$type = getLayerDisplayType();

	//	Get the selection list.
	//
	$selection = `ls -selection`;

	//	Remove layers from the selection list.
	//
	$remove = `ls -type displayLayer`;
	$selection = stringArrayRemove($remove, $selection);
	$remove = `listConnections renderLayerManager.renderLayerId`;
	$selection = stringArrayRemove($remove, $selection);

	for ($object in $selection) {
		if ("Display" == $type) {
			editDisplayLayerMembers "defaultLayer" $object;
		} else if ("Render" == $type) {
			string $layers[] = `listConnections renderLayerManager.renderLayerId`;
			for ($layer in $layers) {
				// Remove object from non-global layers.
				if (!`getAttr ($layer+".global")`) {
					editRenderLayerMembers -remove $layer $object;
				}
			}
		}
	}
}

global proc layerEditorLayerAttributes(string $layer)
//
//	Description:
//		Show the Attribute Editor for the specified layer or if
//		no layer argument given then use the current layer.
//
//	Arguments:
//		$layer - The specific layer to show the Attribute Editor for,
//				 or an empty string to show the editor for the current layer.
//
{
	//	Get the current layer if the argument is an empty string.
	//
	if ("" == $layer) $layer = getCurrentLayer("");

	//	Get the current layer.
	//
	if ("" != $layer) {

		//	Actually select the layer object.
		//
		select -replace $layer;

		//	Show the Attribute Editor.
		//
		editSelected();
	}
}

global proc layerEditorMembership(string $layer)
//
//	Description:
//		Show the Relationship Editor for the specified layer or if
//		no layer argument given then use the layer selection.
//
//	Arguments:
//		$layer - The specific layer to show the Relationship Editor for,
//				 or an empty string to show the editor for the selected
//				 layers.
//
{
	string $selection[];

	if ("" != $layer) {
		$selection[0] = $layer;

	} else {
		//
		//	Get the current selection.
		//
		$selection = getLayerSelection("");
	}

	//	Display the relationship editor for the type of layers.
	//
	string $type = getLayerDisplayType();

	if ("Display" == $type) {
		relationshipEditor("displayLayers", $selection, {});
	}
}

global proc layerEditorDisplayTypeChange()
//
//	Description:
//		This procedure is called whenever the user changes the type
//		of layers displayed in the Layer Editor.
//
{
	global string $gCurrentLayerEditor;

	string $type, $tab = "";

	//	Get the type of layers currently displayed in the editor.
	//
	$type = getLayerDisplayType();

	if ("Display" == $type) {
		$tab = "DisplayLayerTab";
	} else if ("Render" == $type) {
		$tab = "RenderLayerTab";
	} else if ("Anim" == $type) {
		$tab = "AnimLayerTab";
	}

	setParent $gCurrentLayerEditor;

	if ("" != $tab) {
		tabLayout -edit -selectTab $tab DisplayLayerUITabLayout;
	}

	// Return the focus to the view pane
	setFocus `getPanel -wf`;
}

global proc layerEditorMoveDisplayLayer(int $up)
//
//	Description
//		Move current display layer up or down in the selection list
//		when user presses reorder buttons
//
{
	string $currLayer = getCurrentLayer("");
	string $allLayers[];
	//	Remove the default layers. Default layers have an id of 0.
	string $tempLayers[] = `ls -type displayLayer`;
	for ($layer in $tempLayers) {
		if (0 != `getAttr ($layer + ".identification")`) {
			$allLayers[size($allLayers)] = $layer;
		}
	}

	int $currPos = `getAttr ($currLayer + ".displayOrder")`;
	int $offset = ($up ? 1 : -1);
	for ($layer in $allLayers) {
		int $layerPos = `getAttr ($layer + ".displayOrder")`;
		if ($layerPos == $currPos+$offset) {
			setAttr ($layer + ".displayOrder") $currPos;
			setAttr ($currLayer + ".displayOrder") $layerPos;
			break;
		}
	}

	updateLayerEditor();
}

global proc string displayLabel( int $showNamespace, string $layer )
//
//	Description:
//		Given a layer name, and whether or not we want the namespace displayed,
//	return the appropriate label.
//
{
	string $label = $layer;
	if( !$showNamespace){
		// Replace namespace by "...:" if there is one
		//
		string $tokens[];
		int $numTokens = `tokenize $layer ":" $tokens`;
		if( $numTokens > 1 ){
			$label = ("...:" + $tokens[$numTokens-1]);
		}
	}
	return( $label );
}

global proc updateLayersByType(string $type)
//
//	Description:
//		Update the Layer Editor according to the specified type.
//
//		Create and/or delete layer buttons as necessary.
//
//	Arguments:
//		$type - Type of layers to update. Values are "Display", "Render",
//				"Anim"
//
{
	global string $gCurrentLayerEditor;

	if ("" == $gCurrentLayerEditor) {
		error (uiRes("m_layerEditor.kNoLayerEditor"));
		return;
	}

	if ("Anim" == $type) {
		rebuildAnimLayerEditor("AnimLayerTab");
		return;
	}

	if ("Render" == $type) {
		updateEditorRenderLayer("RenderLayerTab");
		return;
	}

	setParent $gCurrentLayerEditor;

	string $buttonLayout;
	string $layer, $layerArray[];
	string $button, $buttonArray[];
	string $removeArray[];
	int	$layerID, $index, $colorIndex, $transparent, $useRGBColor;

	//	Width of layer buttons.
	//
	int	$kLayerButtonWidth = 350;

	//	Get all layers of the appropriate type.
	//
	if ("Display" == $type) {
		$buttonLayout = "LayerEditorDisplayLayerLayout";
		$layerArray = `ls -type displayLayer`;

	} else {
		string $errMsg  = (uiRes("m_layerEditor.kInvalidLayerType"));
		string $errDisp = `format -s $type $errMsg`;
		error ($errDisp);
		return;
	}

	if ($type == "Display") {
		//	Remove the default layers. Default layers have an id of 0.
		//
		$index = 0;
		for ($layer in $layerArray) {
			if (0 == `getAttr ($layer + ".identification")`) {
				$removeArray[$index++] = $layer;
			}
		}
		$layerArray = stringArrayRemove($removeArray, $layerArray);
	}

	int $sortOrder = `optionVar -exists displayLayerSortOptions` ? `optionVar -query displayLayerSortOptions` : 0;

	// we only want to use the display order when its sortOrder is chronological.
	if (!$sortOrder)
	{
		//	Now sort the remaining layers according to their display order.
		//
		$layerArray = sortLayers($layerArray);
		// Reverse the order of the layerArray, so that we can list the
		// layers from the bottom to the top in the render layer editor
		// just like in photoshop.
		//
		$layerArray = reverseArray($layerArray);
	}

	//	Get the current array of layer buttons.
	//
	$buttonArray = `layout -query -childArray $buttonLayout`;

	//	Remove the old layer buttons.
	//
	for ($button in $buttonArray) {
		$parentPath = "";
		if (`layerButton -q -ex $button`) {
			$parentPath = `layerButton -q -p $button`;
			$parentPath += "|";
		}
		//
		//	Delete button.
		//
		deleteUI ($parentPath + $button);
	}
	
	int $showNamespace;
	if("Display" == $type)
	{
		$showNamespace = `optionVar -query displayLayerShowNamespace`;
	}
	
	for ($layer in $layerArray) {
		//
		//	Create button.
		//
		if ("Display" == $type) {
			$transparent = false;
			$colorIndex = `getAttr ($layer + ".color")`;
			$useRGBColor = `getAttr ($layer + ".overrideRGBColors")`;
			if (0 == $colorIndex && $useRGBColor == false) $transparent = true;

			layerButton -parent $buttonLayout
				-label			  (`displayLabel $showNamespace $layer `)
				-name			   $layer
				-transparent		$transparent
				-width			  $kLayerButtonWidth
				-command			("layerEditorLayerButtonSelect #m #1")
				-doubleClickCommand ("createLayerEditorQuickEditWindow { \"#1\" }")
				-renameCommand	  ("layerEditorLayerButtonRename #1 #2")
				-typeCommand		("layerEditorLayerButtonTypeChange #1")
				-visibleCommand	 ("layerEditorLayerButtonVisibilityChange #1")
				-hideOnPlaybackCommand ("layerEditorLayerButtonHidePlaybackChange #1")
				-dropCallback	   ("layerEditorLayerButtonDrop")
				-dragCallback	   ("layerEditorLayerButtonDrag")
				$layer;
		}

		//	Attach a popup menu to each layer button.
		//
		$popupMenu = `popupMenu -button 3 -parent $layer`;
		popupMenu -edit
			-postMenuCommand ("layerEditorShowPopupMenu #1 #2")
			$popupMenu;
	}

	// Highlight the active display layer.
	//
	if( "Display" == $type ){
		string $selectedItem = `editDisplayLayerGlobals -query -currentDisplayLayer`;

		// Check if the button exists, since there is no button for the
		// default display layer.
		//
		if( `layerButton -exists $selectedItem` )
			layerButton -edit -select true -current true $selectedItem;
	}
}

global proc updateLayerOrderByType(string $type)
//
//	Description:
//		Update the order of layers given their current display order.
//
//		Set the layer's display order attribute based on the layer
//		button's position in the editor.
//
//	Arguments:
//		$type - Type of layer. Values are "Display" or "Render".
//
{
	global string $gCurrentLayerEditor;

	if ("" == $gCurrentLayerEditor) {
		error (uiRes("m_layerEditor.kNoLayerEditor"));
		return;
	}

	setParent $gCurrentLayerEditor;

	//	Get all the layers of the appropriate type.
	//
	string $layerType;
	if ("Display" == $type) {
		$layerType = "displayLayer";
	} else if ("Render" == $type){
		$layerType = "renderLayer";
	} else {
		string $errMsg  = uiRes("m_layerEditor.kInvalidLayerType");
		string $errDisp = `format -s $type $errMsg`;
		error ($errDisp);
		return;
	}

	string $layerArray[];

	if("Display" == $type){
		//get the layers from the editor 
		string $buttonLayers[] = `gridLayout -q -gridOrder LayerEditorDisplayLayerLayout`;
		$buttonLayers = reverseArray($buttonLayers);
		$layerArray = $buttonLayers;
	}else{
		//	Remove the default layers. Default layers have an id of 0.
		string $tempLayers[] = `ls -type $layerType`;
		for ($layer in $tempLayers) {
			if (0 != `getAttr ($layer + ".identification")`) {
				$layerArray[size($layerArray)] = $layer;
			}
		}
		$layerArray = sortLayers($layerArray);
	}
	
	if (size($layerArray) > 0) {
		// Re-index the layers based on the position of the first layer;
		// ensuring that the display order is unique and increasing.
		//

		string $command;

		for ($i = 1; $i <= size($layerArray); $i++) {
			string $layer = $layerArray[$i-1];
			
			int $index = `getAttr ($layer+".displayOrder")`;
		   
			if ($index != $i)
			{
				if ($command != "") $command += "; ";
				$command += "setAttr " + $layer+".displayOrder " + $i;
			}
		}
	
		if ($command != "") evalEcho($command);
	}
}

global proc updateLayerEditor()
//
//	Description:
//		Update the Layer Editor.
//
//		This procedure must be called whenever the state of layers in
//		the scene changes. For example, a new scene is created, or a 
//		scene is opened, or a layer is added or removed.
//
{
	updateLayersByType("Display");
}

global proc int layerEditorVisibilityStateChange(
	int	$newState,
	string $layout)
//
//	Description:
//		This procedure is called whenever the visibility state of the 
//		Layer Editor is changed.
//
//	Arguments:
//		newState - The new visibile state of the Layer Editor.
//
//		layout - The parent layout for the Layer Editor.
//
//	Returns:
//		true - If the change of state is to be allowed.
//
//		false - If the state change is rejected.
//
{
	int $result = true;

	//	Defer these commands because this proc is called when the visibility
	//	state is about to change. This proc must return true to accept 
	//	the state change. After this proc returns then restore the
	//	panel focus and update the pref menu.
	//
	evalDeferred("restoreLastPanelWithFocus(); ");

	return $result;
}

//
//	Description:
//		Create the Layer Editor UI.
//
{
	global string $gLayerEditorForm;

	//	Create the Layer Editor.
	//
	createLayerEditor($gLayerEditorForm);

	//	Update the Layer Editor.
	//
	updateLayerEditor();
}
