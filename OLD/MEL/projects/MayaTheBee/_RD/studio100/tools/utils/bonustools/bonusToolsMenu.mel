// Copyright (C) 1997-2006 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//
// bonusToolsMenu.mel
// author: cpam
//
// updated: Jan 2003 for 4.5
//			added new menu items
//			commented out obsolete menu items
//
// updated: Apr 2003 for 5.0
//			restructured so that the menu is sensitive to the module
//			(there are too many menuItems to show all at once)
//			added new items, removed some old ones
//
// updated: September 2003 for 5.0 booster
//			added new menuItems
//
// updated: April 2004 for 6.0
//			added new menuItems
//
// updated: August 2004 for 6.01
//			added new menuItems
//			rearranged animation menuItems
//
// updated: November 2004 for 3December
//			added new menuItems
//
// updated: January 2005 for 6.5
//			added new menuItems
//
// updated: July 2005 for 7.0
//			added new menuItems
//			commented out obsolete menuItems
//
// updated: January/June 2006 for 8.0
//			added new menuItems
//			commented out obsolete menuItems
//
// updated: November 2006 for 8.5
//			added new menuItems
//
// updated: July 2007 for Maya 2008
//			added new menuItems
//
// updated: December 2007 for Maya 2008
//			added new menuItems
//
// updated: July 2008 for Maya 2009
//			added new menuItems
//
// updated: July 2009 for Maya 2010
//			
//
proc bonusToolsMenuGeneral(string $os){
	///////////////////////////////////
	// GENERAL TOOLS//
	///////////////////////////////////
	/*
	menuItem -l "Copy Attribute Values"
		-ann ("Copy highlighted attribute values from the Channel Box - " +
			"Select target node first")
		-echoCommand true
		-c "copyAttr"
		copyAttrItem;
		*/
	
	/*
	menuItem -l "Replicate Attribute"
		-ann ("Copy highlighted attributes from the Channel Box - " +
			"Select target node first")
		-echoCommand true
		-c "replicateAttr"
		replicateAttrItem;
		*/

	/*
	menuItem -l "Search and Replace Object Names"
		-ann "Search and replace object names for selected objects"
		-echoCommand true
		-c "searchReplaceWin"
		searchReplaceWinItem;
		*/

	/*
	menuItem -l "Rename Selected Objects"
		-ann "Rename all selected objects"
		-echoCommand true
		-c "renamer"
		renamerWinItem;
	*/

	menuItem -l "Attribute Collection"
		-ann "Build custom UI"
		-echoCommand true
		-c "ac"
		acItem;
		
	/*	
	menuItem -l "Publish Attrs to Container"
		-ann "Add and connect selected channel box attributes to container node"
		-echoCommand true
		-c "python \"from addAndConnectAttrToContainer import *\";python \"addAndConnectAttrToContainer()\""
		;
		*/

	menuItem -l "Proportional Transform"
		-ann "Transform selected objects proportionally"
		-echoCommand true
		-c "performPropMove 0"
		propMoveItem;

		menuItem -optionBox true
			-label "Proportional Transform Option Box" 
			-annotation "Proportional Transform Option Box"
			-command "performPropMove 1" 
			propMoveOptItem;

	/*
	menuItem -l "Window Builder"
		-ann "Build a window to control attributes selected in the Channel Box"
		-echoCommand true
		-c "bgAttrAccess"
		windowBuilderItem;
		*/

	menuItem -l "Miscellaneous"
		//-ann "Build a window to control attributes selected in the Channel Box"
		-p bonusToolsMenu
		-to 1
		-subMenu true
		-aob true
		miscGeneralMenu;

		menuItem -l "Long List Attributes"
			-ann "List selected objects attributes in a scrollable window"
			-echoCommand true
			-c "attrListWin"
			longListItem;

		menuItem -l "Filter Objects Window"
			-ann "List all objects in the scene and filter based on type"
			-echoCommand true
			-c "bt_filterActionWindow"
			filterObjectsItem;

		menuItem -l "Calculator"
			-ann "Calculator Window"
			-echoCommand true
			-c "calculator"
			calculatorItem;

		if (`pluginInfo -q -l "measure"`){
			menuItem -l "Surface Area"
				-ann "Measure the surface of the selected objects"
				-c "measure -s -ver" 
				-i "surface.xpm"
				surfaceItem;

			menuItem -l "Volume"
				-ann "Measure the volume of the selected objects"
				-c "measure -v -ver" -i "volume.xpm"
				volumeItem;
		}
		
		menuItem -l "Create Menu from Shelf"
			-ann "Create a pull-down menu for the specified shelf"
			-echoCommand true
			-c "performShelfToMenu 0"
			shelfToMenuItem;
			
			menuItem -optionBox true
				-label "Proportional Transform Option Box" 
				-annotation "Proportional Transform Option Box"
				-command "performShelfToMenu 1" 
				shelfToMenuOptItem;

	setParent -m ..;

	menuItem -divider true;

	////////////////////////////////////////
	// SELECTION TOOLS //
	////////////////////////////////////////
	//menuItem -l "Invert Component Selection"
	//	-ann "Select the inversion of active components"
	//	-echoCommand true
	//	-c "invertCompSelection"
	//	invertCompSelectionItem;
	/*

	menuItem -l "Edge Path Selection Tool"
	-ann "Select/Deselect contiguous edges"
	-echoCommand true
	-image "edgePathIcon.xpm"
	-c "edgePath"
	-dragDoubleClickCommand  "QT_edgePathOptWin \" \""
	edgePathItem;

		menuItem -optionBox true
		-label "Edge Path Selection Option Box" 
		-annotation "Select/Deselect contiguous edges Option Box"
		-image "edgePathIcon.xpm"
		-command "edgePath\;QT_edgePathOptWin \" \"" 
		edgePathOptItem;

	menuItem -l "Face Path Selection Tool"
	-ann "Select/Deselect contiguous faces"
	-echoCommand true
	-image "facePathIcon.xpm"
	-c "facePath"
	-dragDoubleClickCommand "QT_facePathOptWin \" \""
	facePathItem;

		menuItem -optionBox true
		-label "Face Path Selection Option Box" 
		-annotation "Select/Deselect contiguous faces Option Box"
		-image "facePathIcon.xpm"
		-command "facePath\;QT_facePathOptWin \" \"" 
		facePathOptItem;
		*/

	//add select sub menu

	//catch plugin load in case plugin is not found
	//catch (`loadPlugin "convertVerticesToEdgesCmd.mll"`);
	//catch (`loadPlugin "convertVerticesToFacesCmd.mll"`);
	//catch (`loadPlugin "convertEdgesToFacesCmd.mll"`);
	//catch (`loadPlugin "getProjectedFacesCmd.mll"`);
	//only create menu items if plugin is loaded
	if (`exists convertVerticesToEdges`  
		|| `exists convertVerticesToFaces`
		|| `exists convertEdgesToFaces`
		|| `exists getProjectedFaces`){

		menuItem -l "Select Components"
			-parent bonusToolsMenu
			-tearOff 1
			-subMenu true
			bonusGameSelectMenu;

		/*
		if (`exists convertVerticesToEdges`) {
			menuItem -l "Select Edges Contained by Vertices"
			-ann "Select Edges Contained by Currently Selected Vertices"
			-echoCommand true
			-c "convertVerticesToEdges"
			edgesByVertsItem;
		}
		
		if (`exists convertVerticesToFaces`) {
			menuItem -l "Select Faces Contained by Vertices"
			-ann "Select Faces Contained by Currently Selected Vertices"
			-echoCommand true
			-c "convertVerticesToFaces"
			facesByVertsItem;
		}

		if (`exists convertEdgesToFaces`) {
			menuItem -l "Select Faces Contained by Edges"
			-ann "Select Faces Contained by Currently Selected Edges"
			-echoCommand true
			-c "convertEdgesToFaces"
			facesByEdgesItem;
		}
		*/

		if ($os != "mac"){
			if (`exists getProjectedFaces`) {
				menuItem -l "Select Poly Projection Node Faces"
					-ann ("Select Faces belonging to the projection nodes " +
					"highlighted in the channel box")
					-echoCommand true
					-c "bgGetProjectedFaces"
					projectedFacesItem;
			}
		}

		setParent -m ..;
	}
	//end select sub menu
	

/*
		menuItem -l "Hide Faces"
			-ann "Hide Faces: Hide the selected polygon faces."
			-echoCommand true
			-c "bgHideFaces"
			hideFaces;

		menuItem -l "Show Faces"
			-ann "Show Faces: Show the selected polygon faces."
			-echoCommand true
			-c ("if (!`exists bgHideFaces`) source bgHideFaces;" +
				"disableHideFaces")
			showFaces;

		menuItem -l "Refresh Face Display"
			-ann "Refresh Face Display: Refresh the display of Hidden faces."
			-echoCommand true
			-c ("if (!`exists bgHideFaces`)	source bgHideFaces; "+
				"refreshHideFaces")
			refreshFaces;

		setParent -m ..;
*/
	menuItem -divider true;

	///////////////////////////////////
	// DISPLAY TOOLS //
	///////////////////////////////////

	menuItem -l "Toggle Selected Faces Display"
		-ann "Toggle Selected Faces Display: Selected Faces will be hidden. If nothing is selected, hidden facces will be shown."
		-echoCommand true
		-c "toggleHideShowFaces"
		toggleFacesItem;

	menuItem -l "Layer Viewer..."
		-ann "Layer Viewer..."
		-echoCommand true
		-c "layerViewer"
		layerViewerItem;

	// build the next bunch of menuItems which are shared by the layerViewer.mel
	//setLayerToMenuItems;

	menuItem -l "Adjust Clipping Planes..."
		-ann "Adjust clipping planes for camera in active viewport"
		-echoCommand true
		-c "adjustClipPlanes"
		adjustClipPlanesItem;

	menuItem -divider true;
}

	///////////////////////////////////
	// MODELING TOOLS //
	///////////////////////////////////
proc bonusToolsMenuModeling(string $os){

	//setParent -menu bonusToolsMenu;

	/*
	menuItem -l "Triangle Count HUD"
		-ann "Adds triangle count to the Heads Up Display"
		-echoCommand true
		-c "toggleTriCountHUD"
		triCountItem;
	*/

	menuItem -l "Vertex Color Display..."
		-ann "Vertex Color: Toggle vertex color display modes in all panels"
		-echoCommand true
		-c "bgVertexColorDisplayUI"
		vertexColorItem;

	menuItem -l "Toggle Single/Double Sided"
		-ann "Toggle Single/Double Sided display of selected objects"
		-echoCommand true
		-c "toggleSingleDoubleSided"
		;

	menuItem -l "Toggle Vertex Distance HUD"
		-ann "Toggle the display of the distance between selected vertices."
		-echoCommand true
		-c "toggleVertDistanceHUD"
		;

	menuItem -l "Toggle Edge Length HUD"
		-ann "Toggle the display of the selected edge's length."
		-echoCommand true
		-c "toggleEdgeLengthHUD"
		;

	menuItem -divider true;

	///////////////////////////////////
	// ALIGN/MODIFY TOOLS //
	///////////////////////////////////

	menuItem -l "Bounding Box Scale Window..."
		-ann "Adjust the scale and pivot of selected objects based on the bounding box."
		-echoCommand true
		-c "boundingBoxScaleWindow"
		;

	//menuItem -l "Move Along Edge Window..."
	//	-ann "Select objects/components to move followed by an edge to move them along."
	//	-echoCommand true
	//	-c "moveAlongEdgeWin"
	//	;

	//menuItem -l "Move Along Normal Window..."
	//	-ann "Select objects/components to move followed by a face to move them along."
	//	-echoCommand true
	//	-c "moveAlongNormalWin"
	//	;

	/*
	menuItem -l "Orient To Vertex Tool"
		-ann "Rotate an object so that selected vertices are aligned."
		-echoCommand true
		-image "orientToVert.xpm"
		-c "orientToVertTool"
		-dragDoubleClickCommand "orientToVertTool;toolPropertyWindow"
		;

		menuItem -optionBox true
			-label "Orient To Vertex Tool Option Box" 
			-annotation "Orient To Vertex Tool Option Box"
			-image "orientToVert.xpm"
			-command "orientToVertTool;toolPropertyWindow" 
			;

	menuItem -l "Orient To Edge Tool"
		-ann "Rotate an object so that the select vertex touches the selected edge."
		-echoCommand true
		-image "orientToEdge.xpm"
		-c "orientToEdgeTool"
		-dragDoubleClickCommand "orientToEdgeTool;toolPropertyWindow"
		;

		menuItem -optionBox true
			-label "Orient To Edge Tool Option Box" 
			-annotation "Orient To Edge Tool Option Box"
			-image "orientToEdge.xpm"
			-command "orientToEdgeTool;toolPropertyWindow" 
			;
			*/

	menuItem -l "Orient To Vert/Edge Tool"
		-ann "Rotate an object so that the selected vertex touches the selected vert/edge."
		-echoCommand true
		-image "orientToEdge.xpm"
		-c "orientToTool"
		-dragDoubleClickCommand "orientToTool;toolPropertyWindow"
		;

		menuItem -optionBox true
			-label "Orient To Vert/Edge Tool Option Box" 
			-annotation "Orient To Vert/Edge Tool Option Box"
			-image "orientToEdge.xpm"
			-command "orientToTool;toolPropertyWindow" 
			;
			
	menuItem -divider true;

	///////////////////////////////////
	// CURVE TOOLS //
	///////////////////////////////////

	menuItem -l "Create Spiral Curve"
		-ann "Create a spiral curve"
		-echoCommand true
		-c "performSpiral 0"
		spiralCurveItem;

		menuItem -optionBox true
			-label "Create Spiral Curve Option Box" 
			-annotation "Create Spiral Curve Option Box"
			-command "performSpiral 1" 
			spiralCurveOptItem;

	menuItem -l "Create Curve from Edges..."
		-ann "Create a curve on poly mesh from selected contiguous edges"
		-echoCommand true
		-c "bgCreateCurveFromEdges"
		crvOnPolyItem;

	menuItem -l "Lock Curve Intersections"
		-ann "Lock intersection of selected curve or edit points"
		-echoCommand true
		-c "bt_lockIntersections"
		lockIntersectionsItem;

	menuItem -divider true;

	///////////////////////////////////
	// MESH CREATION TOOLS //
	///////////////////////////////////

	menuItem -l "Extra Poly Primitives"
		-to 1
		-subMenu true
		polyPrimitivesMenu;

	/*
		if (`exists polyPrimitive`){	
			menuItem -l "Icosahedron"
				-ann "Create a polygon icosahedron"
				-echoCommand true
				-c "polyPrimitive 1"
				icosahedronItem;

			menuItem -l "Dodecahedron"
				-ann "Create a polygon dodecahedron"
				-echoCommand true
				-c "polyPrimitive 2"
				dodecahedronItem;

			menuItem -l "Tetrahedron"
				-ann "Create a polygon tetrahedron"
				-echoCommand true
				-c "polyPrimitive 3"
				tetrahedronItem;

			menuItem -l "Octahedron"
				-ann "Create a polygon octahedron"
				-echoCommand true
				-c "polyPrimitive 5"
				octahedronItem;

			menuItem -l "Soccer Ball"
				-ann "Create a polygon soccer ball"
				-echoCommand true
				-c "polyPrimitive 8"
				soccerBallItem;
		}
		*/

		menuItem -l "Teapot"
			-ann "Create a teapot"
			-echoCommand true
			-c "teapotBrush"
			teapotItem;
			
		menuItem -l "Random Houses"
			-ann "Create simple, random houses"
			-echoCommand true
			-c "python \"from houseGenerator import *\";python \"houseGenerator()\""
			houseItem;

	setParent -m ..;

	if (`pluginInfo -q -l "PolyTools"`){
		menuItem -l "Poly Digits"
			-ann "Create polygonal geometry in the shape of a digital readout."
			-echoCommand true
			-c "polyDigits -n polyReadout#"
			polyDigitsItem;
	}

	/*
	menuItem -l "Convert Instance"
		-ann "Convert selected instances to real objects"
		-echoCommand true
		-c "convertInstanceToReal"
		convertInstanceItem;
		*/

	//menuItem -l "Duplicate Reference"
	//	-ann "Duplicate the reference file associated with the active geometry."
	//	-echoCommand true
	//	-c "duplicateReference"
	//	duplicateReferenceItem;

	/*
	menuItem -l "Replace Object Window"
		-ann "Replace selected objects with last selected object."
		-echoCommand true
		-c "replaceObjWin"
		;
		*/
		
	/*	
	menuItem -l "Position Along Curve"
		-ann "Position selected objects along selected curve."
		-echoCommand true
		-c "python \"from positionAlongCurve import *\";python \"positionAlongCurve()\""
		;
		*/

	menuItem -divider true;

	if (`exists LT_UI`){
		menuItem -l "Level Tools..."
			-ann "Open the Level Tools UI"
			-echoCommand true
			-c "LT_UI"
			levelToolsItem;

		menuItem -divider true;
	}

	/*
	menuItem -l "Component Center Snap"
	-ann "Snap components to center of first selected component"
	-echoCommand true
	-c "compMidPointSnapTool"
	compMidPointSnapItem;
	*/

	menuItem -l "Component Transform Manipulator"
	-ann "Create a manipulator to translate or scale selected polygon components"
	-echoCommand true
	-c "bgComponentTransformManip"
	compTranslateManipItem;

	menuItem -l "Move Object Pivot To Component Centre"
	-ann "Move the pivot point of the object to the centre of the selected components"
	-echoCommand true
	-c "moveObjectPivotToComponentCentre;"
	moveObjectPivotToComponentCentreItem;

	menuItem -divider true;

	menuItem -l "Poly Tools"
		-to 1
		-subMenu true
		polyToolsMenu;

		menuItem -l "Poly Poke Tool"
			-ann "Poly Poke Tool"
			-echoCommand true
			-c "polyPokeTool"
			polyPokeToolItem;

		menuItem -l "Poly Wedge Tool"
			-ann "Poly Wedge Tool"
			-echoCommand true
			-c "polyWedgeTool"
			polyWedgeToolItem;

		menuItem -l "Poly Flip Edge Tool"
			-ann "Poly Flip Edge Tool"
			-echoCommand true
			-c "polyFlipEdgeTool"
			polyFlipEdgeToolItem;

		menuItem -l "Poly Subdivide Tool"
			-ann "Poly Subdivide Tool"
			-echoCommand true
			-c "polySubdivideTool"
			polySubdivideToolItem;

		menuItem -l "Poly Merge Verts Tool"
			-ann "Poly Merge Verts Tool"
			-echoCommand true
			-c "polyMergeVertsTool"
			polyMergeVertsToolItem;

	setParent -m ..;

	//menuItem -l "Create Curve from Edges"
	//-ann "Create a degree 1 curve from selected contiguous edges"
	//-echoCommand true
	//-c "duplicateEdges"
	//duplicateEdgesItem;

	//menuItem -l "Create Curve on Poly Mesh"

	/*
	menuItem -l "Face Path Split Tool"
		-ann "Split contiguous faces"
		-echoCommand true
		-c "facePathSplit"
		facePathSplitItem;

		menuItem -optionBox true
			-label "Face Path Split Option Box" 
			-annotation "Split contiguous faces Option Box"
			-image "facePathSplitIcon.xpm"
			-command "facePathSplit\;QT_facePathSplitOptWin \" \"" 
			facePathSplitOptItem;
			*/

	if ($os != "mac"){
		//catch (`loadPlugin "drawSplitTool.mll"`);
		if (`pluginInfo -q -l "drawSplitTool"`){
			menuItem -l "Draw Split Tool"
				-ann "Split polygonal geometry by drawing on the mesh"
				-echoCommand true
				-image "drawSplitIcon.xpm"
				-c "drawSplitTool"
				-dragDoubleClickCommand "drawSplitTool\;toolPropertyWindow"
				drawSplitItem;
			
			menuItem -optionBox true
				-label "Draw Split Option Box" 
				-annotation "Draw Split Option Box"
				-image "drawSplitIcon.xpm"
				-command "drawSplitTool\;toolPropertyWindow" 
				drawSplitOptItem;
		}
		
		//catch (`loadPlugin "drawReduceTool.mll"`);
		if (`pluginInfo -q -l "drawReduceTool"`){
			menuItem -l "Draw Reduce Tool"
				-ann "Reduce polygonal geometry by drawing on the mesh"
				-echoCommand true
				-image "drawReduceIcon.xpm"
				-c "drawReduceTool"
				-dragDoubleClickCommand "drawReduceTool\;toolPropertyWindow"
				drawReduceItem;
			
			menuItem -optionBox true
				-label "Draw Reduce Option Box" 
				-annotation "Select/Deselect contiguous faces Option Box"
				-image "drawReduceIcon.xpm"
				-command "drawReduceTool\;toolPropertyWindow" 
				drawReduceOptItem;
		}
	}

	/*
	if (!`optionVar -exists "chamferVertexOffset"`)
	{
		optionVar -fv "chamferVertexOffset" 0.3;
	}

	menuItem -l "Chamfer Vertex"
		-ann "Chamfer selected poly vertex"
		-echoCommand true
		-c ("vertexMod 0 1 " + 
			"`optionVar -q chamferVertexExpression`" +
			"`optionVar -q chamferVertexOffset`")
		chamferVertexItem;

		menuItem -optionBox true
			-label "Chamfer Vertex Option Box" 
			-annotation "Chamfer selected poly vertex Option Box"
			-command "bgChamferVertexWin" 
			chamferVertexOptItem;

	if (!`optionVar -exists "extrudeVertexOffset"`)
	{
		optionVar -iv "extrudeVertexMode" 1;
		optionVar -fv "extrudeVertexOffset" 0.3;
	}

	menuItem -l "Extrude Vertex"
		-ann "Extrude selected poly vertex"
		-echoCommand true
		-c ("vertexMod `optionVar -q extrudeVertexMode`" +
			" 1 `optionVar -q extrudeVertexExpression` " +
			"`optionVar -q extrudeVertexOffset`")
		extrudeVertexItem;

			menuItem -optionBox true
				-label "Extrude Vertex Option Box" 
				-annotation "Extrude selected poly vertex Option Box"
				-command "extrudeVertexWin" 
				extrudeVertexOptItem;
	*/

	//add utility sub menu

	//catch plugin load in case plugin is not found
	//catch (`loadPlugin "closestPointOnCurve.mll"`);
	//catch (`loadPlugin "closestPointOnMesh.mll"`);
	//catch (`loadPlugin "pointOnMeshInfo.mll"`);
	//only create menu items if plugin is loaded
	if (`exists closestPointOnCurve`  
		|| `exists closestPointOnMesh`
		|| `exists pointOnMesh`){

		menuItem -l "Geometry Utilities"
			-p bonusToolsMenu
			-to 1
			-subMenu true
			bonusGameUtilityMenu;

		if (`exists closestPointOnCurve`) {
			menuItem -l "Create Closest Point on Curve Node"
			-ann ("Create a node to return information about the closest " +
				"point on a selected curve")
			-echoCommand true
			-c "closestPointOnCurve"
			closestPointOnCurveItem;
		}
		
		if (`exists closestPointOnMesh`) {
			menuItem -l "Create Closest Point on Mesh Node"
			-ann "Create a node to return information about the closest point on a selected mesh"
			-echoCommand true
			-c "closestPointOnMesh"
			closestPointOnMeshItem;
		}

		if (`exists pointOnMesh`) {
			menuItem -l "Create Point on Mesh Info Node"
			-ann "Create a node to return mesh info for the selected mesh."
			-echoCommand true
			-c "pointOnMesh"
			pointOnMeshInfoItem;
		}

		setParent -m ..;
	}
	//end utility sub menu

	menuItem -l "Adjust Vertex Normals..."
		-ann "Adjust vertex normals interactively"
		-echoCommand true
		-c "bgAdjustVertexNormalsWin"
		bgAdjustVertexNormalsItem;

	/*
	if (`exists polyNormalManipTool`) {
		menuItem -l "Vertex Normals Tool"
			-ann "Manipulator to adjust vertex normals with history"
			-echoCommand true
			-c "createPolyNormalManipTool"
			polyNormalManipToolItem;
	}

	menuItem -l "Geometry Transmogrifier..."
		-ann "Adjust selection and transform proportionally"
		-echoCommand true
		-c "bgTransmogrifierWin"
		bgTransmogrifierWinItem;
	*/

	/*
	menuItem -l "Bridge"
		-ann "Select two polygon faces and two polygon edges to bridge"
		-echoCommand true
		-c "tcPolyBridge"
		bridgeItem;
		*/

	/*			
	menuItem -l "Bridge Faces"
		-ann "Select two polygon faces and bridge between them"
		-echoCommand true
		-c "bridgeFaces"
		bridgeFacesItem;
		*/
	menuItem -l "Mirror Soft Mod..."
		-ann "Mirror selected soft mod node"
		-echoCommand true
		-c "bt_mirrorSoftModUI"
		bt_mirrorSoftModItem;
		
	menuItem -l "Mirror Instance Mesh..."
		-ann "Cut and make a mirrored instance of the selected mesh"
		-echoCommand true
		-c "bt_mirrorInstanceMesh"
		bt_mirrorInstanceMeshItem;
		
	menuItem -l "Merge and Combine"
		-ann "Merge and connect all selected meshes"
		-echoCommand true
		-c "bt_mergeCombineMeshes"
		bt_mergeCombineMeshesItem;
		
	menuItem -l "Connect Border Edges"
		-ann "Connect two selected polygon edge border regions"
		-echoCommand true
		-c "performPolyConnectBorders 0"
		connectBordersItem;

			menuItem -optionBox true
				-label "Connect Border Edges Option Box" 
				-annotation "Connect Border Edges Option Box"
				-command "performPolyConnectBorders 1"
				connectBordersOptItem;

	/*
	menuItem -l "Merge Selected Vertices by Distance"
		-ann "Select two vertices to be merged"
		-echoCommand true
		-c "polyMergeSelectedVerts"
		mergeSelectedVertsItem;
		*/

	menuItem -l "Extrude Face and Scale UVs"
		-ann "Extrude faces and scale the resultant UVs"
		-echoCommand true
		-c "extrudeFaceAndScaleUV"
		extrudeFaceAndScaleUVItem;
		
	menuItem -l "Merge Vertices by Distance"
		-ann "Select two vertices to specify a distance. All vertices on the mesh closer than this distance will be merged"
		-echoCommand true
		-c "polyMergeAllVertsUnderSelectedDistance"
		mergeVertsByDistanceItem;
		

	menuItem -l "Merge Selected Border Edges"
		-ann "Merge border edges oonnected to selected edge(s)."
		-echoCommand true
		-c "source tcPolyBridge;tcPolyZipper"
		zipperItem;

	//menuItem -l "Collapse to Center"
	//	-ann "Collapse selected faces/edges to their center point."
	//	-echoCommand true
	//	-c "ConvertSelectionToVertices;polyMergeSelectedVerts;"
	//	collapseItem;

	/*
	menuItem -l "Mirror Cut"
		-ann "Cut and mirror a poly mesh for symetrical modeling"
		-echoCommand true
		-c "polyMirrorCut"
		polyMirrorCutItem;
	*/

	menuItem -l "Paint Geometry Tool"
		-ann "Paint specified geometry onto selected surface"
		-echoCommand true
		-c "ScriptPaintTool;artUserPaintCtx -e -tsc \"geometryPaint\" `currentCtx`;"
		geometryPaintItem;
		
	menuItem -divider true;

	menuItem -l "Poly Copy Paste History"
		-to 1
		-subMenu true
		polyCopyPasteHistoryMenu;

		menuItem -l "Set Nodes to Copy"
			-ann "Select poly construction history nodes in order from first to last"
			-echoCommand true
			-c "string $nodesToCopy[] = `ls -sl`;"
			nodesToCopyItem;

		/*
		menuItem -l "Set Target Meshes"
			-ann "Select meshes to copy construction history to."
			-echoCommand true
			-c "string $targetMeshes[] = `ls -sl`;"
			targetMeshesItem;
			*/

		menuItem -l "Poly Copy Paste History"
			-ann "Copy and paste history as defined by above menu item."
			-echoCommand true
			-c "string $targetMeshes[] = `ls -sl`;polyCopyPasteHistory $nodesToCopy $targetMeshes;"
			polyCopyPasteHistoryItem;

		setParent -m ..;

	menuItem -l "Delete Upstream History"
		-ann "Select a mesh and an input node in the channel box. History on the upstream nodes will be baked."
		-echoCommand true
		-c "polyDeleteUpstreamHistory"
		polyDeleteUpstreamHistoryItem;
		
	menuItem -l "Insert Intermediate Poly Shape"
		-ann "Select a mesh and an input node in the channel box. A new shape node will be added for adjusting intermediate history."
		-echoCommand true
		-c "insertIntermediatePolyShape"
		insertIntermediatePolyShapeItem;
		
	menuItem -divider true;
		
	menuItem -l "Delete Edge and Cut UVs"
		-ann "Delete selected edge(s) and cut the surrounding UVs"
		-echoCommand true
		-c "polyDeleteEdgeSaveUVs"
		deleteEdgeCutUVsItem;

	menuItem -l "Split Around Selection"
		-ann "Split around the selection based on the edge ring that contains it"
		-echoCommand true
		-c "polyConvertToRingAndSplitAround"
		polyConvertToRingAndSplitAroundItem;
		
	menuItem -l "Separate Selected Edges"
		-ann "Separate the selected poly edges"
		-echoCommand true
		-c "polySplitSelectedEdges"
		polySplitSelectedEdgesItem;
		
	if (!`optionVar -exists "selectEveryNEdgeTool"`)
		optionVar -intValue "selectEveryNEdgeTool" 0;
		
	menuItem -l "Select Every N Edges"
		-ann "Propagate selection pattern of edge loops or rings"
		-echoCommand true
		-c ("int $state = `optionVar -query \"selectEveryNEdgeTool\"`;if ($state) selectEveryNEdgeTool; else selectEveryNEdge")
		selectEveryNEdgeItem;
		
		menuItem -optionBox true
			-label "Select Every N Edges Option Box" 
			-annotation "Select Every N Edges Option Box"
			-command "performSelectEveryNEdge"
			selectEveryNEdgeOptItem;

	menuItem -l "Normal Checker"
		-ann "Highlight reversed normals in red."
		-echoCommand true
		-c "normalChecker"
		;

	if (`pluginInfo -q -l "ColorTools"`){
		menuItem -l "Adjust CPV"
			-ann "Adjust CPV of selected meshes."
			-echoCommand true
			-c "polyAdjustCPV"
			;
	}

	menuItem -divider true;

	//////////////////////
	// UV TOOLS//
	//////////////////////
	/*
	menuItem -l "Snap UVs"
	-ann "Snap all selected UVs to first selected UV"
	-echoCommand true
	-c "UVPointSnapTool"
	snapUVsItem;
	*/

	/*
	menuItem -l "Copy UVs between UV Sets..."
		-ann ("Copy UVs of selected faces from current " +
			"UV Set to user specified UV Set")
		-echoCommand true
		-c "bgUVCompCopy"
		copyBetweenSetsItem;
	*/

	menuItem -l "Preserve UVs..."
		-ann "Lock/unlock UVs while tweaking the mesh."
		-echoCommand true
		-c "bt_preserveUVsUI"
		bt_preserveUVsItem;
		
	menuItem -l "Automatic Wrap Map..."
		-ann "Create and unwrap UVs for selected faces"
		-echoCommand true
		-c "bgAutomaticTrackMapWin"
		bgAutomaticTrackMapItem;
		
	menuItem -l "Align UV Shells..."
		-ann "Align UV Shells in the Texture Editor"
		-echoCommand true
		-c "python \"from AlignUVShells import *\";python \"AlignUVShellsWindow()\""
		alignUVShellsItem;

	menuItem -l "Map Unmapped Faces"
		-ann "Create UVs for unmapped faces on selected mesh"
		-echoCommand true
		-c "polyBevelMap"
		mapUnmappedFacesItem;

	menuItem -l "Smooth Face Mapping"
		-ann "Smooth UVs for selected face(s) on selected mesh"
		-echoCommand true
		-c "polyFixAppendMap"
		smoothFaceMappingItem;
		
	menuItem -l "Auto Map Multiple Meshes"
		-ann "Create an automatic mapping projection node to control multiple meshes"
		-echoCommand true
		-c "createAutoProjectionController"
		createAutoProjectionControllerItem;

	menuItem -l "Texture Editor Image Dimming..."
		-ann "Control the dimming of the texture displayed in the UV Texture Editor"
		-echoCommand true
		-c "textureEditorDimImageWindow"
		dimImageItem;
		
	menuItem -l "Assign Checker Shader"
		-ann "Assign a checkered shader to the selected mesh to test UV mapping"
		-echoCommand true
		-c "assignCheckerShader"
		assignCheckerShaderItem;

	menuItem -l "Adjust UVs"
		-to 1
		-subMenu true
		adjustUVMenu;

		/*
		menuItem -l "Align UVs..."
			-ann "Align UVs horizontally or vertically"
			-echoCommand true
			-c "alignUVWin"
			alignUVsItem;

		menuItem -l "Grid UVs..."
			-ann "Snap UVs to a user defined grid"
			-echoCommand true
			-c "gridUVWin"
			gridUVsItem;

		menuItem -l "Grab/Paste UVs..."
			-ann "Grab and Paste UV coordinates"
			-echoCommand true
			-c "grabPasteUVsWin"
			grabPasteUVsItem;
		*/

		menuItem -l "Cycle UVs"
			-ann "Cycle UV positions around selected face"
			-echoCommand true
			-c "polyRotateUVsByVertex"
			cycleUVsItem;

		menuItem -l "Rotate UVs around Vertex..."
			-ann "Rotate selected UVs around selected vertex"
			-echoCommand true
			-c "polyRotateUVsAboutVertexWin"
			rotateUVsVertItem;
	
		menuItem -l "UV Precision..."
			-ann "Set the number of decimal places for selected UVs"
			-echoCommand true
			-c "bgTruncateUVWin"
			bgTruncateUVItem;

		menuItem -l "Clamp UVs..."
			-ann "Clamp the active UVs to the specified bounding box"
			-echoCommand true
			-c "bgClampUVWin"
			bgClampUVItem;

		setParent -m ..;

	//catch (`loadPlugin "polyNurbsProjection.mll"`);
	if (`pluginInfo -q -l "polyNurbsProjection"`){
		menuItem -l "Poly NURBS Projection"
		-ann ("Select destination poly mesh followed by source NURBS " + 
			"surface to transfer UVs and texture from.")
		-echoCommand true
		-c "polyNurbsProjection"
		polyNurbsProjectionItem;
		}

	/*
	if (`pluginInfo -q -l "TextureTools"`){
		menuItem -l "Unfold UVs"
			-ann "Unfold UVs: Select a poly object or UV's to be unfolded"
			-echoCommand true
			-dragMenuCommand "performUnfold 2"
			-c "performUnfold 0" 
			-i "vacantCell.xpm"
			unfoldUVItem;
	
			menuItem -optionBox true
				-ann "Unfold UVs Option Box"
				-l "Unfold UVs Option Box"
				-c "performUnfold 1"
				-i "vacantCell.xpm"
				unfoldUVOptItem;
		
		menuItem -l "Layout Multiple UVs"
			-ann "Layout Multiple UVs: Select several poly objects to layout simultaneously"
			-echoCommand true
			-dragMenuCommand "performPolyMultiLayoutUV 2"
			-c "performPolyMultiLayoutUV 0" 
			-i "vacantCell.xpm"
			layoutMultUVItem;
		
			menuItem -optionBox true
				-ann "Layout Multiple UVs Option Box"
				-l "Layout Multiple UVs Option Box"
				-c "performPolyMultiLayoutUV 1"
				-i "vacantCell.xpm"
				layoutMultUVOptItem;
	}
	*/

	menuItem -divider true;

	//catch (`loadPlugin "polyVariance.mll"`);
	if (`pluginInfo -q -l "polyVariance"`){
		menuItem -l "Adaptive Prelight"
		-ann "Subdivide polygonal geometry by vertex lighting on the mesh"
		-echoCommand true
		-c "bgPerformPolyAdaptivePrelight 0"
		adaptivePrelightItem;

			menuItem -optionBox true
			-label "Adaptive Prelight Option Box" 
			-annotation "Adaptive Prelight Option Box"
			-command "bgPerformPolyAdaptivePrelight 1" 
			adaptivePrelightOptItem;
	}

	//catch (`loadPlugin "polyAttributeMap.mll"`);
	if (`pluginInfo -q -l "polyAttributeMap"`){
		menuItem -l "Poly Attribute Map"
			-ann "Write Polygon attributes to a texture map"
			-echoCommand true
			-c "bgPerformPolyAttributeMap 0"
			polyAttributeMapItem;
		
			menuItem -optionBox true
				-label "Poly Attribute Map Option Box" 
				-annotation "Poly Attribute Map Option Box"
				-command "bgPerformPolyAttributeMap 1" 
				polyAttributeMapOptItem;
	}

}

	//////////////////////////////////
	// RENDERING/TEXTURE TOOLS//
	//////////////////////////////////
proc bonusToolsMenuRendering(string $os){

	//setParent -menu bonusToolsMenu;

	/*
	menuItem -l "Select Face Shader"
		-ann ("Select the shader and open the Attribute Editor for the " +
			"currently selected face")
		-echoCommand true
		-c "bgGetComponentShader"
		bgComponentShaderItem;
	*/

	menuItem -divider true;
	/*
	menuItem -l "Create Stereo Camera"
		-ann ("Create a setup for rendering stereo images")
		-echoCommand true
		-c "performStereo 0"
		stereoCameraItem;

			menuItem -optionBox true
				-label "Create Stereo Camera Option Box" 
				-annotation "Create Stereo Camera Option Box"
				-command "performStereo 1"
				stereoCameraOptItem;
	*/
	if (`pluginInfo -q -l "sun"`){
		menuItem -l "Create Sun Light"
			-ann "Creates a new sun light"
			-c "sunLight" -i "directionallight.xpm"
			sunItem;
	}

	if (`pluginInfo -q -l "ftiExport"`){
		menuItem -l "FTI Export..."
			-ann "Create an FTI image to be used as an icon."
			-c "performExportFti"
			ftiItem;
	}

	menuItem -divider true;

	menuItem -l "Make Texture Layered"
		-ann ("Select textures connected to shaders to make into " +
			"layered textures")
		-echoCommand true
		-c "bgMakeSelectedLayered"
		makeSelectedLayeredItem;

	menuItem -l "Layer Textures"
		-ann ("Select texture connected to layered texture followed " +
			"by texture to layer")
		-echoCommand true
		-c "bgLayerTextures"
		layerTexturesItem;

	/*
	menuItem -l "Test Render Node"
		-ann ("Test selected render node")
		-echoCommand true
		-c "performCompositeTest 0"
		performCompositeTestItem;

			menuItem -optionBox true
				-label "Test Render Node Option Box" 
				-annotation "Test Render Node Option Box"
				-command "performCompositeTest 1"
				performCompositeTestOptItem;

	menuItem -l "Test Render Node Sequence"
		-ann ("Create a sequence of images for selected render node")
		-echoCommand true
		-c "performComposite 0"
		performCompositeItem;

			menuItem -optionBox true
				-label "Test Render Node Sequence Option Box" 
				-annotation "Test Render Node Sequence Option Box"
				-command "performComposite 1"
				performCompositeOptItem;
*/
	menuItem -l "Change Texture Paths..."
		-ann ("Open the relocate textures window")
		-echoCommand true
		-c "relocateTexturesWin"
		relocateTexturesItem;

	menuItem -l "Organize Files..."
		-ann ("Open the organize files window")
		-echoCommand true
		-c "organizeFilesWindow"
		organizeFilesItem;

	menuItem -divider true;

	menuItem -l "Generate Light Maps"
		-ann ("Generate light maps, layered textures and new UV sets " +
			"for scene geometry")
		-echoCommand true
		-c "bgPerformGenerateLightMaps 0"
		generateLightMapsItem;

			menuItem -optionBox true
				-label "Generate Light Maps Option Box" 
				-annotation "Generate Light Maps Option Box"
				-command "bgPerformGenerateLightMaps 1"
				generateLightMapsOptItem;

			/*
	if (`pluginInfo -q -l "TextureTools"`){
		menuItem -l "Poly Remap Image"
		-ann "Remap an image based on UVSets"
		-echoCommand true
		//-image "render_swColorPerVertex.xpm"
		-c "performPolyWarpImage 0"
		polyWarpImageItem;

			menuItem -optionBox true
				-label "Poly Remap Image Option Box" 
				-annotation "Poly Warp Image Option Box"
				-command "performPolyWarpImage 1"
				polyWarpImageOptItem;
	}
	*/

	menuItem -l "Isometric Render"
		-to 1
		-subMenu true
		isometricRenderMenu;

		menuItem -l "Render Current View"
			-ann "Render the current view isometrically."
			-echoCommand true
			-c "bgIsometricRender render"
			isometricRender;

		menuItem -l "Preview"
			-ann "Preview the isometric render in the viewports."
			-echoCommand true
			-c "bgIsometricRender preview"
			isometricPreview;

		menuItem -l "Reset"
			-ann "Reset the viewports from isometric display."
			-echoCommand true
			-c "bgIsometricRender reset"
			isometricReset;

		setParent -m ..;

	//catch (`loadPlugin "swColorPerVertex.mll"`);
	//catch (`loadPlugin "cvColorShader.mll"`);
	if (`pluginInfo -q -l "cvColorShader"`){
		menuItem -l "Create CPV Render Node"
		-ann "Create a node to software render color per vertex"
		-echoCommand true
		-image "render_swColorPerVertex.xpm"
		-c "createNode cvColorShader -name swCPV"
		swCPVItem;
	}

	menuItem -divider true;

	if (`pluginInfo -q -l "Fur"`){
	menuItem -l "Fur Blender"
		-ann "Blend two selected fur descriptions onto the third selected fur target"
		-c "furBlender" 
		furBlenderItem;
	}

}


	///////////////////////////////
	// ANIMATION TOOLS//
	///////////////////////////////
proc bonusToolsMenuAnimation(string $os){

	//setParent -menu bonusToolsMenu;

	/*
	menuItem -l "Create Turntable Animation"
		-ann "Select objects to be centred on the turntable."
		-echoCommand true
		-c "turnTable"
		turnTableItem;
		*/

	menuItem -l "Walk Cycle Control Window..."
		-ann "Walk Cycle Control Window helps create animation cycles."
		-echoCommand true
		-c "walkCycleControl"
		walkCycleControlItem;

	if (`pluginInfo -q -l "audioWave"`){
		menuItem -l "Create Audio Wave Node"
			-ann "Create a node that can drive channels based on an audio signal"
			-echoCommand true
			-c "createNode audioWave"
			audioWaveItem;
	}

	/*
	menuItem -l "Current Frame Display"
		-ann "Create a particle object to display the current frame"
		-echoCommand true
		-c "bgCurrentFrameDisplay"
		bgCurrentFrameDisplayItem;
		*/

	menuItem -divider true;

	///////////////////////////////
	// SKINNING TOOLS//
	///////////////////////////////

	menuItem -l "Prune Influence Objects..."
		-ann ("Select skinned geometry to prune a user specified number " +
			"of influence objects from")
		-echoCommand true
		-c "pruneNumInfluenceWin"
		pruneNumInfluenceWinItem;

	menuItem -l "Remove Influence Objects..."
		-ann "Select skinned geometry to remove influence objects from"
		-echoCommand true
		-c "removeInfluenceWin"
		removeInfluenceWinItem;
		
	menuItem -l "Nudge Vert Weights..."
		-ann "Select verts and an influence objects to adjust weights for"
		-echoCommand true
		-c "nudgeVertWeightsWindow"
		nudgeVertWeightsWindowItem;
		
	menuItem -l "Pose Blend Shape Editor..."
		-ann "Add corrective blend shapes for selected mesh and set selected joint as a set driven key driver"
		-echoCommand true
		-c "poseBlendShapeEditor"
		poseBlendShapeEditorItem;

	//menuItem -l "Add Multiple Influence Objects"
	//	-ann "Select skinned geometry and influence objects to add"
	//	-echoCommand true
	//	-c "addMultipleInfluences"
	//	addMultipleInfluencesItem;

	/*
	menuItem -l "Delete History and Save Skinning"
		-ann "Select geometry to remove history from - skinning will be maintained"
		-echoCommand true
		-c "deleteHistoryKeepSkinning";
	*/

	menuItem -divider true;

	///////////////////////////////
	// GENERAL ANIMATION TOOLS//
	///////////////////////////////

	/*
	menuItem -l "Reorient Animated Character"
		-ann "Select root joint of FK animated character"
		-echoCommand true
		-c "reorientCharacterWin"
		reorientCharacterWinItem;
	*/

	menuItem -l "Bake IK to Clip"
		-ann ("Bake the animation of the selected IK handle into a clip " +
			"for the active character")
		-echoCommand true
		-c "bgBakeIKToClip 1"
		bakeIKToClipItem;

	menuItem -l "Store Pose"
		-ann "Create a shelf button for the selected node(s) current positions"
		-echoCommand true
		-c "bgStorePose"
		storePoseItem;

	menuItem -l "FKIK Control Window"
		-ann "A window for easier keying of fk ik animation"
		-echoCommand true
		-c "fkikControlWindow"
		fkikControlWindowItem;

	menuItem -l "Bake Redirection"
		-ann "Bake the motion from the redirection node onto selected nodes"
		-echoCommand true
		-c "performBakeRedirection 0"
		bakeRedirectItem;

			menuItem -optionBox true
				-label "Bake Redirection Option Box" 
				-annotation "Bones on Curve Option Box"
				-command "performBakeRedirection 1"
				bakeRedirectOptItem;

	menuItem -l "Mirror Animation..."
		-ann "Mirror Animation across an axis..."
		-echoCommand true
		-c "bgMirrorAnim"
		mirrorAnimationItem;

	menuItem -l "Reverse Animation..."
		-ann "Reverse Animation for the selected hierarchy..."
		-echoCommand true
		-c "bgReverseAnim"
		reverseAnimationItem;

	/*  OLD TOOL NAME
	menuItem -l "Dynamic Secondary Animation..."
		-ann "Apply dynamic-driven secondary animation..."
		-echoCommand true
		-c "bgDynamicSecondaryAnim"
		;
		*/

	menuItem -l "Make Joints Dynamic..."
		-ann "Apply dynamic-driven secondary animation..."
		-echoCommand true
		-c "bt_makeJointsDynamicUI"
		;
		
	menuItem -divider true;

	///////////////////////////////
	// RIGGING TOOLS//
	///////////////////////////////

	menuItem -l "Create Circle Under Transform"
		-ann "Create a circle under the selected transform node"
		-echoCommand true
		-c "createCircleUnderTransform"
		createCircleUnderTransformItem;

	menuItem -l "Rename New Joints"
		-ann ("Window to control joint names as joints are created - " +
			"Can also be applied to other objects")
		-echoCommand true
		-c "renameNewJointsWin"
		renameNewJointsWinItem;

	/*
	menuItem -l "Split Joint"
		-ann "Insert a joint above the selected joint"
		-echoCommand true
		-c "splitJoint"
		splitJointItem;
		*/

	menuItem -l "Bones on Curve"
		-ann "Create bones for selected curve"
		-echoCommand true
		-c "performBonesOnCurve 0"
		bonesOnCurveItem;

			menuItem -optionBox true
				-label "Bones on Curve Option Box" 
				-annotation "Bones on Curve Option Box"
				-command "performBonesOnCurve 1"
				bonesOnCurveOptItem;

	menuItem -l "Copy Set Driven Key..."
		-ann "UI to copy Set Driven Key curves between objects"
		-echoCommand true
		-c "copySDKWindow"
		copySDKItem;

	menuItem -l "Select Cluster Members"
		-ann "Convert selected cluster to contained components"
		-echoCommand true
		-c "bgSelectClusterMembers"
		bgSelectClusterMembersItem;

	menuItem -l "Setup Arm"
		-ann "Create an arm control for selected shoulder and wrist joint (arm should point in +Z)"
		-echoCommand true
		-c "performArmSetup 0"
		armSetupItem;

			menuItem -optionBox true
				-label "Setup Arm Option Box" 
				-annotation "Setup Arm Option Box"
				-command "performArmSetup 1"
				armSetupOptItem;

	menuItem -l "Setup Back..."
		-ann "Create a back control for selected pelvis and neck joint (body should point in +Z)"
		-echoCommand true
		-c "backSetupWin"
		backSetupItem;

	menuItem -l "Setup Foot"
		-ann "Create a foot control for selected hip and ankle joint (foot should point in +Z)"
		-echoCommand true
		-c "performFootSetup 0"
		footSetupItem;

			menuItem -optionBox true
				-label "Setup Foot Option Box" 
				-annotation "Setup Foot Option Box"
				-command "performFootSetup 1"
				footSetupOptItem;

	menuItem -l "Stretchy IK..."
		-ann "Add stretchy IK to the selected IK handles"
		-echoCommand true
		-c "stretchyIKWin"
		stretchyIKItem;

	menuItem -l "Skeleton Works..."
		-ann "Create and catalog skeletons"
		-echoCommand true
		-c "skeletonWorks"
		skeletonWorksItem;


	///////////////////////////////
	// TRAX TOOLS//
	///////////////////////////////
	/*
	menuItem -divider true;

	menuItem -label "Trim Clip After"
		-annotation "Trim clip after current time."
		-echoCommand true
		-command "trimAfterCmd";
		
	menuItem -label "Trim Clip Before"
		-annotation "Trim clip before current time."
		-echoCommand true
		-command "trimBeforeCmd";

	menuItem -label "Graph Clip Weight"
		-annotation "Graph weight curve for clip"
		-echoCommand true
		-command //("string $currentPanel = `getPanel -withFocus`;" +
			("clipWeightGraph clipEditorPanel1ClipEditor" );
		
	menuItem -label "Select Clip's Character"
		-annotation "Select character based on selected clip."
		-echoCommand true
		-command //("string $currentPanel = `getPanel -withFocus`;" +
			("selectCharacter clipEditorPanel1ClipEditor" );

	menuItem -label "Find Character"
		-annotation "List the character in trax."
		-echoCommand true
		-command ("characterFindmenu clipEditorPanel1ClipEditorcurrentListItem clipEditorPanel1ClipEditor" );
		*/

}

	///////////////////////////////
	// DYNAMICS TOOLS//
	///////////////////////////////
proc bonusToolsMenuDynamics(string $os){

	//setParent -menu bonusToolsMenu;

	menuItem -l "Paint Emitters Tool"
		-ann ("Paint particle emitters on selected surface")
		-echoCommand true
		-c "ScriptPaintTool;artUserPaintCtx -e -tsc \"emitterPaint\" `currentCtx`;"
		emitterPaintItem;

	/*  OLD TOOL NAME
	menuItem -l "Dynamic Secondary Animation..."
		-ann "Apply dynamic-driven secondary animation..."
		-echoCommand true
		-c "bgDynamicSecondaryAnim"
		;
		*/

	menuItem -l "Make Joints Dynamic..."
		-ann "Apply dynamic-driven secondary animation..."
		-echoCommand true
		-c "bt_makeJointsDynamicUI"
		;

}

	///////////////////////////////
	// CLOTH TOOLS//
	///////////////////////////////
proc bonusToolsMenuCloth(string $os){

	//setParent -menu bonusToolsMenu;

	menuItem -l "Select Cloth Panel Faces"
		-ann ("Convert the selected cloth panel to contained faces")
		-echoCommand true
		-c "clothPanelToFaces"
		clothPanelToFacesItem;
		

	menuItem -l "Thicken Cloth"
		-ann ("Extrude and smooth selected cloth meshes to give them thickness")
		-echoCommand true
		-c "clothThicken"
		clothThickenItem;

}

	///////////////////////////////
	// BONUS TOOLS//
	///////////////////////////////
proc bonusToolsMenuBonus(string $os){

	//setParent -menu bonusToolsMenu;
	menuItem -l "Help"
		-ann ("Bonus Tools Help")
		-echoCommand true
		//-checkBox `optionVar -query bonusToolsMenuToggle`
		-c "bonusToolsHelp \"docs/bonusTools.html\""
		;
	
	menuItem -l "Toggle Menu Style"
		-ann ("Toggle menu style between a constant display and a mode based display")
		-echoCommand true
		-checkBox `optionVar -query bonusToolsMenuToggle`
		-c "bonusToolsMenuToggle"
		;
	/*
	menuItem -l "Help"
		-ann ("Open the Bonus Tools help in a web browser")
		-echoCommand true
		-c "showBonusToolsHelp"
		;
	*/
}

proc bonusToolsMenuToggle(){

	int $state = `optionVar -query "bonusToolsMenuToggle"`;
	int $state = !($state);
	optionVar -intValue "bonusToolsMenuToggle" $state;

}


proc bonusToolsSubMenuStyle(string $os){

	menuItem -label "Modeling"
		-tearOff 1
		-allowOptionBoxes true
		-subMenu true
		//-parent bonusToolsMenu
		btModeling;
	setParent -m btModeling;
	bonusToolsMenuModeling $os;
	setParent -m bonusToolsMenu;

	menuItem -label "Animation"
		-tearOff 1
		-allowOptionBoxes true
		-subMenu true
		//-parent bonusToolsMenu
		btAnimation;
	setParent -m btAnimation;
	bonusToolsMenuAnimation $os;
	setParent -m bonusToolsMenu;

	menuItem -label "Rendering"
		-tearOff 1
		-allowOptionBoxes true
		-subMenu true
		//-parent bonusToolsMenu
		btRendering;
	setParent -m btRendering;
	bonusToolsMenuRendering $os;
	setParent -m bonusToolsMenu;

	menuItem -label "Dynamics"
		-tearOff 1
		-allowOptionBoxes true
		-subMenu true
		//-parent bonusToolsMenu
		btDynamics;
	setParent -m btDynamics;
	bonusToolsMenuDynamics $os;
	setParent -m bonusToolsMenu;

	menuItem -label "Cloth"
		-tearOff 1
		-allowOptionBoxes true
		-subMenu true
		//-parent bonusToolsMenu
		btCloth;
	setParent -m btCloth;
	bonusToolsMenuCloth $os;
	setParent -m bonusToolsMenu;

	menuItem -label "Bonus"
		-tearOff 1
		-allowOptionBoxes true
		-subMenu true
		//-parent bonusToolsMenu
		btBonus;
	setParent -m btBonus;
	bonusToolsMenuBonus $os;
	setParent -m bonusToolsMenu;

}

proc bonusToolsModeMenuStyle (string $os, string $mayaMode){

	switch( $mayaMode ) {
		case "animationMenuSet":	bonusToolsMenuAnimation $os; break;
		case "polygonsMenuSet":	bonusToolsMenuModeling $os; break;
		case "renderingMenuSet":	bonusToolsMenuRendering $os; break;
		case "dynamicsMenuSet":	bonusToolsMenuDynamics $os; break;
		case "clothMenuSet":		bonusToolsMenuCloth $os; break;
		case "liveMenuSet":		bonusToolsMenuRendering $os; break;
		default:			bonusToolsMenuModeling $os; break;
	}
	
}

global proc bonusToolsMenu(){

	global string $gMainWindow;
	global string $gMenuModeButton;
	string $mayaMode = `setMenuMode`;
	string $os = `about -operatingSystem`;
	int $index = -1;

	if(`menu -exists bonusToolsMenu`) {
		// Find out the current index of menu
		string $allMenus[] = `window -q -menuArray $gMainWindow`;
		string $menu;
		for($menu in $allMenus) {
			$index++;
			if($menu == "bonusToolsMenu") {
				break;
			}
		}
		
		deleteUI -menu bonusToolsMenu;
	}

	setParent $gMainWindow;

	menu -label "Bonus Tools"
		-parent $gMainWindow
		-tearOff 1
		-allowOptionBoxes true
		-familyImage "bonusGame.xpm"
		bonusToolsMenu;

	if($index >= 0) {
		// Move bonus tools menu to the previous position
		window -edit -menuIndex bonusToolsMenu $index $gMainWindow;
	}

	bonusToolsMenuGeneral $os;

	if (!`optionVar -exists "bonusToolsMenuToggle"`)
		optionVar -intValue "bonusToolsMenuToggle" 0;

	int $state = `optionVar -query "bonusToolsMenuToggle"`;

	if ($state)
		bonusToolsSubMenuStyle $os;
	else{
		bonusToolsModeMenuStyle $os $mayaMode;
		menuItem -divider true;
		bonusToolsMenuBonus $os;

	}
	hotBox -updateMenus;

}
