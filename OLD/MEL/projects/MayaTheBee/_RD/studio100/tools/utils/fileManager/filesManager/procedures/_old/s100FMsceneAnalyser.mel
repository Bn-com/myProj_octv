/*
 Procs to analyse what references are in a scene and export the list as a text file
 and/or read result from it and prompt it out in a UI (if any file is found)

	Author : Quentin Auger
	Creation : March 2012, for MayaTheBee TV serie show.

 EXAMPLE of what can be printed out :
*/
// --------------------------------- Studio100 Scene Analyser -------------------------------
//
// This file is automatically generated by Studio100's s100FMsceneAnalyser() script.
// Edit at your own risk.
//
// CURRENT SCENE "" :
// Path :
//
// REFERENCE STATISTICS :
//
// Number	 [ Asset Type ] 	 Reference Names (SubRef type)
// ------	----------------	-------------------------------
//    1 	 [ Character  ] 	 "C_AphidLowOriginal_01" (ANIMCACHE)
//    2 	 [ Character  ] 	 "C_AphidLowOriginal_01" (RENDER)
//    1 	 [ Character  ] 	 "C_AphidOriginal_01" (MASTER)
//
// => 4 Character(s), 0 Prop(s),
//    0 Location(s), 0 Location-Module(s),
//    0 Vegetation(s), 0 Micro-Vegetation(s),
//    0 Camera(s), 0 FL LightRig(s), 0 Unknown Reference Node(s)...
//  = Total : 4 Asset(s)
//
//    Using 1 MASTER/Ref, 0 LAYOUT, 0 ANIM,
//          1 ANIMCACHE, 2 RENDER, 0 No-Specific-State file(s)
//         [total : 4]
//
// ================================================================================================
//
//  NON-REFERENCE STATISTICS ('INSTANCE' subRefs and Asset-Associated Xforms) :
//  ------------------------
//
//  Number	 [ Asset Type ] 	 Maya File Names (SubRef type)  	 "INSTANCE" (transform in scene)
// ------	----------------	------------------------------- 	 -------------------------------
//     1 	 [ Character  ] 	 "C_AphidLowOriginal_01" (MASTER)  -> "C_AphidLowOriginal_01_INSTANCE_001"
//
//  => 1 Character(s), 0 Prop(s),
//     0 Location(s), 0 Location-Module(s),
//     0 Vegetation(s), 0 Micro-Vegetation(s),
//     0 Camera(s), 0 FL LightRig(s), 0 Matte Painting(s), 0 Unknown asset type(s)...
//   = Total : 1 Asset(s)
//
//     Using 1 MASTER/Ref, 0 LAYOUT, 0 ANIM,
//           0 ANIMCACHE, 0 RENDER, 0 No-Specific-State file(s)
//          [total : 1]
//
//
//  ================================================================================================
//
//  FULL TOTAL : Ref'd/Non-Ref'd STATISTICS (Referenced subRefs and 'INSTANCE'/Asset-Associated Xforms) :
//  ---------------------------------------
//
//  => 5 Character(s), 0 Prop(s),
//     0 Location(s), 0 Location-Module(s),
//     0 Vegetation(s), 0 Micro-Vegetation(s),
//     0 Camera(s), 0 FL LightRig(s), 0 Matte Painting(s), 0 Unknown asset type(s)...
//   = Total : 5 Asset(s)
//
//     Using 5 MASTER/Ref, 0 LAYOUT, 0 ANIM,
//           0 ANIMCACHE, 0 RENDER, 0 No-Specific-State file(s)
//           1 non-ref'd INSTANCES,
//          [total : 5]
//
// --- End of "" analyse ---

// ========================================================================================================

// Main starting proc that can be called by user (FileManager for example) :

global proc string s100FMsceneAnalyser(int $showWindow)
{
	string $currentScene = `file -q -sn -shortName`;
	print ("\r\n// Analysing content of current scene : \""+$currentScene+"\" : \r\n");

	string $currentSceneLN = `file -q -sn `;
	print ("// >> \""+$currentSceneLN+"\" \r\n\r\n");

	string $analyseTextFileName = s100FMac_returnAnalyseTextFileName( $currentScene, $currentSceneLN) ;

	string $analyse = s100FM_doSceneAnalyser($currentScene, $currentSceneLN);

	if (size($analyse))
	{
		int $fileNameOK = size($analyseTextFileName) ;
		if ($fileNameOK==false)
			warning ("Could NOT find a proper Analyse Text File Name for current scene !");

		if ($showWindow)
			s100FMsceneAnalyser_editUI( $analyse,  $currentScene,  $analyseTextFileName, $fileNameOK) ;
		else if ($fileNameOK)
			s100FMsceneAnalyser_saveFile($analyse, $analyseTextFileName);
    }
	else
	{
		warning ("Analyse of current scene '"+$currentScene+"' gave nothing back..");
		return "";
    }
	return $analyseTextFileName;
}


// Procs related to text file where analyse is printed out / read from  :
//
global proc s100FMac_promptSceneAnalyseFromFile()
{
	string $currentScene = `file -q -sn -shortName`;
	print ("\r\n// Analysing content of current scene : \""+$currentScene+"\" : \r\n");
	string $currentSceneLN = `file -q -sn `;
	print ("// >> \""+$currentSceneLN+"\" \r\n\r\n");

	string $analyseTextFileName = s100FMac_returnAnalyseTextFileName( $currentScene, $currentSceneLN) ;

	if(`filetest -e $analyseTextFileName`)
	{
		string $analyse=s100FMsceneAnalyser_loadFile($analyseTextFileName);
		if(size($analyse))
		{
			s100FMsceneAnalyser_editUI( "",  $currentScene,  $analyseTextFileName, 1) ;
			scrollField -e -text $analyse s100FMac_analyseTF;
        }
		else
			print ("// No Analyse Text found in \""+$analyseTextFileName+"\"");
    }
	else
		error "No Analyse File found for current scene - aborted";
}

global proc s100FMsceneAnalyser_saveFile(string $analyse, string $analyseTextFileName)
{
	int $moveOn = s100FMac_saveVersionIfneeded($analyseTextFileName);
	if ($moveOn)
	{
		int $fileId=`fopen $analyseTextFileName "w"`;
		string $lines[] = stringToStringArray($analyse,"\r\n");
		for ($i=0; $i<size($lines); $i++)
		{
			// stripping starting "// " beginning for better readibility
			string $curLine = $lines[$i];
			if (startsWith($curLine,"// "))
				$curLine = substitute("// ",$curLine," ");
			fprint $fileId ($curLine+"\r\n");
		}
		fclose $fileId; // fclose 3
		print ("// s100FMsceneAnalyser_saveFile >> wrote result in \"" + $analyseTextFileName +"\" \r\n") ;
	}
}

global proc string s100FMsceneAnalyser_loadFile(string $analyseTextFileName)
{
	string $analyse = "";
	if(`filetest -e $analyseTextFileName`)
	{
		int $fileId=`fopen $analyseTextFileName "r"`;
		while ( !`feof $fileId` )
		{
			string $curLine = `fgetline $fileId`;
			if (!startsWith($curLine,"//"))
				$curLine = "//"+$curLine;
			$analyse += $curLine;
		}
		fclose $fileId; // fclose 3
		print ("// s100FMsceneAnalyser_loadFile >> read analyse from \"" + $analyseTextFileName +"\" \r\n") ;
	}
	else
		print ("// s100FMsceneAnalyser_loadFile >> Cannot find text file \""+$analyseTextFileName+"\" \r\n");
	return $analyse;
}


global proc string s100FMac_returnAnalyseTextFileName(string $currentScene, string $currentSceneLN)
{
	string $analyseTextFileName = "";
	string $filePath = `match "^.*/" $currentSceneLN`;
	if (size($currentScene))
	{
		string $noExt = `match "^[^\.]*" $currentScene`;
		$analyseTextFileName = $filePath+$noExt+"__Analyse.txt";
    }
	return $analyseTextFileName;
}


global proc int s100FMac_saveVersionIfneeded(string $analyseTextFileName)
{
	if(`filetest -s $analyseTextFileName`)
	{
		// getting file path with no ending "/":
		string $filePath = `match "^.*/" $analyseTextFileName`;
		if (!endsWith($filePath,"/"))
			$filePath = $filePath+"/";

		string $filepart = `match "[^/\\]*$" $analyseTextFileName`;

		if(!`filetest -d ($filePath +"_old/") `)
		{
			sysFile -makeDir ($filePath +"_old/") ;
			print ("// s100FMac_saveVersionIfneeded >> folder created : " + $filePath +"_old/ \r\n") ;
        }
		$inc = s100FM_exportSubRefGetNumbOfIncrement($filePath +"_old/") ;
		$goFolder = ($filePath +"_old/" + $inc +"/") ;
		sysFile -makeDir $goFolder ;
		print ("// s100FMac_saveVersionIfneeded >> folder created : '"+$goFolder+"' \r\n") ;

		int $ok = !catch(`sysFile -copy ($goFolder + $filepart) ($analyseTextFileName) `);
		if ($ok)
			print ("// s100FMac_saveVersionIfneeded >> file saved : '"+($goFolder+$filepart)+"' \r\n") ;
		return $ok;
	}
	else
		print ("// s100FMac_saveVersionIfneeded >> nothing to backup\r\n");
	return 1;
}



// Procs related to the UI where scene analyse text file is shown up  :
//
global proc s100FMsceneAnalyser_editUI(string $analyse, string $currentScene, string $analyseTextFileName, int $fileOK )
{
	string $win = "s100FMac_sceneAnalyseEditUI";
	if (`window -ex $win`)
		deleteUI $win;

	window -wh 610 400 -t ("S100 Analyse of scene \""+$currentScene+"\"") $win;

		formLayout s100FMac_sceneAnalyseEditFL;

			// Main scriptEditor part:
			scrollField -wordWrap false -text $analyse s100FMac_analyseTF;

			// Bottom buttons part:
				formLayout s100FMac_sceneAnalyseBtnsFL;

					button -label "Refresh from SCENE" -bgc 1.0 1.0 1.0
						-c ("string $analyse=s100FM_doSceneAnalyser(`file -q -sn -shortName`,`file -q -sn`);if(size($analyse)) scrollField -e -text $analyse s100FMac_analyseTF; else print \"// No Reference Analyse was possible - aborted\";")
						s100FMac_b1;

					button -en $fileOK -label "Reload from FILE (if any)" -bgc 1.0 1.0 0.0
						-ann ("Reloading last informations from Scene Analyse Text File \""+$analyseTextFileName+"\" into current UI.")
						-c ("string $analyse=s100FMsceneAnalyser_loadFile(\""+$analyseTextFileName+"\");if(size($analyse)) scrollField -e -text $analyse s100FMac_analyseTF; else error \"No Analyse File found for current scene - aborted\";")
						s100FMac_b2;

					button -en $fileOK -label "SAVE Analyse + QUIT" -bgc 1.0 0.2 0.1
						-ann ("Save these informations into Scene Analyse Text File \""+$analyseTextFileName+"\" and close this UI.")
						-c ("string $analyse=`scrollField -q -text s100FMac_analyseTF`; s100FMsceneAnalyser_saveFile($analyse,\""+$analyseTextFileName+"\"); deleteUI "+$win+";")
						s100FMac_b3;

					button -label "Cancel" -c ("deleteUI "+$win+";")
					s100FMac_b4;

				setParent ..;

		setParent ..;

		// edit formLayout
		//
		formLayout -edit
			-attachForm		s100FMac_analyseTF	"top"		10
			-attachForm		s100FMac_analyseTF	"left"		5
			-attachForm		s100FMac_analyseTF	"right"		5
			-attachControl	s100FMac_analyseTF	"bottom"	15    s100FMac_sceneAnalyseBtnsFL

			-attachNone		s100FMac_sceneAnalyseBtnsFL	"top"
			-attachForm		s100FMac_sceneAnalyseBtnsFL	"left"		5
			-attachForm		s100FMac_sceneAnalyseBtnsFL	"right"		5
			-attachForm		s100FMac_sceneAnalyseBtnsFL	"bottom"	5

		s100FMac_sceneAnalyseEditFL;

		formLayout -edit
			-attachPosition s100FMac_b1 "left"  	10 0
			-attachPosition s100FMac_b1 "right"  	0 25

			-attachPosition s100FMac_b2 "left"  	10 25
			-attachPosition s100FMac_b2 "right"  	0 50

			-attachPosition s100FMac_b3 "left"  	10 50
			-attachPosition s100FMac_b3 "right"  	0 75

			-attachControl	s100FMac_b4	"left"		10 	s100FMac_b3
			-attachPosition	s100FMac_b4	"right"		10 100

			-attachForm	s100FMac_b4	"bottom"		10

		s100FMac_sceneAnalyseBtnsFL;

	showWindow $win;

}


// Main Procs  :
//

global proc string s100FM_doSceneAnalyser(string $currentScene, string $currentSceneLN)
{
	// ------------------------------ ANALYSES ------------------------------

	// REFERENCE statistics :
	//
	// REF. VARS :
		string $refTmp[] = `s100findAllReferenceNode` ;
		string $refFiles[] = {};
		// size($refTmp); print $refTmp;

		// names, number of instances, types (char,loc,props..), states (master/subRefs) :
		int $instNums[]={}; string $refTypes[]={}; string $refs[]={}; string $subRefStates[]={};

		// types of assets:
		string $props[]={};	string $chars[]={};	string $locations[]={};	string $locModules[]={};
		string $veges[]={};	string $microVeges[]={};
		string $mattes[]={}; string $cameras[]={};
		string $FLlightRigs[]={}; // Final Layout Light Rigs
		string $unknown[]={};

		// states of files:
		string $noStates[]={};
		string $masters[]={}; string $layouts[]={};	string $anims[]={};	string $animCaches[]={}; string $renders[]={};

		// Analyse = filling up previous vars :
		s100_FMSAanalyseRefNodesOrFiles( 	$refTmp, $refFiles, $instNums, $refTypes, $refs, $subRefStates,
											$props, $chars, $locations, $locModules, $veges, $microVeges, $cameras, $FLlightRigs, $mattes, $unknown,
											$noStates, $masters, $layouts, $anims, $animCaches, $renders
										) ;


	// NON-REFERENCE statistics :
	//
	 // NON-REF. VARS :
	 	string $nonrefTmp[] = {};
		string $nonrefFiles[] = {};
		// size($refTmp); print $refTmp;

		// names, number of instances, types (char,loc,props..), states (master/subRefs) :
		int $nonRef_instNums[]={}; string $nonRef_refTypes[]={}; string $nonRef_refs[]={}; string $nonRef_subRefStates[]={};

		// types of assets:
		string $nonRef_props[]={};	string $nonRef_chars[]={};	string $nonRef_locations[]={};	string $nonRef_locModules[]={};
		string $nonRef_veges[]={};	string $nonRef_microVeges[]={};
		string $nonRef_mattes[]={}; string $nonRef_cameras[]={};
		string $nonRef_FLlightRigs[]={}; // Final Layout Light Rigs
		string $nonRef_unknown[]={};

		// states of files:
		string $nonRef_noStates[]={};
		string $nonRef_masters[]={}; string $nonRef_layouts[]={};	string $nonRef_anims[]={};	string $nonRef_animCaches[]={}; string $nonRef_renders[]={};

	 // Analysing "instances"/file associations (onto non-references): keeping the ones whose actually associated to existing files:
		//string $instances[]={"C_AphidLowOriginal_01_INSTANCE_001"};
		global string $gS100_associatedRefFileTag;
		string $instances[] = s100FMlistAllRefAssociatedObjsInScene();
		$instances = s100_keepingObjsIfReferencedOrNot($instances, 0);
		$instances = s100_keepingObjsIfAssociatedFileExists($instances, 1, $nonrefFiles);
		// debug :
			//$nonrefFiles[0] = "Y:/000_3D_BANK/01_Characters/Aphid/MA_C_AphidLowOriginal_01/MA_C_AphidLowOriginal_01.ma";

		if (size($instances)!=0)
		{
			s100_FMSAanalyseRefNodesOrFiles($nonrefTmp, $nonrefFiles, $nonRef_instNums, $nonRef_refTypes, $nonRef_refs, $nonRef_subRefStates,
										$nonRef_props, $nonRef_chars, $nonRef_locations, $nonRef_locModules, $nonRef_veges, $nonRef_microVeges,
										$nonRef_cameras, $nonRef_FLlightRigs, $nonRef_mattes,
										$nonRef_unknown, $nonRef_noStates, $nonRef_masters, $nonRef_layouts, $nonRef_anims, $nonRef_animCaches, $nonRef_renders
										) ;
        }


	// ------------------------------ PRINT ANALYSES ------------------------------

	// Printing results :
	// ----------------------
	print "\r\n";

	string $result = s100FMSA_printAndReturnString("// --------------------------------- Studio100 Scene Analyser ------------------------------- \r\n// \r\n");
	$result += ("// This file is automatically generated by Studio100's s100FMsceneAnalyser() script.\r\n// Edit at your own risk.\r\n// \r\n");

	$result += s100FMSA_printAndReturnString("// CURRENT SCENE \""+$currentScene+"\" : \r\n");
	$result += s100FMSA_printAndReturnString("// Path : "+$currentSceneLN+" \r\n// \r\n");

	// print REFERENCE STATISTICS :
	$result += s100FMSA_printAndReturnString("// REFERENCE STATISTICS : \r\n"
											+"// -------------------- \r\n//\r\n");

	$result += s100FM_printAnalyse( {},  // no 'instances' here
									$instNums, $refTypes, $refs, $subRefStates,
									$props, $chars, $locations, $locModules,
									$veges, $microVeges,
									$cameras, $FLlightRigs, $mattes,
									$unknown,
									$masters, $layouts, $anims, $animCaches,
									$renders, $noStates
								);

	$result += s100FMSA_printAndReturnString("// \r\n// \r\n// ================================================================================================\r\n// \r\n");

	// print NON-REFERENCE STATISTICS :
	$result += s100FMSA_printAndReturnString("// NON-REFERENCE STATISTICS ('INSTANCE' subRefs and Asset-Associated Xforms) :\r\n"
											+"// ------------------------ \r\n//\r\n");
	if (size($instances)==0)
		$result += s100FMSA_printAndReturnString("// No 'asset-associated' non-ref'd Xforms found in scene. (thru \""+$gS100_associatedRefFileTag+"\" attribute) - skipped.\r\n// \r\n");
	else
	{
		$result += s100FM_printAnalyse( $instances,
									$nonRef_instNums, $nonRef_refTypes, $nonRef_refs, $nonRef_subRefStates,
									$nonRef_props, $nonRef_chars, $nonRef_locations, $nonRef_locModules,
									$nonRef_veges, $nonRef_microVeges,
									$nonRef_cameras, $nonRef_FLlightRigs, $nonRef_mattes,
									$nonRef_unknown,
									$nonRef_masters, $nonRef_layouts, $nonRef_anims, $nonRef_animCaches,
									$nonRef_renders, $nonRef_noStates
								);
    }


	$result += s100FMSA_printAndReturnString("// \r\n// \r\n// ================================================================================================\r\n// \r\n");

	// print NON-REFERENCE STATISTICS :
	$result += s100FMSA_printAndReturnString("// FULL TOTAL : Ref'd/Non-Ref'd STATISTICS (Referenced subRefs and 'INSTANCE'/Asset-Associated Xforms) :\r\n"
											+"// --------------------------------------- \r\n");
	{
		$result += s100FM_printAnalyseTotal (
									// types of assets :
									stringArrayCatenate($props,$nonRef_props), stringArrayCatenate($chars,$nonRef_chars),
									stringArrayCatenate($locations,$nonRef_locations), stringArrayCatenate($locModules,$nonRef_locModules),
									stringArrayCatenate($nonRef_veges,$veges), stringArrayCatenate($nonRef_microVeges,$microVeges),
									stringArrayCatenate($nonRef_cameras,$cameras), stringArrayCatenate($nonRef_FLlightRigs,$FLlightRigs),
                                    stringArrayCatenate($nonRef_mattes,$mattes),
									stringArrayCatenate($nonRef_unknown,$unknown),
									// types of subRefs :
									stringArrayCatenate($nonRef_masters,$masters), stringArrayCatenate($nonRef_layouts,$layouts),
									stringArrayCatenate($nonRef_anims,$anims), stringArrayCatenate($nonRef_animCaches,$animCaches),
									stringArrayCatenate($nonRef_renders,$renders), stringArrayCatenate($nonRef_noStates,$noStates),
									$instances
								);
    }

	$result += s100FMSA_printAndReturnString("// \r\n// --- End of \""+$currentScene+"\" analyse ---\r\n");


	return $result;
}
// end of : s100FMsceneAnalyser()


// Printing/returning results :
//
global proc string s100FM_printAnalyse( string $instances[],
										int $instNums[], string $refTypes[], string $refs[], string $subRefStates[],

										// types of assets:
										string $props[], string $chars[], string $locations[], string $locModules[],
										string $veges[], string $microVeges[],
										string $cameras[], string $FLlightRigs[], string $mattes[],
										string $unknown[],

										// states of files:
										string $masters[], string $layouts[], string $anims[], string $animCaches[],
										string $renders[], string $noStates[]
									)
{
	string $result = "" ;
	string $instancesPart = "";
	string $instancesPartSub = "";
	if (size($instances))
	{
		$instancesPart    = " \t \"INSTANCE\" (transform in scene) ";
		$instancesPartSub = " \t ------------------------------- ";
    }

	$result += s100FMSA_printAndReturnString("// Number\t [ Asset Type ] \t Maya File Names (SubRef type) "+$instancesPart+"\r\n");
	$result += s100FMSA_printAndReturnString("// ------\t----------------\t-------------------------------"+$instancesPartSub+"\r\n");

	if (size($refs))
		for ($r=0; $r<size($refs); $r++)
		{
			string $number = s100FMSA_addPadding($instNums[$r], 4," ",0);
			string $object = "";
			if (size($instances[$r]))
				$object = ("  -> \""+$instances[$r]+"\"");
			$result += s100FMSA_printAndReturnString("// "+$number+" \t [ "+$refTypes[$r]+" ] \t \""+$refs[$r]+"\" ("+$subRefStates[$r]+")"+$object+"\r\n");
        }
	else
		$result += s100FMSA_printAndReturnString("// No reference found here !\r\n");

	$result += s100FM_printAnalyseTotal( // types of assets:
										$props, $chars, $locations, $locModules,
										$veges, $microVeges,
										$cameras, $FLlightRigs, $mattes,
										$unknown,

										// states of files:
										$masters, $layouts, $anims, $animCaches,
										$renders, $noStates,
										{}
									);
	return $result;
	// print "###\r\n"; print $result;
}

global proc string s100FM_printAnalyseTotal( // types of assets:
										string $props[], string $chars[], string $locations[], string $locModules[],
										string $veges[], string $microVeges[],
										string $cameras[], string $FLlightRigs[], string $mattes[],
										string $unknown[],

										// states of files:
										string $masters[], string $layouts[], string $anims[], string $animCaches[],
										string $renders[], string $noStates[],
										string $instances[]
									)
{
	string $result = "" ;
	$result += s100FMSA_printAndReturnString("// \r\n// => "	 +size($chars)+" Character(s), "
															 +size($props)+" Prop(s), \r\n"
													+"//    "+size($locations)+" Location(s), "
															 +size($locModules)+" Location-Module(s), \r\n"
													+"//    "+size($veges)+" Vegetation(s), "
															 +size($microVeges)+" Micro-Vegetation(s), \r\n"
													+"//    "+size($cameras)+" Camera(s), "
															 +size($FLlightRigs)+" FL LightRig(s), "
															 +size($mattes)+" Matte Painting(s), "
															 +size($unknown)+" Unknown asset type(s)...\r\n");
	$result += s100FMSA_printAndReturnString("//  = Total : "
    +( size($chars) + size($props) + size($locations) + size($locModules) + size($veges) + size($microVeges)
	+  size($cameras) + size($FLlightRigs) + size($mattes) + size($unknown))
	+  " Asset(s)\r\n// \r\n" );

	$result += s100FMSA_printAndReturnString("//    Using "+size($masters)+" MASTER/Ref, "+size($layouts)+" LAYOUT, "+size($anims)+" ANIM, \r\n"
											+"//          "+size($animCaches)+" ANIMCACHE, "+size($renders)+" RENDER, "+size($noStates)+" No-Specific-State file(s)\r\n"
											);
	if (size($instances))
		$result += s100FMSA_printAndReturnString("//          "+size($instances)+" non-ref'd INSTANCES, \r\n");

	$result += s100FMSA_printAndReturnString("//         "+"[total : "
											+(size($masters)+size($layouts)+size($anims)+size($animCaches)+size($renders)+size($noStates))+"]\r\n");

	return $result;
}


// return results of analyse of passed file path (considering they are assets)
// ex:
/*
 		string $path01 = "Y:/000_3D_BANK/04_Vegetations/Flower/MA_V_Bindweed_01/MA_V_Bindweed_01_Lo.ma";
		string $refFiles[] = {$path01};
 		s100_analysePassedFiles($refFiles);
*/
global proc string s100_analysePassedFiles(string $refFiles[])
{
	string $referenceNodes[] = {}; // no passed references
	int $instNums[]={};
	string $refTypes[]={};
	string $refs[]={};
	string $subRefStates[]={};

	// types of assets:
	string $props[]={};
	string $chars[]={};
	string $locations[]={};
	string $locModules[]={};
	string $veges[]={};
	string $microVeges[]={};
	string $cameras[]={};
	string $FLlightRigs[]={}; // Final Layout Light Rigs
	string $mattes[]={};
	string $unknown[]={};

	// states of files:
	string $noStates[]={};
	string $masters[]={};
	string $layouts[]={};
	string $anims[]={};
	string $animCaches[]={};
	string $renders[]={};


	s100_FMSAanalyseRefNodesOrFiles(	$referenceNodes, $refFiles, $instNums, $refTypes, $refs, $subRefStates,
										$props, $chars, $locations, $locModules, $veges, $microVeges, $cameras, $FLlightRigs, $mattes, $unknown,
										$noStates, $masters, $layouts, $anims, $animCaches, $renders
									) ;

	// Printing results :
	// ----------------------
	//print $result;
	print "\r\n";

	string $result = s100FMSA_printAndReturnString("// --------------------------------- Studio100 File Path Analyser ------------------------------- \r\n// \r\n");
	$result += ("// This file is automatically generated by Studio100's s100_analysePassedFiles() script.\r\n// Edit at your own risk.\r\n// \r\n");

	$result += s100FMSA_printAndReturnString("// Number\t [ Asset Type ] \t Reference Names (SubRef type) \r\n");
	$result += s100FMSA_printAndReturnString("// ------\t----------------\t-------------------------------\r\n");

	if (size($refFiles))
		for ($r=0; $r<size($refFiles); $r++)
		{
			string $number = $instNums[$r];
			$number = s100FMSA_addPadding($number,4," ",0);
			$result += s100FMSA_printAndReturnString("// "+$number+" \t [ "+$refTypes[$r]+" ] \t \""+$refs[$r]+"\" ("+$subRefStates[$r]+")\r\n");
		}
	else
		$result += s100FMSA_printAndReturnString("// No File Path found here !\r\n");

	$result += s100FMSA_printAndReturnString("// \r\n// => "	 +size($chars)+" Character(s), "
															 +size($props)+" Prop(s), \r\n"
													+"//    "+size($locations)+" Location(s), "
															 +size($locModules)+" Location-Module(s), \r\n"
													+"//    "+size($veges)+" Vegetation(s), "
															 +size($microVeges)+" Micro-Vegetation(s), \r\n"
													+"//    "+size($cameras)+" Camera(s), "
															 +size($FLlightRigs)+" FL LightRig(s), "
															 +size($unknown)+" Unknown Reference Node(s)...\r\n");
	$result += s100FMSA_printAndReturnString("//  = Total : "
    +( size($chars) + size($props) + size($locations) + size($locModules) + size($veges) + size($microVeges)
	+  size($cameras) + size($FLlightRigs) + size($unknown))
	+  " Asset(s)\r\n// \r\n" );

	$result += s100FMSA_printAndReturnString("//    Using "+size($masters)+" MASTER/Ref, "+size($layouts)+" LAYOUT, "+size($anims)+" ANIM, \r\n"
											+"//          "+size($animCaches)+" ANIMCACHE, "+size($renders)+" RENDER, "+size($noStates)+" No-Specific-State file(s)\r\n"
											+"//         "+"[total : "
													+(size($masters)+size($layouts)+size($anims)+size($animCaches)+size($renders)+size($noStates))+"]\r\n");

	$result += s100FMSA_printAndReturnString("// \r\n// --- End of paths analyse ---\r\n");

	return $result;
}


// Real analyse of every refNode : file, file type , asset type, subRef type etc..
//
global proc s100_FMSAanalyseRefNodesOrFiles( string $referenceNodes[], string $refFiles[], int $instNums[],string $refTypes[], string $refs[], string $subRefStates[],
									 // types of assets:
									  string $props[], string $chars[], string $locations[], string $locModules[], string $veges[], string $microVeges[], string $cameras[], string $FLlightRigs[], string $mattes[], string $unknown[],
									 // states of files:
									  string $noStates[], string $masters[], string $layouts[], string $anims[], string $animCaches[], string $renders[]
									)
{
	int $max = max(size($referenceNodes),size($refFiles));
	for ($i=0; $i<$max; $i++) // $rn = $refTmp[3] ; $rn = $referenceNodes[2]
	{
		// if a reference node is passed getting main part of filename used by this reference to analyse it
		//    (types acc. to name convention C/P/V/L...)
		// If not, using passed file :

		string $rn = $referenceNodes[$i];
		string $file = $refFiles[$i]; // Example: "t:/_RD/studio100/reference_files/camera/camera_1pnt.ma"
		if ($rn != "")
			$file = `referenceQuery -filename $rn`;
		else if ($file=="")
		{
			warning ("s100_FMSAanalyseRefNodesOrFiles >> Can not Analyse index \""+$i+"\" of passed referenceNodes and/or Files! Skipped.");
			continue;
        }

		string $filepart = `match "[^/\\]*$" $file`;
		string $usableFilePart = `match "^[^\.]*" $filepart ` ;
		if (startsWith($usableFilePart,"MA_"))
			$usableFilePart = substring($usableFilePart,4,size($usableFilePart)) ;

		// getting rid of last 'subRef' part and getting the "state" (Master/ANIM/LAYOUT/ANIMCACHE/RENDER) at the same time:
		string $curState = "MASTER";
		string $subRefNames[] = s100FM_exportSubRef_returnEveryPossibleSubRef();
		for ($srf in $subRefNames)
		{
			if ( endsWith($usableFilePart,("_"+$srf)) )
			{
				$usableFilePart = substring($usableFilePart,1,(size($usableFilePart)-size($srf)-1)) ;
				$curState = $srf;
				break;
            }
        }
		//print  ("// Reference node \""+$rn+"\" ---> file : \""+$filepart+"\" (\""+$usableFilePart+"\") :\r\n");

		string $buf[];
		int $num = `tokenize $usableFilePart "_" $buf`;
		{
			// is ref already listed? If it is, which index of $refs?
			int $index = s100SAl_firstIndexOfDoubleStringIn2Array( $usableFilePart, $curState, $refs, $subRefStates );

			// if yes : just incrementing its number:
			if ($index != -1 )
			{
				$instNums[$index] += 1;

				// yet : incrementing sizes of lists of types:
				string $curType = strip($refTypes[$index]);
				switch($curType)
				{
					case "Character":
						$chars[size($chars)]=$refs[$index];
					break;
					case "Props":
						$props[size($props)]=$refs[$index];
					break;
					case "Location":
						$locations[size($locations)]=$refs[$index];
					break;
					case "Loc-Module":
						$locModules[size($locModules)]=$refs[$index];
					break;
					case "Vegetation":
						$veges[size($veges)]=$refs[$index];
					break;
					case "Micro-Vege":
						$microVeges[size($microVeges)]=$refs[$index];
					break;
					case "Matte":
						$mattes[size($mattes)]=$refs[$index];
					break;
					case "Camera":
						$cameras[size($cameras)]=$refs[$index];
					break;
					case "FL_LgtRig":
						$FLlightRigs[size($FLlightRigs)]=$refs[$index];
					break;
					case "----??----":
						$unknown[size($unknown)]=$refs[$index];
					break;
					default:
						$unknown[size($unknown)]=$refs[$index];
					break;
                }
            }
			// if not (res: -1), adding it and updating all other infos (type, LOD?...):
			else
			{
				// warning if we could have found the same ref but with another state :
				int $indexRef = s100SAlArr_firstStringIndexInArray($usableFilePart,$refs);
				if ($indexRef!= -1)
					warning ("\""+$rn+"\"'s current state ("+$curState+") is different from previously found one! ("+$subRefStates[$indexRef]+") => counting it as a different asset");

				// Completing lists
				// at index:
				$index = size($refs);

				$refs[$index] = $usableFilePart;
				$instNums[$index] = 1;
				$subRefStates[$index] = $curState;

				// getting type of asset from its name (apart from cameras), filling :
				switch ($buf[0])
				{
					case "C":
						print ("// \""+$rn+"\" is a CHARACTER ("+$curState+")\r\n");
						$refTypes[$index] = "Character ";
						$chars[size($chars)]=$usableFilePart;
					break;
					case "L":
						print ("// \""+$rn+"\" is a LOCATION ("+$curState+")\r\n");
						$refTypes[$index] = " Location ";
						$locations[size($locations)]=$usableFilePart;
					break;
					case "LM":
						print ("// \""+$rn+"\" is a LOCATION MODULE ("+$curState+")\r\n");
						$refTypes[$index] = " Loc-Modl ";
						$locModules[size($locModules)]=$usableFilePart;
					break;
					case "P":
						if ($num==5)
						{
							//warning ("Reference node \""+$rn+"\" is made of 5 parts. Is it a Location or LocationModule ?");
							if ($buf[1]=="LM")
							{
								print ("// \""+$rn+"\" is a LOCATION MODULE PACK ("+$curState+")\r\n");
								$refTypes[$index] = "LocModPack";
								$locModules[size($locModules)]=$usableFilePart;
							}
							else if ($buf[1]=="L")
							{
								print ("// \""+$rn+"\" is a LOCATION PACK ("+$curState+")\r\n");;
								$refTypes[$index] = " Loc-Pack ";
								$locations[size($locations)]=$usableFilePart;
							}
							else
							{
								warning (" Couldn't find what kind of reference \""+$usableFilePart+"\" is ! (not a LOCATION/MODULE PACK it seems)");
								$refTypes[$index] = "----??----";
								$unknown[size($unknown)]=$usableFilePart;
							}
						}
						else
						{
							print ("// \""+$rn+"\" is a PROPS ("+$curState+")\r\n");
							$refTypes[$index] = "  Props   ";
							$props[size($props)]=$usableFilePart;
						}
					break;
					case "V":
						print ("// \""+$rn+"\" is a VEGETATION ("+$curState+")\r\n");
						$refTypes[$index] = "Vegetation";
						$veges[size($veges)]=$usableFilePart;
					break;
					case "MV":
						print ("// \""+$rn+"\" is a MICRO-VEGETATION ("+$curState+")\r\n");
						$refTypes[$index] = "Micro-Vege";
						$microVeges[size($microVeges)]=$usableFilePart;
					break;
					case "M":
						print ("// \""+$rn+"\" is a MATTE-PAINTING ("+$curState+")\r\n");
						$refTypes[$index] = "  Matte   ";
						$mattes[size($mattes)]=$usableFilePart;
					break;
					default: // string $rn = "Ep016_Sq017A_Sc096_CamRN"
					{
						int $camOrLR = 0;
						//warning (" Couldn't find what kind of reference \""+$usableFilePart+"\" is by its name!");
						// Example: "t:/_RD/studio100/reference_files/camera/camera_1pnt.ma"
						if (size($filepart))
						{
							if ($usableFilePart == "FL_LgtRig")
							{
								print ("// \""+$rn+"\" is a Final Layout LIGHT RIG ("+$curState+")\r\n");
								$refTypes[$index] = "FL_LghtRig";
								$FLlightRigs[size($FLlightRigs)]=$usableFilePart;
								$camOrLR = 1;
                            }
							else if (startsWith($filepart, "camera"))
							{
								print ("// \""+$rn+"\" is a CAMERA ("+$curState+")\r\n");
								$refTypes[$index] = "  Camera  ";
								$cameras[size($cameras)]=$usableFilePart;
								$camOrLR = 1;
                            }
                        }
						if ($camOrLR==0)
						{
							print ("// \""+$rn+"\" is NOT a Camera or a FinalLayout LightRig anyway ("+$curState+")\r\n");
							$refTypes[$index] = "----??----";
							$unknown[size($unknown)]=$usableFilePart;
                        }
					}
					break;
				}
            }

			// Updating lists of states now:
			switch($curState)
			{
				case "MASTER":
					$masters[size($masters)]=$refs[$index];
				break;
				case "ANIM":
					$anims[size($anims)]=$refs[$index];
				break;
				case "LAYOUT":
					$layouts[size($layouts)]=$refs[$index];
				break;
				case "ANIMCACHE":
					$animCaches[size($animCaches)]=$refs[$index];
				break;
				case "RENDER":
					$renders[size($renders)]=$refs[$index];
				break;
				default:
					$noStates[size($noStates)]=$refs[$index];
				break;
			}
		}
	}
}


// UTILS :

// unused:
global proc int s100SAlArr_firstStringIndexInArray( string $theString, string $theArray[] )
{
	int $i;
	for ($i=0; $i<size($theArray); $i++)
		if ($theString == $theArray[$i])
			return $i;
	return -1;
}

global proc int[] s100SAlArr_allStringIndexInArray( string $theString, string $theArray[] )
{
	int $indexList[];
  	int $i;
	for ($i=0; $i<size($theArray); $i++)
		if ($theString == $theArray[$i])
			$indexList[size($indexList)] = $i;
	return $indexList;
}

/*
	int $padding = 4 ;
	int $int = 1; string $string = ($int);
	string $string = "235";
	string $charToPad = "0";
	string $charToPad = " ";
	s100FMSA_addPadding($string, $padding, $charToPad, 1)
	s100FMSA_addPadding($string, $padding, $charToPad, 0)
*/
//
global proc string s100FMSA_addPadding(string $string, int $padding, string $charToPad, int $padAsSuffix)
{
	string $res = $string;
	while ($padding > size($res) )
	{
	 	if ($padAsSuffix)
			$res = $res+$charToPad;
		else
			$res = $charToPad+$res;
    }
	return $res;
}

// returns index where string1 is found in Array1 IF string2 is found in Array2 at same index!
// returns -1 if no match is found (could be b/c one of strings are not found at all in arrays or not at the same index:
//
global proc int s100SAl_firstIndexOfDoubleStringIn2Array( string $theString1, string $theString2, string $theArray1[], string $theArray2[] )
{
	int $indexList[] = s100SAlArr_allStringIndexInArray( $theString1, $theArray1 );
  	int $i;
	for ($i=0; $i<size($indexList); $i++)
		if ($theString2 == $theArray2[$indexList[$i]])
			return $indexList[$i];
	return -1;
}


global proc string s100FMSA_printAndReturnString(string $string)
{
	print $string;
	return $string;
}