//     AdvancedSkeleton
//     Version 5.420
//
//
// AdvancedSkeleton is is a collection of Maya tools for doing character setup.
//
// INSTALLATION:
// drag`n`drop the "install.mel" file into Maya (drop in any viewport).
//
// For detailed instructions read the "install.txt" file
//
// Copyright (C)2017 Animation Studios
//
// email: support@animationstudios.com.au
// Last Modified 26/11/2017

global proc AdvancedSkeleton5 ()
{
global int $asBuilding;
global int $asRebuilding;
global int $asFaceIsResetting;
global string $gMainProgressBar;
global string $asDSAltPivot;
global int $asFitModeScriptJobNr4;
global int $asSkipConfirm;
string $evalManagerStats[];
string $m;
string $currentUnitLinear=`currentUnit -q -f`;
$m="Units currently set to: \""+$currentUnitLinear+"\"\nAdvancedSkeleton requires \"cm\".\nClick OK to switch";
if ($currentUnitLinear!="centimeter")
	if (`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`=="Ok")
		currentUnit -l cm;	
if (`asMayaVersionAsFloat`>=2012)
	if (`manipMoveContext -q -ex Move`)
		if (!catchQuiet (`manipMoveContext -q -orientJointEnabled Move`))
			if (`manipMoveContext -q -orientJointEnabled Move`)
				manipMoveContext -e -orientJointEnabled 0 Move;
int $haveRanThisVersion=`optionVar -q asHaveRanThisVersion`;
int $asDock=`optionVar -q asDock`;
if (`exists dockControl`)
	if (!`optionVar -ex asDock`)
		$asDock=1;
int $asWorkspace;
$asBuilding=0;
$asRebuilding=0;
$asFitModeSkip=0;
$asSkipConfirm=0;
$asDSAltPivot="";
int $csm=0;//CorrectiveShapeMode
string $boldFont="smallBoldLabelFont";
if (`asMayaVersionAsFloat`<2012)
	$boldFont="plainLabelFont";
string $asScriptLocation=`asGetScriptLocation`;
string $labels[]={"Root","Chest","Mid","Hip","Foot","Heel","Toes","ToesEnd","BigToe","PinkyToe","LegAim","QToes","Shoulder","Hand","0","1","2","3"};
string $attributes[]={"twist/bendy","inbetween","global","aim","wheel","freeOrient","worldOrient","flipOrient","noMirror","noFlip","noControl","ikLocal","centerBtwFeet","hipSwinger","geoAttach","curveGuide"};
string $geometry,$allFaceGeoString,$eyeR,$eyeL,$upperTeeth,$lowerTeeth,$tongue,$label,
	$eyeBrowL,$eyeBrowR,$eyeLashL,$eyeLashR,$headJoint,$skinCluster;
if (`attributeExists Geometry FaceFitSkeleton`)
	$geometry=`getAttr FaceFitSkeleton.Geometry`;
if (`attributeExists AllFaceGeo FaceFitSkeleton`)
	$allFaceGeoString=`getAttr FaceFitSkeleton.AllFaceGeo`;
if (`attributeExists Eye_R FaceFitSkeleton`)
	$eyeR=`getAttr FaceFitSkeleton.Eye_R`;
if (`attributeExists Eye_L FaceFitSkeleton`)
	$eyeL=`getAttr FaceFitSkeleton.Eye_L`;
if (`attributeExists UpperTeeth FaceFitSkeleton`)
	$upperTeeth=`getAttr FaceFitSkeleton.UpperTeeth`;
if (`attributeExists LowerTeeth FaceFitSkeleton`)
	$lowerTeeth=`getAttr FaceFitSkeleton.LowerTeeth`;
if (`attributeExists Tongue FaceFitSkeleton`)
	$tongue=`getAttr FaceFitSkeleton.Tongue`;
if (`attributeExists HeadJoint FaceFitSkeleton`)
	$headJoint=`getAttr FaceFitSkeleton.HeadJoint`;
if (`attributeExists "SkinCluster" FaceFitSkeleton`)
	$skinCluster=`getAttr FaceFitSkeleton.SkinCluster`;

string $rootLevelObjects[]=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		$csm=1;
int $dsm=0;//DrivingSystemMode
$rootLevelObjects=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists sdkDriverValue $rootLevelObjects[$i]`)
		$dsm=1;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
if ($asFitModeScriptJobNr4!=0)
	if (!`scriptJob -ex $asFitModeScriptJobNr4`)
		$asFitModeScriptJobNr4=0;
if ($asFitModeScriptJobNr4==0)
	$asFitModeScriptJobNr4=`scriptJob -runOnce 1 -e SceneOpened asSceneOpened`;

if (`exists workspaceControl`)
	if (`workspaceControl -q -ex asWorkspaceControl`)
		{
//		workspaceControl -e -clp 1 asWorkspaceControl;
//		workspaceControl -e -clp 0 asWorkspaceControl;
		if (`formLayout -q -ex asFormLayout`)
			deleteUI -control asFormLayout;
		setParent asWorkspaceControl;
		$asWorkspace=1;
		}
if (`exists dockControl`)
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		deleteUI -control AdvancedSkeletonDockControl;
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;

if (!$asWorkspace)
	window -t AdvancedSkeleton5 AdvancedSkeletonWindow;

formLayout asFormLayout;
scrollLayout asScrollLayout;
columnLayout -adj 1 asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Pre" asPreFrameLayout;

columnLayout -adj 0;
	text -fn $boldFont -l "This \"Preparation\" section is optional,";
	text -fn $boldFont -l "but recommended for clean file and workflow";
	separator -h 10;
	text -l "Clean :";
	text -l "Group your model, so that you have 1 top node.";
	text -l "And name this group \"geo\"";
	text -l "Then use the model-cleaner tool:";
	rowLayout -nc 4 -cw4 60 114 51 15;
		separator;
		button -w 72 -l "Model Clean" -c asModelCleaner;
		separator;
		button -w 11 -l "?" -c "asHelpImage asPreModelCleaner";
		setParent..;
	separator -h 10;
	text -l "Then save your cleaned model.";
	separator -h 5;
	text -l "Also, you can check the symmetry:";
	rowLayout -nc 4 -cw4 60 114 51 15;
		separator;
		button -w 72 -l "Model Check" -c asModelCheckerUI;
		separator;
		button -w 11 -l "?" -c "asHelpImage asPreModelChecker";
		setParent..;
	separator -h 5;
	separator -w 262;
	separator -h 5;
	if (`asIsMayaLT`)
		{
		separator -w 262 -h 10	;
		text -fn $boldFont -l "Next is to reference model-file into rig-file.";
		text -fn $boldFont -l "But MayaLT does not have referencing.";
		text -fn $boldFont -l "So, just rig the model-file instead.";
		}
	else
		{
		text -l "Create rig file:";
		rowLayout -nc 4 -cw4 60 114 51 15;
			separator;
			button -w 72 -l "New Scene" -c NewScene;
			separator;
			button -w 11 -l "?" -c "asHelpImage asPreNewScene";
			setParent..;
		text -l "Reference-in the model:";
		rowLayout -nc 4 -cw4 60 114 51 15;
			separator;
			button -w 72 -l "Reference" -c asReferenceModelBrowser;
			separator;
			button -w 11 -l "?" -c "asHelpImage asPreReference";
			setParent..;
		}

setParent asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Body" asBodyFrameLayout;
columnLayout -adj 1;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Fit" asBodyFitFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 1;
				text -h 10 -l "FitSkeletons:";
				setParent..;
			rowLayout -nc 4 -cw4 60 114 49 15;
				separator -st none;
				columnLayout;
					rowLayout -nc 3 -cw3 114 49 15;
						optionMenu asFitFiles;
						button -l "Import" -c asFitSkeletonImport;
						button -w 11 -l "?" -c "asHelpImage asFitSkeletons";
						setParent..;
					text -l " extra limbs:";
					rowLayout -nc 3 -cw3 114 49 15;
						optionMenu asLimbFiles;
						button -l "Import" -c asFitSkeletonLimbsImport;
						button -w 11 -l "?" -c "asHelpImage asFitLimbs";
						setParent..;
					separator -h 5;
					rowLayout -nc 3 -cw3 114 49 15;
						separator -st none;
						button -h 15 -l "Export" -c asFitSkeletonExport;
						button -h 15 -w 11 -l "?" -c "asHelpImage asFitExport";
						setParent..;
					setParent..;
				setParent..;
			separator;
			rowLayout -nc 1;
				text -h 10 -l "Create:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 81 15;
				separator;
 				$gBuffStr = `toolButton -style iconOnly -doubleClickCommand "toolPropertyWindow" -cl toolCluster `;
    		$gBuffStr1 = `jointCtx -image1 "kinJoint.png" -image2 "vacantCell.png" -image3 "vacantCell.png" -scaleCompensateJ 1
        -degreeOfFreedomJ "xyz" -jointOrientationJ 0 0 0 -scaleOrientationJ 0 0 0 -scaleJ 1 1 1 -autoJointOrient "xyz" 
        -secondaryAxisOrient "yup" -jointAutoLimits 0-createIKHandle 0-solverTypeH "ikSCsolver" -autoPriorityH 0
        -snapHandleH 1 -forceSolverH 1 -stickyH "off" -priorityH 1 -weightH 1 -poWeightH 1`;
				if (`asMayaVersionAsFloat`>=2012)
			    toolButton -edit -tool $gBuffStr1 -toolImage1 $gBuffStr1 "kinJoint.png" $gBuffStr;
		    toolButton -edit -tool $gBuffStr1 $gBuffStr;
		    button -w 72 -l "ReSample" -c asFitResample;
				button -w 11 -l "?" -c "asHelpImage asFitCreate";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -h 10 -l "IK-Label:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				optionMenu -cc asUpdateLabelHelp asLabelType;
				for ($label in $labels)
					menuItem -l $label;
				separator;
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator;
				text -fn $boldFont -en 0 asLabelHelp;
				button -w 11 -l "?" -c "asHelpImage asFitLabels";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				button -w 72 -l "Add" -c asAddFitJointLabel;
				button -w 72 -l "Remove" -c asRemoveFitJointLabel;
				setParent..;
			separator -h 10;
			rowLayout -nc 1;
				text -h 10 -l "Attribute:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 81 15;
				separator;
				optionMenu -cc asUpdateAttributeHelp asAttributeType;
				for ($attribute in $attributes)
					menuItem -l $attribute;
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator;
				text -fn $boldFont -en 0 asAttributeHelp;
				button -w 11 -l "?" -c "asHelpImage asFitAttributes";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				button -w 72 -l "Add" -c asAddFitJointAttribute;
				button -w 72 -l "Remove" -c asRemoveFitJointAttribute;
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "Display:";
				setParent..;
			floatSliderGrp -cw3 85 35 20 -l "joint" -field 1 -min 0.01 -max 10.0 -pre 2 -v `jointDisplayScale -q` -dc "jointDisplayScale #1" -cc "jointDisplayScale #1";
			rowLayout -h 18 -nc 4 -cw4 62 78 85 15;
				separator;
				checkBox -l "geometry" -cc asFitGeometry asVisGeo;
				optionMenu -en 0 -cc asChangeVisGeoType asVisGeoType;
					menuItem -l "cylinders" -data 0;
					menuItem -l "boxes" -data 1;
					menuItem -l "spheres" -data 2;
					menuItem -l "bones" -data 3;
				button -w 11 -l "?" -c "asHelpImage asFitDisplayGeometry";
				setParent..;
			floatSliderGrp -h 18 -cw3 85 35 20 -l "gap" -field 1 -min 0.01 -max 1 -pre 2 -v 0.75 asVisGap;
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "pole-vector" -onc "asFitDisplayPoleVector 1" -ofc "asFitDisplayPoleVector 0" asVisPoleVector;
				button -w 11 -l "?" -c "asHelpImage asFitDisplayPoleVector";
				setParent..;
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "joint-orient" -onc "asFitDisplayJointOrient 1" -ofc "asFitDisplayJointOrient 0" asVisJointOrient;
				button -w 11 -l "?" -c "asHelpImage asFitDisplayJointOrient";
				setParent..;
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "joint-axis" -onc "asFitDisplayJointAxis 1" -ofc "asFitDisplayJointAxis 0" asVisJointAxis;
				button -w 11 -l "?" -c "asHelpImage asFitDisplayJointAxis";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -h 10 -l "Placement:";
				setParent..;
			rowLayout -nc 5 -cw5 62 29 40 92 15;
				separator -st none;
				if (`asHaveMeshCenterSnap`)
					{
					text -l "Snap:";
					iconTextCheckBox -w 26 -h 26 -i "snapMeshCenter.png" -cc "snapMode -meshCenter #1" asMeshCenterSnapButton;
					}
				else
					{
					separator -st none;
					separator -st none;
					}
				checkBox -l "Lock middle" -cc asFitModeLockCenterJoints asLockCenterJoints;
				button -w 11 -l "?" -c "asHelpImage asFitPlacement";
				setParent..;
			rowLayout -nc 5 -cw5 62 29 40 92 15;
				separator -st none;
				button -h 15 -l "copy" -c asPlacementCopy;
				separator -st none;
				button -en 0 -h 15 -l "paste" -c asPlacementPaste asPlacementPasteButton;
				setParent..;
			separator;
			rowLayout -nc 1;
				text -h 10 -l "Auto-Orient:";
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator -st none;
				button -w 156 -l FitMode -c asFitMode;
				button -w 11 -l "?" -c "asHelpImage asFitMode";
				setParent..;
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 82 62 81 15;
				separator -st none;
				text -l "Or, manual:";
				button -w 72 -l "Update Now" -c asFitModeManualUpdate;
				button -w 11 -l "?" -c "asHelpImage asFitUpdateNow";
				setParent..;
			separator;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build" asBodyBuildFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 2;
				separator -w 120 -st none;
				checkBox -l "ReBuild Connections" -v 1 asRebuildConnections;
				setParent..;
			rowLayout -nc 4 -cw4 5 85 5 100;
				separator -w 5 -st none;
				button -l "Toggle Fit/Adv" -c asToggleFitAdvancedSkeleton asToggleFitSkeletonButton;
				separator -w 5 -st none;
				button -l "Build AdvancedSkeleton" -c asReBuildAdvancedSkeleton asBuildAdvancedSkeletonButton;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option1)" asBodyDeform1FrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 3 -cw3 100 126 15;
				separator;
				text -l "Skinning:";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinning";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator -st "none";
				columnLayout;
					text -l "Select objects to deform, then:";  
					separator -h 5 -st none;
					button -w 140 -l "+ Select DeformJoints" -c asSelectDeformJoints;
					separator -h 5 -st none;
					button -w 140 -l "Set Smooth Bind Options" -c asSetSmoothBindOptions;
					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option2)" asBodyDeform2FrameLayout;
		columnLayout -adj 1;
			text -l "SkinCage:";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Cage:";
				button -w 60 -l "Create" -c asCreateSkinCage;
				button -w 60 -l "Delete" -c asDeleteSkinCage;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCage";
				setParent..;
			separator -st "none";
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorControlCurves 1 SkinCageCurvesSet";
				button -w 60 -l "Right>Left" -c "asMirrorControlCurves 0 SkinCageCurvesSet";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageMirror";
				setParent..;
			separator -h 5 -st "none";
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select objects to deform, then:";
				setParent..;
			columnLayout;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Copy weights" -c asCopySkin;
					button -w 11 -l "?" -c "asHelpImage asDeformSkinCageCopyWeights";
					setParent..;
				setParent..;
			separator -h 10 -st none;
				rowLayout -nc 4 -cw4 60 165 64 15;
				text -l "Adjust:";
				button -w 162 -l "\"DeformationWidth\"" -c asSkinCurvesToWidth;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageDWidth";
				setParent..;
			rowLayout -nc 3 -cw3 60 165 15;
				separator;
				button -w 162 -l " Add wrist details" -c asAddWristDetails;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageAddWristDetails";
				setParent..;
			rowLayout -nc 3 -cw3 60 165 15;
				separator;
				button -w 162 -l " Create Groin Locators" -c asCreateGroinLocators;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageCreateGroinLocators";
				setParent..;
			rowLayout -nc 3 -cw3 60 165 15;
				separator;
				button -w 162 -l " Adjust Groin area" -c asAdjustGroinArea;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageAdjustGroinArea";
				setParent..;
			separator -h 10 -st none;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Sliders:";
				button -w 60 -l "Create" -c asCreateSliders;
				button -w 60 -l "Delete" -c asDeleteSliders;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageSliders";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Delete SkinCurves" -c asDeleteSkinCurves;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageDeleteCurves";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option3)" asBodyDeform3FrameLayout;
		columnLayout -adj 1;
			text -l "SubWrap:";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Cage:";
				button -w 60 -l "Create" -c asCreateSkinSub;
				button -w 60 -l "Delete" -c asDeleteSkinSub;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapCage";
				setParent..;
			separator -h 5 -st none;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				text -l "Select objects to deform, then:";  
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Wrap selected mesh" -c asWrapSkin;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapWrap";
				setParent..;
			separator;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Detach" -c asSkinSubDetach;
				button -w 60 -l "Attach" -c asSkinSubAttach;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapAttach";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Exclude selected vertices" -c asWrapExlude;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapExlude";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option4)" asBodyDeform4FrameLayout;
		columnLayout -adj 1;
			text -l "SkinLoops:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select EdgeLoop + FK control, then";
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				separator;
				checkBox -v 1 -l "mirror" asCreateSkinLoopCheckBox;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Create New SkinLoop" -c "asCreateSkinLoop 0";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCreate";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Select All SkinLoops" -c asSelectAllSkinLoops;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsSelectAll";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select objects to deform, then:"; 
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Bind" -c "asBindSkinLoops 0";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsBind";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "For cloth over skin, copy weighs.\nSelect cloth, then:"; 
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Copy" -c "asCopySkinLoopWeights";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCopy";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select objects to CutUp, then:"; 
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "CutUp:";
				button -w 60 -l "Create" -c "asBindSkinLoops 1";
				button -w 60 -l "Delete" -c asDeleteCutUp;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCutUp";
				setParent..;
			separator -w 242 -h 5;
			setParent..;
		setParent..;
		frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (DeltaMush)" asBodyDeformDeltaMushFrameLayout;
			columnLayout -adj 1;
				text -l "Delta-Mush:";
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select skinned objects, then:";
				setParent..;
			columnLayout;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Harden weights" -c asHardenWeights;
					button -w 11 -l "?" -c "asHelpImage asDeformDeltaMushHarden";
					setParent..;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Apply Delta Mush" -c asApplyDeltaMush;
					button -w 11 -l "?" -c "asHelpImage asDeformDeltaMushApply";
					setParent..;
			if (`asMayaVersionAsFloat`>=2016)
				{
				rowLayout -nc 3 -cw3 80 165 15;
					separator;
					checkBox -l "use wbDeltaMush" wbDeltaMush;
					setParent..;
				}
				rowLayout -nc 3 -cw3 80 165 15;
					separator;
					text -l "Plugin by: Webber Huang\n<xracz.fx@gmail.com>";
					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Skeleton)" asBodyGeometrySkeletonFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateSkeleton;
				button -w 60 -l "Delete" -c asDeleteSkeleton;
				button -w 11 -l "?" -c "asHelpImage asGeometrySkeletonCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorGeometry Skeleton 1";
				button -w 60 -l "Right>Left" -c "asMirrorGeometry Skeleton 0";
				button -w 11 -l "?" -c "asHelpImage asGeometrySkeletonMirror";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Muscular)" asBodyGeometryMuscularFrameLayout;
		columnLayout -adj 1;
			text -l "Make sure to create Skeleton first.";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Muscular:";
				button -w 60 -l "Create" -c asCreateMuscular;
				button -w 60 -l "Delete" -c asDeleteMuscular;
				button -w 11 -l "?" -c "asHelpImage asGeometryMuscularCreate";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (PolyBoxes)" asBodyGeometryPolyBoxesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreatePolyBoxes;
				button -w 60 -l "Delete" -c asDeletePolyBoxes;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorGeometry Boxes 1";
				button -w 60 -l "Right>Left" -c "asMirrorGeometry Boxes 0";
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesMirror";
				setParent..;
			separator -h 10;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Boolean:";
				button -w 60 -l "Create" -c asCreateBoolean;
				button -w 60 -l "Delete" -c asDeleteBoolean;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesBoolean";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Warp:";
				button -w 60 -l "Create" -c asCreateWarp;
				button -w 60 -l "Delete" -c asDeleteWarp;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesWarp";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Mannequin)" asBodyGeometryMannequinFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateMannequin;
				button -w 60 -l "Delete" -c asDeleteMannequin;
				button -w 11 -l "?" -c "asHelpImage asGeometryMannequinCreate";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -m 1 -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Retopology)" asBodyGeometryRetopologyFrameLayout;
		columnLayout -adj 1;
			text -l "Make sure to create SkinCage or SkinSub first.";
			separator -st none -h 5;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select Hi-res model, then:";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Retopo:";
				button -w 60 -l "Create" -c asCreateRetopo;
				button -w 60 -l "Delete" -c asDeleteRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoCreate";
				setParent..;
			separator -st none -h 5;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Make any tweaks needed, then:";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Update selected" -c asUpdateRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoUpdate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorRetopo 1";
				button -w 60 -l "Right>Left" -c "asMirrorRetopo 0";
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoMirror";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Normal Map" -c asNormalMapRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoNormalMap";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Bind:";
				button -w 60 -l "Bind" -c asBindRetopo;
				button -w 60 -l "UnBind" -c asUnBindRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoBind";
				setParent..;

			separator -h 15;
			rowLayout -nc 2 -cw2 130 100;
				separator -st none;
				text -h 20 -l "Face:";
				setParent..;
			rowLayout -nc 2 -cw2 90 100;
				separator -st none;
				optionMenu asCreateFaceRetopoOptionMenu;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
//				text -l "Guides:";
				separator -st none;
				button -w 60 -l "Create" -c asCreateFaceRetopo;
				button -w 60 -l "Delete" -c "asDeleteFaceRetopo 0";
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoCreate";
				setParent..;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Make any tweaks needed, then:";
				setParent..;
			separator -h 5 -st none;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Match guides" -c asMatchGuidesFaceRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoMatch";
				setParent..;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Tweak further if needed.";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Connect Body" -c asConnectBodyFaceRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoConnect";
				setParent..;
			separator -h 10 -st none;
			rowLayout -nc 2 -cw2 90 100;
				text -l "Eyes:";
				optionMenu asCreateFaceRetopoEyeBallOptionMenu;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st none;
				button -w 60 -l "Create" -c asCreateEyesFaceRetopo;
				button -w 60 -l "Delete" -c "delete headTopologyEyes";
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoEyesCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "bind eyes" -c asBindEyesFaceRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoEyesBind";
				setParent..;

			separator -h 10 -st none;
			rowLayout -nc 2 -cw2 90 100;
				text -l "Teeth:";
				optionMenu asCreateFaceRetopoTeethOptionMenu;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st none;
				button -w 60 -l "Create" -c asCreateTeethFaceRetopo;
				button -w 60 -l "Delete" -c "delete headTopologyTeeth";
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoTeethCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "bind teeth" -c asBindTeethFaceRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoTeethBind";
				setParent..;

			separator -h 10 -st none;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Face rig prep" -c asFaceRigPrepRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoPrep";
				setParent..;
			separator -h 5 -st none;
			text -l "You can now now Build Face Setup";
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Cluster Controls" asBodyClusterControlsFrameLayout;
		columnLayout -adj 0;
			text -l "Create:";
			separator -st none -h 5;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout -adj 0;
					text -l "First create a SoftMod:";
					iconTextButton -w 35 -h 35 -i "softMod.png" -c SoftModTool;
					text -l "Then:";
					rowLayout -nc 2;
						checkBox -l "mirror" -v 1 -onc "checkBox -e -v 0 asClusterControlMiddleCheckBox" asClusterControlMirrorCheckBox;
						checkBox -l "Middle Controller" -v 0 -onc "checkBox -e -v 0 asClusterControlMirrorCheckBox" asClusterControlMiddleCheckBox;
						setParent..;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Create Control from SoftMod" -c "asConvertSoftModToControl";
						button -w 11 -l "?" -c "asHelpImage asClusterControlCreate";
						setParent..;
					setParent..;
				setParent..;
			separator -st none -h 10;
			text -l "Edit:";
			separator -st none -h 5;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout -adj 0;
					button -w 190 -l "Paint weights for selected Control" -c asPaintClusterControlWeights;
					setParent..;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Motion Capture" asBodyMotionCaptureFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Skeleton:";
				button -w 60 -l "Create" -c asCreateMoCap;
				button -w 60 -l "Delete" -c asDeleteMocap;
				button -w 11 -l "?" -c "asHelpImage asMotionCaptureCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "FK/IK:";
				button -w 60 -l "Set All FK" -c asSetAllFK;
				button -w 60 -l "Default" -c "asGoToBuildPose bodySetup";
				button -w 11 -l "?" -c "asHelpImage asMotionCaptureAllFK";
				setParent..;
			rowLayout -nc 5 -cw5 60 60 38 64 15;
				text -l "Bvh file:";
				button -w 60 -l "Read" -c asReadBVH;
				floatField -w 38 -v 120 -pre 1 -ann "set frames per second (in bvh file)" asBVHfps;
				button -w 60 -l "Delete" -c asDeleteBHV;
				button -w 11 -l "?" -c "asHelpImage asMotionCaptureReadBvh";
				setParent..;
			separator;
			rowLayout -nc 4 -cw4 60 60 38 100;
				separator -st none;
				columnLayout;
					text -l "Then constrain the Bvh skeleton,";
					text -l "to the MoCap skeleton.";
					separator -h 5 -st none;
					text -l "Or try auto-connect";
					setParent..;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st none;
				button -w 60 -l "Connect" -c asAutoMapMocap;
				button -w 60 -l "Disconnect" -c asDeleteMocapMap;
				button -w 11 -l "?" -c "asHelpImage asMotionCaptureConnect";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Game Skeleton" asBodyGameSkeletonFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Unreal:";
				button -w 60 -l "Create" -c asCreateGameSkeletonUnreal;
				button -w 60 -l "Delete" -c asDeleteGameSkeletonUnreal;
				button -w 11 -l "?" -c "asHelpImage asGameSkeletonCreate";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Transfer Skinning" -c asTransferSkinUnreal;
				button -w 11 -l "?" -c "asHelpImage asGameSkeletonTransfer";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Control Curves" asBodyControlCurvesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorControlCurves 1 ControlSet";
				button -w 60 -l "Right>Left" -c "asMirrorControlCurves 0 ControlSet";
				button -w 11 -l "?" -c "asHelpImage asControlCurvesMirror";
				setParent..;
			separator -h 10;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Scale:";
				floatField -v 1 -ann "set scale-factor" ScaleCCFloatField;
				button -w 60 -l "Scale" -c "asScaleControlCurves";
				button -w 11 -l "?" -c "asHelpImage asControlCurvesScale";
				setParent..;
			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Swap:";
				text -l "First select Control(s) to replace,";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Then select (add) any custom curve,";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Then:";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st "none";
				button -w 162 -l "Swap Curve" -c asSwapCurve;
				button -w 11 -l "?" -c "asHelpImage asControlCurvesSwap";
				setParent..;
			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Color:";
				int $cellHeight = 17, $cellWidth = 10;
				int $rows = 2, $columns = 16;
				palettePort -w ($columns * $cellWidth) -h ($rows * $cellHeight) -dim $columns $rows -ced 0 -td 1 asCurveColorPalettePort;
				float $colorComponentArray[];
				palettePort -edit -rgbValue 0 0 0 0 asCurveColorPalettePort;
				for ($index = 1; $index <= 31; $index++) {
					$colorComponentArray = `colorIndex -query $index`;
					palettePort -edit -rgbValue $index
						$colorComponentArray[0]
						$colorComponentArray[1]
						$colorComponentArray[2]
						asCurveColorPalettePort;
						}
				if (`asMayaVersionAsFloat`>=2014)
					palettePort -e -ced 1 asCurveColorPalettePort;
				setParent..;
			rowLayout -nc 3 -cw3 60 90 50;
				separator;
				optionMenu asCurveColorTypeOptionMenu;
					menuItem -l "FK";
					menuItem -l "IK";
					menuItem -l "FKIK";
					menuItem -l "Bend";
					menuItem -l "Selected";
					menuItem -l "*All";
					menuItem -l "Face:A";
					menuItem -l "Face:B";
					menuItem -l "Face:C";
					menuItem -l "Face:Aim";
					menuItem -l "Face:Teeth";
					menuItem -l "Face:Tongue";
					menuItem -l "Face:Region";
					menuItem -l "Face:Squash";
					menuItem -l "Face:Custom";
				optionMenu asCurveColorSideOptionMenu;
					menuItem -l "Right";
					menuItem -l "Left";
					menuItem -l "Middle";
					menuItem -l "*All";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st "none";
				button -w 162 -l "Set Color" -c asSetCurveColor;
				button -w 11 -l "?" -c "asHelpImage asControlCurvesColor";
				setParent..;

			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Re-use:";
				text -l "This will print in ScriptEditor:";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				columnLayout;
					text -l "commands to set control curves to";
					text -l "current shapes and colors.";
					button -w 162 -l "Script Editor" -c "ScriptEditor;";
					button -w 162 -l "Clear History" -c "scriptEditorInfo -clearHistory";
					rowLayout -nc 3;
						checkBox -l "shape" -v 1 asControlCurvesReUseShapeCheckBox;
						checkBox -l "color" -v 1 asControlCurvesReUseColorCheckBox;
						checkBox -l "`catch`" asControlCurvesReUseCatchCheckBox;
						setParent..;
					checkBox -l "SkinCurves" asControlCurvesReUseSkinCurvesCheckBox;
					button -w 162 -l "Print Commands" -c asControlCurvesPrintInfo;
					setParent..;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Control Mesh" asBodyControlMeshFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 2 -cw2 60 100;
				columnLayout -adj 0;
					text -l "Create:";
					setParent..;	
				columnLayout -adj 0;
					text -l "First select the poly-faces to use";
					text -l "Then select (add) the control,";
					text -l "Then:";
					checkBox -v 1 -l "mirror" asCreateControlMeshMirrorCheckBox;
					rowLayout -nc 3 -cw3 100 64 15;
						button -w 162 -l "Create ControlMesh" -c asCreateControlMesh;
						button -w 11 -l "?" -c "asHelpImage asControlMeshCreate";
						setParent..;
					separator -h 5;
					text -l "Or, select mesh and auto-create";
					rowLayout -nc 3 -cw3 100 64 15;
						button -w 162 -l "Create ControlMeshes" -c asCreateControlMeshes;
						button -w 11 -l "?" -c "asHelpImage asControlMeshesCreate";
						setParent..;
					separator -h 5;
					text -l "IK controls & driving-systems";
					rowLayout -nc 3 -cw3 100 64 15;
						button -w 162 -l "Create IK ControlMeshes" -c asCreateIKControlMeshes;
						button -w 11 -l "?" -c "asHelpImage asControlMeshesCreateIK";
						setParent..;
					setParent..;	
				setParent..;	

			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				columnLayout -adj 0;
					text -l "Delete:";
					setParent..;	
				columnLayout -adj 0;
					button -w 162 -l "Delete Selected" -c asDeleteControlMesh;
					separator -h 5;
					button -w 162 -l "Delete All" -c asDeleteAllControlMesh;
					setParent..;
				setParent..;
			setParent..;
		setParent..;	

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Partial Joints" asBodyPartialJointsFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreatePartialJoints;
				button -w 60 -l "Delete" -c asDeletePartialJoints;
				button -w 11 -l "?" -c "asHelpImage asPartialJoints";
				setParent..;	
			setParent..;	
		setParent..;	

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Joint Groups" asBodyJointGroupFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateJointGroups;
				separator;
				button -w 11 -l "?" -c "asHelpImage asJointGroups";
				setParent..;	
			setParent..;	
		setParent..;	

setParent asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Face" asFaceFrameLayout;
columnLayout -adj 1 asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Pre" asFacePrepFrameLayout;
		columnLayout -adj 0;
			button -l "Create Face FitSkeleton Node" -c asCreateFaceFitSkeleton;
			rowLayout -nc 2 -cw2 130 15;
				text -l "Then move and scale this:";
				button -w 15 -l "?" -c "asHelpImage fitFaceSkeletonNode";
				setParent..;
			text -l "lower circle just under the character`s jaw";
			text -l "upper circle just above the character`s head";
			separator -h 10;
			text -l "Choose Geometry";
			text -l " * = Optional";
			rowLayout -nc 2 -cw2 120 100;
				button -w 120 -l "Face" -c "asChooseInput asFaceGeometryTextField";
				textField -w 100 -ed 0 -tx $geometry asFaceGeometryTextField;
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				button -w 120 -l "All Head" -c "asChooseInput asFaceAllFaceGeoTextField";
				textField -w 100 -ed 0 -tx $allFaceGeoString asFaceAllFaceGeoTextField;
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				button -w 120 -l "Right Eye" -c "asChooseInput asFaceEye_RTextField";
				textField -w 100 -ed 0 -tx $eyeR asFaceEye_RTextField;
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				button -w 120 -l "Left Eye" -c "asChooseInput asFaceEye_LTextField";
				textField -w 100 -ed 0 -tx $eyeL asFaceEye_LTextField;
				setParent..;
			separator -h 7 -st none;
			rowLayout -nc 3 -cw3 120 100 10;
				button -w 120 -l "Upper Teeth" -c "asChooseInput asFaceUpperTeethTextField";
				textField -w 100 -ed 0 -tx $upperTeeth asFaceUpperTeethTextField;
				text -l "*";
				setParent..;
			rowLayout -nc 3 -cw3 120 100 10;
				button -w 120 -l "Lower Teeth" -c "asChooseInput asFaceLowerTeethTextField";
				textField -w 100 -ed 0 -tx $lowerTeeth asFaceLowerTeethTextField;
				text -l "*";
				setParent..;
			rowLayout -nc 3 -cw3 120 100 10;
				button -w 120 -l "Tongue" -c "asChooseInput asFaceTongueTextField";
				textField -w 100 -ed 0 -tx $tongue asFaceTongueTextField;
				text -l "*";
				setParent..;
			separator -h 10;
			checkBox -m 1 -l advanced -onc "columnLayout -e -m 1 asFaceAdvancedinputColumnLayout" -ofc "columnLayout -e -m 0 asFaceAdvancedinputColumnLayout";
			columnLayout -m 0 asFaceAdvancedinputColumnLayout;
				separator -h 15;
				text -l "For creating FaceSetup,";
				text -l "without AdvancedSkeleton body rig:";
				separator -h 5;
				rowLayout -nc 2 -cw 1 120;
					button -w 120 -l "Choose Head Joint" -c "asChooseInput asFaceHeadJointTextField";
				textField -w 100 -ed 0 -tx $headJoint asFaceHeadJointTextField;
					setParent..;
				text -l "SkinCluster found on Face Geo:";
				textField -w 150 -m 1 -tx $skinCluster asFaceSkinClusterTextField;

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Fit" asFaceFitFrameLayout;
		columnLayout -adj 0 asFaceFitColumnLayout;
		$checkValue=`objExists FaceFitEyeBall`;
		string $sections[]={"EyeBall"};
		for ($c=0;$c<size($sections);$c++)
			{
			rowLayout -nc 7;
				button -w 100 -l $sections[$c] -c ("asBuildFit"+$sections[$c]);
				separator -w 5 -st none;
				checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc ("asFaceDeleteFromCheckBox "+$sections[$c]) ("asFaceFit"+$sections[$c]);
				button -w 15 -l "?" -c ("asHelpImage fitFace"+$sections[$c]);
				separator -w 10 -st none;
				separator -w 35 -st none;
				button -l "hide" -c ("setAttr FaceFit"+$sections[$c]+".v (!`getAttr FaceFit"+$sections[$c]+".v`)");
				setParent..;
			}
		separator -st none -h 10;
		text -l "Select edgeLoops, then:";
		$sections={"EyeLid","EyeLidDroopy","Lip","SmileCrease","SmileFold","EyeBrowInner","EyeBrowOuter","EyeBrowMid1","EyeBrowMid2","EyeBrowMid3","EyeBrowMiddle",
			"ForeHead","JawPivot","JawCorner","Jaw","Throat","Cheek","CheekRaiser","Nose","NoseUnder","NoseCorner","NoseSide","NoseMiddle","Nostril",
			"Tongue","TeethCollider"};
		string $parts[]={"Outer","Main","Inner"};
		int $upAndLo[]={1,1,1};
		int $mainAndOuter[]={1,0,1};
		int $isSphere[]={0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0};
		int $hideable;
		for ($c=0;$c<size($sections);$c++)
			{
			$hideable=0;
			if (`gmatch $sections[$c] "*Inner"`)
				$hideable=1;
			if ($sections[$c]=="EyeLidDroopy")
				{
				frameLayout -mw 25 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional extra EyeLid controls:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitExtraEyeLidFrameLayout;
					columnLayout;
				}
			if ($sections[$c]=="Lip" || $sections[$c]=="ForeHead" || $sections[$c]=="Tongue" || $sections[$c]=="EyeBrowInner")
				{
				setParent asFaceFitColumnLayout;
				separator -st none -h 10;
				}
			if ($sections[$c]=="SmileCrease")
				{
				frameLayout -mw 25 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional SmileCrease controls:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitSmileCreaseFrameLayout;
					columnLayout;
//				separator -st none -h 10;
					text -l "Select edges then:";
				}
			if ($sections[$c]=="EyeBrowInner" || $sections[$c]=="JawPivot")
				{
//				separator -st none -h 10;
				text -l "Select 1 vertex, then:";
				}
			if ($sections[$c]=="EyeBrowMid1")
				{
				frameLayout -mw 25 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional extra EyeBrow controls:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitExtraEyeBrowFrameLayout;
					columnLayout;
				}
			if ($sections[$c]=="ForeHead")
				{
				text -l "Select 3 vertices, then:";
				$hideable=1;
				}
			if ($sections[$c]=="NoseSide")
				{
				frameLayout -mw 25 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional extra Nose controls:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitExtraNoseFrameLayout;
					columnLayout;
				}
			if ($sections[$c]=="TeethCollider")
				$hideable=1;
			if ($sections[$c]=="Tongue")
				{
				frameLayout -mw 16 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional tongue & teeth controls:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitTongueTeethFrameLayout;
					columnLayout;
					text -l "(No selection needed)";
				}
			for ($a=0;$a<size($parts);$a++)
				{
				if ($mainAndOuter[$c]==0) $parts[$a]="";
				else $parts={"Outer","Main","Inner"};
				if ($sections[$c]=="EyeBrow" && $parts[$a]=="Inner")
					continue;
				if ($mainAndOuter[$c]==0 && $a>0)
					continue;
				$checkValue=`objExists ("FaceFit"+$sections[$c]+$parts[$a])`;
				rowLayout -nc 7;
					button -w 100 -l ($sections[$c]+$parts[$a]) -c ("asCreateFaceFit "+$sections[$c]+" \""+$parts[$a]+"\" "+$upAndLo[$c]+" "+$mainAndOuter[$c]+" "+$isSphere[$c]);
					popupMenu;
						menuItem -l "re-select" -c ("asFaceReSelect "+$sections[$c]+" \""+$parts[$a]+"\"");//since $parts can be blank
					separator -w 5 -st none;
					checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc ("asFaceDeleteFromCheckBox "+$sections[$c]+$parts[$a]) ("asFaceFit"+$sections[$c]+$parts[$a]);
					button -w 15 -l "?" -c ("asHelpImage fitFace"+$sections[$c]+$parts[$a]);
					if ($sections[$c]!="TeethCollider")
						separator -w 10 -st none;
					if ($parts[$a]=="Inner")
						button -w  35 -l "assist" -c ("asFaceAssist "+$sections[$c]);
					else if ($sections[$c]!="TeethCollider")
						separator -w 35 -st "none";
					if ($hideable || (($sections[$c]=="EyeLid" || $sections[$c]=="Lip") && $parts[$a]=="Inner"))
						button -l "hide" -c ("setAttr FaceFit"+$sections[$c]+$parts[$a]+".v (!`getAttr FaceFit"+$sections[$c]+$parts[$a]+".v`)");
					setParent..;
				}
			}
		separator -h 18 -w 242;
		setParent asFaceFitColumnLayout;
			separator -st none -h 10;
			columnLayout;
				$checkValue=`objExists FaceFitJawCurves`;
				rowLayout -nc 4 -cw4 100 5 20 15;
					button -w 100 -l "Jaw Curves" -c asFaceFitJawCurves;
					separator -w 5 -st none;
					checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc "asFaceDeleteFromCheckBox JawCurves" asFaceFitJawCurves;
					button -w 15 -l "?" -c "asHelpImage fitFaceJawCurves";
					setParent..;
				rowLayout -nc 2 -cw2 129 15;
					text -l "Tweak curves";
					button -w 15 -l "?" -c "asHelpImage fitFaceJawCurvesTweak";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build" asFaceBuildFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 25 60 35 100;
				separator -w 25 -st none;
				button -m 0 -w 60 -l "Delete Adv" -c asDeleteAdvancedFace asDelteAdvFaceButton;
				separator -w 35 -st none;
				checkBox -m 0 -l "Keep build pose" -v 1 asFaceKeepBuildPose;
				setParent..;
			rowLayout -nc 4 -cw4 5 85 20 100;
				separator -w 5 -st none;
				button -l "Toggle Fit/Adv" -c asToggleFitFace asToggleFitFaceButton;
				separator -w 20 -st none;
				button -l "Build AdvancedFace" -c asBuildAdvancedFace asBuildAdvancedFaceButton;
				setParent..;
			setParent..;
		setParent..;

	string $stepBuildText[];
	$stepBuildText[size($stepBuildText)]="";
	$stepBuildText[size($stepBuildText)]="Prep";
	$stepBuildText[size($stepBuildText)]="CtrlBox";
//	$stepBuildText[size($stepBuildText)]="FaceTargets";
	$stepBuildText[size($stepBuildText)]="EyeBall";
	$stepBuildText[size($stepBuildText)]="EyeLid";
	$stepBuildText[size($stepBuildText)]="EyeBrow";
	$stepBuildText[size($stepBuildText)]="Lip";
//	$stepBuildText[size($stepBuildText)]="LipFalloffDistanceCenter";
//	$stepBuildText[size($stepBuildText)]="LipFalloffDistanceSide";
	$stepBuildText[size($stepBuildText)]="LipFalloff";
	$stepBuildText[size($stepBuildText)]="Jaw";
	$stepBuildText[size($stepBuildText)]="JawFinish";
	$stepBuildText[size($stepBuildText)]="Nose";
	$stepBuildText[size($stepBuildText)]="SmileCrease";
	$stepBuildText[size($stepBuildText)]="SmileFold";
	$stepBuildText[size($stepBuildText)]="Cheek";
	$stepBuildText[size($stepBuildText)]="Tongue";
	$stepBuildText[size($stepBuildText)]="Regions";
	$stepBuildText[size($stepBuildText)]="EyeAim";
	$stepBuildText[size($stepBuildText)]="UpperLowerFace";
	$stepBuildText[size($stepBuildText)]="Finish";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build ..." asFaceStepBuildFrameLayout;
		columnLayout -adj 0;
			text -l "Step Build:";
			text -fn $boldFont -l "Use this section if normal Build had errors,";
			text -fn $boldFont -l "or to modify the build result.";
			separator -h 5;
			for ($i=1;$i<size($stepBuildText);$i++)
				{
				rowLayout -nc 2 -cw2 159 80 ("asStepBuildRowLayout"+$i);
					text -l ($i+" : "+$stepBuildText[$i]) ("stepBuild"+$i+"Text");
					button -w 80 -h 15 -l "Build" -c ("asFace"+$stepBuildText[$i]+";asStepBuildComplete "+$i+";");
					setParent..;

				if ($stepBuildText[$i]=="EyeBall")
					text -l "   You can now test eye rotation.";

				if ($stepBuildText[$i]=="CtrlBox")
					text -l "   You can postition the CtrlBox.";

				if ($stepBuildText[$i]=="EyeLid")
					{
					text -l "   You can now test blink & fleshy-eye.";
					}
				if ($stepBuildText[$i]=="EyeBrow")
					{
					text -l "   If the weighting does not work well,";
					rowLayout -nc 3 -cw3 10 20 200;
						separator -st none;
						text -l "try:";
						button -l "alternative weighting" -c asEyeBrowSkinning2;
						setParent..;
					}
				if ($stepBuildText[$i]=="LipFalloff")
					{
					text -l "   You can now test the controller.";
					text -l "   If the area is to small or too big,";
					rowLayout -nc 7 -cw 1 10 ;
						separator -st none;
						text -l "Outside:";
						intField -w 22 -v 3 -min 0 -cc ("setAttr FaceFitSkeleton.vtxsFromLipToNose `intField -q -v vtxsFromLipToNoseIntField`") vtxsFromLipToNoseIntField;
						text -l "Inside:";
						intField -w 22 -v 2 -min 0 lipFalloffInsideMouthIntField;
						button -w 40 -h 12 -l "test" -c "createNode -n asFaceLipFalloffTest transform;asFaceLipFalloff;";
						button -w 40 -h 12 -l "update" -c "asFaceLipFalloff;print \"// Updated\\n\"";
						setParent..;
					}
				if ($stepBuildText[$i]=="Jaw")
					{
					text -l "   Scrub time-slider to check Jaw.\n";
					rowLayout -nc 2 -cw2 200 80;
						text -al left -l "   1: Move and rotate the jaw-control,\n       to the \"mouth-open\" shape.\n       (do this at frame 30)";
						setParent..;
					separator -h 5;
					rowLayout -nc 2 -cw2 200 80;
						text -al left -l "   2:Edit curves to define weighting.\n       (do this at frame 0)";
						button -w 15 -h 12 -l "?" -c "asHelpImage fitFaceJawCurvesTweak";
						setParent..;
					rowLayout -nc 2 -cw2 190 80;
						text -l "   3:Set number of weight-smooths";
						intField -w 35 -v 50 asFaceNumJawSmooths;
						setParent..;
					rowLayout -nc 2 -cw2 180 80;
						text -l "       After any adjustments, then:";
						button -w 40 -h 12 -l "update" -c "asFaceWeightLips;asFaceUpdateJawCurvesWeights;print \"// Updated\\n\"";
						setParent..;
					rowLayout -nc 2 -cw2 190 80;
						text -l "   4:You can also paint Jaw-weights:";
						shelfButton -w 34 -h 34 -ann "Paint weights on smooth bound skins." -l "Paint Skin Weights Tool" -dcc "ArtPaintSkinWeightsTool;toolPropertyWindow"
			        -image paintSkinWeights.png -image1 paintSkinWeights.png -style "iconOnly" -c "ArtPaintSkinWeightsTool;";
						setParent..;
					}
				if ($stepBuildText[$i]=="SmileFold")
					{
					text -l "   You can move the controller,";
					text -l "   and adjust the \"dropoffDistance\" attributes";
					}
				if ($stepBuildText[$i]=="Cheek")
					{
					text -l "   You can move the controller,";
					text -l "   and adjust the \"influence\" attributes";
					}
				if ($stepBuildText[$i]=="UpperLowerFace")
					{
					rowLayout -nc 2 -cw2 190 80;
						text -l "   You can number of weight-smooths";
						intField -w 35 -v 6 asFaceNumUpperLowerFacemooths;
						setParent..;
					rowLayout -nc 2 -cw2 180 80;
						text -l "       After any adjustments, then:";
						button -w 40 -h 12 -l "update" -c "asFaceUpperLowerFace;print \"// Updated\\n\"";
						setParent..;
					}
				separator -w 240;
				}

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Tweaks" asFaceTweaksFrameLayout;
		columnLayout;
		text -al left -l "After Face Build,\ntest moving the controllers,\nand modify the \"influence\" attributes if needed.";
		separator -h 5;
		text -al left -l "To save modified values,\nright-click on the face:\"Go to Build Pose\" button,\nand choose \"set build pose\".";
		separator -h 10;
		rowLayout -nc 2 -cw2 170 80;
			text -al left -l "Then paint skinweights if needed:";
			shelfButton -w 34 -h 34 -ann "Paint weights on smooth bound skins." -l "Paint Skin Weights Tool" -dcc "ArtPaintSkinWeightsTool;toolPropertyWindow"
				-image paintSkinWeights.png -image1 paintSkinWeights.png -style "iconOnly" -c "ArtPaintSkinWeightsTool;";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EyeBalls" asFaceEyeBallsFrameLayout;
		columnLayout;
		text -l "Select edgeLoops, then:";
		separator -h 5;
		rowLayout -nc 4;
			button -w 100 -l "Right Pupil" -c ("asEyeBallsChooseInput asFacePupil_RTextField");
			textField -w 100 -ed 0 asFacePupil_RTextField;
			separator -w 24 -st none;
			button -w 11 -l "?" -c "asHelpImage asEyeBallsPupil";
			setParent..;
		rowLayout -nc 4;
			button -w 100 -l "Right  Iris" -c ("asEyeBallsChooseInput asFaceIris_RTextField");
			textField -w 100 -ed 0 asFaceIris_RTextField;
			separator -w 24 -st none;
			button -w 11 -l "?" -c "asHelpImage asEyeBallsIris";
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 4;
			button -w 100 -l "Left Pupil" -c ("asEyeBallsChooseInput asFacePupil_LTextField");
			textField -w 100 -ed 0 asFacePupil_LTextField;
			setParent..;
		rowLayout -nc 4;
			button -w 100 -l "Left  Iris" -c ("asEyeBallsChooseInput asFaceIris_LTextField");
			textField -w 100 -ed 0 asFaceIris_LTextField;
			setParent..;
		separator -h 10;
		checkBox -l "include Iris-size attribute" asFaceIrisCheckBox;
		rowLayout -nc 3;
			button -w 100 -l "Setup EyeBall" -c asFaceEyeBallBuild;
			separator -w 50 -st none;
			button -h 15 -w 50 -l "Edit SDK" -c asFaceEditEyeBallSDK;
			setParent..;
		setParent..;

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EyeBrows" asFaceBrowsFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 2 -cw2 20 100;
				separator -st none -w 15;
				columnLayout;
					text -l "Select EyeBrows, then:";
					separator -h 5;
					button -w 150 -l "SkinWeights to face" -c "asFaceCopyWeightsToFace";
					text -l "or:";
					button -w 150 -l "WrapDeform to face" -c "asFaceWrapDeformToFace";
					text -l "or:";
					button -w 150 -l "WireDeform to face" -c "asFaceWireDeformToFace";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EyeLashes" asFaceLashesFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 2 -cw2 20 100;
				separator -st none -w 15;
				text -l "Select EyeLashes, then:";
				setParent..;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Attach" -c "asFaceAttachEyeLashes";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " DeltaMush" asFaceDeltaMushFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Create DeltaMush" -c "asFaceDeltaMush";
				setParent..;
			separator -st "none" -h 15;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Select eyeLidArea" -c "select eyeLidArea";
				setParent..;
			separator -st "none" -h 5;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Select eyeBrowArea" -c "select eyeBrowArea";
				setParent..;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Select lipArea" -c "select lipArea";
				setParent..;
			separator -st "none" -h 15;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "zero weight selected" -c "evalEcho \"percent -v 0 asFaceDeltaMush\";";
				setParent..;

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " HeadSquash" asFaceSquashFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Create HeadSquash" -c "asAdvancedSquash";
				setParent..;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Optimize HeadSquash" -c "asOptimizeSquash";
				setParent..;
			text -fn $boldFont -l "To make sure only head";
			text -fn $boldFont -l "and no other parts of body gets squashed";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " CustomControls" asFaceCustomControlsFrameLayout;
		rowLayout -nc 2;
			separator -w 25 -st none;
			columnLayout -adj 0;
				text -l "First create a SoftMod:";
				iconTextButton -w 35 -h 35 -i "softMod.png" -c SoftModTool;
				text -l "Then:";
				rowLayout -nc 5;
					checkBox -l "Mirror" -v 1 -onc "checkBox -e -v 0 asCustomControlMiddleCheckBox" asCustomControlMirrorCheckBox;
					checkBox -l "Middle" -v 0 -onc "checkBox -e -v 0 asCustomControlMirrorCheckBox" asCustomControlMiddleCheckBox;
					separator -w 5 -st none;
					text -l "MaxWeight:";
					floatField -w 30 -v 1.0 -pre 2 asCustomControlMaxWeightFloatField;
					setParent..;
				rowLayout -nc 2 -cw2 198 15;
					button -w 190 -l "Create Control from SoftMod" -c "asFaceConvertSoftModToCustomControl";
					button -w 11 -l "?" -c "asHelpImage asClusterControlCreate";
					setParent..;
				setParent..;
			setParent..;

setParent asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Pose" asPoseFrameLayout;
columnLayout -adj 1 asPoseColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Driving Systems" asBodyDrivingSystemsFrameLayout;
		columnLayout -adj 0;
			text -l "Create:";
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				columnLayout -adj 0;
					text -l "First make the pose to be driven";
					text -l "(e.g. folded wings, hand guesture..)";
					text -l "Then:";
					setParent..;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st none;
				button -w 162 -l"Create Driving System" -c asCreateDrivingSystem;
				button -w 11 -l "?" -c "asHelpImage asDrivingSystemsCreate";
				setParent..;
			separator -w 242 -h 5;
			text -l "Edit:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Right Click on any of these buttons,\nto access existing Driving Systems.";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15;
				separator -st none;
				button -w 50 -en (!$dsm) -l "Edit" -c asAutoFindAndEditDrivingSystem asEditDrivingSystemsButton;
				popupMenu -pmc "asPopulateDrivingSystemsPopupMenu Edit" asEditDrivingSystemsPopupMenu;
				button -w 50 -en (!$csm) -l "Delete" asDeleteDrivingSystemsButton;
				popupMenu -pmc "asPopulateDrivingSystemsPopupMenu Delete" asDeleteDrivingSystemsPopupMenu;
				button -w 50 -en (!$dsm) -l "Graph" asGraphDrivingSystemsButton;
				popupMenu -pmc "asPopulateDrivingSystemsPopupMenu Graph" asGraphDrivingSystemsPopupMenu;
				button -w 11 -l "?" -c "asHelpImage asDrivingSystemsEdit";
				setParent..;
			separator -st none -h 20;
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				text -l "After editing pose, then:";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15 asDSEditChoicesRowLayout;
				separator -st none;
				button -w 50 -l "Apply" -c asDrivingSystemEditApply;
//				separator;
//				checkBox -v 1 -l "mirror" asDrivingSystemMirrorCheckBox;
				button -w 50 -l "Cancel" -c asDrivingSystemEditCancel;

	setParent asPoseColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Corrective Shapes" asBodyCorrectiveFrameLayout;
		columnLayout -adj 0;
			text -l "Create:";
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				columnLayout -adj 0;
					text -l "Go to pose to correct, then:";
					text -l "Select mesh to correct, then:";
					setParent..;
				setParent..;
			rowLayout -nc 2 -cw2 80 100;
				separator -st none;
				checkBox -v 1 -l "Angle Rotations" asCorrectiveAngleCheckBox;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st none;
				button -w 162 -en (!$csm) -l "Create Corrective Shape" -c asCreateCorrectiveShape asCreateCorrectiveButton;
				button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesCreate";
				setParent..;
			separator -w 242 -h 5;
			text -l "Edit:";
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				text -l "Right Click on any of these buttons,\nto access existing Corrective Shapes.";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15;
				separator -st none;
				button -w 50 -en (!$csm) -l "Edit" asEditCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Edit" asEditCorrectiveShapesPopupMenu;
				button -w 50 -en (!$csm) -l "Delete" asDeleteCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Delete" asDeleteCorrectiveShapesPopupMenu;
				button -w 50 -en (!$csm) -l "Graph" asGraphCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Graph" asGraphCorrectiveShapesPopupMenu;
				button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesEdit";
				setParent..;
			separator -st none -h 20;
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				text -l "After sculpted shape, then:";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15 asCorrectiveEditChoicesRowLayout;
				separator -st none;
				button -l "Apply" -c asConnectCorrectiveShape;
				checkBox -v 1 -l "mirror" asCorrectiveMirrorCheckBox;
				button -l "Cancel" -c asCancelCorrectiveShape;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Corrective Shapes - Advanced" asBodyCorrectiveAdvancedFrameLayout;
		
			rowLayout -nc 2;
				separator -w 10 -st none;
				columnLayout -adj 0;
			frameLayout -cll 1 -cl 1 -w 225 -cc asFL -ec asFL -l " Bake" asBodyCorrectiveBakeFrameLayout;
//			checkBox -l advanced -onc "columnLayout -e -m 1 asCorrectiveAdvancedColumnLayout" -ofc "columnLayout -e -m 0 asCorrectiveAdvancedColumnLayout";
				columnLayout -m 0 asCorrectiveAdvancedColumnLayout;
	//				separator -h 15 -st none;
					rowLayout -nc 2 -cw2 209 100;
						text -l "Bake Deformations to Corrective Shapes:";
						button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesBake";
						setParent..;
					rowLayout -nc 2;
						button -w 120 -l "Source" -c "textField -e -tx `ls -sl` asBakeToCorrective1TextField";
						textField -w 100 -ed 0 asBakeToCorrective1TextField;
						setParent..;
					rowLayout -nc 2;
						button -w 120 -l "Destination" -c "textField -e -tx `ls -sl` asBakeToCorrective2TextField";
						textField -w 100 -ed 0 asBakeToCorrective2TextField;
						setParent..;
					text -l "rotations:";
					rowLayout -nc 6 asBakeAxisRowLayout;
						checkBox -l "+x" -v 1 asBakeX1CheckBox;
						checkBox -l "+y" -v 1 asBakeY1CheckBox;
						checkBox -l "+z" -v 1 asBakeZ1CheckBox;
						checkBox -l "-x" -v 1 asBakeX2CheckBox;
						checkBox -l "-y" -v 1 asBakeY2CheckBox;
						checkBox -l "-z" -v 1 asBakeZ2CheckBox;
						setParent..;
					text -l "Select FK controller, then:";
					rowLayout -nc 3 -cw3 80 50 100;
						button -w 50 -l "Bake" -c asBakeIntoCorrectiveShapes;
	//					text "or";
	//					button -l "Create Source" -c asCurveBasedAutoCorrectiveShapes;
							setParent..;
						setParent..;
					setParent..;

				frameLayout -cll 1 -cl 1 -w 225 -cc asFL -ec asFL -l " CurveBased deformations" asBodyCorrectiveCBDFrameLayout;
				columnLayout;
				rowLayout -nc 2 -cw2 209 100;
					text -l "Create Curve Based Deformation objects,\nto use as Corrective Shape targets";
					button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesCurveBased";
					setParent..;
				rowLayout -nc 2;
					button -w 120 -l "Mesh" -c "textField -e -tx `ls -sl` asBodyCorrectiveCBDMeshTextField";
					textField -w 100 -ed 0 asBodyCorrectiveCBDMeshTextField;
					setParent..;
				rowLayout -nc 2;
					button -w 120 -l "FK control" -c "textField -e -tx `ls -sl` asBodyCorrectiveCBDFKControlTextField";
					textField -w 100 -ed 0 asBodyCorrectiveCBDFKControlTextField;
					setParent..;
				button -l "Create Curves" -c asCBDCreateCurves;
				button -l "Create test animation" -c asCBDCreateTestAnim;
				text -l "Tweak curves to match geo, if needed";
				button -l "Hide original mesh" -c asCBDHideMesh;
				button -l "Create new deformation mesh" -c asCBDCreateDeformMesh;
//				button -l "Update deformation mesh" -c asCBUpdateDeformMesh;
				rowLayout -nc 4;
					separator -w 30 -st none;
					button -l "Show original" -c asCBDShowOriginal;
					separator -w 10 -st none;
					button -l "Show new" -c asCBDShowNew;
					setParent..;
				text -l "\"Slide\" attributecan be adjusted, if needed.";
				separator -h 5;
				text -l "When finished:";
				rowLayout -nc 4;
					separator -w 10 -st none;
					button -l "Bake as Corrective" -c asCBBakeDeformMesh;
					text -w 30  -l "or";
					button -l "Cancel" -c asCBCleanup;


setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Tools" asToolsFrameLayout;
columnLayout -adj 1;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "SelectorDesigner" -c asSelectorDesigner;
		button -w 11 -l "?" -c "asHelpImage asSelectorDesigner";
		setParent..;
	separator -st none -h 5;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "PoserDesigner" -c asPoserDesigner;
		button -w 11 -l "?" -c "asHelpImage asPoserDesigner";
		setParent..;
	separator -st none -h 5;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "WalkDesigner" -c asWalkDesigner;
		button -w 11 -l "?" -c "asHelpImage asWalkDesigner";

setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Display" asDisplayFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "MotionSystem:";
			button -w 60 -l "Hide" -c "setAttr MotionSystem.v 0";
			button -w 60 -l "Show" -c "setAttr MotionSystem.v 1";
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joints:";
			button -w 60 -l "Hide" -c "asJointsVisibility 0";
			button -w 60 -l "Show" -c "asJointsVisibility 1";
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joint axis:";
			button -w 60 -l "Hide" -c "asDisplayRigRLA 0";
			button -w 60 -l "Show" -c "asDisplayRigRLA 1";
			setParent..;
		rowLayout -nc 2 -cw2 73 100;
			text "Joint Size:";
			floatSliderGrp -cw2 35 130 -field 1 -min 0.01 -max 10.0 -pre 2 -v `jointDisplayScale -q` -dc "jointDisplayScale #1" -cc "jointDisplayScale #1";
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			separator;
			button -w 150 -l "Select jointLayer" -c "select jointLayer;AttributeEditor";

setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Optimize" asOptimizeFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Delete Unused Nodes" -c "hyperShadePanelMenuCommand(\"\", \"deleteUnusedNodes\");print \"// Unused nodes deleted.\\n\"";
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Remove Unused Influences" -c asRemoveAllUnusedInfluences;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Prune Clusters" -c asPruneAllClusters;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Delete saved UIs" -c asSaveUIs;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Delete Unused joints" -c asDeleteUnusedJoints;
			setParent..;

setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Publish" asPublishFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Set DisplayLayers to \"R\"" -c asSetDisplayLayersToR;
			setParent..;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Set Joints to hidden" -c "asJointsVisibility 0";
			setParent..;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Go to Build Pose" -c "asGoToBuildPose bodySetup;if (`objExists FaceControlSet`)asGoToBuildPose faceSetup;";
			setParent..;
		separator -st none -h 10;
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "Publish" -c asPublish;
			button -w 11 -l "?" -c "asHelpImage asPublish";

setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Demo" asDemoFrameLayout;
	columnLayout -adj 1;
		separator -h 10 -st none;
		rowLayout -nc 3 -cw3 50 178 15;
			separator -st none;
			button -l "Check online for Demo updates" -c asCheckForDemoUpdates;
			button -w 11 -l "?" -c "asHelpImage asDemoCheckOnline";
			setParent..;
		separator -h 10 -st none;
		rowLayout -nc 4;
			separator -w 50 -st none;
			optionMenu asDemoOptionMenu;
			separator -w 25 -st none;
			button -l "Open" -c asOpenDemoFile;
			setParent..;

setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "About" asAboutFrameLayout;
columnLayout -adj 1;
	image -h 83 -i ($asScriptLocation+"/AdvancedSkeleton5Files/icons/asLogo.png") asHelpImage;
	if (`asIsMayaLT`)
		text -l "\nNote:\nRunning Maya LT,\n so not all AdvancedSkeleton features enabled.\n";
	button -l "visit AdvancedSkeleton website" -c "showHelp -a \"http://www.animationstudios.com.au/advancedskeleton\"";
	separator -h 15;
	if (`asMayaVersionAsFloat`>=2012)
		{
		rowLayout -nc 4 -cw4 60 50 70 100;
			text -l " Window:";
			button -c "asDockWindow 1" -l " Dock ";
			button -c "asDockWindow 0" -l " UnDock ";
			button -c asCreateWorkspaceControl -l "Workspace" asWorkspaceButton;
			if (`asMayaVersionAsFloat`<2017)
				button -e -en 0 -ann "Workspace-controller requires Maya2017 or higher" asWorkspaceButton;
			setParent..;
		}
	separator -h 15;
	rowLayout -nc 5 -cw5 110 30 40 54 15;
		button -l "Check For Updates" -c asCheckForUpdates;
		text -l "found:";
		text -m 1 -l "x.xxx" asUpdateFoundVersion;
		button -en 0 -l "Update" -c asUpdateVersion asUpdateVersionButton;
		button -w 11 -l "?" -c "asHelpImage asAboutUpdate";
		setParent..;
	checkBox -m 0 -v 0 asBetaCheckBox;	
	separator -h 15;
	rowLayout -nc 3 -cw3 80 158 15;
		text -l "current version:";
		button -l `asGetScriptVersionAsString` -c "print \"// right click on button to change version.\\n\"";
			popupMenu asVersionsPopupMenu;
		button -w 11 -l "?" -c "asHelpImage asAboutCurrentVersion";
		setParent..;
	separator -h 5;

	rowLayout -nc 3 -cw3 80 158 15;
		text -l "version history:";
		button -l "download version history info" -c asVersionHistory;
		setParent..;
	separator -h 5;


	columnLayout -adj 0;
		text -l "For support, go to:\nwww.facebook.com/AdvancedSkeleton\nOr email: support@animationstudios.com.au\n\nFor license information, read the eula.txt file.";

setParent asFormLayout;
rowLayout -nc 2 -cw2 120 100 asRowLayout;
columnLayout;
	rowLayout -nc 5 -cw5 30 90 10 30 90;
		text -l "body:" asBodyText;
		button -c "asGoToBuildPose bodySetup" -l "Go to Build Pose";
		popupMenu;
		menuItem -l "set build pose" -c "asSetBuildPose bodySetup";
		separator -w 10 -st none;
		text -l "face:" asFaceText;
		button -c "asGoToBuildPose faceSetup" -l "Go to Build Pose" asGoToBuildPoseFaceButton;
		popupMenu;
		menuItem -l "set build pose" -c "asSetBuildPose faceSetup";
		setParent..;
	setParent..;
formLayout -e
	-af asScrollLayout "right" 0
	-af asScrollLayout "left" 0
	-af asScrollLayout "top" 0
	-ac asScrollLayout "bottom" 0 asRowLayout
	-af asRowLayout "bottom" 0
	asFormLayout;

if (!`control -q -ex asWorkspaceControl`)
	{
	if($asDock)
		{
		if (`asMayaVersionAsFloat`>=2012)
			dockControl -l AdvancedSkeleton -w 296 -fl 0 -floatChangeCommand asDockWindowChangeFloatingState -a "left" -con AdvancedSkeletonWindow -aa "left" -aa "right" AdvancedSkeletonDockControl;
		else
			dockControl -l AdvancedSkeleton -w 296 -fl 0 -a "left" -con AdvancedSkeletonWindow -aa "left" -aa "right" AdvancedSkeletonDockControl;
		evalDeferred "dockControl -e -r AdvancedSkeletonDockControl;";
		}
	else
		showWindow;
	}
asUpdateLabelHelp;
asUpdateAttributeHelp;
asEnsureFitSkeletonAttributes;
asUpdateButtonEnables;
if (`window -q -ex AdvancedSkeletonWindow`)
	{
	window -e -w 296 AdvancedSkeletonWindow;
	if (`asMayaVersionAsFloat`<2012)
		window -e -w 309 AdvancedSkeletonWindow;
	if (!`windowPref -q -ex AdvancedSkeletonWindow`)
		window -e -h 500 AdvancedSkeletonWindow;
	}
if ($asFaceIsResetting)
	$asFaceIsResetting=0;
else
	asFaceUpdateInfo 1;

//update UI from optionVars
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
    if (`gmatch $framLayouts[$i] "as*FrameLayout"`)
        if (`optionVar -ex $framLayouts[$i]`)
            frameLayout -e -cl `optionVar -q $framLayouts[$i]` $framLayouts[$i];

//populate fitSkeletonFiles optionMenu
string $fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletons/";
string $fitSkeletonFiles[]=`getFileList -fld $fitSkeletonsDir`;
setParent -menu asFitFiles;
for ($i=0;$i<size($fitSkeletonFiles);$i++)
	{
	if (`gmatch $fitSkeletonFiles[$i] "[.]*"` || $fitSkeletonFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $fitSkeletonFiles[$i];
	}

//populate Retopology optionMenus
string $headTopologyDir=$asScriptLocation+"/AdvancedSkeleton5Files/div/headTopology/";
string $headTopoFiles[]=`getFileList -fld $headTopologyDir`;
setParent -menu asCreateFaceRetopoOptionMenu;
for ($i=0;$i<size($headTopoFiles);$i++)
	{
	if (`gmatch $headTopoFiles[$i] "[.]*"` || $headTopoFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $headTopoFiles[$i];
	}
string $headTopologyEyeBallDir=$asScriptLocation+"/AdvancedSkeleton5Files/div/headTopologyEyeBall/";
string $headTopoEyeBallFiles[]=`getFileList -fld $headTopologyEyeBallDir`;
setParent -menu asCreateFaceRetopoEyeBallOptionMenu;
for ($i=0;$i<size($headTopoEyeBallFiles);$i++)
	{
	if (`gmatch $headTopoEyeBallFiles[$i] "[.]*"` || $headTopoEyeBallFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $headTopoEyeBallFiles[$i];
	}
string $headTopologyTeethDir=$asScriptLocation+"/AdvancedSkeleton5Files/div/headTopologyTeeth/";
string $headTopoTeethFiles[]=`getFileList -fld $headTopologyTeethDir`;
setParent -menu asCreateFaceRetopoTeethOptionMenu;
for ($i=0;$i<size($headTopoTeethFiles);$i++)
	{
	if (`gmatch $headTopoTeethFiles[$i] "[.]*"` || $headTopoTeethFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $headTopoTeethFiles[$i];
	}

//populate Demo optionMenu
string $exampleFoldersDir=$asScriptLocation+"/AdvancedSkeleton5Files/exampleFiles/downloads/";
string $exampleFolders[]=`getFileList -fld $exampleFoldersDir`;
setParent -menu asDemoOptionMenu;
for ($i=0;$i<size($exampleFolders);$i++)
	{
	string $exampleFile=$exampleFoldersDir+$exampleFolders[$i]+"/"+$exampleFolders[$i]+".mb";
	if (`file -q -ex $exampleFile`)
		menuItem -l $exampleFolders[$i];
	}

$fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletonsLimbs/";
$fitSkeletonFiles=`getFileList -fld $fitSkeletonsDir`;
setParent -menu asLimbFiles;
for ($i=0;$i<size($fitSkeletonFiles);$i++)
	{
	if (`gmatch $fitSkeletonFiles[$i] "[.]*"` || $fitSkeletonFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $fitSkeletonFiles[$i];
	}

//Exist EditDrivingSystemMode (if stuck)
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;

//Set 0.2 jointDisplayScale if first run of AdvancedSkeleton
if (!`optionVar -ex asBodyFrameLayout`)
	jointDisplayScale 0.2;

//populate asVersionsPopupMenu
string $oldVersionsDir=$asScriptLocation+"/AdvancedSkeleton5Files/oldVersions/";
int $latestLocal;
setParent -menu asVersionsPopupMenu;
string $oldVersions[];
if (`file -q -ex $oldVersionsDir`)
	$oldVersions=`getFileList -fld $oldVersionsDir`;
$oldVersions=`sort $oldVersions`;
for ($i=size($oldVersions);$i>-1;$i--)
	{
	if ($i==size($oldVersions))
		{
		$label=`asGetLatestLocalVersionAsString`;
		$latestLocal=1;
		}
	else
		{
		$label=$oldVersions[$i];
		$latestLocal=0;
		}
	$label=`substitute "AdvancedSkeleton_v" $label ""`;
	menuItem -l $label -c ("asSourceVersion \""+$label+"\" "+$latestLocal);
	}

//Maya less than2012 limitations
if (`asMayaVersionAsFloat`<2012)
	{
	string $childArray[]=`columnLayout -q -ca asFaceColumnLayout`;
	for ($i=0;$i<size($childArray);$i++)
		layout -e -m 0 $childArray[$i];
	setParent asFaceColumnLayout;
	text -l "FaceSetup requires Maya2012 or higher";
//	frameLayout -e -m 0 asFaceTweakControlsFrameLayout;
	}

//Maya LT limitations
if (`asIsMayaLT`)
	{
	frameLayout -e -en 0 asBodyDeform2FrameLayout;//no wire deformer
	frameLayout -e -en 0 asBodyDeform3FrameLayout;//no wire deformer
	frameLayout -e -en 0 asBodyDrivingSystemsFrameLayout;//no sdk
	frameLayout -e -en 0 asFaceFrameLayout;//no nCloth
	}

if (!$haveRanThisVersion) asFirstRunOfNewVersion;//First time running this version

progressBar -e -ep $gMainProgressBar;
}

global proc asScriptLocatorProc (){}

global proc string asGetScriptLocation ()
{
string $whatIs=`whatIs asScriptLocatorProc`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder-1)`;
return $scriptLocation;
}

global proc float asGetScriptVersion ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $file=$asScriptLocation+"/AdvancedSkeleton5.mel";
float $version=`asGetScriptVersionFromFile $file`;
return $version;
}

global proc string asGetScriptVersionAsString ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $file=$asScriptLocation+"/AdvancedSkeleton5.mel";
string $versionAsString=`asGetScriptVersionFromFileAsString $file`;
return $versionAsString;
}

global proc float asGetScriptVersionFromFile (string $file)
{
string $versionAsString=`asGetScriptVersionFromFileAsString $file`;
float $version=$versionAsString;
return $version;
}

global proc string asGetScriptVersionFromFileAsString (string $file)
{
string $versionString;
string $tempString[];
int $lineNr;
if (`file -q -ex $file`)
	{
	int $fileId=`fopen $file "r"`;
	string $nextLine = `fgetline $fileId`;
	while ( size( $nextLine ) > 0 )
		{
		$lineNr++;
		$nextLine = `fgetline $fileId`;
		if (`gmatch $nextLine "*Version*"`)
			{
			tokenize $nextLine $tempString;
			tokenize $tempString[2] "[.]" $tempString;
			for ($i=0;$i<size($tempString);$i++)
				{
				$versionString+=$tempString[$i];
				if ($i==0)
					$versionString+=".";
				}
//			$version=$versionString;
			}
		if($lineNr>10)
			break;
		}
	fclose $fileId;
	}
else
	warning "Unable to determine AdvancedSkeleton version number";
return $versionString;
}

global proc asSourceVersion (string $versionAsString, int $latestLocal)
{
global string $gShelfTopLevel;
int $sucess;
string $buttons[];

string $asFile,$iol,$image;
string $latestLocalScriptLocation=`asGetLatestLocalScriptLocation`;
if ($latestLocal)
	$asFile=$latestLocalScriptLocation+"/AdvancedSkeleton5.mel";
else
	{
	$asFile=$latestLocalScriptLocation+"/AdvancedSkeleton5Files/oldVersions/AdvancedSkeleton_v"+$versionAsString+"/AdvancedSkeleton5.mel";
	$iol=$versionAsString;
	if (!`file -q -ex $asFile`)
		{
		warning ("attempted to source version: "+$versionAsString+", but could not find file:\""+$asFile+"\", so using latest installed version instead");
		optionVar -iv asUseVersionLatestLocal 1;
		return;
		}
	}

string $cmd="source \""+$asFile+"\";AdvancedSkeleton5;";
string $shelves[]=`tabLayout -q -ca $gShelfTopLevel`;
for ($i=0;$i<size($shelves);$i++)
	{
	$buttons=`layout -q -ca $shelves[$i]`;
	for ($y=0;$y<size($buttons);$y++)
		{
		if (!`shelfButton -q -ex $buttons[$y]`)
			continue;
		string $ann=`shelfButton -q -ann $buttons[$y]`;
		if ($ann=="AdvancedSkeleton5")
			{
			$image=`shelfButton -q -i $buttons[$y]`;
			if ($iol=="")
				$image=`substitute "AS4version" $image "AS4"`;
			else
				$image=`substitute "AS4" $image "AS4version"`;
			shelfButton -e -c $cmd -iol $iol -i $image -i1 $image $buttons[$y];
			$sucess=1;
			}
		}
	}
if ($sucess)
	{
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		evalDeferred -lp ("deleteUI -control AdvancedSkeletonDockControl");
	else if (`window -q -ex AdvancedSkeletonWindow`)
	    evalDeferred -lp ("deleteUI AdvancedSkeletonWindow");
	if (`exists workspaceControl`)
		if (`workspaceControl -q -ex asWorkspaceControl`)
			deleteUI asWorkspaceControl;
	print ("// Shelf button updated, Click on the button to launch choosen version of AdvancedSkeleton\n");
	}
}

global proc int asIsMayaLT ()
{
int $isMayaLT=0;
if (!`exists CreateWrap`)
	$isMayaLT=1;
return $isMayaLT;
}

global proc int asHaveMeshCenterSnap ()
{
int $haveSnap;
string $helpString=`help snapMode`;
string $tempString[];
tokenize $helpString $tempString;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]=="-meshCenter")
		$haveSnap=1;
return $haveSnap;
}

global proc asFirstRunOfNewVersion ()
{
global string $gShelfTopLevel;
int $hasAS,$hasPicker;
string $currentShelf = `tabLayout -query -selectTab $gShelfTopLevel`;
string $asScriptLocation=`asGetScriptLocation`;
string $shelfButtons[]=`shelfLayout -q -ca $currentShelf`;
for ($i=0;$i<size($shelfButtons);$i++)
	{
	if (!`shelfButton -q -ex $shelfButtons[$i]`)
		continue;
	if (`shelfButton -q -ann $shelfButtons[$i]`=="AdvancedSkeleton5") $hasAS=1;
	if (`shelfButton -q -ann $shelfButtons[$i]`=="picker") $hasPicker=1;
	if (`shelfButton -q -ann $shelfButtons[$i]`=="Selector:picker") $hasPicker=1;
	}
if ($hasAS && !$hasPicker)
	if (`confirmDialog -title "Add tool ?" -message 
	("This version have a new tool for your shelf (Picker)\n"
	+"Add this to your shelf now ?")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`=="Yes")
    {
		evalEcho ("source \""+$asScriptLocation+"/AdvancedSkeleton5Files/picker/install.mel\"");
		SavePreferences;
		}
optionVar -iv asHaveRanThisVersion 1;
}

global proc asUpdateLabelHelp ()
{
string $type=`optionMenu -q -v asLabelType`;
string $help="";
if ($type=="Hand" || $type=="Shoulder")
	$help="Hand + Shoulder = Arm IK";
if ($type=="Hip" || $type=="Foot")
	$help="Hip + Foot = Leg IK";
if ($type=="LegAim")
	$help="LegAim + Hip + Foot = 3 bone Leg IK";
if ($type=="Heel" || $type=="Toes" || $type=="ToesEnd")
	$help="Heel + Toes + ToesEnd = FootRoll";
if ($type=="BigToe" || $type=="PinkyToe")
	$help="BigToe + PinkyToe = FootRock";
if ($type=="QToes")
	$help="Quadped toes";
if ($type=="Root" || $type=="Chest" || $type=="Mid")
	$help="Root + Chest (+ Mid) = Spine IK";
if ($type=="0" || $type=="1" || $type=="2" || $type=="3")
	$help="0,1,2, etc.. = Spline IK (tail)";


text -e -l $help asLabelHelp;
}

global proc asUpdateAttributeHelp ()
{
string $type=`optionMenu -q -v asAttributeType`;
string $help="";
if ($type=="twist/bendy")
	$help="TwistJoints & Bendy-limbs";
if ($type=="inbetween")
	$help="Creates extra inbetween joints";
if ($type=="global")
	$help="Keeps limbs orientation fixed";
if ($type=="aim")
	$help="LookAt (AimConstraint)";
if ($type=="wheel")
	$help="Wheel Roller";
if ($type=="freeOrient")
	$help="Free limb orientation";
if ($type=="worldOrient")
	$help="Orient limb to world-space";
if ($type=="flipOrient")
	$help="Reverse up-vector";
if ($type=="noMirror")
	$help="For non-symmetrical limbs";
if ($type=="noFlip")
	$help="Ignore Mirror behaviour";
if ($type=="noControl")
	$help="Skips creating FK-control";
if ($type=="ikLocal")
	$help="Local oriented IK-control";
if ($type=="centerBtwFeet")
	$help="Makes Root follow IK legs";
if ($type=="geoAttach")
	$help="Controller sticks to geometry";
if ($type=="curveGuide")
	$help="For feather setup";

text -e -l $help asAttributeHelp;
}

global proc asFitResample ()
{
if (`window -q -ex asFitResample`)
	deleteUI asFitResample;
window -t Resample asFitResample;

int $numJoints=2;
string $allDescendents[],$tempString[];
string $selJoints[]=`ls -sl -type joint`;
string $startJoint=$endJoint="none";
if (size($selJoints)==1)
	{
	string $asFitJointIKInfo[]=`asFitJointIKInfo $selJoints[0]`;
	if ($asFitJointIKInfo[1]!="")
		$startJoint=$asFitJointIKInfo[1];
	if ($asFitJointIKInfo[3]!="")
		$endJoint=$asFitJointIKInfo[3];
	}
if (size($selJoints)==2)
	{
	$allDescendents=`listRelatives -ad $selJoints[0]`;
	if (`stringArrayCount $selJoints[1] $allDescendents`)
		{
		$startJoint=$selJoints[0];
		$endJoint=$selJoints[1];
		}
	$allDescendents=`listRelatives -ad $selJoints[1]`;
	if (`stringArrayCount $selJoints[0] $allDescendents`)
		{
		$startJoint=$selJoints[1];
		$endJoint=$selJoints[0];
		}
	}
//Find current $numJoints
if (`objExists $startJoint` && `objExists $endJoint` )
	{
	string $countJoint=$endJoint;
	for ($i=0;$i<99;$i++)
		{
		$tempString=`listRelatives -p $countJoint`;
		$countJoint=$tempString[0];
		if ($countJoint=="" || $countJoint==$startJoint)
			break;
		$numJoints++;
		}
	}

columnLayout -adj 1;
rowLayout -nc 2;
	textFieldGrp -cw2 60 100 -l "StartJoint:" -ed 0 -tx $startJoint asFitResampleStartJointtextFieldGrp;
	button -h 15 -l "pick" -c "asFitResamplePick asFitResampleStartJointtextFieldGrp";
	setParent..;
rowLayout -nc 2;
	textFieldGrp -cw2 60 100 -l "EndJoint" -ed 0 -tx $endJoint asFitResampleEndJointtextFieldGrp;
	button -h 15 -l "pick" -c "asFitResamplePick asFitResampleEndJointtextFieldGrp";
	setParent..;
intFieldGrp -v1 $numJoints -cw2 60 50 -l "joints" asFitResampleNumJoints;
button -l "ReSample" -c asFitResampleJoints;
showWindow asFitResample;
}

global proc asFitResampleJoints ()
{
global string $gSelect;
setToolTo $gSelect;
string $sel[]=`ls -sl`;
string $tempString[],$joints[],$parentJoints[];
string $newJoint;
string $startJoint=`textFieldGrp -q -tx asFitResampleStartJointtextFieldGrp`;
string $endJoint=`textFieldGrp -q -tx asFitResampleEndJointtextFieldGrp`;
int $numJoints=`intFieldGrp -q -v1 asFitResampleNumJoints`;
$tempString=`ls -l $endJoint`;
tokenize $tempString[0] "|" $parentJoints;
int $reachedStart=0;
for ($i=0;$i<size($parentJoints);$i++)
	{
	if ($parentJoints[$i]==$startJoint)
		$reachedStart=1;
	if ($reachedStart)
		$joints[size($joints)]=$parentJoints[$i];	
	}
if (!`objExists $startJoint`)
	error ("startJoint :\""+$startJoint+"\" does not exists");
if (!`objExists $endJoint`)
	error ("endJoint :\""+$endJoint+"\" does not exists");
if ($numJoints<2)
	error "Can not ReSample to less than 2";
if (!`stringArrayCount $startJoint $joints`)
	error ("endJoint:\""+$endJoint+"\" is not a child of startJoint:\""+$startJoint+"\"");
if ($startJoint==$endJoint)
	error "StartJoint and EndJoint can not be the same";

select $startJoint $endJoint;
$tempString=`ikHandle -sol ikSplineSolver -scv false -pcv false`;
duplicate -n tempIKCurve $tempString[2];
delete $tempString[0] $tempString[2];
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f tempIKCurveShape.worldSpace[0] tempPointOnCurveInfo.inputCurve;
select tempIKCurve;refresh;

int $startJointLocks[]=`asUnLockAttrs $startJoint`;
int $endJointLocks[]=`asUnLockAttrs $endJoint`;

float $startJointFat=1;
float $startJointFatY=1;
float $startJointFatZ=1;
float $endJointFat=1;
float $endJointFatY=1;
float $endJointFatZ=1;
if (`attributeExists fat $startJoint`) $startJointFat=`getAttr ($startJoint+".fat")`;
if (`attributeExists fatY $startJoint`) $startJointFatY=`getAttr ($startJoint+".fatY")`;
if (`attributeExists fatZ $startJoint`) $startJointFatZ=`getAttr ($startJoint+".fatZ")`;
if (`attributeExists fat $endJoint`) $endJointFat=`getAttr ($endJoint+".fat")`;
if (`attributeExists fatY $endJoint`) $endJointFatY=`getAttr ($endJoint+".fatY")`;
if (`attributeExists fatZ $endJoint`) $endJointFatZ=`getAttr ($endJoint+".fatZ")`;

$tempString=`listRelatives -p $startJoint`;
string $startJointParent=$tempString[0];
if ($startJointParent!="")
	parent -w $startJoint;
parent -w $endJoint;
float $radius=`getAttr ($startJoint+".radius")`;
rename $endJoint tempRename;
if (`objExists $joints[1]`) delete $joints[1];
string $parent=$startJoint;
string $newJointName=$joints[0];
if ($joints[0]=="Root")
	{
	createNode -n Spine transform;
	$newJointName="Spine";
	}
for ($i=1;$i<$numJoints-1;$i++)
	{
	select -cl;
	$newJoint=`joint -n $newJointName -rad $radius`;
	setAttr tempPointOnCurveInfo.parameter ((1.0/($numJoints-1))*$i);
	$pos=`getAttr tempPointOnCurveInfo.position`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $newJoint;
	parent $newJoint $parent;
	$parent=$newJoint;
	asEnsureFitJointAttrs $newJoint;
	setAttr ($newJoint+".fat") ($startJointFat+(($i/($numJoints-1.0))*($endJointFat-$startJointFat)));
	setAttr ($newJoint+".fatY") ($startJointFatY+(($i/($numJoints-1.0))*($endJointFatY-$startJointFatY)));
	setAttr ($newJoint+".fatZ") ($startJointFatZ+(($i/($numJoints-1.0))*($endJointFatZ-$startJointFatZ)));
	asFitModeUpdateJoints $newJoint 0;
	refresh;
	}
if ($joints[0]=="Root" && `objExists |Spine`) delete |Spine;
if (`objExists $endJoint`)
	rename $endJoint ($endJoint+"_2");
rename tempRename $endJoint;
parent $endJoint $parent;
if ($startJointParent!="")
	parent $startJoint $startJointParent;

asReLockAttrs $startJoint $startJointLocks;
asReLockAttrs $endJoint $endJointLocks;

asFitModeUpdateJoints $endJoint 0;
delete tempIKCurve;
if (`checkBox -q -ex asLockCenterJoints`)
	if (`checkBox -q -v asLockCenterJoints`)
		asFitModeLockCenterJoints;

print ("// Joints Resampled\n");
catchQuiet (`select $sel`);
}

global proc int[] asUnLockAttrs (string $obj)
{
int $lockedAttrs[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		$lockedAttrs[size($lockedAttrs)]=`getAttr -l ($obj+"."+$trs[$y]+$xyz[$z])`;
		setAttr -l 0 ($obj+"."+$trs[$y]+$xyz[$z]);
		}
return $lockedAttrs;
}

global proc asReLockAttrs (string $obj, int $lockedAttrs[])
{
int $attrNr=0;
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		setAttr -l $lockedAttrs[$attrNr] ($obj+"."+$trs[$y]+$xyz[$z]);
		$attrNr++;
		}
}

global proc asFitResamplePick (string $textFieldGrp)
{
string $selJoints[]=`ls -sl -type joint`;
if (!size($selJoints))
	error "No joint selected";
textFieldGrp -e -tx $selJoints[0] $textFieldGrp;
}

global proc asAddFitJointLabel ()
{
string $labelType=`optionMenu -q -v asLabelType`;
string $sel[]=`ls -sl -type joint`;
int $labelCode;
for ($i=0;$i<size($sel);$i++)
	{
	setAttr ($sel[$i]+".drawLabel") 1;
	$labelCode=`asLabelCodeLookup $labelType 1`;
	setAttr ($sel[$i]+".type") $labelCode;
	if ($labelCode==18)
		setAttr -type "string" ($sel[$i]+".otherType") $labelType;
	}
}

global proc asRemoveFitJointLabel ()
{
string $sel[]=`ls -sl -type joint`;
for ($i=0;$i<size($sel);$i++)
	setAttr ($sel[$i]+".drawLabel") 0;
}

global proc string asLabelCodeLookup (string $labelCode, int $labelToCode)
{

string $result;
int $codes[]={0,1,2,4,18,10,12,15,16,17,18,18,18,18,18,18,18,18,18,18,18,18,18,18};
string $labels[]={"None","Root","Hip","Foot","ToesEnd","Shoulder","Hand","PropA","PropB","PropC","Other","Chest","Mid","Toes","Heel","BigToe","PinkyToe","LegAim","QToes","Eye","Wheel","0","1","2","3"};

for ($i=0;$i<size($labels);$i++)
	{
	if ($labelToCode)
		if ($labels[$i]==$labelCode)
			return $codes[$i];
	if (!$labelToCode)
		if ($codes[$i]==$labelCode)
			return $labels[$i];
	}
return "";
}

global proc string asLabel (string $obj)
{
string $label;
if (size(`ls -ap $obj`)>1)
	error ("More than one object matches name: "+$obj+"\n");
if (!`objExists $obj`)
	return "AA";
if (!`attributeExists "type" $obj`)
	return "BB";
int $labelNum=`getAttr ($obj+".type")`;
if (!`getAttr ($obj+".drawLabel")`)
	return "";

$label=`asLabelCodeLookup $labelNum 0`;
if ($labelNum==18)
	{
	$label=`getAttr ($obj+".otherType")`;
	}

return $label;
}

global proc int asComponentToNr (string $component)
{
int $nr;
string $tempString[];
tokenize $component "[" $tempString;
tokenize $tempString[1] "]" $tempString;
$nr=$tempString[0];
return $nr;
}

global proc asAddFitJointAttribute ()
{
string $attr=`optionMenu -q -v asAttributeType`;
string $sel[]=`ls -sl`;
float $dv=1;
string $meshObject,$curveObject;
for ($i=0;$i<size($sel);$i++)
	{
	if (`attributeExists $attr $sel[$i]` && `objectType $sel[$i]`!="joint")
		continue;
	if (`attributeExists $attr $sel[$i]` && `objectType $sel[$i]`=="joint")
		{warning ("Skipping "+$sel[$i]+", it has the attribute already added!\n");continue;}
	if ($attr=="twist/bendy" && `attributeExists twistJoints $sel[$i]`)
		{warning ("Skipping "+$sel[$i]+", it has the attribute already added!\n");continue;}

	if ($attr=="twist/bendy")
		{
		if (`attributeExists inbetweenJoints $sel[$i]`) error "\"inbetweenJoints\" attribute already exists, can not mix `Twist` and `Inbetween`";
		addAttr -k 1 -ln "twistJoints" -at long -min 0 -max 10 -dv 2 $sel[$i];
		addAttr -k 1 -ln "bendyJoints" -at bool -dv 0 $sel[$i];
		//Update geo, if in FitMode
		global int $asFitModeScriptJobNr1;
		if ($asFitModeScriptJobNr1 && `scriptJob -ex $asFitModeScriptJobNr1`)
			if (`checkBox -q -ex asVisGeo`)
				if (`checkBox -q -v asVisGeo`)
					asFitModeUpdateAllGeometry;
		}
	else if ($attr=="inbetween")
		{
		if (`attributeExists twistJoints $sel[$i]`) error "\"twistJoints\" attribute already exists, can not mix `Twist` and `Inbetween`";
		if (`attributeExists bendyJoints $sel[$i]`) error "\"bendyJoints\" attribute already exists, can not mix `Twist` and `Inbetween`";
		addAttr -k 1 -ln "inbetweenJoints" -at long -min 0 -dv 2 $sel[$i]; 
		addAttr -k 1 -ln "unTwister" -at bool -dv 0 $sel[$i];
		}
	else if ($attr=="global")
		{
		addAttr -k 1 -ln $attr -at double -min 0 -max 10 -dv 0 $sel[$i];
		addAttr -k 1 -ln "globalTranslate" -at bool -dv 0 $sel[$i];
		}
	else if ($attr=="worldOrient")
		addAttr -k 1 -ln $attr -at "enum" -en "xUp:yUp:zUp:xDown:yDown:zDown:" -dv 0 $sel[$i];
	else if ($attr=="ikLocal")
		addAttr -k 1 -ln $attr -at "enum" -en "addCtrl:nonZero:localOrient:" -dv 0 $sel[$i];
	else if ($attr=="geoAttach")
		{
		for ($y=0;$y<size($sel);$y++)
			{
			string $tempString[]=`listRelatives -s $sel[$y]`;
			if ($tempString[0]!="")
				if (`objectType $tempString[0]`=="mesh")
					$meshObject=$sel[$y];
			}
		if (size($sel)<2 || $meshObject=="")
			error "Select both FitJoint AND Geometry to attach to";
		addAttr -k 1 -ln $attr -at "enum" -en `substituteAllString $meshObject ":" "__"` $sel[$i];
		addAttr -k 1 -ln ($attr+"Mode") -at "enum" -en "point:orient:parent" -dv 2 $sel[$i];
		select $sel[$i];
		}
	else if ($attr=="curveGuide")
		{
		for ($y=0;$y<size($sel);$y++)
			{
			string $tempString[]=`listRelatives -s $sel[$y]`;
			if ($tempString[0]!="")
				if (`objectType $tempString[0]`=="nurbsCurve")
					$curveObject=$sel[$y];
			}
		if (size($sel)<2 || $curveObject=="")
			error "Select both FitJoint AND Curve";
		addAttr -k 1 -ln $attr -at "enum" -en `substituteAllString $curveObject ":" "__"` $sel[$i];
		addAttr -k 1 -ln ($attr+"Mode") -at "enum" -en "point:aim" -dv 1 $sel[$i];
		select $sel[$i];
		}
	else
		addAttr -k 1 -ln $attr -at bool -dv $dv $sel[$i];
	}
}

global proc asRemoveFitJointAttribute ()
{
string $sel[]=`ls -sl -type joint`;
string $attr=`optionMenu -q -v asAttributeType`;
for ($i=0;$i<size($sel);$i++)
	{
	if (`attributeExists $attr $sel[$i]`)
		deleteAttr ($sel[$i]+"."+$attr);
	if ($attr=="twist/bendy" && `attributeExists "twistJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".twistJoints");
	if ($attr=="twist/bendy" && `attributeExists "bendyJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".bendyJoints");
	if ($attr=="inbetween" && `attributeExists "inbetweenJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".inbetweenJoints");
	if ($attr=="inbetween" && `attributeExists "unTwister" $sel[$i]`)
		deleteAttr ($sel[$i]+".unTwister");
	if ($attr=="geoAttach" && `attributeExists "geoAttachMode" $sel[$i]`)
		deleteAttr ($sel[$i]+".geoAttachMode");
	if ($attr=="global" && `attributeExists "globalTranslate" $sel[$i]`)
		deleteAttr ($sel[$i]+".globalTranslate");
	}
}

global proc asFitDisplayJointAxis  (int $onOff)
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
asEnsureFitSkeletonAttributes;
string $tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -type joint -c $fitJoints[$i]`;
	string $child=$tempString[0];
	if ($child=="")
		continue;
	setAttr ($fitJoints[$i]+".displayLocalAxis") $onOff;
	}
if (`attributeExists visJointAxis FitSkeleton`)
	setAttr FitSkeleton.visJointAxis $onOff;
}

global proc asFitDisplayPoleVector (int $onOff)
{
string $sel[]=`ls -sl`;
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
float $ikLenght;
float $pos1[],$pos2[],$pos3[];
string $ik,$IKParentJoint,$IKMiddleJoint,$IKChildJoint,$IKSolver,$IKNumCtrls;
string $tempString[],$asFitJointIKInfo[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
if ($onOff==0)
	{
	if (`objExists FitSkeletonPoleVectors`) delete FitSkeletonPoleVectors;
	if (`objExists FitSkeletonVisualizers`)
		{
		$tempString=`listRelatives -c FitSkeletonVisualizers`;
		if ($tempString[0]=="")
			delete FitSkeletonVisualizers;
		if (`attributeExists visPoleVector FitSkeleton`)
			setAttr FitSkeleton.visPoleVector 0;
		}
	return;
	}

for ($i=0;$i<size($fitJoints);$i++)
	{
	$asFitJointIKInfo=`asFitJointIKInfo $fitJoints[$i]`;
	if (!size($asFitJointIKInfo))
		continue;

	$ik=$asFitJointIKInfo[0];
	$IKParentJoint=$asFitJointIKInfo[1];
	$IKMiddleJoint=$asFitJointIKInfo[2];
	$IKChildJoint=$asFitJointIKInfo[3];
	$IKSolver=$asFitJointIKInfo[4];
	$IKNumCtrls=$asFitJointIKInfo[5];

	if ($fitJoints[$i]!=$IKParentJoint)
		continue;
	if ($IKSolver!="ikRPsolver")
		continue;

	if (!`objExists FitSkeletonVisualizers`)
		createNode -n FitSkeletonVisualizers transform;
	if (!`objExists FitSkeletonPoleVectors`)
		createNode -n FitSkeletonPoleVectors -p FitSkeletonVisualizers transform;
	asFitModeEnsureShaders;
	asEnsureFitSkeletonAttributes;
	setAttr FitSkeleton.visPoleVector 1;

	//Analyze $ikLenght
	$ikLenght=0;
	$tempString=`listRelatives -ad -type joint $fitJoints[$i]`;
	for ($y=size($tempString)-1;$y>-1;$y--)
		{
		$ikLenght+=`getAttr ($tempString[$y]+".tx")`;
		if ($tempString[$y]==$IKChildJoint)
			break;
		}
	$ikLenght=abs($ikLenght);

	createNode -n tempPoleVecPlacer1 transform;
	createNode -n tempPoleVecPlacer2 -p tempPoleVecPlacer1 transform;
	createNode -n tempPoleVecPlacer3 -p tempPoleVecPlacer2 transform;
	$tempString=`pointConstraint $IKParentJoint $IKChildJoint tempPoleVecPlacer1`;
	setAttr ($tempString[0]+"."+$IKParentJoint+"W0") `getAttr ($IKChildJoint+".tx")`;
	setAttr ($tempString[0]+"."+$IKChildJoint+"W1") `getAttr ($IKMiddleJoint+".tx")`;
	aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject $IKParentJoint $IKMiddleJoint tempPoleVecPlacer2;
	setAttr tempPoleVecPlacer3.tx $ikLenght;

	$pos1=`xform -q -ws -t $IKParentJoint`;
	$pos2=`xform -q -ws -t $IKChildJoint`;
	$pos3=`xform -q -ws -t tempPoleVecPlacer3`;
	delete tempPoleVecPlacer1;
	if (`objExists ("VisualizePoleVector_"+$ik)`) delete ("VisualizePoleVector_"+$ik);
	polyCreateFacet -n ("VisualizePoleVector_"+$ik) -ch 0 -tx 1 -s 1 -p $pos1[0] $pos1[1] $pos1[2] -p $pos2[0] $pos2[1] $pos2[2] -p $pos3[0] $pos3[1] $pos3[2];
	parent ("VisualizePoleVector_"+$ik) FitSkeletonPoleVectors;
	sets -e -forceElement asRedSG ("VisualizePoleVector_"+$ik);
	setAttr ("VisualizePoleVector_"+$ik+".overrideEnabled") 1;
	setAttr ("VisualizePoleVector_"+$ik+".overrideDisplayType") 2;
	}
catchQuiet (`select $sel`);
}

global proc asFitDisplayJointOrient (int $onOff)
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
asEnsureFitSkeletonAttributes;
string $tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	setAttr -k $onOff ($fitJoints[$i]+".jointOrientX");
	setAttr -k $onOff ($fitJoints[$i]+".jointOrientY");
	setAttr -k $onOff ($fitJoints[$i]+".jointOrientZ");
	}
if (`attributeExists visJointOrient FitSkeleton`)
	setAttr FitSkeleton.visJointOrient $onOff;
}

global proc asFitMode ()
{
global int $asFitModeScriptJobNr1;
global int $asFitModeScriptJobNr3;
string $sel[]=`ls -sl`;
int $onOff=1;
if ($asFitModeScriptJobNr1 && `scriptJob -ex $asFitModeScriptJobNr1`)
	$onOff=0;
//asByPassSDK $onOff;
select -cl;
if ($onOff)
	{
	asFitModeManualUpdate;
	$asFitModeScriptJobNr1=`scriptJob -cu 1 -killWithScene -e SelectionChanged asFitModeSelectionChanged`;
	if (`objExists FitSkeleton`)
		$asFitModeScriptJobNr3=`scriptJob -cu 1 -killWithScene -ac FitSkeleton.s asFitModeUpdateScale`;
	headsUpDisplay -s 2 -b 0 -bs "medium" -l "FitMode" -lfs "large" HUDFitMode;
	print "// Entered FitMode\n";
	}
else
	{
	if (`scriptJob -ex $asFitModeScriptJobNr1` && $asFitModeScriptJobNr1!=0)
		{
		scriptJob -kill $asFitModeScriptJobNr1;
		$asFitModeScriptJobNr1=0;
		}
	if (`scriptJob -ex $asFitModeScriptJobNr3`  && $asFitModeScriptJobNr3!=0)
		{
		scriptJob -kill $asFitModeScriptJobNr3;
		$asFitModeScriptJobNr3=0;
		}
	asFitModeSelectionChanged;
	if (`headsUpDisplay -ex HUDFitMode`)
		headsUpDisplay -rem HUDFitMode;
	print "// Exited FitMode\n";
	}
select $sel;
}

global proc asToggleFitAdvancedSkeleton  ()
{
int $fitSkeletonVis=`getAttr FitSkeleton.visibility`;
setAttr -l 0 FitSkeleton.visibility;
setAttr -l 1 FitSkeleton.visibility (!$fitSkeletonVis);
setAttr MotionSystem.visibility $fitSkeletonVis;
setAttr DeformationSystem.visibility $fitSkeletonVis;
if (!$fitSkeletonVis)
	asDrivingSystemToFitSkeleton;
}

global proc asDrivingSystemToFitSkeleton ()
{
if (!`objExists DrivingSystem`)
	return;

if (`attributeExists drivingSystem FitSkeleton`)
	deleteAttr FitSkeleton.drivingSystem;
addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;

string $userAttrs[]=`listAttr -ud -s FitSkeleton`;
for ($i=0;$i<size($userAttrs);$i++)
	if (`gmatch $userAttrs[$i] "drivingSystem_*"`)
		deleteAttr ("FitSkeleton."+$userAttrs[$i]);

string $tempString[];	
string $drivingSystems[]=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	addAttr -k 0 -ln ("drivingSystem_"+$drivingSystems[$i]) -at bool -dv true -multi FitSkeleton;
	int $attrNr=0;
	string $userAttrs[]=`listAttr -ud -s -k $drivingSystems[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		string $sdks[]=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$userAttrs[$y])`;
		for ($z=0;$z<size($sdks);$z++)
			{
			if (!`attributeExists drivingSystemOut $sdks[$z]`) addAttr -k 0 -ln drivingSystemOut -at message $sdks[$z];
			if (`attributeExists $userAttrs[$y] $sdks[$z]`)
				deleteAttr ($sdks[$z]+"."+$userAttrs[$y]);
			string $addAttrCmd="addAttr -k 0 -ln "+$userAttrs[$y]+" -at \"float\" ";
			if (`addAttr -q -hasMinValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasMinValue 1 -minValue "+`addAttr -q -min ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			if (`addAttr -q -hasMaxValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasMaxValue 1 -maxValue "+`addAttr -q -max ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			if (`addAttr -q -hasSoftMinValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasSoftMinValue 1 -softMinValue "+`addAttr -q -softMinValue ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			if (`addAttr -q -hasSoftMaxValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasSoftMaxValue 1 -softMaxValue "+`addAttr -q -softMaxValue ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			$addAttrCmd+=$sdks[$z];
			eval ($addAttrCmd);

			connectAttr -f ("FitSkeleton.drivingSystem_"+$drivingSystems[$i]+"["+$attrNr+"]") ($sdks[$z]+"."+$userAttrs[$y]);
			$tempString=`listConnections ($sdks[$z]+".drivingSystemOut")`;
			if ($tempString[0]!="FitSkeleton")
				connectAttr -na ($sdks[$z]+".drivingSystemOut") FitSkeleton.drivingSystem;
			$attrNr++;
			}
		}
	}
}

global proc string asUniqueName (string $obj)
{
string $newName=$obj;
string $tempString[]=`ls $obj`;
if (size($tempString)>1)
	for ($i=1;$i<99;$i++)
		if (!`objExists ($obj+$i)`)
			{
			$newName=$obj+$i;
			rename $tempString[0] $newName;
			break;
			}
return $newName;
}

global proc asFitModeManualUpdate ()
{
string $sel[]=`ls -sl`;
//asByPassSDK 1;
if (!`objExists FitSkeleton`)
	return;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	$fitJoints[$i]=`asUniqueName $fitJoints[$i]`;

//Also ensure uniqueLabel
string $labelArray[];
for ($i=0;$i<size($fitJoints);$i++)
	{
	string $label=`asLabel $fitJoints[$i]`;
	if ($label=="")
		continue;
	if (!`gmatch $label "*Shoulder*"` && !`gmatch $label "*Hip*"` && !`gmatch $label "*Root*"` && !`gmatch $label "0*"`)
		continue;
	for ($y=0;$y<size($fitJoints);$y++)
		{
		if ($i==$y)
			continue;
		string $otherLabel=`asLabel $fitJoints[$y]`;
		if ($otherLabel==$label)
			{
			string $newLabel;
			for ($a=1;$a<99;$a++)
				{
				$newLabel=$label+$a;
				if (!`stringArrayCount $newLabel $labelArray`)
					break;
				}
			setAttr ($fitJoints[$i]+".type") 18;
			setAttr -type "string" ($fitJoints[$i]+".otherType") $newLabel;
			$labelArray[size($labelArray)]=$newLabel;
			}
		}
	}

for ($i=0;$i<size($fitJoints);$i++)
	{
	asFitModeUpdateJoints $fitJoints[$i] 0;
	asFitModeUpdateFat $fitJoints[$i];
	}
catchQuiet (`select $sel`);
//asByPassSDK 0;
print "// Updated Orientations\n";
}

global proc asFitModeSelectionChanged ()
{
global int $asFitModeScriptJobNr2[];
global string $asFitModeOffRLA[];
for ($i=0;$i<size($asFitModeOffRLA);$i++)
	if (`objExists $asFitModeOffRLA[$i]`)
		setAttr ($asFitModeOffRLA[$i]+".displayLocalAxis") 0;

clear $asFitModeOffRLA;
for ($i=0;$i<size($asFitModeScriptJobNr2);$i++)
	if ($asFitModeScriptJobNr2[$i])
		if (`scriptJob -ex $asFitModeScriptJobNr2[$i]`)
			{
			scriptJob -kill $asFitModeScriptJobNr2[$i];
			$asFitModeScriptJobNr2[$i]=0;
			}
string $sel[]=`ls -sl -type joint`;
string $tempString[];
string $rlaParent,$rlaChild;
float $pos[];
string $aimParents;
for ($i=0;$i<size($sel);$i++)
	{
	//Parent
//	if (size(`ls -ap $sel[$i]`)>1)
//		continue;
	$rlaParent=`asRlaParent $sel[$i]`;
	if (!`objExists $rlaParent`)
		continue;
//	string $parentOtherChildren[]=`listRelatives -c -type joint $rlaParent`;
//	$parentOtherChildren=`stringArrayRemove {$sel[$i]} $parentOtherChildren`;
//	if (size($parentOtherChildren) && $sel[$i]!="BackA")
//		continue;

	if (!`getAttr ($rlaParent+".displayLocalAxis")`)
		$asFitModeOffRLA[$i]=$rlaParent;
	setAttr ($rlaParent+".displayLocalAxis") 1;
	if ($aimParents!="")
		$aimParents+="@";
	$aimParents+=$sel[$i];
	}

for ($i=0;$i<size($sel);$i++)
	{
	//Child
	$rlaChild=`asRlaChild $sel[$i]`;
//	if (size(`ls -ap $rlaChild`)!=1)
//		continue;
	$aimParents+="@"+$rlaChild;
	if (`attributeExists fatYabs $sel[$i]`)
		$asFitModeScriptJobNr2[2]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".fatYabs") ("asFitModeUpdateFat \""+$sel[$i]+"\"")`;
	if (`attributeExists fatZabs $sel[$i]`)
		$asFitModeScriptJobNr2[3]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".fatZabs") ("asFitModeUpdateFat \""+$sel[$i]+"\"")`;
	if (`attributeExists twistJoints $sel[$i]`)
		$asFitModeScriptJobNr2[3]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".twistJoints") ("asFitModeUpdateAllGeometry")`;

	}
if ($aimParents!="")
	{
	$asFitModeScriptJobNr2[0]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".translate") ("asFitModeUpdateJoints \""+$aimParents+"\" 0")`;
	$asFitModeScriptJobNr2[1]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".rotate") ("asFitModeUpdateJoints \""+$aimParents+"\" 0")`;
	}
}

global proc asFitModeLockCenterJoints ()
{
string $sel[]=`ls -sl`;
if (!`objExists FitSkeleton`)
	return;
int $lock=`getAttr FitSkeleton.lockCenterJoints`;
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;
float $pos[],$pos2[];
string $fitSkeletonJoints[]=`listRelatives -f -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitSkeletonJoints);$i++)
	{
	$pos=`xform -q -ws -t $fitSkeletonJoints[$i]`;
	if ($lock)
		if ($pos[0]<-$centerTolerance || $pos[0]>$centerTolerance)
			continue;

	$tempString=`listRelatives -p $fitSkeletonJoints[$i]`;
	$parent=$tempString[0];
	createNode -n transformSampler -p $parent transform;

	setAttr -type float3 transformSampler.t 1 0 0;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l $lock ($fitSkeletonJoints[$i]+".tx");

	setAttr -type float3 transformSampler.t 0 1 0;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l $lock ($fitSkeletonJoints[$i]+".ty");

	setAttr -type float3 transformSampler.t 0 0 1;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l $lock ($fitSkeletonJoints[$i]+".tz");

	delete transformSampler;
	setAttr -l $lock ($fitSkeletonJoints[$i]+".rx");
	setAttr -l $lock ($fitSkeletonJoints[$i]+".ry");
	}
select $sel;
}

global proc asPlacementCopy ()
{
global string $gMove;
setToolTo $gMove;
float $pos[]=`manipMoveContext -q -position "Move"`;
button -e -en 1 -ann ($pos[0]+" "+$pos[1]+" "+$pos[2]) asPlacementPasteButton;
}

global proc asPlacementPaste ()
{
int $editPivotMode=`manipMoveContext -q -editPivotMode Move`;
string $sel[]=`ls -sl`;
string $ann=`button -q -ann asPlacementPasteButton`;
string $buffer[];
tokenize $ann $buffer;

for ($i=0;$i<size($sel);$i++)
	if ($editPivotMode)
		move -a $buffer[0] $buffer[1] $buffer[2] ($sel[$i]+".scalePivot") ($sel[$i]+".rotatePivot");
	else
		move -a $buffer[0] $buffer[1] $buffer[2] $sel[$i];
}

global proc asFitModeUpdateFat (string $joint)
{
string $rlaParent=`asRlaParent $joint`;
//update flare
if (`objExists ($rlaParent+"GapBlenderA")`)
	if (`attributeExists dummyInput1 ($rlaParent+"GapBlenderA")`)
		{
		setAttr ($rlaParent+"GapBlenderA"+".input[1]") `getAttr ($rlaParent+"GapBlenderA"+".dummyInput1")`;
		setAttr ($rlaParent+"GapBlenderB"+".input[1]") `getAttr ($rlaParent+"GapBlenderB"+".dummyInput1")`;
		}
}

global proc asFitModeUpdateAllGeometry ()
{
checkBox -e -v 0 asVisGeo;
asFitGeometry;
checkBox -e -v 1 asVisGeo;
asFitGeometry;
}

global proc asFitModeUpdateScale ()
{
if (!`objExists FitSkeleton`)
	return;
float $fitSkeletonScale[3]=`getAttr FitSkeleton.s`;
if ($fitSkeletonScale[0]==1 && $fitSkeletonScale[1]==1 && $fitSkeletonScale[2]==1)
	return;
float $pos[];
string $sel[]=`ls -sl`;
int $lockTxs[],$lockTys[],$lockTzs[];
string $fitJointsParent[],$tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
string $generatedTransform;

setAttr -type float3 FitSkeleton.s 1 1 1;
for ($i=0;$i<size($fitJoints);$i++)
	{
	$lockTxs[$i]=`getAttr -l ($fitJoints[$i]+".tx")`;$lockTys[$i]=`getAttr -l ($fitJoints[$i]+".ty")`;$lockTzs[$i]=`getAttr -l ($fitJoints[$i]+".tz")`;
	setAttr -l 0 ($fitJoints[$i]+".tx");setAttr -l 0 ($fitJoints[$i]+".ty");setAttr -l 0 ($fitJoints[$i]+".tz");
	}
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -p $fitJoints[$i]`;
	$generatedTransform="";
	if ($tempString[0]!="" && `objectType $tempString[0]`=="transform" && $tempString[0]!="FitSkeleton")
		{
		$generatedTransform=$tempString[0];
		$tempString=`listRelatives -p $generatedTransform`;
		}
	$fitJointsParent[$i]=$tempString[0];
	parent -w $fitJoints[$i];
	if ($generatedTransform!="")
		delete $generatedTransform;
	$tempString=`listRelatives -p $fitJoints[$i]`;
	$generatedTransform=$tempString[0];
	if ($generatedTransform!="")//generated Xform
		{
		$pos=`xform -q -ws -t $fitJoints[$i]`;
		setAttr -type float3 ($generatedTransform+".s") 1 1 1;
		parent -w $fitJoints[$i];
		xform -ws -t $pos[0] $pos[1] $pos[2] $fitJoints[$i];
		delete $generatedTransform;
		}
	}
for ($i=0;$i<size($fitJoints);$i++)
	{
	$pos=`xform -q -ws -t $fitJoints[$i]`;
	xform -ws -t ($pos[0]*$fitSkeletonScale[0]) ($pos[1]*$fitSkeletonScale[1]) ($pos[2]*$fitSkeletonScale[2]) $fitJoints[$i];
	if (`attributeExists fat $fitJoints[$i]`) setAttr ($fitJoints[$i]+".fat") (`getAttr ($fitJoints[$i]+".fat")`*$fitSkeletonScale[1]);
	}
for ($i=0;$i<size($fitJoints);$i++)
	if (`objExists $fitJointsParent[$i]`)
		parent $fitJoints[$i] $fitJointsParent[$i];
for ($i=0;$i<size($fitJoints);$i++)
	{
	setAttr -l $lockTxs[$i] ($fitJoints[$i]+".tx");setAttr -l $lockTys[$i] ($fitJoints[$i]+".ty");setAttr -l $lockTzs[$i] ($fitJoints[$i]+".tz");
	}
scale -r -p 0 0 0 $fitSkeletonScale[1] $fitSkeletonScale[1] $fitSkeletonScale[1] FitSkeletonShape.cv[0:7] ;
asFitModeManualUpdate;
select $sel;
}

global proc asFitModeUpdateJoints (string $jointsString, int $recursive)
{
int $upV[3]={0,1,0};
int $childNr,$newChildNr,$reachedKneeJoint,$flipOrient;
int $editPivotMode=`manipMoveContext -q -editPivotMode Move`;
float $scale=1;
float $pos[],$pos2[];
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
float $centerTolerance=0.01*$scale;
asFitModeUpdateScale;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$tempString3[],$joints[],$jointAllDescendents[],$otherJointsInIK[];
string $connectCmds[],$rlaParentChildren[],$newRlaParentChildren[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $generatedTransform1,$generatedTransform2,$IKParentJoint,$IKChildJoint,$jointLongName,$worldOrient,$upVecObj;
string $rlaParent,$rlaParentLabel,$rlaChild,$rlaParentRlaChild,$label,$tempLabel,$joint,$aimAt;
tokenize $jointsString "@" $joints;
for ($joint in $joints)
	{
	if (size(`ls -ap $joint`)!=1)
		continue;
	$label=`asLabel $joint`;
	$rlaParent=`asRlaParent $joint`;
	$rlaParent=`asUniqueName $rlaParent`;
	$rlaParentLabel=`asLabel $rlaParent`;
	string $rlaChild=`asRlaChild $joint`;
	$rlaChild=`asUniqueName $rlaChild`;

	int $childNr=0;
	clear $rlaParentChildren;
	if ($rlaParent!="")
		{
		$rlaParentRlaChild=`asRlaChild $rlaParent`;
		$rlaParentChildren=`listRelatives -type joint -c $rlaParent`;
		if (size($rlaParentChildren)>1)
			for ($i=0;$i<size($rlaParentChildren);$i++)
				{
				if ($joint==$rlaParentChildren[$i])
					$childNr=$i;
				}
		}
	if (!`objExists $rlaParent`)
		continue;
	if (`attributeExists freeOrient $rlaParent`)
		continue;
	if (`asRlaChild $rlaParent`!=$joint && $rlaParent!="Cup")
		continue;
	$worldOrient="";
	if (`attributeExists worldOrient $rlaParent`)
		$worldOrient=`getAttr ($rlaParent+".worldOrient")`;
	$flipOrient=0;
	if (`attributeExists flipOrient $joint`)
		if (`getAttr ($joint+".flipOrient")`)
			$flipOrient=!$flipOrient;
	string $rlaParentParent=`asRlaParent $rlaParent`;
	clear $otherJointsInIK;
	$tempString=`ls -l $joint`;
	$jointLongName=$tempString[0];
	$jointAllDescendents=`listRelatives -allDescendents -type joint $joint`;
	$jointAllDescendents[size($jointAllDescendents)]=$joint;
	string $parentOtherChildren[]=`listRelatives -c $rlaParent`;
	$parentOtherChildren=`stringArrayRemove {$joint} $parentOtherChildren`;
	int $center=0;
	$pos=`xform -q -ws -t $joint`;
	if ($pos[0]>-$centerTolerance && $pos[0]<$centerTolerance) $center=1;

	//IK-plane ($flip)
	tokenize $jointLongName "|" $tempString;
	for ($i=size($tempString)-1;$i>-1;$i--)
		{
		if (!$recursive)
			if (!`stringArrayCount $tempString[$i] $joints`)
				$otherJointsInIK[size($otherJointsInIK)]=$tempString[$i];
		if (`attributeExists flipOrient $tempString[$i]`)
			if (`getAttr ($tempString[$i]+".flipOrient")`)
				$flipOrient=!$flipOrient;
		$tempLabel=`asLabel $tempString[$i]`;
		if (`gmatch $tempLabel "*Shoulder*"` || `gmatch $tempLabel "*Hip*"`)
			{
			$IKParentJoint=$tempString[$i];
			break;
			}
		}
	for ($i=size($jointAllDescendents)-1;$i>-1;$i--)
		{
		if (!$recursive)
			if (!`stringArrayCount $jointAllDescendents[$i] $joints`)
				$otherJointsInIK[size($otherJointsInIK)]=$jointAllDescendents[$i];
		$tempLabel=`asLabel $jointAllDescendents[$i]`;
		if (`gmatch $tempLabel "*Hand*"` || `gmatch $tempLabel "*Foot*"`)
			{$IKChildJoint=$jointAllDescendents[$i];break;}
		}

	int $lockTX=`getAttr -l ($joint+".tx")`;int $lockTY=`getAttr -l ($joint+".ty")`;int $lockTZ=`getAttr -l ($joint+".tz")`;
	int $lockRX=`getAttr -l ($joint+".rx")`;int $lockRY=`getAttr -l ($joint+".ry")`;int $lockRZ=`getAttr -l ($joint+".rz")`;
	int $lockPTX=`getAttr -l ($rlaParent+".tx")`;int $lockPTY=`getAttr -l ($rlaParent+".ty")`;int $lockPTZ=`getAttr -l ($rlaParent+".tz")`;
	int $lockPRX=`getAttr -l ($rlaParent+".rx")`;int $lockPRY=`getAttr -l ($rlaParent+".ry")`;int $lockPRZ=`getAttr -l ($rlaParent+".rz")`;
	setAttr -l 0 ($joint+".tx");setAttr -l 0 ($joint+".ty");setAttr -l 0 ($joint+".tz");
	setAttr -l 0 ($joint+".rx");setAttr -l 0 ($joint+".ry");setAttr -l 0 ($joint+".rz");
	setAttr -l 0 ($rlaParent+".tx");setAttr -l 0 ($rlaParent+".ty");setAttr -l 0 ($rlaParent+".tz");
	setAttr -l 0 ($rlaParent+".rx");setAttr -l 0 ($rlaParent+".ry");setAttr -l 0 ($rlaParent+".rz");

	if (size($parentOtherChildren))
		{
		createNode -n otherChildrenPlaceHolder -p $rlaParent transform;
		parent -w otherChildrenPlaceHolder;
		}
	for ($i=0;$i<size($parentOtherChildren);$i++)
		{
		$tempString=`parent $parentOtherChildren[$i] otherChildrenPlaceHolder`;
		$parentOtherChildren[$i]=$tempString[0];
		}
		
	$tempString=`parent -w $joint`;
	$joint=$tempString[0];
	$tempString=`listRelatives -p $joint`;
	if (size($tempString))
		$generatedTransform1=$tempString[0];

	//disconnect connections
	clear $connectCmds;
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			$tempString=`listConnections -p 1 ($rlaParent+"."+$trs[$y]+$xyz[$z])`;
			if ($tempString[0]!="")
				{
				$connectCmds[size($connectCmds)]="connectAttr -f "+$tempString[0]+" "+$rlaParent+"."+$trs[$y]+$xyz[$z]+";";
				disconnectAttr $tempString[0] ($rlaParent+"."+$trs[$y]+$xyz[$z]);
				}
			}

	if ($center && $joint==$rlaParentRlaChild) // Center
		{
		$upV={0,0,1}; if ($flipOrient) $upV={0,0,-1};
		$tempString=`aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "vector" -worldUpVector 1 0 0 $joint $rlaParent`;
		delete $tempString[0];
		}
	if (($IKParentJoint=="" || $IKChildJoint=="") && !$center) // Non-IK (side)
		{
		$upV={0,1,0}; // if ($flipOrient) $upV={0,-1,0}; These are free oriented, so no flip
		$upVecObj=`createNode joint`;
		parent -r $upVecObj $rlaParent;
		setAttr ($upVecObj+".translate") 0 3 0;
		parent -w $upVecObj;
		$tempString=`listRelatives -p $upVecObj`;
		if (size($tempString))
			$generatedTransform2=$tempString[0];
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0] $upVecObj;
		}

	if (($IKParentJoint!="" && $IKChildJoint!="") && !$center) // IK
		{
		$upV={0,1,0}; if ($flipOrient) $upV={0,-1,0};
		$tempLabel=`asLabel $IKParentJoint`;
		if (`gmatch $tempLabel "*Hip*"`)
			$upV={0,-1,0};
			$upVecObj=`createNode joint`;
		parent -r $upVecObj $rlaParent;
		setAttr ($upVecObj+".translate") 0 3 0;
		parent -w $upVecObj;
		$tempString=`listRelatives -p $upVecObj`;
		if (size($tempString))
			$generatedTransform2=$tempString[0];
		pointConstraint $IKParentJoint $IKChildJoint $upVecObj;
		if ($rlaParent==$IKParentJoint)
			{
			$tempString=`aimConstraint -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj $joint $rlaParent`;
			//All Legs should have Y forwards, even `reverse-legs`.
			createNode -n tempTransform -p $rlaParent transform;
			setAttr tempTransform.ty 1;
			$pos=`xform -q -ws -t $rlaParent`;
			$pos2=`xform -q -ws -t tempTransform`;
			delete tempTransform;
			if ($pos2[2]<$pos[2])
				setAttr ($tempString[0]+".upVectorY") (`getAttr ($tempString[0]+".upVectorY")`*-1);
			}
		else
			{
			delete `orientConstraint $IKParentJoint $upVecObj`;
			$tempString=`aimConstraint -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "objectrotation" -worldUpVector $upV[0] $upV[1] $upV[2] -worldUpObject $upVecObj $joint $rlaParent`;
			}
		delete $tempString[0];
		delete $upVecObj;
		}
	else
		clear $otherJointsInIK;

	//Special case, $worldOrient
	if ($worldOrient!="" && `objExists $rlaParentParent`)
		{
		$upVecObj=$rlaParentParent;
		$upVecObj=`createNode -n tempUpVector -p $joint transform`;
		parent -w $upVecObj;
		move -r -ws 0 1 0 $upVecObj;
		float $upVec=1;
		parent $upVecObj $rlaParentParent;
/* was re-introduced in 5.242 to improve on twisted skinCage, but caused reversed Roll. re-removed in 5.321
		//Could be `reverse-knee`
		if (!`attributeExists reverseKnee $rlaParent`)
			addAttr -k 0 -ln reverseKnee -at bool -dv 0 $rlaParent;
		if (`getAttr ($upVecObj+".ty")`<0)
			{
			$upVec=-1;
			setAttr ($rlaParent+".reverseKnee") 1;
			}
*/
		createNode -n tempAimAt -p $rlaParent transform;
		parent -w tempAimAt;
		move -r -ws 0 -1 0 tempAimAt;
		if ($worldOrient==0) $tempString=`aimConstraint -aimVector -1 0 0 -upVector 0 $upVec 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==1) $tempString=`aimConstraint -aimVector 0 -1 0 -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==2) $tempString=`aimConstraint -aimVector 0 0 -1 -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==3) $tempString=`aimConstraint -aimVector 1 0 0  -upVector 0 $upVec 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==4) $tempString=`aimConstraint -aimVector 0 1 0  -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==5) $tempString=`aimConstraint -aimVector 0 0 1  -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;

		delete $tempString[0] $upVecObj tempAimAt;
		}

	//Special case, Scapula
	if (`gmatch $rlaParent "Scapula*"` && $IKParentJoint!="")
		{
		$upVecObj=$IKParentJoint;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, LegAim
	if (`gmatch $rlaParentLabel "LegAim*"`)
		{
		$upVecObj=$IKParentJoint;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, Cup
	if ($rlaParent=="Cup" && `objExists RingFinger1` && `objExists MiddleFinger1`)
		{
		$upVecObj=`asRlaParent $rlaParent`;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVecObj RingFinger1 MiddleFinger1 $rlaParent`;
		delete $tempString[0];
		}
	//Special case, Eyes
	if (`gmatch $rlaParent "Eye*"`)
		{
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 -1 0 -worldUpType "vector" -worldUpVector 0 1 0 $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, Root with no centered child
	if ($rlaParent=="Root" && !$center)
		{
		setAttr -type float3 ($rlaParent+".rotate") 0 0 0;
		setAttr -type float3 ($rlaParent+".jointOrient") 90 0 90;
		}

	makeIdentity -a 1 -t 0 -r 1 -s 0 $rlaParent;

	if (size($parentOtherChildren))
		{
		parent $parentOtherChildren $rlaParent;
		delete otherChildrenPlaceHolder;
		}

	parent $joint $rlaParent;
	//restore sibiling order
	if (size($rlaParentChildren)>1)
		{
		$newRlaParentChildren=`listRelatives -type joint -c $rlaParent`;
		for ($i=0;$i<size($newRlaParentChildren);$i++)
			{
			if ($joint==$newRlaParentChildren[$i])
				$newChildNr=$i;
			}
		if ($newChildNr!=$childNr)
			reorder -relative ($childNr-$newChildNr) $joint;
		}
	if (`objExists $generatedTransform1`) delete $generatedTransform1;
	if (`objExists $generatedTransform2`) delete $generatedTransform2;

	//restore connections
	for ($i=0;$i<size($connectCmds);$i++)
		if (catchQuiet (`eval ($connectCmds[$i])`)) 
			warning ("Failed: "+$connectCmds[$i]+"\n");

	//update lenght
	if (`objExists ($rlaParent+"ScaleYMultiDiv1")`)
		setAttr ($rlaParent+"ScaleYMultiDiv1.input1Y") (`getAttr ($rlaParent+"ScaleYMultiDiv1.dummyInput1Y")`*(1.0/$scale));

	//update skeleton scale
	if (`objExists ($rlaParent+"Bone")` && `objExists ($rlaParent+"Distance")`)
		{
		float $lenght=`getAttr ($rlaParent+"Distance.distance")`*(1.0/$scale);
		setAttr ($rlaParent+"Bone.sx") $lenght;
		}

	//update scale from FitSkeleton
//	if (`objExists ($joint+"Aim")`)
//		setAttr ($joint+"Aim.sx") (1.0/$scale);

	setAttr -l $lockTX ($joint+".tx");setAttr -l $lockTY ($joint+".ty");setAttr -l $lockTZ ($joint+".tz");
	setAttr -l $lockRX ($joint+".rx");setAttr -l $lockRY ($joint+".ry");setAttr -l $lockRZ ($joint+".rz");
	setAttr -l $lockPTX ($rlaParent+".tx");setAttr -l $lockPTY ($rlaParent+".ty");setAttr -l $lockPTZ ($rlaParent+".tz");
	setAttr -l $lockPRX ($rlaParent+".rx");setAttr -l $lockPRY ($rlaParent+".ry");setAttr -l $lockPRZ ($rlaParent+".rz");
	}

//Update the other joints in the same IK to ensure IK-plane
for ($i=0;$i<size($otherJointsInIK);$i++)
	asFitModeUpdateJoints $otherJointsInIK[$i] 1;
if (`objExists FitSkeletonPoleVectors`) {asFitDisplayPoleVector 0;asFitDisplayPoleVector 1;}
select $sel;
//Restore `insert-mode`, as newer version of Maya will drop this when:createNode
if ($editPivotMode)
	if (!`manipMoveContext -q -editPivotMode Move`)
		EnterEditMode;
}

global proc string[] asFitJointIKInfo (string $joint)
{
int $IKNumCtrls=2;
string $ik,$IKParentJoint,$IKMiddleJoint,$IKChildJoint,$IKSolver,$IKParentJointLabel;
string $asFitJointIKInfo[],$tempString[];
$tempString=`ls -l $joint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	$label=`asLabel $tempString[$i]`;
//	if ($i<size($tempString)-1)
//		if (`gmatch $label "*Hand*"` || `gmatch $label "*Foot*"` || `gmatch $label "*Chest*"`)
//			break;
	if (`gmatch $label "*Shoulder*"` || `gmatch $label "*Hip*"` || `gmatch $label "*Root*"` || `gmatch $label "0*"`)
		{
		$IKParentJoint=$tempString[$i];
		$IKParentJointLabel=$label;
		break;
		}
	}

string $jointAllDescendents[]=`listRelatives -allDescendents -type joint $joint`;
string $anotherSpineIkJoints[];
$jointAllDescendents[size($jointAllDescendents)]=$joint;
for ($i=size($jointAllDescendents)-1;$i>-1;$i--)
	{
	$label=`asLabel $jointAllDescendents[$i]`;
	int $validLabelHit=0;
	if (`gmatch $label "*Hand*"` && `gmatch $IKParentJointLabel "*Shoulder*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Foot*"` && `gmatch $IKParentJointLabel "*Hip*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Toes*"` && `gmatch $IKParentJointLabel "*Hip*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Chest*"` && `gmatch $IKParentJointLabel "*Root*"`)
		$validLabelHit=1;
	if ($validLabelHit)
		{
		$IKChildJoint=$jointAllDescendents[$i];
		break;
		}
	if (`gmatch $label "0*"` && $jointAllDescendents[$i]!=$joint)//track $anotherSpineIkJoints, so $IKChildJoint is not from another SplineIK
		{
		$tempString=`listRelatives -allDescendents -type joint $jointAllDescendents[$i]`;
		$anotherSpineIkJoints=`stringArrayCatenate $anotherSpineIkJoints $tempString`;
		}
	if (`gmatch $label "*[1-9]*"` && `gmatch $IKParentJointLabel "*0*"` && !`stringArrayCount $jointAllDescendents[$i] $anotherSpineIkJoints`)
		$IKChildJoint=$jointAllDescendents[$i];
	}

if ($IKParentJoint!= "" && $IKChildJoint!="")
	{
	//Find $IKMiddleJoint
	$tempString=`ls -l $IKChildJoint`;
	tokenize $tempString[0] "|" $tempString;
	int $numIkJoints=0;
	for ($i=size($tempString)-1;$i>-1;$i--)
		{
		$numIkJoints++;
		if ($tempString[$i]==$IKParentJoint)
		break;
		}
	int $middleNr=$numIkJoints/2;
	$IKMiddleJoint=$tempString[size($tempString)-1-$middleNr];
	//Find $IKNumCtrls
	$tempString=`ls -l $IKChildJoint`;
	tokenize $tempString[0] "|" $tempString;
	for ($i=size($tempString)-2;$i>-1;$i--)
		{
		if ($tempString[$i]==$IKParentJoint)
		break;
		$label=`asLabel $tempString[$i]`;
		if (`gmatch $label "*Mid*"` || `gmatch $label "[0-9]*"`)
			$IKNumCtrls++;
		}

	$IKSolver="ikRPsolver";
	$label=`asLabel $IKParentJoint`;
	if (`gmatch $label "*Shoulder*"`)
		$ik="Arm"+`substitute "Shoulder" $label ""`;
	if (`gmatch $label "*Hip*"`)
		$ik="Leg"+`substitute "Hip" $label ""`;
	if (`gmatch $label "*Root*"`)
		{
		$ik="Spine"+`substitute "Root" $label ""`;
		$IKSolver="ikSplineSolver";
		}
	if (`gmatch $label "*0*"`)
		{
		$ik="Spline"+`substitute "[0-9]*" $label ""`;
		$IKSolver="ikSplineSolver";
		}

	$asFitJointIKInfo[0]=$ik;
	$asFitJointIKInfo[1]=$IKParentJoint;
	$asFitJointIKInfo[2]=$IKMiddleJoint;	
	$asFitJointIKInfo[3]=$IKChildJoint;	
	$asFitJointIKInfo[4]=$IKSolver;
	$asFitJointIKInfo[5]=$IKNumCtrls;
	}

return $asFitJointIKInfo;
}

global proc string[] asGetIKJoints (string $IKStartJoint, string $IKEndJoint)
{
string $IKJoints[];
string $tempString[]=`ls -l $IKEndJoint`;
tokenize $tempString[0] "|" $tempString;
int $foundStartJoint=0;
for ($i=0;$i<size($tempString);$i++)
	{
    if ($tempString[$i]==$IKStartJoint)
        $foundStartJoint=1;
    if ($foundStartJoint)
    	$IKJoints[size($IKJoints)]=$tempString[$i];
	}
return $IKJoints;
}

global proc asFitSDKCreateAttribute ()
{
global string $asFitSDKMessage;
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$drivenObjs[],$drivenAttrs[];
float $drivenDefaultValue[],$drivenValue[];
if (!size($sel))
	warning "Nothing selected, you should select a SDK Object first\n";
else
	$tempString=`listRelatives -c $sel[0]`;
if ($tempString[0]=="")
	error "Selected Object is not a nurbsCurve\n";
if (`objectType $tempString[0]`!="nurbsCurve")
	error "Selected Object is not a nurbsCurve\n";
$existingDefaultPoseCmdString=`getAttr ($sel[0]+".defaultPose")`;
$existingDefaultPoseCmds=`stringToStringArray $existingDefaultPoseCmdString ";"`;

string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $cmd;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
		{
		$objAttr=$fitJoints[$i]+"."+$trs[$y]+$xyz[$z];
		float $value=`getAttr $objAttr`;
		for ($a=0;$a<size($existingDefaultPoseCmds);$a++)
			if (`gmatch $existingDefaultPoseCmds[$a] ("setAttr "+$objAttr+" *")`)
				{
				tokenize $existingDefaultPoseCmds[$a] $tempString;
				float $defaultValue=$tempString[2];
				if ($value>$defaultValue+0.001 || $value<$defaultValue-0.001)
					{
					tokenize $tempString[1] "." $tempString2;
					$drivenObjs[size($drivenObjs)]=$tempString2[0];
					$drivenAttrs[size($drivenAttrs)]=$tempString2[1];
					$drivenDefaultValue[size($drivenDefaultValue)]=$defaultValue;
					$drivenValue[size($drivenValue)]=$value;
					}
				}
		}
if (!size($drivenObjs))
	error "Found No attributes changed from Default Pose";

string $suggestAttrName;
if (`gmatch $drivenObjs[0] "*Finger*"` || `gmatch $drivenObjs[0] "*Toe*"`)
	{
	$suggestAttrName=`substitute "[0-9]" $drivenObjs[0] ""`;
	$suggestAttrName=`substitute "Finger" $suggestAttrName ""`;
	$suggestAttrName=`substitute "Toe" $suggestAttrName ""`;
	$suggestAttrNameFirstLetter=`substring $suggestAttrName 1 1`;
	$suggestAttrName=`tolower $suggestAttrNameFirstLetter`+`substring $suggestAttrName 2 99`+"Curl";
	}

$asFitSDKMessage="Create Set-Driven-Key for these ?\n\n";
for ($i=0;$i<size($drivenObjs);$i++)
	{
	float $value=`getAttr ($drivenObjs[$i]+"."+$drivenAttrs[$i])`;
	float $roundFactor=0.5;
	if ($value<0) $roundFactor=-0.5;
	$value=(trunc($value*`pow 10 3`+$roundFactor)/`pow 10 3`); //round to precition of 3
	$asFitSDKMessage+=$drivenObjs[$i]+"."+$drivenAttrs[$i]+" = "+$value+"\n";
	}
$asFitSDKAttrName=$suggestAttrName;
$asFitSDKObjName=$sel[0];
$asFitSDKDriverValue=10;

string $dialogResult=`layoutDialog -t "Confirm" -ui asFitSDKCreateAttributeLayout`;
if ($dialogResult!="OK")
	return;

string $attrName=$asFitSDKAttrName;
if ($attrName=="" || `gmatch $attrName "* *"`)
	error "Not a valid attribute name";	
if (`attributeExists $attrName $sel[0]`)
	deleteAttr ($sel[0]+"."+$attrName);
addAttr -k 1 -ln $attrName -at double $sel[0];
if ($asFitSDKDriverHasMin) addAttr -e -softMinValue $asFitSDKDriverMin ($sel[0]+"."+$attrName);
if ($asFitSDKDriverHasMax) addAttr -e -softMaxValue $asFitSDKDriverMax ($sel[0]+"."+$attrName);

for ($i=0;$i<size($drivenObjs);$i++)
	{
	float $driverValue=10;
	$objAttr=$drivenObjs[$i]+"."+$drivenAttrs[$i];
	setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenDefaultValue[$i] -dv 0 -cd ($sel[0]+"."+$attrName) $objAttr;
	setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenValue[$i] -dv $asFitSDKDriverValue -cd ($sel[0]+"."+$attrName) $objAttr;
//	setAttr ($sel[0]+"."+$attrName) $driverValue;
	}
select $drivenObjs;
setInfinity -pri cycleRelative -poi cycleRelative;

select $sel;
}

global proc asFitSDKCreateAttributeLayout ()
{
global string $asFitSDKMessage;
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
string $tempString[];
tokenize $asFitSDKMessage "\n" $tempString;
int $maxTextLines=35;
if (size($tempString)>$maxTextLines)
	{
	$asFitSDKMessage="";
	for ($i=0;$i<$maxTextLines;$i++)
		$asFitSDKMessage+=$tempString[$i]+"\n";
	$asFitSDKMessage+="...And "+(size($tempString)-$maxTextLines)+" more..";
	}
columnLayout;
	text -l $asFitSDKMessage;
	separator -h 10 -st none;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Name:";
		textField -w 80 -tx $asFitSDKAttrName asFitSDKAttrNameTextField;
		setParent..;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Value:";
		floatField -w 50 -v $asFitSDKDriverValue -pre 1 asFitSDKDriverValueFloatField;
		setParent..;
	separator -st none -h 3;
	rowLayout -nc 3 -cw3 10 85 85;
		separator;
		checkBox -l "Min" -v 1 -onc "floatField -e -en 1 asFitSDKDriverMinFloatField" -ofc "floatField -e -en 0 asFitSDKDriverMinFloatField" asFitSDKDriverHasMinCheckBox;
		checkBox -l "Max" -v 1 -onc "floatField -e -en 1 asFitSDKDriverMaxFloatField" -ofc "floatField -e -en 0 asFitSDKDriverMaxFloatField" asFitSDKDriverHasMaxCheckBox;
		setParent..;
	rowLayout -nc 3 -cw3 10 85 85;
		separator;
		floatField -w 50 -v 0 -pre 1 asFitSDKDriverMinFloatField;
		floatField -w 50 -v $asFitSDKDriverValue -pre 1 asFitSDKDriverMaxFloatField;
		setParent..;
	separator -h 10 -st none;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "asFitSDKCreateAttributeGetName;layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;
}

global proc asFitSDKCreateAttributeGetName ()
{
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
$asFitSDKAttrName=`textField -q -tx asFitSDKAttrNameTextField`;
$asFitSDKDriverValue=`textField -q -tx asFitSDKDriverValueFloatField`;
$asFitSDKDriverHasMin=`checkBox -q -v asFitSDKDriverHasMinCheckBox`;
$asFitSDKDriverHasMax=`checkBox -q -v asFitSDKDriverHasMaxCheckBox`;
$asFitSDKDriverMin=`floatField -q -v asFitSDKDriverMinFloatField`;
$asFitSDKDriverMax=`floatField -q -v asFitSDKDriverMaxFloatField`;
}

global proc string asRlaParent (string $joint)
{
string $tempString[]=`listRelatives -p -type joint $joint`;
string $rlaParent=$tempString[0];
return $rlaParent;
}

global proc string asRlaChild (string $joint)
{
float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
float $centerTolerance=0.01*$scale;
string $children[]=`listRelatives -type joint -c $joint`;
string $rlaChild="";
float $pos[3]=`xform -q -ws -t $joint`;
int $center=0;
if ($pos[0]>-$centerTolerance && $pos[0]<$centerTolerance) $center=1;
for ($y=0;$y<size($children);$y++)
	{
	float $childPos[3]=`xform -q -ws -t $children[$y]`;
	int $childCenter=0;
	if ($childPos[0]>-$centerTolerance && $childPos[0]<$centerTolerance) $childCenter=1;
	if ($center && $childCenter) $rlaChild=$children[$y];
	if (!$center && !$childCenter) $rlaChild=$children[$y];
	//Use `first` child as $rlaChild
	if ($rlaChild!="")
	 break;
	}

//if (!$center && size($children)>1)
//	$rlaChild="";

//Preferred $rlaChild
if (`gmatch $joint "*Head*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Head*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Ankle*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Toes*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Toes*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Toes*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Root*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Spine*"`)
			$rlaChild=$children[$y];

return $rlaChild;
}

global proc asFitGeometry ()
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
asEnsureFitSkeletonAttributes;
string $sel[]=`ls -sl`;
int $displayGeometry=`checkBox -q -v asVisGeo`;
int $visPoleVector;
if (`attributeExists visPoleVector FitSkeleton`) $visPoleVector=`getAttr FitSkeleton.visPoleVector`;
if (`objExists FitSkeletonVisualizers`) delete FitSkeletonVisualizers;
if (`objExists Mannequin_Geometry`) delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`) delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`) delete SkinCage_Geometry;
if ($displayGeometry==0)
	{
	asUpdateButtonEnables;
	if ($visPoleVector) asFitDisplayPoleVector 1;
	return;
	}
asFitModeEnsureShaders;
int $twistJoints,$inbetweenJoints;
float $aimV[3]={1,0,0};
float $upV[3]={0,1,0};
string $part;

createNode -n FitSkeletonVisualizers transform;
connectAttr FitSkeleton.s FitSkeletonVisualizers.s;
createNode -n Aims -p FitSkeletonVisualizers transform;
string $tempString[],$geoObjs[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;
string $templateBones[]=`listRelatives -c Skeleton_Geometry`;
for ($i=0;$i<size($templateBones);$i++)
	rename $templateBones[$i] ($templateBones[$i]+"_template");

for ($i=size($fitJoints)-1;$i>-1;$i--) // Reverse order, so endJoints can copy `fat` value from parent
	asEnsureFitJointAttrs $fitJoints[$i];

for ($i=0;$i<size($fitJoints);$i++)
	{
	clear $geoObjs;
	string $rlaChild=`asRlaChild $fitJoints[$i]`;
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	if ($rlaChild=="" && $fitJoints[$i]=="Root" && $tempString[0]!="") // Root to use sideChild, if no middleChild
		$rlaChild=$tempString[0];
	if ($rlaChild=="")
		continue;
	if (`attributeExists worldOrient $fitJoints[$i]`)
		continue;
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	if ($fitJoints[$i]=="*Jaw*" || `gmatch $fitJoints[$i] "*Eye*"`)
		continue;	

	createNode -n ($fitJoints[$i]+"Aim") -p Aims transform;
	$twistJoints=0;
	if (`attributeExists twistJoints  $fitJoints[$i]`)
		$twistJoints=`getAttr ($fitJoints[$i]+".twistJoints")`;
	$inbetweenJoints=0;
	if (`attributeExists inbetweenJoints  $fitJoints[$i]`)
		$inbetweenJoints=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
	for ($y=0;$y<$twistJoints+$inbetweenJoints+1;$y++)
		{
		$part="";
		if ($y>0)
			$part="Part"+$y;

		createNode -n ($fitJoints[$i]+$part+"Geo") -p ($fitJoints[$i]+"Aim") transform;
	
		//box
		$tempString=`polyCube -n ($fitJoints[$i]+$part+"Box") -w 1.75 -h 1 -d 1.75 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0`;
		$box=$tempString[0];
		$geoObjs[size($geoObjs)]=$box;
		move -r 0 0.5 0 ($box+".vtx[0:7] ");
		sets -e -forceElement asRedSG ($box+".f[1]");
		sets -e -forceElement asRed2SG ($box+".f[3]");
		sets -e -forceElement asGreenSG ($box+".f[0]");
		sets -e -forceElement asGreen2SG ($box+".f[2]");
		sets -e -forceElement asBlueSG ($box+".f[4]");
		sets -e -forceElement asBlue2SG ($box+".f[5]");
		connectAttr FitSkeleton.visBoxes ($box+".v");
		setAttr ($box+"Shape.overrideEnabled") 1;
		setAttr ($box+"Shape.overrideDisplayType") 2;
		parent $box ($fitJoints[$i]+$part+"Geo");
		setAttr -type float3 ($box+".s") 1 1 1;
		rotate -r -p 0 0 0 -os 0 -90 -90 ($box+".vtx[0:7]");
	
		
		//cylinder
		$tempString=`cylinder -n ($fitJoints[$i]+$part+"Cyl") -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 1 -hr 1 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 1 -ch 0`;
		$cyl=$tempString[0];
		$geoObjs[size($geoObjs)]=$cyl;
		move -r 0 0.5 0 ($cyl+".cv[0:3][0:7]");
		sets -e -forceElement asBlueSG ($cyl+".sf[0][7]") ($cyl+".sf[0][0]");//sf[0][1:2]
		sets -e -forceElement asGreenSG ($cyl+".sf[0][1:2]");//sf[0][3:4]
		sets -e -forceElement asBlue2SG ($cyl+".sf[0][3:4]");//sf[0][5:6]
		sets -e -forceElement asGreen2SG ($cyl+".sf[0][5:6]");//sf[0][7]
		connectAttr FitSkeleton.visCylinders ($cyl+".v");
		setAttr ($cyl+"Shape.overrideEnabled") 1;
		setAttr ($cyl+"Shape.overrideDisplayType") 2;
		parent $cyl ($fitJoints[$i]+$part+"Geo");
		setAttr -type float3 ($cyl+".s") 1 1 1;
		rotate -r -p 0 0 0 -os 0 -90 -90 ($cyl+".cv[0:3][0:7]");	
		}

	//sphere
	$tempString=`polyCube -n ($fitJoints[$i]+"Sphere") -w 2.5 -h 2.5 -d 2.5 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0`;
	$sphere=$tempString[0];
	sets -e -forceElement asRedSG ($sphere+".f[1]");
	sets -e -forceElement asRed2SG ($sphere+".f[3]");
	sets -e -forceElement asGreenSG ($sphere+".f[0]");
	sets -e -forceElement asGreen2SG ($sphere+".f[2]");
	sets -e -forceElement asBlueSG ($sphere+".f[4]");
	sets -e -forceElement asBlue2SG ($sphere+".f[5]");
	polySmooth  -mth 0 -dv 2 -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 0 $sphere;
	connectAttr FitSkeleton.visSpheres ($sphere+".v");
	setAttr ($sphere+"Shape.overrideEnabled") 1;
	setAttr ($sphere+"Shape.overrideDisplayType") 2;
	parent $sphere ($fitJoints[$i]+"Aim");
	setAttr -type float3 ($sphere+".s") 1 1 1;
	rotate -r -p 0 0 0 -os 0 -90 -90 ($sphere+".vtx[0:999]");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sy");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sz");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sx");

	//bones
	$bone=$fitJoints[$i]+"Bone";
	if ($fitJoints[$i]=="Scapula")
		continue;
	if (`objExists ($fitJoints[$i]+"Bone_template")`){
	duplicate -n $bone ($fitJoints[$i]+"Bone_template");}
	else if ($fitJoints[$i]=="Root" || $fitJoints[$i]=="Chest" || `gmatch $fitJoints[$i] "Neck*"` || `gmatch $fitJoints[$i] "Spine*"`)
		duplicate -n $bone SpineBone_template;
	else if (`gmatch $fitJoints[$i] "*Finger*"`)
		duplicate -n $bone DigitBone_template;
	else
		duplicate -n $bone GenericBone_template;
	sets -e -forceElement asBonesSG $bone;
	parent $bone ($fitJoints[$i]+"Aim");
	connectAttr FitSkeleton.visBones ($bone+".v");
	connectAttr ($fitJoints[$i]+".fat") ($bone+".sy");
	connectAttr ($fitJoints[$i]+".fat") ($bone+".sz");

	//Flare
	select $geoObjs;
	$tempString=`nonLinear -type flare  -lowBound 0 -highBound 1 -startFlareX 1 -startFlareZ 1 -endFlareX 1 -endFlareZ 1 -curve 0`;
	string $flare=`rename $tempString[0] ($fitJoints[$i]+"Flare")`;
	string $flareHandle=`rename $tempString[1]  ($fitJoints[$i]+"FlareHandle")`;
	parent $flareHandle ($fitJoints[$i]+"Aim");
	setAttr -type float3 ($flareHandle+".s") 1 1 1;
	setAttr -type float3 ($flareHandle+".t") 0 0 0;
	setAttr -type float3 ($flareHandle+".r") 0 0 -90;
	setAttr -l 1 ($flareHandle+".v") 0;
	
	connectAttr ($fitJoints[$i]+".fatYabs") ($flare+".startFlareX");
	connectAttr ($fitJoints[$i]+".fatZabs") ($flare+".startFlareZ");
	
	//Gap
	if (`objExists ($fitJoints[$i]+"GapBlenderA")`) delete ($fitJoints[$i]+"GapBlenderA");
	if (`objExists ($fitJoints[$i]+"GapBlenderB")`) delete ($fitJoints[$i]+"GapBlenderB");
	string $gapBlenderA=`createNode -n ($fitJoints[$i]+"GapBlenderA") blendTwoAttr`;
	string $gapBlenderB=`createNode -n ($fitJoints[$i]+"GapBlenderB") blendTwoAttr`;
	connectAttr FitSkeleton.visGap ($gapBlenderA+".attributesBlender");
	connectAttr FitSkeleton.visGap ($gapBlenderB+".attributesBlender");
	connectAttr ($fitJoints[$i]+".fatYabs") ($gapBlenderA+".input[0]");
	connectAttr ($fitJoints[$i]+".fatZabs") ($gapBlenderB+".input[0]");
	addAttr -k 0 -ln dummyInput1 -at double $gapBlenderA;
	addAttr -k 0 -ln dummyInput1 -at double $gapBlenderB;
	connectAttr ($rlaChild+".fatYabs") ($gapBlenderA+".dummyInput1");
	connectAttr ($rlaChild+".fatZabs") ($gapBlenderB+".dummyInput1");
	setAttr ($gapBlenderA+".input[1]") `getAttr ($rlaChild+".fatYabs")`;
	setAttr ($gapBlenderB+".input[1]") `getAttr ($rlaChild+".fatZabs")`;

	connectAttr ($gapBlenderA+".output") ($flare+".endFlareX");
	connectAttr ($gapBlenderB+".output") ($flare+".endFlareZ");

	//Distance
	if (`objExists ($fitJoints[$i]+"Distance")`) delete ($fitJoints[$i]+"Distance");
	createNode -n ($fitJoints[$i]+"Distance") distanceBetween;
	connectAttr ($fitJoints[$i]+".worldMatrix[0]") ($fitJoints[$i]+"Distance.inMatrix1");
	connectAttr ($rlaChild+".worldMatrix[0]") ($fitJoints[$i]+"Distance.inMatrix2");
	if (`objExists ($fitJoints[$i]+"ScaleYMultiDiv1")`) delete ($fitJoints[$i]+"ScaleYMultiDiv1");
	createNode -n ($fitJoints[$i]+"ScaleYMultiDiv1") multiplyDivide;
	setAttr ($fitJoints[$i]+"ScaleYMultiDiv1.operation") 2;
//	connectAttr ($fitJoints[$i]+"Distance.distance") ($fitJoints[$i]+"ScaleYMultiDiv1.input1Y");

	addAttr -ln dummyInput1Y -at double ($fitJoints[$i]+"ScaleYMultiDiv1");
	connectAttr ($fitJoints[$i]+"Distance.distance") ($fitJoints[$i]+"ScaleYMultiDiv1.dummyInput1Y");
	setAttr ($fitJoints[$i]+"ScaleYMultiDiv1.input1Y") `getAttr ($fitJoints[$i]+"Distance.distance")`;

//	connectAttr FitSkeleton.sx ($fitJoints[$i]+"ScaleYMultiDiv1.input2Y");
	if (`objExists ($fitJoints[$i]+"ScaleYMultiDiv2")`) delete ($fitJoints[$i]+"ScaleYMultiDiv2");
	createNode -n ($fitJoints[$i]+"ScaleYMultiDiv2") multiplyDivide;
	connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($fitJoints[$i]+"ScaleYMultiDiv2.input1Y");
	connectAttr FitSkeleton.visGap ($fitJoints[$i]+"ScaleYMultiDiv2.input2Y");
	
	connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($flareHandle+".sy");

	parentConstraint $fitJoints[$i] ($fitJoints[$i]+"Aim");

	for ($y=0;$y<$twistJoints+$inbetweenJoints+1;$y++)
		{
		$part="";
		if ($y>0)
			$part="Part"+$y;

		createNode -n ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y) multiplyDivide;
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".input1Y");
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".input2Y") ($y*(1.0/($twistJoints+$inbetweenJoints+1)));
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".outputY") ($fitJoints[$i]+$part+"Geo.tx");

		createNode -n ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y) multiplyDivide;
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".operation") 2;
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv2.outputY") ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".input1Y");
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".input2Y") ($twistJoints+$inbetweenJoints+1);
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".outputY") ($fitJoints[$i]+$part+"Geo"+".sx");
		}
	}

if (`objExists PelvisBone`)
	{
	parent PelvisBone FitSkeletonVisualizers;
	setAttr PelvisBone.tx 0;
	setAttr -type float3 PelvisBone.r 0 0 0;
	pointConstraint -skip x Hip PelvisBone;
	}

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;
asFitModeManualUpdate;
asUpdateButtonEnables;
asChangeVisGeoType;
if ($visPoleVector) asFitDisplayPoleVector 1;
catchQuiet (`select $sel`);
}

global proc asChangeVisGeoType ()
{
string $geoType=`optionMenu -q -v asVisGeoType`;
setAttr FitSkeleton.visCylinders 0;
setAttr FitSkeleton.visBoxes 0;
setAttr FitSkeleton.visSpheres 0;
setAttr FitSkeleton.visBones 0;
if ($geoType=="cylinders")
	setAttr FitSkeleton.visCylinders 1;
if ($geoType=="boxes")
	setAttr FitSkeleton.visBoxes 1;
if ($geoType=="spheres")
	setAttr FitSkeleton.visSpheres 1;
if ($geoType=="bones")
	setAttr FitSkeleton.visBones 1;
}

global proc asEnsureFitJointAttrs (string $fitJoint)
{
if (!`attributeExists fat $fitJoint`)
	{
	float $dv=1;
	string $rlaChild=`asRlaChild $fitJoint`;
	if ($rlaChild!="")
		{
		$dv=`getAttr ($rlaChild+".tx")`;
		$dv=`abs($dv)`;
		}
	else
		{
		string $tempString[]=`listRelatives -p -type joint $fitJoint`;
		if ($tempString[0]!="" && `attributeExists fat $tempString[0]`)
			$dv=`getAttr ($tempString[0]+".fat")`;
		}
	addAttr -k 1 -min 0 -dv $dv -ln fat -at double $fitJoint;
	}
if (!`attributeExists fatY $fitJoint`)
	addAttr -k 1 -min 0 -dv 1 -ln fatY -at double $fitJoint;
if (!`attributeExists fatZ $fitJoint`)
	addAttr -k 1 -min 0 -dv 1 -ln fatZ -at double $fitJoint;
if (!`attributeExists fatYabs $fitJoint`)
	addAttr -k 0 -ln fatYabs -at double $fitJoint;
if (!`attributeExists fatZabs $fitJoint`)
	addAttr -k 0 -ln fatZabs -at double $fitJoint;
if (`objExists ($fitJoint+"Fat")`) delete ($fitJoint+"Fat");
createNode -n ($fitJoint+"Fat") multiplyDivide;
connectAttr -f ($fitJoint+".fat") ($fitJoint+"Fat.input1Y");
connectAttr -f ($fitJoint+".fat") ($fitJoint+"Fat.input1Z");
connectAttr -f ($fitJoint+".fatY") ($fitJoint+"Fat.input2Y");
connectAttr -f ($fitJoint+".fatZ") ($fitJoint+"Fat.input2Z");
connectAttr -f ($fitJoint+"Fat.outputY") ($fitJoint+".fatYabs");
connectAttr -f ($fitJoint+"Fat.outputZ") ($fitJoint+".fatZabs");
}

global proc asRemoveUnusedfromBuildPose (string $uiName)
{
string $buildPose="buildPose";
if ($uiName=="faceSetup")
	$buildPose="faceBuildPose";
string $newBuildPoseCmd;
string $cmds[],$tempString[];
string $buildPoseCmd=`getAttr ($buildPose+".udAttr")`;
tokenize $buildPoseCmd ";" $cmds;
for ($i=0;$i<size( $cmds);$i++)
	{
	tokenize $cmds[$i] $tempString;
	string $ctrl=$tempString[size($tempString)-1];
	if (`gmatch $cmds[$i] "*[.]*"`)
		$ctrl=$tempString[size($tempString)-2];
	if (`objExists $ctrl`)
		$newBuildPoseCmd+=$cmds[$i]+";";
	}
setAttr -type "string" ($buildPose+".udAttr") $newBuildPoseCmd;
}

global proc asUpdateASToolsProcsInSelectors ()
{
string $AdvancedSkeleton5File=`asGetScriptLocation`+"/AdvancedSkeleton5.mel";
string $fDet,$fDet2;
string $files[];
int $fileId=`fopen $AdvancedSkeleton5File "r"`;
string $nextLine = `fgetline $fileId`;
int $copyLines=0;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId`;
	if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
		$copyLines=1;
	if (!$copyLines)
		continue;
	$fDet+=$nextLine;
	if ($nextLine=="//-- ASTools Procedures Ends Here --//\n")
		break;
	}
fclose $fileId;

string $selectorsDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/Selector/";
string $selectorFiles[]=`getFileList -fs "*.mel" -fld $selectorsDir`;
for ($i=0;$i<size($selectorFiles);$i++)
	$files[size($files)]=$selectorsDir+$selectorFiles[$i];
$files[size($files)]=`asGetScriptLocation`+"/AdvancedSkeleton5Files/picker/picker.mel";

for ($i=0;$i<size($files);$i++)
	{
	int $fileId=`fopen $files[$i] "r"`;
	string $nextLine = `fgetline $fileId`;
	int $copyLines=0;
	$fDet2="";
	while (size($nextLine)>0)
		{
		$fDet2+=$nextLine;
		$nextLine=`fgetline $fileId`;
		if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
			break;
		}
	fclose $fileId;

	int $fileId2=`fopen $files[$i] "w"`;
	fprint $fileId2 ($fDet2+$fDet);
	fclose $fileId2;
print ("// Updated:"+$files[$i]+"\n");
	}
}

global proc float asRoundOff (float $value, int $decimals)
{
float $rounded;
if ($value>=0) $rounded=(trunc($value*`pow 10 $decimals`+0.5)/`pow 10 $decimals`);
else $rounded=(trunc(abs($value)*`pow 10 $decimals`+0.5)/`pow 10 $decimals`)*-1;
return $rounded;
}

global proc asSetFixedWrapOptions ()
{
optionVar -intValue autoWeightThreshold 1;
optionVar -intValue exclusiveBind 0;
optionVar -intValue renderInfl 1;
optionVar -stringValue falloffMode "volume";
}

global proc asSwapCurve ()
{
string $side,$oppositeSide;
string $tempString[];
string $sel[]=`ls -sl`;
int $last=`size($sel)`-1;
string $selShapes[];
if (size($sel)<2)
	error "Selected both controls to replace, and the new curve to use";
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	$selShapes[$i]=$tempString[0];
	if (!`objExists $selShapes[$i]`)
		error ("selected object:\""+$sel[$i]+"\" is not a nurbsCurve");
	$tempString=`listRelatives -s $sel[$i]`;
	if (`objectType $selShapes[$i]`!="nurbsCurve" && `objectType $selShapes[$i]`!="nurbsSurface")
		error ("selected object:\""+$sel[$i]+"\" is not a nurbsCurve");
//	if ($i==$last && `sets -im ControlSet $sel[$i]`)
//		error ("\""+$sel[$i]+"\" is a control. The new curve must be select last, and must not be a existing control");
	}
select $sel[$last];
DeleteHistory;
		
for ($i=0;$i<size($sel)-1;$i++)
	{
	delete `listRelatives -s $sel[$i]`;
	duplicate -n tempXform $sel[$last];
	$tempString=`listRelatives -f -s tempXform`;
	for ($y=0;$y<size($tempString);$y++)
		rename $tempString[$y] ($sel[$i]+"Shape");
	$tempString=`listRelatives -s tempXform`;
	for ($y=0;$y<size($tempString);$y++)
		{
		parent -add -s $tempString[$y] $sel[$i];
		float $rot[]=`xform -q -ws -ro $sel[$i]`;
//		if(!(`gmatch $sel[0] "IK*"` || `gmatch $sel[0] "Pole*"` || `gmatch $sel[0] "RootX*"`))
		if (!($rot[0]==0 && $rot[1]==0 && $rot[2]==0))
			rotate -r -os -90 -90 0 ($tempString[$y]+".cv[0:99]");
		sets -add AllSet $tempString[$y];
		}
	delete tempXform;
	}
	dgdirty -a;
}

global proc asSetCurveColor ()
{
int $curveColor=`palettePort -q -setCurCell asCurveColorPalettePort`;
int $useOverrideRGBColors=0;
float $rgb[];
string $type;
string $controllers[],$controlSetMembers[];
string $curveColorType=`optionMenu -q -v asCurveColorTypeOptionMenu`;
string $curveColorSide=`optionMenu -q -v asCurveColorSideOptionMenu`;

if (`asMayaVersionAsFloat`>=2014)
	{
	//Maya2015 onwards have "overrideRGBColors"
	$rgb=`palettePort -q -rgb asCurveColorPalettePort`;
	$storedRgb=`colorIndex -query $curveColor`;
	if ($storedRgb[0]!=$rgb[0] || $storedRgb[1]!=$rgb[1] || $storedRgb[2]!=$rgb[2])
		{
		print "// Non default index color, using \"overrideRGBColors\".\n";
		$useOverrideRGBColors=1;
		}
	}

if (`objExists ControlSet`)
	$controlSetMembers=`sets -q ControlSet`;
//if (`gmatch $curveColorType "Face:*"` && `objExists FaceControlSet`)
//	$controlSetMembers=`sets -q FaceControlSet`;
	
string $sel[]=`ls -sl`;
string $tempString[];
string $side;
if ($curveColorSide=="Right") $side="_R";
if ($curveColorSide=="Left") $side="_L";
if ($curveColorSide=="Middle") $side="_M";

if ($curveColorType=="Selected")
	$controllers=$sel;
else
	for ($i=0;$i<size($controlSetMembers);$i++)
		{
		if ($curveColorType!="*All")
			if (!`gmatch $controlSetMembers[$i] ($curveColorType+"*")`)
				continue;
		if ($curveColorSide!="*All")
			if (!`gmatch $controlSetMembers[$i] ("*"+$side)`)
				continue;
		$controllers[size($controllers)]=$controlSetMembers[$i];
		}

//different way to find the controllers for Face:
if (`gmatch $curveColorType "Face:*"` && `objExists ctrlBox`)
	{
	$type=`substitute "Face:" $curveColorType ""`;
	$tempString=`listConnections -s 0 -d 1 ("ctrlBox."+$type+"CtrlVis")`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($curveColorSide!="*All")
			if (!`gmatch $tempString[$i] ("*"+$side)`)
				continue;
		$controllers[size($controllers)]=$tempString[$i];
		}
	}

for ($i=0;$i<size($controllers);$i++)
	{
	$tempString=`listRelatives -s $controllers[$i]`;
	if ($tempString[0]!="")
		{
		setAttr ($tempString[0]+".overrideColor") $curveColor;
		if ($useOverrideRGBColors)
			{
			setAttr ($tempString[0]+".overrideRGBColors") 1;
			setAttr -type float3 ($tempString[0]+".overrideColorRGB") $rgb[0] $rgb[1] $rgb[2];
			}
		}
	}
}

global proc asControlCurvesPrintInfo ()
{
string $controlSetMembers[]=`sets -q ControlSet`;
string $curveShape;
string $tempString[],$cmds[],$skinCurves1[],$skinCurves2[];
int $spans,$degree,$numCVs;
float $cvPos[3],$pos[],$rot[],$sca[];
int $reuseShape=`checkBox -q -v asControlCurvesReUseShapeCheckBox`;
int $reuseColor=`checkBox -q -v asControlCurvesReUseColorCheckBox`;
int $reuseCatch=`checkBox -q -v asControlCurvesReUseCatchCheckBox`;
int $reuseSkinCurves=`checkBox -q -v asControlCurvesReUseSkinCurvesCheckBox`;

if ($reuseSkinCurves)
	{
	$skinCurves1=`listConnections SkinCurves1.drawInfo`;
	$skinCurves2=`listConnections SkinCurves2.drawInfo`;
	$controlSetMembers=`stringArrayCatenate $skinCurves1 $skinCurves2`;
	}

for ($i=0;$i<size($controlSetMembers);$i++)
	{
	//SkinCurves also use xform
	if ($reuseSkinCurves)
		{
		$pos=`getAttr ($controlSetMembers[$i]+".t")`;
		$rot=`getAttr ($controlSetMembers[$i]+".r")`;
		$sca=`getAttr ($controlSetMembers[$i]+".s")`;
		$cmds[size($cmds)]="setAttr -type float3 "+$controlSetMembers[$i]+".t "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		$cmds[size($cmds)]="setAttr -type float3 "+$controlSetMembers[$i]+".r "+$rot[0]+" "+$rot[1]+" "+$rot[2];
		$cmds[size($cmds)]="setAttr -type float3 "+$controlSetMembers[$i]+".s "+$sca[0]+" "+$sca[1]+" "+$sca[2];
		}

	$tempString=`listRelatives -s $controlSetMembers[$i]`;
	for ($z=0;$z<size($tempString);$z++)
		{
		$curveShape=$tempString[$z];
		if (!`objExists $curveShape`)
			continue;
		if (`objectType $curveShape`!="nurbsCurve")
			continue;
		$spans=`getAttr ($curveShape+".spans")`;
		$degree=`getAttr ($curveShape+".degree")`;
		$numCVs=$spans+$degree;
		if ($reuseShape)
			for ($y=0;$y<$numCVs;$y++)
				{
				$cvPos=`getAttr ($curveShape+".controlPoints["+$y+"]")`;
				$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2];
				}
		//color
		if ($reuseColor)
			$cmds[size($cmds)]="setAttr "+$curveShape+".overrideColor "+`getAttr ($curveShape+".overrideColor")`;
		}
	}
for ($i=0;$i<size($cmds);$i++)
	if ($reuseCatch)
		$cmds[$i]="catch (`"+$cmds[$i]+"`)";

for ($i=0;$i<size($cmds);$i++)
	print ($cmds[$i]+";\n");
}

global proc asCreateControlMesh ()
{
string $sel[]=`ls -sl`;
float $pos[];
string $tempString[],$tempString2[];
int $mirror=`checkBox -q -v asCreateControlMeshMirrorCheckBox`;
if (size($sel)<2)
	error "Select polyFaces And Control";
string $control=$sel[size($sel)-1];
if (`gmatch $control "*.*"`)
	error "Control must be selected last";
if (!`gmatch $sel[0] "*.f*"`)
	error "Poly-faces must be selected";
string $sourceMeshes[]=`ls -sl -o -type mesh`;
if (size($sourceMeshes)>1)
	error "select faces from only 1 object at the time";
int $numLetters=size($control);
string $mirrorControl=`substring $control 1 ($numLetters-2)`+"_L";
if (`gmatch $control "*_L"`)
	$mirrorControl=`substring $control 1 ($numLetters-2)`+"_R";
select -d $control;
string $faces[]=`ls -sl`;
string $meshControl;
asEnsureMainCtrlVisAttrs;
for ($y=0;$y<99;$y++)
	{
	if ($y==0) $meshControl=$control+"MeshCtrl";
	else $meshControl=$control+"MeshCtrl"+$y;
	if (!`objExists $meshControl`)
		break;
	}
createNode -n $meshControl mesh;
//$tempString=`polySphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 0`;
$tempString=`listRelatives -p $meshControl`;
string $generatedXform=$tempString[0];
parent -add -s $meshControl $control;
delete $generatedXform;

$tempString=`listRelatives -p $faces[0]`;
string $sourceMesh=$tempString[0];
$tempString=`listRelatives -p $sourceMesh`;
string $sourceXform=$tempString[0];

string $transformGeometry=`createNode -n ($control+"MCTransformGeometry") transformGeometry`;
connectAttr ($control+".worldInverseMatrix[0]") ($transformGeometry+".transform");
connectAttr -f ($sourceMesh+".outMesh") ($transformGeometry+".inputGeometry");
connectAttr -f ($transformGeometry+".outputGeometry") ($meshControl+".inMesh");

//ReAssign Shading
string $shaderCmd;
string $shadingEngines[]=`ls -type shadingEngine`;
for ($i=0;$i<size($shadingEngines);$i++)
	{
	hyperShade -o $shadingEngines[$i];
	$tempString=`ls -sl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`gmatch $tempString[$y] ($sourceXform+"[.]*")`)
			{
			select `substitute $sourceXform $tempString[$y] $meshControl`;
			sets -e -forceElement $shadingEngines[$i];
			}
		}
	}

select -cl;
for ($i=0;$i<size($faces);$i++)
	{
	tokenize $faces[$i] "." $tempString;
	select -add ($meshControl+"."+$tempString[1]);
	}
asInvertSelection;
int $allFacesSelected=0;
$tempString=`ls -sl`;
if ($tempString[0]=="")
	$allFacesSelected=1;
if ($allFacesSelected) select ($meshControl+".f[0]");
delete;
$tempString=`listConnections -s 1 -d 0 ($meshControl+".inMesh")`;
string $deleteComponent=`rename $tempString[0] ($control+"MCDeleteComponent")`;
if ($allFacesSelected) setAttr ($deleteComponent+".nodeState") 1;

if ($mirror && !`objExists controlMeshMirroring` && !`objExists controlMeshBatch` && `objExists $mirrorControl`)
	{
	createNode -n controlMeshMirroring transform;
	if (`objExists closestSampler`) delete closestSampler;
	createNode -n closestSampler closestPointOnMesh;
	connectAttr ($sourceMesh+".outMesh") closestSampler.inMesh;

	select $faces;
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	select -cl;
	for ($i=0;$i<size($tempString);$i++)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		setAttr -type float3 closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
		select -add ($sourceMesh+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");	
		}
	ConvertSelectionToContainedFaces;
	select -add $mirrorControl;
	asCreateControlMesh;
	delete controlMeshMirroring;
	}

//setAttr ($meshControl+".overrideEnabled") 1;
//setAttr ($meshControl+".overrideShading") 0;
setAttr ($meshControl+".castsShadows") 0;
setAttr ($meshControl+".receiveShadows") 0;
setAttr ($meshControl+".motionBlur") 0;
setAttr ($meshControl+".primaryVisibility") 0;
setAttr ($meshControl+".smoothShading") 0;
setAttr ($meshControl+".visibleInReflections") 0;
setAttr ($meshControl+".visibleInRefractions") 0;

connectAttr -f Main.ctrlMeshVis ($meshControl+".v");
$tempString=`listRelatives -s -type nurbsCurve $control`;
if ($tempString[0]!="")
	{
	$tempString2=`listConnections -s 1 -d 0 ($tempString[0]+".v")`;
	if ($tempString2[0]=="")
		connectAttr -f Main.ctrlCurveVis ($tempString[0]+".v");
	}

select -cl;
print ("// "+$meshControl+" created.\n");
}

global proc asCreateControlMeshes ()
{
global string $gMainProgressBar;
string $joint;
string $tempString[],$infs[],$weightJoints[],$faceVtxs[];
string $sel[]=`ls -sl`;
float $jointWeights[];
float $biggestJointWeight;
if ($sel[0]=="")
	error "Nothing selected";
if (`gmatch $sel[0] "*.*"`)
	error "Found components selected, Makes sure to select a object";
string $historyNodes[]=`listHistory -pdo 1 -il 2 $sel[0]`;
string $skinCluster,$faceCtrlName;
for ($i=0;$i<size($historyNodes);$i++)
	if (`nodeType $historyNodes[$i]`=="skinCluster")
		$skinCluster=$historyNodes[$i];
if ($skinCluster=="")
	error "No SkinCluster found on selected object";
string $infJoints[]=`listConnections ($skinCluster+".matrix")`;
string $infJointCtrls[];

int $tempInts[]=`polyEvaluate -f $sel[0]`;
int $numFaces=$tempInts[0];
int $isFaceCtrl;
clear $infs;
if (`objExists controlMeshBatch`) delete controlMeshBatch;
createNode -n controlMeshBatch transform;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "working" -bp -ii 1 -min 0 -max $numFaces $gMainProgressBar;
for ($y=0;$y<$numFaces;$y++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	select -r ($sel[0]+".f["+$y+"]");
	ConvertSelectionToVertices;
	$weightJoints=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster`;
	$faceVtxs=`ls -sl -fl`;
	for ($a=0;$a<size($faceVtxs);$a++)
		{
		select $faceVtxs[$a];
		for ($z=0;$z<size($weightJoints);$z++)
			{
			if ($z==0) clear $jointWeights;
			$jointWeights[$z]+=`skinPercent -ignoreBelow 0.001 -t $weightJoints[$z] -q -v $skinCluster`;
			}
		}

	$biggestJointWeight=0;
	for ($z=0;$z<size($weightJoints);$z++)
		{
		if ($jointWeights[$z]>$biggestJointWeight)
			{
			$biggestJointWeight=$jointWeights[$z];
			$infs[$y]=$weightJoints[$z];
			}
		}
	}
select -cl;

for ($i=0;$i<size($infJoints);$i++)
	{
	$faceCtrlName=`substitute "Joint" $infJoints[$i] ""`;
	$isFaceCtrl=0;
	if (`objExists $faceCtrlName`)
		if (`objExists FaceControlSet`)
			if (`sets -im FaceControlSet $faceCtrlName`)
				$isFaceCtrl=1;
	if (`objExists ("FK"+$infJoints[$i])` && !`gmatch $infJoints[$i] "*Part[0-9]*"`)
		$infJointCtrls[$i]="FK"+$infJoints[$i];
	else if ($isFaceCtrl)
		$infJointCtrls[$i]=$faceCtrlName;
	else
		{
		$joint=$infJoints[$i];
		for ($y=0;$y<99;$y++)
			{
			if (!`objExists $joint`)
				{
				print ("// Found no ctrl for:"+$infJoints[$i]+"\n");
				stringArrayRemove {$infJoints[$i]} $infJoints;
				break;
				}
			$tempString=`listRelatives -p $joint`;
			$joint=$tempString[0];
			if (`objExists ("FK"+$joint)` && !`gmatch $joint "*Part[0-9]*"`)
				{
				$infJointCtrls[$i]="FK"+$joint;
				$y=99;
				}
			}
		}
	}
string $infJointCtrls2[]=`stringArrayRemoveDuplicates $infJointCtrls`;
for ($i=0;$i<size($infJointCtrls2);$i++)
	{
	select -cl;
	for ($q=0;$q<size($infJoints);$q++)
		{
		if ($infJointCtrls[$q]!=$infJointCtrls2[$i])
			continue;
		for ($y=0;$y<$numFaces;$y++)
			{
			if ($infs[$y]==$infJoints[$q])
				select -add ($sel[0]+".f["+$y+"]");
			}
		}
	$tempString=`ls -sl`;
	if ($tempString[0]=="")
		continue;
	select -add $infJointCtrls2[$i];
	refresh;
	asCreateControlMesh;

	}

if (`objExists controlMeshBatch`) delete controlMeshBatch;
}

global proc asCreateIKControlMeshes ()
{
if (!`objExists ControlSet`)
	error "ControlSet not found";
float $scale=`asGetScale`;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$tempString5[],$curveShapes[];
string $controlSetMembers[]=`sets -q ControlSet`;
string $meshCtrl;
asFitModeEnsureShaders;
if (`objExists tempTG`) delete tempTG;
createNode -n tempTG transformGeometry;
setAttr tempTG.invertTransform 1;
asEnsureMainCtrlVisAttrs;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (`gmatch $controlSetMembers[$i] "FK*"` && !`gmatch $controlSetMembers[$i] "FKIK*"`)
		continue;
	$curveShapes=`listRelatives -s -type nurbsCurve $controlSetMembers[$i]`;
	for ($y=0;$y<size($curveShapes);$y++)
		{
		if (`gmatch $curveShapes[$y] "Pole*"`)
			$tempString=`extrude -ch 0 -rn false -po 0 -et 0 -upn 0 -d 0 0 1 -length ($scale*0.1) -rotation 0 -scale 1 -dl 3 $curveShapes[$y]`;
		else
			$tempString=`extrude -ch 0 -rn false -po 0 -et 0 -upn 1 -length ($scale*0.1) -rotation 0 -scale 1 -dl 3 $curveShapes[$y]`;
		$tempString2=`nurbsToPoly -mnd 1 -ch 0 -f 3 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0.01 -es 0 -ntr 0 -mrt 0 -uss 1 $tempString[0]`;
		delete $tempString[0];
		$tempString3=`listRelatives -s $tempString2[0]`;
		$tempString4[0]=`createNode mesh`;
		$tempString5=`listRelatives -p $tempString4[0]`;
		connectAttr -f ($tempString3[0]+".outMesh") tempTG.inputGeometry;
		if (!`isConnected ($controlSetMembers[$i]+".worldMatrix[0]") tempTG.transform`)
			connectAttr -f ($controlSetMembers[$i]+".worldMatrix[0]") tempTG.transform;
		connectAttr -f tempTG.outputGeometry ($tempString4[0]+".inMesh");
		for ($z=0;$z<99;$z++)
			{
			if ($z==0) $meshCtrl=$controlSetMembers[$i]+"MeshCtrl";
			else $meshCtrl=$controlSetMembers[$i]+"MeshCtrl"+$z;
			if (!`objExists $meshCtrl`)
				break;
			}
		rename $tempString4[0] $meshCtrl;
		parent -add -s $meshCtrl $controlSetMembers[$i];
		delete $tempString5[0];
		delete $tempString2[0];
		sets -e -forceElement initialShadingGroup $meshCtrl;

		setAttr ($meshCtrl+".castsShadows") 0;
		setAttr ($meshCtrl+".receiveShadows") 0;
		setAttr ($meshCtrl+".motionBlur") 0;
		setAttr ($meshCtrl+".primaryVisibility") 0;
		setAttr ($meshCtrl+".smoothShading") 0;
		setAttr ($meshCtrl+".visibleInReflections") 0;
		setAttr ($meshCtrl+".visibleInRefractions") 0;

		connectAttr -f Main.ctrlMeshVis ($meshCtrl+".v");
		$tempString=`listRelatives -s -type nurbsCurve $controlSetMembers[$i]`;
		if ($tempString[0]!="")
			{
			$tempString2=`listConnections -s 1 -d 0 ($tempString[0]+".v")`;
			if ($tempString2[0]=="")
				connectAttr -f Main.ctrlCurveVis ($tempString[0]+".v");
			}
		$overrideColor=`getAttr ($curveShapes[$y]+".overrideColor")`;
		if ($overrideColor==13) sets -e -forceElement asRedSG $meshCtrl;
		if ($overrideColor==15 || $overrideColor==6) sets -e -forceElement asBlueSG $meshCtrl;
		if ($overrideColor==17 || $overrideColor==22) sets -e -forceElement asGreen2SG $meshCtrl;

		}
	}
if (`objExists tempTG`) delete tempTG;
}

global proc asEnsureMainCtrlVisAttrs ()
{
if (!`attributeExists ctrlCurveVis Main`)
	{
	addAttr -k 1 -ln ctrlCurveVis -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.ctrlCurveVis;
	}
if (!`attributeExists ctrlMeshVis Main`)
	{
	addAttr -k 1 -ln ctrlMeshVis -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.ctrlMeshVis;
	}
}

global proc asDeleteControlMesh ()
{
string $sel[]=`ls -sl`;
string $tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -type mesh -s $sel[$i]`;
	if (size($tempString))
		delete $tempString;
	}
}

global proc asDeleteAllControlMesh ()
{
string $tempString[]=`ls "*MeshCtrl*" "FK*_*MCTransformGeometry*" "FK*_*MCDeleteComponent*"`;
if (size($tempString))
	delete $tempString;
}

global proc asSetBuildPose (string $uiName)
{
string $controlsSet="ControlSet";
string $fitSkeleton="FitSkeleton";
string $buildPose="buildPose";
if ($uiName=="faceSetup")
	{
	$controlsSet="FaceControlSet";
	$fitSkeleton="FaceFitSkeleton";
	$buildPose="faceBuildPose";
	}
string $controlSetMembers[]=`sets -q $controlsSet`;
string $objAttr,$runCmd,$buildPoseCmd,$newRunCmds;
float $poseValue,$currentValue;
float $runValues[];
string $tempString[],$tempString2[],$runObjAttrs[],$checkObjAttr[];
if (`objExists $fitSkeleton`)
	if (`attributeExists run $fitSkeleton`)
		{
		$runCmd=`getAttr ($fitSkeleton+".run")`;
		$runCmd=`substituteAllString $runCmd "\"" ""`;
		}
if ($runCmd!="")
	tokenize $runCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
	$runValues[size($runValues)]=$tempString2[2];
	}

$buildPoseCmd=`getAttr ($buildPose+".udAttr")`;
tokenize $buildPoseCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	int $loopTimes=0;
	if ($tempString2[0]=="setAttr")
		{
		$objAttr=$tempString2[1];
		$poseValue=$tempString2[2];
		$loopTimes=1;
		$checkObjAttr[0]=$objAttr;
		}
	else if ($tempString2[0]=="xform")
		{
		$loopTimes=9;
		$obj=$tempString2[size($tempString2)-1];
		$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
		$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
		$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
		$poseValue=0;
		}
	for ($z=0;$z<$loopTimes;$z++)
		{
		$currentValue=`getAttr $checkObjAttr[$z]`;
		if($z>5) $poseValue=1;//scale
		//actual poseValue might come from the run attribute//
		for ($y=0;$y<size($runObjAttrs);$y++)
			if ($checkObjAttr[$z]==$runObjAttrs[$y])
				$poseValue=$runValues[$y];

		if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
			$newRunCmds+="setAttr "+$checkObjAttr[$z]+" "+$currentValue+";";
		}
	}

if ($newRunCmds=="")
	{
	print "// No changes to the build pose detected\n";
	return;
	}

string $m="Set the following as default values ?\n\n"+`substituteAllString $newRunCmds ";" "\n"`;
string $confirmResult=`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`;
if ($confirmResult!="Ok")
	return;
if (!`attributeExists run $fitSkeleton`)
	addAttr -ln run -dt "string" $fitSkeleton;
setAttr -type "string" ($fitSkeleton+".run") ($runCmd+";"+$newRunCmds);
}

global proc asfileBrowse (string $tool, string $action)
{
string $fc,$ft;
int $mode=0;
if ($action=="Open")
	{
	$fc="asOpen "+$tool;
	$ft="mel";
	}
if ($action=="SaveAs")
	{
	$fc="asSaveAs "+$tool;
	$ft="mel";
	$mode=1;
	}
if ($action=="Import")
	{
	$fc="as"+$tool+"BackgroundImport";
	$ft="*";
	}
if (`asMayaVersionAsFloat`>=2011)
	eval ($fc+" \""+`fileDialog -dm ("*."+$ft) -m $mode`+"\" "+"fileType");
else
	{
	if (`about -win`)
		fileBrowserDialog -m $mode -fc $fc -ft $ft -an $action;
	else
		fileBrowser $fc $action $ft $mode;
	}
}

global proc astoShelf (string $tool)
{
global string $gShelfTopLevel;
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
if ($projectName=="untitled")
	error "Can not put \"untitled\" on shelf, save your project first\n";

string $cmd="source \""+$projectPath+$projectName+".mel\";";
string $ext=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=".png";
$icon=$projectPath+$projectName+"/"+$projectName+"_background32"+$ext;
string $setParent=`setParent -q`;
if (`tabLayout -exists $gShelfTopLevel`)
	{
	string $currentShelf=`tabLayout -query -selectTab $gShelfTopLevel`;
	setParent $currentShelf;
	shelfButton -c $cmd -ann ($tool+":"+$projectName) -label ($tool+":"+$projectName) -i1 $icon
		-st`shelfLayout -query -style $currentShelf`
		-width `shelfLayout -query -cellWidth $currentShelf`
		-height `shelfLayout -query -cellHeight $currentShelf`;
	}
setParent $setParent;
}

global proc string asUniqueFile (string $file)
{
// Copies given file to a random named file, to avoid fileNode cache
string $buffer[];
int $numTok=`tokenize $file "/" $buffer`;
string $path="";
if (`gmatch $file "/*"`)
	$path="/";
for ($i=0;$i<($numTok-1);$i++)
	$path+=$buffer[$i]+"/";
$numTok=`tokenize $file "." $buffer`;
string $ext=$buffer[$numTok-1];
string $randNumber=`rand 42`;
string $uniqueFile=$path+"unique"+`substituteAllString $randNumber "." ""`+"."+$ext;
sysFile -cp $uniqueFile $file;
return $uniqueFile;
}

global proc string[] asGetControlSets ()
{
string $controlSets[];
string $sets[]=`ls -type objectSet`;
for ($i=0;$i<size($sets);$i++)
	{
	if (!`sets -q -r $sets[$i]` && !`sets -q -v $sets[$i]` && !`sets -q -eg $sets[$i]` && !`sets -q -fc $sets[$i]` && !`sets -q -ep $sets[$i]`)
		if (`gmatch $sets[$i] "*[c-C]ontrol[s-S]et*"`)
			$controlSets[size($controlSets)]=$sets[$i];
	}
return $controlSets;
}

//-- AS IO Procedures (for tools) Starts Here --//
global proc int asOpen (string $tool, string $fileName, string $fileType)
{
global int $asfileLoading;
string $sel[]=`ls -sl`;
select -cl;
string $projectName=`basename $fileName ".mel"`;
string $projectPath=`dirname $fileName`+"/";
string $asIconLocation=$projectPath+$projectName+"/";
int $anim;
string $bgExt=".tga";
if (`about -mac`)
	$bgExt=".iff";

//if ($tool=="Poser")
//	asPoserDesigner;

evalEcho ("source \""+$fileName+"\";\n"
	+"as"+$tool+$projectName);
window -e -i 1 ("as"+$tool+$projectName);

if ($tool=="Poser")
	{
	$asfileLoading=1;
	string $gridOrder[]=`gridLayout -q -go ("asPoser"+$projectName+"GridLayout")`;
	int $nc=`gridLayout -q -nc ("asPoser"+$projectName+"GridLayout")`;
	int $nr=`gridLayout -q -nr ("asPoser"+$projectName+"GridLayout")`;
	intField -e -v $nc asPoserNc;
	intField -e -v $nr asPoserNr;
	asPoserUpdateGrid;
	int $childNum,$lenght;
	string $uiName="asPoserDefault";
	string $loadData[];
	$loadData[0]=$uiName;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] ("asPoser"+$projectName+"ColumnLayout*")`)
			{
			$image=`iconTextButton -q -i ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$loadData[1]=$image;
//			$label=`iconTextButton -q -l ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$label=`text -q -l ("asPoser"+$projectName+"Text"+$childNum)`;
			$loadData[2]=$label;
			$cmd=`iconTextButton -q -c ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$cmd=`substitute ("asPoser"+$projectName)  ("\""+$cmd+"\"") $uiName`;
			$lenght=size($cmd);
			$loadData[3]=`substring $cmd 2 ($lenght-1)`;
			$loadData[4]=$childNum;
			$anim=0;
			if (!`gmatch $cmd "*asSetAttrs *"`)
				$anim=1;
			$loadData[5]=$anim;
			asNewPose $loadData $anim;
			}
		}
	evalDeferred ("deleteUI as"+$tool+$projectName);
	}
if ($tool=="Selector")
	{
	asSelectorDesigner;
	$asfileLoading=1;
	
	window -e -w `window -q -w ("asSelector"+$projectName)` -h `window -q -h ("asSelector"+$projectName)` asSelectorDefault;
	asSelectorBackgroundImport ($asIconLocation+$projectName+"_background"+$bgExt) "image";
	
	int $width,$height,$msg0AsInt,$msg1AsInt;
	string $iol;
	string $buffer[],$msgs[];
	//restore controlSets
	string $controlSetsText,$controlSets[];
	if (`text -q -ex ("asSelector"+$projectName+"ControlSetsText")`)
		{
		$controlSetsText=`text -q -l ("asSelector"+$projectName+"ControlSetsText")`;
		$controlSets=`stringToStringArray $controlSetsText " "`;
		if (`menuItem -q -ex ControlSet`)
			menuItem -e -cb 0 ControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if (`menuItem -q -ex $controlSets[$i]`)
				menuItem -e -cb 1 $controlSets[$i];
		}

	string $ctls[]=`formLayout -q -ca ("asSelector"+$projectName+"FormLayout")`;
	int $mirrorButtons=`optionVar -q asSelectorMirrorButtons`;
	optionVar -iv asSelectorMirrorButtons 0;
	for ($ctl in $ctls)
		if (`iconTextButton -q -ex $ctl` && !`gmatch $ctl "*BGPicture"`)
			{
			tokenize $ctl ":" $buffer;
			$msg0AsInt=$msgs[0]=$buffer[size($buffer)-2];
			$msg1AsInt=$msgs[1]=$buffer[size($buffer)-1];
			$width=`iconTextButton -q -w $ctl`;
			$height=`iconTextButton -q -h $ctl`;
			$iol=`iconTextButton -q -iol $ctl`;
			$cmd=`iconTextButton -q -c $ctl`;
			$cmd=`substitute ("\""+$projectName+"\"") (""+$cmd) "\"Default\""`;
			$buttonName=`substitute $projectName $ctl ""`;
			$ann=`iconTextButton -q -ann $ctl`;
			$msgs[2]=$iol;
			$msgs[3]=$cmd;
			$msgs[4]=$buttonName;
			$msgs[6]=$ann;
			renameUI $ctl ("deleteMeUI"+$ctl);
			asSelectorDpc "asSelectorBGImage"  "asSelectorBGImage" $msgs ($msg0AsInt+$width-4) ($msg1AsInt+$height-5) 2;
			}
	optionVar -iv asSelectorMirrorButtons $mirrorButtons;
	evalDeferred -lp asSelectorRefresh;
	}

//evalDeferred ("deleteUI as"+$tool+$projectName);
text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");
$asfileLoading=0;
select $sel;

return 1;
}

global proc int asSaveAs (string $tool, string $fileName, string $fileType)
{
if ($fileName=="")
	return 0;
string $sel[]=`ls -sl`;
string $projectName;
string $buffer[];
int $numFileNameChar=size ($fileName);
tokenize $fileName "/" $buffer;
string $file=$buffer[size($buffer)-1];
int $numFileChar=size ($file);
tokenize $file "." $buffer;
$projectName=$buffer[0];
string $tempTrn=`createNode transform`;
$projectName=`createNode -p $tempTrn -n $projectName transform`;
delete $tempTrn;
tokenize $projectName "|" $buffer;
$projectName=$buffer[size($buffer)-1];
string $projectPath=`substring $fileName 1 ($numFileNameChar-$numFileChar)`;

string $previousProjectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $previousProjectName=`text -q -l ("as"+$tool+"ProjectName")`;

text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
asSave $tool;

select $sel;
return 1;
}

global proc asSave (string $tool)
{
if (`text -q -l ("as"+$tool+"ProjectName")`=="untitled")
	{
	asfileBrowse $tool "SaveAs";
	return;
	}
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
string $projectFile=$projectPath+$projectName+".mel";
string $installFile=$projectPath+$projectName+"/install.mel";
string $asIconLocation=$projectPath+$projectName+"/";
string $ext=".xpm";
string $bgExt=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=$bgExt=".png";
if (`about -linux`)
	$ext=".xpm";
string $tmpDir=`internalVar -utd`;
string $tmpIconDir=$tmpDir+"AdvancedSkeleton/"+$tool+"/untitled/";
string $uiName="as"+$tool+$projectName;
string $bgc;
string $buffer[];
string $fDet="";
$fDet+="//This file has been generated by AdvancedSkeleton"+$tool+"//\n";
$fDet+="//Using AdvancedSkeleton Version: "+`asGetScriptVersion`+"//\n";
$fDet+="\n";
$fDet+="global proc "+$uiName+" ()\n";
$fDet+="{\n";
$fDet+="if (`window -q -ex "+$uiName+"`)\n";
$fDet+="\tdeleteUI "+$uiName+";\n";
$fDet+="\n";
$fDet+="string $asSelectorScriptLocation=`asSelectorScriptLocation`;\n";
$fDet+="string $asIconLocation=$asSelectorScriptLocation+\""+$projectName+"/\";\n";
$fDet+="window -rtf 1 -mb 1 -t "+$projectName+" "+$uiName+";\n";
$fDet+="menu -l Edit;\n";
$fDet+="\tmenuItem -l Refresh -c \"asPopulateNameSpaceMenu "+$uiName+"\";\n";
$fDet+="\tmenuItem -l Filter -c \"asFilterNameSpaceMenuUI "+$uiName+"\";\n";
$fDet+="\tsetParent..;\n";
if ($tool=="Selector")
	{
	$fDet+="menu -l Display;\n";
	$fDet+="\tmenuItem -l Controls -c asControlsVisibilityToggle;\n";
	$fDet+="\tmenuItem -l \"Set HotKey\" -c asSetupControlVisibilityHotKeyDialog;\n";
	$fDet+="\tmenuItem -l Joints -c \"asJointsVisibilityToggle "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l GimbalLock -c \"asVisualizeGimbalLock "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Pose -aob 1;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 0\";\n";
	$fDet+="\tmenuItem -l Paste -en 0 "+$uiName+"PosePaste;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Reset -c \"asGoToBuildPose "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l Mirror -c \"asMirror "+$uiName+"\";\n";
	$fDet+="\tmenuItem -optionBox 1 -c \"asMirrorOptions "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Anim;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 1\";\n";
	$fDet+="\tmenuItem -l Paste -en 0 "+$uiName+"AnimPaste;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Clean -c \"asDeleteStaticChannels "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asAnimBake "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l SwitchFKIK -c asAutoSwitchFKIK;\n";
	$fDet+="\tmenuItem -l SwitchPivot -c asAutoSwitchPivot;\n";
	$fDet+="menu -l Dynamics;\n";
	$fDet+="\tmenuItem -l \"Add to selected\" -c \"asDynAdd "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l \"Remove from selected\" -c \"asDynRemove "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l \"Set Initial State\" -c \"evalEcho saveInitialState -all\";\n";
	$fDet+="\tmenuItem -l \"Interactive Playback\" -c \"evalEcho InteractivePlayback\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asDynBake "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l UnBake -c \"asDynUnBake "+$uiName+"\";\n";
	$fDet+="menu -l Parent;\n";
	$fDet+="\tmenuItem -l \"Add parent constraint\" -c \"asParentAdd asPicker 0\";\n";
	$fDet+="\tmenuItem -l \"Add parent constraint (Extra)\" -c \"asParentAdd asPicker 1\";\n";
	}
$fDet+="\n";

//controlsets
string $controlSetsText;
string $menuItems[];
if (`menu -q -ex ("as"+$tool+"ControlSetsMenu")`)
	{
	$menuItems=`menu -q -ia ("as"+$tool+"ControlSetsMenu")`;
	for ($i=0;$i<size($menuItems);$i++)
		if (`menuItem -q -cb $menuItems[$i]`)
			$controlSetsText+=`menuItem -q -l $menuItems[$i]`+" ";
	}

//remove old files & copy files from `untitled`
string $fileList[];
if (`file -q -ex ($projectPath+$projectName)`)
	{
	$fileList=`getFileList -fld ($projectPath+$projectName+"/")`;
	for ($file in $fileList)
		sysFile -del ($projectPath+$projectName+"/"+$file);
	}
else
	sysFile -md ($projectPath+$projectName);
$fileList=`getFileList -fld $tmpIconDir`;
for ($file in $fileList)
	if (!`gmatch $file "*.tif"`)
		sysFile -cp ($projectPath+$projectName+"/"+`substitute ("untitled_") $file ($projectName+"_")`) ($tmpIconDir+$file);

window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");

if ($tool=="Poser")
	{
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="optionMenu -cc \"asCharChange "+$uiName+"\" "+$uiName+"OptionMenu;\n";
	$fDet+="scrollLayout "+$uiName+"ScrollLayout;\n";
	int $cw=`gridLayout -q -cw asPoserDefaultGridLayout`;
	int $ch=`gridLayout -q -ch asPoserDefaultGridLayout`;
	int $nc=`intField -q -v asPoserNc`;
	int $nr=`intField -q -v asPoserNr`;
	$fDet+="gridLayout -cw "+$cw+" -ch "+$ch+" -nc "+$nc+" -nr "+$nr+" "+$uiName+"GridLayout;\n";


	$fDet+="formLayout -e\n";
	$fDet+="	-af "+$uiName+"OptionMenu \"top\" 0\n";
	$fDet+="	-ac "+$uiName+"ScrollLayout \"top\" 0 "+$uiName+"OptionMenu\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"bottom\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"left\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"right\" 0\n";
	$fDet+="	"+$uiName+"FormLayout;\n";
	$fDet+="\n";
	$fDet+="\n";

	string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
	int $childNum,$doConnectControl;
	string $cmd,$label,$ann,$animAnn;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] "asPoser*"`)
			{
			$iconTextButton=("asPoserDefaultIconTextButton"+$childNum);
			$floatSlider=("asPoserDefaultFloatSlider"+$childNum);
			$text=("asPoserDefaultText"+$childNum);
			$label=`text -q -l $text`;
			$doConnectControl=`floatSlider -q -m $floatSlider`;
			$ann=`floatSlider -q -ann $floatSlider`;
			$cmd=`iconTextButton -q -c $iconTextButton`;
			$cmd=`substitute  "asPoserDefault" $cmd $uiName`;
			$cmd=`substitute  "untitled_" $cmd ($projectName+"_")`;
			$cmd=`encodeString $cmd`;
			$bgc="";
			if (!`gmatch $cmd "asSetAttrs *"`)
				$bgc=" -bgc 1 0 0";
			$fDet+="string $cmd=\""+$cmd+"\";\n";
			$image=`iconTextButton -q -i $iconTextButton`;
			tokenize ("\""+$image+"\"") "/" $buffer;
			tokenize $buffer[size($buffer)-1] "." $buffer;
			$imageNr=`match "[0-9]+$" $buffer[0]`;
			$animAnn=`rowColumnLayout -q -ann ("asPoserDefaultRowColumnLayout"+$childNum)`;

			$fDet+="setParent "+$uiName+"GridLayout;\n";
			$fDet+="columnLayout "+$uiName+"ColumnLayout"+$childNum+";\n";
			$fDet+="rowColumnLayout -ann "+$animAnn+" -nc 2 -cw 1 100 -cw 2 15 "+$uiName+"RowColumnLayout"+$childNum+";\n";
			$fDet+="iconTextButton -w 100 -h 75 -i ($asIconLocation+\""+$projectName+"_"+$imageNr+$ext+"\") -c $cmd "+$uiName+"IconTextButton"+$childNum+";\n";
			float $min=`floatSlider -q -min $floatSlider`;
			float $max=`floatSlider -q -max $floatSlider`;
			$fDet+="floatSlider -ann \""+$ann+"\" -m "+$doConnectControl+" -min "+$min+" -max "+$max+" -w 10 -h 75 -hr 0 "+$uiName+"FloatSlider"+$childNum+";\n";
			$fDet+="text -h 15 -al \"center\" -fn \"smallBoldLabelFont\" -l \""+$label+"\""+$bgc+" "+$uiName+"Text"+$childNum+";\n";

			//place it
			$fDet+="gridLayout -e -pos "+$uiName+"ColumnLayout"+$childNum+" "+$childNum+" "+$uiName+"GridLayout;\n";

			//popups
			$fDet+="asPoserupdateGridBlock "+$uiName+" "+$childNum+";\n";

			$fDet+="\n";
			}
		}

	$fDet+="\n";
	$fDet+="asPopulateNameSpaceMenu as"+$tool+$projectName+";\n";
	$fDet+="asCharChange "+$uiName+";\n";
	$fDet+="evalDeferred \"showWindow;\";\n";
	$fDet+="}\n"+$uiName+";\n\n";
	}
if ($tool=="Selector")
	{
	int $pictureWidth=`text -q -l asSelectorBackgroundWidth`;
	int $pictureHeight=`text -q -l asSelectorBackgroundHeight`;
	
	string $allCtls[]=`formLayout -q -ca asSelectorDefaultFormLayout`;
	string $ctlName[],$ctlType[],$ctlWidth[],$ctlHeight[],$ctlLeft[],$ctlTop[],$ctlImage[],$ctlCmd[],$ctlIol[],$ctlAnn[];
	string $ctlKeyCmd[],$ctlLinearKeyCmd[];
	string $ctlAlignFK2IKCmd[],$ctlAlignIK2FKCmd[],$ctlSwitchFK2IKCmd[],$ctlSwitchIK2FKCmd[];
	string $buffer[],$tempString[],$menuItems[];
	int $numTok;
	string $shortImageFileName,$oldProjectName;
	for ($i=0;$i<size($allCtls);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$ctlName[$i]=`substitute "asSelector" $allCtls[$i] $uiName`;
		if (`image -q -ex $allCtls[$i]`)
			$ctlType[$i]="image";
		if (`iconTextButton -q -ex $allCtls[$i]`)
			$ctlType[$i]="iconTextButton";
		$ctlWidth[$i]=`control -q -w $allCtls[$i]`;
		$ctlHeight[$i]=`control -q -h $allCtls[$i]`;
		$numTok=`tokenize $allCtls[$i] ":" $buffer`;
		$ctlLeft[$i]=$buffer[$numTok-2];
		$ctlTop[$i]=$buffer[$numTok-1];
		if ($ctlType[$i]=="iconTextButton")
			{
			$ctlImage[$i]=`eval ($ctlType[$i]+" -q -i \""+$allCtls[$i]+"\"")`;
			tokenize $ctlImage[$i] "/" $buffer;
			$shortImageFileName=$buffer[size($buffer)-1];
			tokenize $shortImageFileName "_" $buffer;
			$oldProjectName=$buffer[0];
			for ($b=1;$b<size($buffer)-3;$b++)
				$oldProjectName+="_"+$buffer[$b];
			$ctlImage[$i]=`substitute ($oldProjectName+"_") $shortImageFileName ($projectName+"_")`;
			$ctlCmd[$i]=`eval ($ctlType[$i]+" -q -c \""+$allCtls[$i]+"\"")`;
			$ctlCmd[$i]=`substitute "\"Default\"" $ctlCmd[$i] ("\""+$projectName+"\"")`;
			$ctlCmd[$i]="\""+`encodeString $ctlCmd[$i]`+"\"";
			$ctlAnn[$i]=`eval ($ctlType[$i]+" -q -ann \""+$allCtls[$i]+"\"")`;
			$ctlIol[$i]=`eval ($ctlType[$i]+" -q -iol \""+$allCtls[$i]+"\"")`;
			$tempString=`eval ($ctlType[$i]+" -q -pma \""+$allCtls[$i]+"\"")`;
			$menuItems=`popupMenu -q -ia $tempString[0]`;
			$ctlKeyCmd[$i]=`menuItem -q -c $menuItems[0]`;
			$ctlKeyCmd[$i]=`substitute "\"Default\"" $ctlKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlKeyCmd[$i]="\""+`encodeString $ctlKeyCmd[$i]`+"\"";
			$ctlLinearKeyCmd[$i]=`menuItem -q -c $menuItems[1]`;
			$ctlLinearKeyCmd[$i]=`substitute "\"Default\"" $ctlLinearKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlLinearKeyCmd[$i]="\""+`encodeString $ctlLinearKeyCmd[$i]`+"\"";
			if (size($menuItems)>6)
				{
				$subMenuItems=`menu -q -ia $menuItems[5]`;
				$ctlAlignFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlAlignFK2IKCmd[$i]=`substitute "\"Default\"" $ctlAlignFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignFK2IKCmd[$i]="\""+`encodeString $ctlAlignFK2IKCmd[$i]`+"\"";
				$ctlAlignIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlAlignIK2FKCmd[$i]=`substitute "\"Default\"" $ctlAlignIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignIK2FKCmd[$i]="\""+`encodeString $ctlAlignIK2FKCmd[$i]`+"\"";
				$subMenuItems=`menu -q -ia $menuItems[6]`;
				$ctlSwitchFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlSwitchFK2IKCmd[$i]=`substitute "\"Default\"" $ctlSwitchFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchFK2IKCmd[$i]="\""+`encodeString $ctlSwitchFK2IKCmd[$i]`+"\"";
				$ctlSwitchIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlSwitchIK2FKCmd[$i]=`substitute "\"Default\"" $ctlSwitchIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchIK2FKCmd[$i]="\""+`encodeString $ctlSwitchIK2FKCmd[$i]`+"\"";
				}
			}
		}

	$fDet+="columnLayout -adj 1;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="rowLayout -nc 5 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 65 -cw 4 50 -cw 5 60;\n";
	$fDet+="optionMenu -cc asSelChange "+$uiName+"OptionMenu;\n";
	$fDet+="button -l set -c \"asSetNameSpaceFromSelection "+$uiName+"\";\n";
	$fDet+="checkBox -v `optionVar -q asShowSelection` -onc \"optionVar -iv asShowSelection 1;asSelChangeToggle;\" -ofc \"optionVar -iv asShowSelection 0;asSelChangeToggle;\" -l Selection "+$uiName+"SelectionCheckBox;\n";
	$fDet+="checkBox -v `optionVar -q asShowKeyed` -onc \"optionVar -iv asShowKeyed 1;asSelChangeToggle;\" -ofc \"optionVar -iv asShowKeyed 0;asSelChangeToggle;\" -l Keyed "+$uiName+"KeyedCheckBox;\n";
	$fDet+="checkBox -v `optionVar -q asShowExtra` -onc \"optionVar -iv asShowExtra 1;asSelChangeToggle;\" -ofc \"optionVar -iv asShowExtra 0;asSelChangeToggle;\" -l Extra "+$uiName+"ExtraCheckBox;\n";
	$fDet+="setParent..;\n";
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="\n";

	$fDet+="//Controls Begin//\n";
	if (`about -mac` || `about -linux`)
		$fDet+="iconTextButton -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	else
		$fDet+="image -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	for ($i=0;$i<size($allCtls);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$fDet+=$ctlType[$i]+" -w "+$ctlWidth[$i]+" -h "+$ctlHeight[$i];
		if ($ctlImage[$i]!="")
			$fDet+=" -i ($asIconLocation+\""+$ctlImage[$i]+"\")";
		if ($ctlImage[$i]!="")
			$fDet+=" -iol \""+$ctlIol[$i]+"\"";
		if ($ctlCmd[$i]!="")
			$fDet+=" -c "+$ctlCmd[$i];
		if ($ctlAnn[$i]!="")
			$fDet+=" -ann \""+$ctlAnn[$i]+"\"";
		$fDet+=" \""+$ctlName[$i]+"\";\n";
		$fDet+="popupMenu;\n";
		$fDet+="\tmenuItem -l Key -c "+$ctlKeyCmd[$i]+";\n";
		$fDet+="\tmenuItem -l LinearKey -c "+$ctlLinearKeyCmd[$i]+";\n";
		if ($ctlAlignFK2IKCmd[$i]!="")
			{
			$fDet+="\tmenuItem -d 1;\n";
			$fDet+="\tmenuItem -l Align -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlAlignFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlAlignIK2FKCmd[$i]+";\n";
			$fDet+="\t\tsetParent -menu ..;\n";
			$fDet+="\tmenuItem -l Switch -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlSwitchFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlSwitchIK2FKCmd[$i]+";\n";
			}
		}
	$fDet+="//Controls End//\n";
	$fDet+="\n";
	$fDet+="formLayout -e\n";
	for ($i=0;$i<size($ctlType);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$fDet+="\t-af \""+$ctlName[$i]+"\" left "+$ctlLeft[$i]+"\n";
		$fDet+="\t-af \""+$ctlName[$i]+"\" top "+$ctlTop[$i]+"\n";
		}
	$fDet+="\t"+$uiName+"FormLayout;\n";
	
	$fDet+="\n\n\n\n";
	
	$fDet+="asPopulateNameSpaceMenu \"asSelector"+$projectName+"\";\n";
	$fDet+="asShowSelJob;\n";
	$fDet+="asSelChange;\n";
	$fDet+="showWindow;\n";
	$fDet+="}\n"+$uiName+";\n\n";
	}

string $AdvancedSkeleton5File=`asGetScriptLocation`+"/AdvancedSkeleton5.mel";
int $fileId2=`fopen $AdvancedSkeleton5File "r"`;
string $nextLine = `fgetline $fileId2`;
int $copyLines=0;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId2`;
	if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
		$copyLines=1;
	if (!$copyLines)
		continue;
	$fDet+=$nextLine;
	if ($nextLine=="//-- ASTools Procedures Ends Here --//\n")
		break;
	}
fclose $fileId2;

int $fileId=`fopen $projectFile "w"`;
fprint $fileId $fDet;
fclose $fileId;

//$installFile
$fDet="";
string $AdvancedSkeletonInstallFile=`asGetScriptLocation`+"/install.mel";
if (!`file -q -ex $AdvancedSkeletonInstallFile`)
	return;
$fileId=`fopen $AdvancedSkeletonInstallFile "r"`;
$nextLine = `fgetline $fileId`;
int $installTemplatePause;
while ( size( $nextLine ) > 0 )
	{
	$nextLine = `fgetline $fileId`;
	if ($nextLine=="//--installTemplate pause--//\n")
		$installTemplatePause=1;
	if ($nextLine=="//--installTemplate resume--//\n")
		{
		$installTemplatePause=0;
		continue;
		}
	if ($installTemplatePause)
		continue;
	if (`gmatch $nextLine "string $scriptName=*"`)
		{
		$fDet+=("string $scriptName=\""+$projectName+"\";\n");
		}
	else if (`gmatch $nextLine "string $sourceFile=*"`)
		{
		$fDet+=("string $sourceFile=$asInstallScriptLocation+\"../\"+$scriptName+\".mel\";\n");
		}
	else if (`gmatch $nextLine "string $icon=*"`)
		{
		$fDet+=("string $icon=$asInstallScriptLocation+\""+$projectName+"_background32.png\";\n");
		}
	else if (`gmatch $nextLine "string $command=*"`)
		{
		$fDet+=("string $command=\"source \\\"\"+$sourceFile+\"\\\"\";\n");
		}
	else
		$fDet+=$nextLine;
	}
fclose $fileId;

$fileId=`fopen $installFile "w"`;
fprint $fileId $fDet;
fclose $fileId;
}
//-- AS IO Procedures (for tools) Ends Here --//


//-- ASTools Procedures Starts Here --//
global proc asSelChange ()
{
global int $asfileLoading;
global int $asSelChangeSwitching;
//int $showSelection=`optionVar -q asSowSelection`;  HERE !
if ($asfileLoading)
	return;
if (!`optionVar -q asShowSelection` && !`optionVar -q asShowKeyed` && !$asSelChangeSwitching)
	return;
int $undoState=`undoInfo -q -state`;
string $sel[]=`ls -sl`;
string $name,$obj,$nodeType,$projectName,$ann;
string $ctls[],$buffer[],$connections[];
int $numLetters,$numTok,$keyed;
string $ext=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=".png";
if (`about -linux`)
	$ext=".xpm";
string $currImage,$buttonImageFile,$buttonImageFileOnK0,$buttonImageFileOnK1,$buttonImageFileOffK0,$buttonImageFileOffK1;
string $windows[]=`lsUI -windows`;
string $layout;
for ($window in $windows)
	{
	$layout="";
	if (size($window)>11)
		$layout="asSelector"+`substring $window 11 999`+"FormLayout";
	if (!`formLayout -q -ex $layout`)
		continue;
	$numLetters=size($layout);
	$name=`substring $layout 11 ($numLetters-10)`;
	$ctls=`formLayout -q -ca $layout`;
	for ($ctl in $ctls)
		{
		if (!`iconTextButton -q -ex $ctl`)
			continue;
		if (`optionVar -q asShowSelection` && !$asSelChangeSwitching)
			$selState="On";
		else
			$selState="Off";
		$keyed=0;
		$ann=`iconTextButton -q -ann $ctl`;
		$numTok=`tokenize $ann ";" $buffer`;
		for ($i=0;$i<$numTok;$i++)
			{
			$obj=`asSelectorResolveNameSpace $name $buffer[$i]`;
			if (!`stringArrayCount $obj $sel`)
				$selState="Off";
			if (`optionVar -q asShowKeyed` && !$asSelChangeSwitching && `objExists $obj`)
				{
				$connections=`listConnections -s 1 -d 0 $obj`;
				for ($node in $connections)
					{
					$nodeType=`objectType $node`;
					if (`gmatch $nodeType "animCurve*"`)
						$keyed=1;
					}
				}
			}

		$currImage=`iconTextButton -q -i1 $ctl`;
		if ($currImage=="")
			return;
		$numTok=`tokenize $currImage "_" $buffer`;
		if ($numTok<3)
			continue;
		$projectName=$buffer[0];
		for ($b=1;$b<size($buffer)-3;$b++)
			$projectName+="_"+$buffer[$b];
		$buttonImageFile=$projectName+"_"+$buffer[$numTok-3]+"_"+$buffer[$numTok-2]+"_"+$selState+"K"+$keyed+$ext;

		if ($buttonImageFile!=$currImage)
			iconTextButton -e -i $buttonImageFile $ctl;		
		}
	}

//PickerSelChange
if (!`optionMenu -q -ex asPickerOptionMenu`)
	return;
int $selectedTabIndex,$overrideColor;
string $picCtrls[],$selPicCtrls[],$selChrCtrls[],$tabLabels[];
string $picNs,$chrNs,$picCtrl,$chrCtrl;

if (`optionMenu -q -ex asPickerOptionMenu`)
	$chrNs=`optionMenu -q -v asPickerOptionMenu`;
if ($chrNs==":")
	$chrNs="";
if (`tabLayout -q -ex asPickerTabLayout`)
	{
	$tabLabels=`tabLayout -q -tl asPickerTabLayout`;
	$selectedTabIndex=`tabLayout -q -selectTabIndex asPickerTabLayout`;
	$picNs="picker_"+$tabLabels[$selectedTabIndex-1]+":";
	}
$picCtrls=`ls -type transform ($picNs+"*")`;
$selPicCtrls=`ls -sl -type transform ($picNs+"*")`;
$selChrCtrls=`ls -sl -type transform ($chrNs+"*")`;

//All .overrideColor==0 off first
if ($undoState) undoInfo -stateWithoutFlush 0;

for ($i=0;$i<size($picCtrls);$i++)
	{
	$overrideColor=0;
	$chrCtrl=`substitute $picNs $picCtrls[$i] $chrNs`;
	if (`optionVar -q asShowExtra`) $chrCtrl=`substitute "FK" $chrCtrl "FKExtra"`;
	if (`objExists $chrCtrl`)
		if (`optionVar -q asShowKeyed` && `asHaveAnimation $chrCtrl`)
			$overrideColor=13;
	setAttr ($picCtrls[$i]+".overrideColor") $overrideColor;
	}

if (!size($selPicCtrls) && !size($selChrCtrls))
	{
	if ($undoState) undoInfo -stateWithoutFlush 1;
	return;
	}

for ($i=0;$i<size($sel);$i++)
	{
	if (`optionVar -q asShowSelection`)
		$overrideColor=14;
	if (`gmatch $sel[$i] ($picNs+"*")`) // $picNs > $chrNs
		{
		$chrCtrl=`substitute $picNs $sel[$i] $chrNs`;
		if (`optionVar -q asShowExtra`) $chrCtrl=`substitute "FK" $chrCtrl "FKExtra"`;
		if (`objExists $chrCtrl` && `optionVar -q asShowSelection`)
			{
			select -d  $sel[$i];
			select -add $chrCtrl;
			if (`optionVar -q asShowKeyed` && `asHaveAnimation $chrCtrl`)
				$overrideColor=13;
			setAttr ($sel[$i]+".overrideColor") $overrideColor;
			}
		else
			print ("// "+$chrCtrl+" not found.\n");
		}
	if (`gmatch $sel[$i] ($chrNs+"*")`) // $chrNs > $picNs
		{
		if ($chrNs=="")
			$picCtrl=$picNs+$sel[$i];
		else
			$picCtrl=`substitute $chrNs $sel[$i] $picNs`;
		if (`optionVar -q asShowExtra`)
			{
			if (!`gmatch $picCtrl "*Extra*"`) continue;
			$picCtrl=`substitute "FKExtra" $picCtrl "FK"`;
			}
		if (`objExists $picCtrl`)
			setAttr ($picCtrl+".overrideColor") $overrideColor;
		}
	}
if ($undoState) undoInfo -stateWithoutFlush 1;
}

global proc float asMayaVersionAsFloat ()
{
float $version=2012;
if (`about -v`=="2016 Extension 2")
	return 2016.5;
if (`exists getApplicationVersionAsFloat`)
	return `getApplicationVersionAsFloat`;
string $versionString=`about -v`;
string $tempString[];
string $char;
tokenize $versionString $tempString;
//default to 2012, if versionString is not all numbers
for ($i=0;$i<size($tempString[0]);$i++)
	{
	$char=`substring $tempString[0] ($i+1) ($i+1)`;
	if (!`gmatch $char "[0-9]"`)
		return 2012;
	}
$version=$tempString[0];
return $version;
}

global proc asSelChangeToggle ()
{
global int $asSelChangeSwitching;
$asSelChangeSwitching=1;
string $sel[]=`ls -sl`;
select -cl;
asSelChange;
$asSelChangeSwitching=0;
select $sel;
}

global proc asCharChange (string $uiName)
{
string $gridOrder[];
if (`gridLayout -q -ex ($uiName+"GridLayout")`)
	{
	$gridOrder=`gridLayout -q -go ($uiName+"GridLayout")`;
	for ($i=1;$i<size($gridOrder)+1;$i++)
		if (`floatSlider -q -ex ($uiName+"FloatSlider"+$i)`)
			{
			$ann=`floatSlider -q -ann ($uiName+"FloatSlider"+$i)`;
			$resolvedName=`asPoserResolveNameSpace $uiName $ann`;
			if (`objExists $resolvedName`)
				connectControl ($uiName+"FloatSlider"+$i) $resolvedName;
			}
	}
asSelChange;
}

global proc asShowSelJob ()
{
global int $asSelChangeScripJobNr;
if ($asSelChangeScripJobNr)
	return;
$asSelChangeScripJobNr=`scriptJob -e "SelectionChanged" "asSelChange"`;
}

global proc string asSelectorResolveNameSpace (string $name, string $obj)
{
string $nameSpace;
string $tempString[];
if (`optionMenu -q -ex ("asSelector"+$name+"OptionMenu")`)
	$nameSpace=`optionMenu -q -v ("asSelector"+$name+"OptionMenu")`;
else if (`optionMenu -q -ex ("asPickerOptionMenu")`)
	$nameSpace=`optionMenu -q -v ("asPickerOptionMenu")`;
else if (`gmatch $name "*:*"`)
	{
	tokenize $name ":" $tempString;
	$nameSpace=$tempString[0]+":";
	}
if ($nameSpace==":")
	$nameSpace="";
string $extraObj;
//Extra control
if (`checkBox -q -ex ("asSelector"+$name+"ExtraCheckBox")`)
	if (`checkBox -q -v ("asSelector"+$name+"ExtraCheckBox")`)
		if (size($obj)>2)
			{
			$extraObj=`substring $obj 1 2`+"Extra"+`substring $obj 3 99`;
			if (`objExists ($nameSpace+$extraObj)`)
				return ($nameSpace+$extraObj);
			}
return ($nameSpace+$obj);
}

global proc asSelect (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

int $modifier=`getModifiers`;
if (($modifier %  2)==0)
	select -cl;
if ($objs[0]=="")
	{
	select -cl;
	return;
	}
for ($obj in $objs)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
for ($obj in $objs)
	select -tgl $obj;
//enable hotKeys
string $formLayout="asSelector"+$name+"FormLayout";
if (`formLayout -q -ex $formLayout`)
	setFocus $formLayout;
}

global proc asKey (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

for ($obj in $objs)
	setKeyframe $obj;
select `ls -sl`;
asSelChange;
}

global proc asLinearKey (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

for ($obj in $objs)
	setKeyframe -itt linear -ott linear $obj;
select `ls -sl`;
asSelChange;
}

global proc asAlignIK2FK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asAlignFKIK" "IK2FK";
}

global proc asAlignFK2IK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asAlignFKIK" "FK2IK";
}

global proc asSwitchIK2FK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asSwitchFKIK" "IK2FK";
}

global proc asSwitchFK2IK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asSwitchFKIK" "FK2IK";
}

global proc asAssembleAlignSwitchCmd (string $name, string $objs[], string $alignSwitchCmd, string $W2K)
{
global int $asBakeFKIK;
$asBakeFKIK=0;
int $numLetters=size($objs[0]);
string $IK=`substring $objs[0] 5 ($numLetters-2)`;
string $side=`substring $objs[0] ($numLetters-1) $numLetters`;
eval ($alignSwitchCmd+" "+$name+" "+$IK+" "+$side+" "+$W2K);
}

global proc asAlignFKIK (string $name, string $IK, string $side, string $W2K)
{
global int $asBakeFKIK;
string $sel[]=`ls -sl`;
string $nameSpace=`asSelectorResolveNameSpace $name ""`;
string $controlCurve=$nameSpace+"FKIK"+$IK+$side;
if (!`objExists $controlCurve`)
	error ("Object:\""+$controlCurve+"\" does not exists !");
string $startJoint=`getAttr ($controlCurve+".startJoint")`;
string $middleJoint=`getAttr ($controlCurve+".middleJoint")`;
string $endJoint=`getAttr ($controlCurve+".endJoint")`;
string $curveCmd;
string $tempLoc1[],$tempLoc2[],$tempConstraint[],$tempConstraintAttrs[],$chainJoints[];
int $isSplineIK,$numIkCtrls,$cvNr;
float $IKCurveLenght,$dist,$stiff,$middleJointLenght,$endJointLenght;
float $pos[],$rot[],$posA[],$posB[],$tempFloat[],$alignIkToFloat[];
if (!`objExists ($nameSpace+"Pole"+$IK+$side)`)
	$isSplineIK=1;
string $requiredObj[]={($nameSpace+"Main"),($nameSpace+"FKX"+$startJoint+$side),($nameSpace+"IKX"+$startJoint+$side),($nameSpace+"IKX"+$middleJoint+$side)};
if ($isSplineIK)
	{
	$chainJoints=`asgetChainJoints ($nameSpace+$startJoint) ($nameSpace+$endJoint)`;
	for ($i=0;$i<size($chainJoints);$i++)
		$chainJoints[$i]=`substitute $nameSpace $chainJoints[$i] ""`;
	for ($i=1;$i<99;$i++)
		{
		if (!`objExists ($nameSpace+"IK"+$IK+$i+$side)`)
			break;
		$numIkCtrls=$i;
		}
	}
else
	$requiredObj=`stringArrayCatenate $requiredObj {($nameSpace+"Pole"+$IK+$side),($nameSpace+"FKX"+$endJoint+$side)}`;
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
float $charsize=`getAttr ($nameSpace+"Main.height")`;
int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -st 0;
if ($asBakeFKIK)
	autoKeyframe -st 1;

string $deleteObjs[]={"IK2FKTempCurve","IK2FKTempXform","IK2FKTempXform2","IK2FKTempXform3","IK2FKTempCurveInfo"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

if ($W2K=="FK2IK" && !$isSplineIK)
	{
	$tempFloat=`xform -q -ws -t ($nameSpace+"FK"+$endJoint+$side)`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);
	$tempLoc1=`spaceLocator`;
	$tempConstraint=`pointConstraint ($nameSpace+"FKX"+$startJoint+$side) ($nameSpace+"FKX"+$endJoint+$side) $tempLoc1[0]`;
	$tempConstraintAttrs=`listAttr -ud $tempConstraint`;

	$middleJointLenght=`getAttr ($nameSpace+"FKOffset"+$middleJoint+$side+".tx")`;
	$endJointLenght=`getAttr ($nameSpace+"FKOffset"+$endJoint+$side+".tx")`;
	setAttr ($tempLoc1[0]+"_pointConstraint1."+$tempConstraintAttrs[0]) `abs($endJointLenght)`;
	setAttr ($tempLoc1[0]+"_pointConstraint1."+$tempConstraintAttrs[1]) `abs($middleJointLenght)`;
	delete $tempConstraint[0];
	$tempConstraint=`aimConstraint -aimVector 1 0 0 ($nameSpace+"FKX"+$middleJoint+$side) $tempLoc1[0]`;
	$tempLoc2=`spaceLocator`;
	parent $tempLoc2[0] $tempLoc1[0];
	setAttr -type float3 ($tempLoc2[0]+".translate") ($charsize/3.333) 0 0;
	$tempFloat=`xform -q -ws -t $tempLoc2[0]`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"Pole"+$IK+$side);
	delete $tempLoc1;
	$tempFloat=`xform -q -ws -ro ($nameSpace+"AlignIKTo"+$endJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);
	if (`objExists ($nameSpace+"IKXToes"+$side)`)
		if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
			setAttr ($nameSpace+"IK"+$IK+$side+".roll") 0;
	}
if ($W2K=="FK2IK" && $isSplineIK)
	{
	$curveCmd="curve -n IK2FKTempCurve -d 1 ";
	for ($i=0;$i<size($chainJoints);$i++)
		{
		if (`objExists ($nameSpace+"FKX"+$chainJoints[$i]+$side)`)
			$pos=`xform -q -ws -t ($nameSpace+"FKX"+$chainJoints[$i]+$side)`;
		else // Tail does not have FKX joint at last $chainJoints, so resolve position
			{
			createNode -n IK2FKTempXform -p ($nameSpace+"FKX"+$chainJoints[($i-1)]+$side) transform;
			$pos=`getAttr ($nameSpace+$chainJoints[$i]+$side+".t")`;
			setAttr -type float3 IK2FKTempXform.t $pos[0] $pos[1] $pos[2];
			$pos=`xform -q -ws -t IK2FKTempXform`;
			delete IK2FKTempXform;
			}
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		}
	eval ($curveCmd);
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s ($numIkCtrls-1) -d 3 -tol 0.0004 IK2FKTempCurve;

	createNode -n IK2FKTempCurveInfo curveInfo;
	connectAttr ($nameSpace+"IK"+$IK+"Curve_M.worldSpace[0]") IK2FKTempCurveInfo.inputCurve;
	$IKCurveLenght=`getAttr IK2FKTempCurveInfo.arcLength`;
	delete IK2FKTempCurveInfo;

	for ($i=1;$i<$numIkCtrls+1;$i++)
		{
		$cvNr=$i;
		if ($i==1) $cvNr=0;
		if ($i==$numIkCtrls) $cvNr=$i+1;
		$pos=`xform -q -ws -t IK2FKTempCurve.cv[$cvNr]`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($nameSpace+"IK"+$IK+$i+$side);
		if ($i==1 || $i==$numIkCtrls)
			{
			if ($i==1) createNode -n IK2FKTempXform -p ($nameSpace+"IK"+$IK+"0AlignTo"+$side) transform;
			if ($i==$numIkCtrls) createNode -n IK2FKTempXform -p ($nameSpace+"IK"+$IK+$numIkCtrls+"AlignTo"+$side) transform;
			createNode -n IK2FKTempXform2 transform;
			createNode -n IK2FKTempXform3 transform;
			parent IK2FKTempXform3 IK2FKTempXform;
			setAttr -type float3 IK2FKTempXform3.t 0 0 0;
			if ($i==1) $pos=`xform -q -ws -t IK2FKTempCurve.cv[1]`;
			if ($i==$numIkCtrls) $pos=`xform -q -ws -t IK2FKTempCurve.cv[$numIkCtrls]`;
			xform -ws -t $pos[0] $pos[1] $pos[2] IK2FKTempXform2;
			aimConstraint -aimVector 1 0 0 -worldUpType objectrotation -worldUpObject ($nameSpace+"FKX"+$chainJoints[0]+$side) -worldUpVector 0 1 0 IK2FKTempXform2 IK2FKTempXform;
			if ($i==$numIkCtrls)
				{
				setAttr IK2FKTempXform_aimConstraint1.aimVectorX -1;
				connectAttr -f ($nameSpace+$chainJoints[(size($chainJoints)-1)]+$side+".worldMatrix[0]") IK2FKTempXform_aimConstraint1.worldUpMatrix;
				}
			$rot=`xform -q -ws -ro IK2FKTempXform3`;
			if ($i==$numIkCtrls && `objExists ($nameSpace+"AlignIKTo"+$chainJoints[(size($chainJoints)-1)]+$side)`)//e.g chest
				$rot=`xform -q -ws -ro ($nameSpace+"AlignIKTo"+$chainJoints[(size($chainJoints)-1)]+$side)`;
			xform -ws -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"IK"+$IK+$i+$side);

			//calculate stiffness $IKCurveLenght
			if ($i==1) 					 {$posA=`xform -q -ws -t IK2FKTempCurve.cv[0]`;   $posB=`xform -q -ws -t IK2FKTempCurve.cv[1]`;}
			if ($i==$numIkCtrls) {$posA=`xform -q -ws -t IK2FKTempCurve.cv[$i+1]`;$posB=`xform -q -ws -t IK2FKTempCurve.cv[$i]`;}
			$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
			$stiff=($dist/($IKCurveLenght/2.0))*10;
			if ($stiff<0) $stiff=0;
			if ($stiff>10) $stiff=10;
			setAttr ($nameSpace+"IK"+$IK+$i+$side+".stiff") $stiff;
			delete IK2FKTempXform IK2FKTempXform2 IK2FKTempXform3;
			}
		}
	delete IK2FKTempCurve;
	print "// Switching from FK to Curve-Based-IK, Target will not fully Align.\n";
	}
if ($W2K=="IK2FK" && !$isSplineIK)
	{
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$startJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$startJoint+$side);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$middleJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$middleJoint+$side);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$endJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$endJoint+$side);
	if (`objExists ($nameSpace+"IKXToes"+$side)`)
		{
		$tempFloat=`xform -q -ws -ro ($nameSpace+"IKXToes"+$side)`;
		xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FKToes"+$side);
		}
	}
if ($W2K=="IK2FK" && $isSplineIK)
	{
	for ($i=0;$i<size($chainJoints);$i++)
		{
		if (!`objExists ($nameSpace+"IKX"+$chainJoints[$i]+$side)` || !`objExists ($nameSpace+"FK"+$chainJoints[$i]+$side)`)
			continue;
		// RootX_M.legLock warning
		if ($chainJoints[$i]=="Root")
			if (`attributeExists legLock RootX_M`)
				if (`getAttr RootX_M.legLock`!=10)
					print ("// Switching from IK to FK for the Spine, Set RootX_M.legLock to 10, for more accurate switching.\n");
		$pos=`xform -q -ws -t ($nameSpace+"IKX"+$chainJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($nameSpace+"IKX"+$chainJoints[$i]+$side)`;
		//inbetween, to use last inbetweener`s rot
		for ($numParts=0;$numParts<99;$numParts++)
			if (!`objExists ($chainJoints[$i]+"Part"+($numParts+1)+$side)`)
				break;
		if ($numParts>0)
			$rot=`xform -q -ws -ro ($nameSpace+$chainJoints[$i]+"Part"+$numParts+$side)`;
		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"FK"+$chainJoints[$i]+$side);
		}
	}

if ($autoKey)
	autoKeyframe -st 1;
if (!$autoKey && $asBakeFKIK)
	autoKeyframe -st 0;
select $sel;
}

global proc asSwitchFKIK (string $name, string $IK, string $side, string $W2K)
{
string $sel[]=`ls -sl`;
string $nameSpace=`asSelectorResolveNameSpace $name ""`;
string $controlCurve=$nameSpace+"FKIK"+$IK+$side;
string $poleCurve=$nameSpace+"Pole"+$IK+$side;
if (!`objExists $controlCurve`)
	error ("Object:\""+$controlCurve+"\" does not exists !");
string $startJoint=`getAttr ($controlCurve+".startJoint")`;
string $middleJoint=`getAttr ($controlCurve+".middleJoint")`;
string $endJoint=`getAttr ($controlCurve+".endJoint")`;
string $chainJoints[];
int $isSplineIK,$numIkCtrls;
if (!`objExists ($nameSpace+"Pole"+$IK+$side)`)
	$isSplineIK=1;
string $requiredObj[]={($nameSpace+"Main"),($nameSpace+"FKX"+$startJoint+$side),($nameSpace+"IKX"+$startJoint+$side),($nameSpace+"IKX"+$middleJoint+$side)};
if ($isSplineIK)
	{
	$chainJoints=`asgetChainJoints ($nameSpace+$startJoint) ($nameSpace+$endJoint)`;
	for ($i=0;$i<size($chainJoints);$i++)
		$chainJoints[$i]=`substitute $nameSpace $chainJoints[$i] ""`;
	for ($i=1;$i<99;$i++)
		{
		if (!`objExists ("IK"+$IK+$i+$side)`)
			break;
		$numIkCtrls=$i;
		}
	}
else
	$requiredObj=`stringArrayCatenate $requiredObj {($nameSpace+"Pole"+$IK+$side),($nameSpace+"FKX"+$endJoint+$side)}`;
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
int $Blend;
int $BlendInverse=10;
int $onOff;
if ($W2K=="FK2IK")
	{
	$Blend=10;
	$BlendInverse=0;
	$onOff=1;
	}

if ($W2K=="FK2IK" && `getAttr ($controlCurve+".FKIKBlend")`>0)
	{
	warning ("Could not switch FK2IK, because \"FKIKBlend\" is not \"0\"\n");
	return;
	}
if ($W2K=="IK2FK" && `getAttr ($controlCurve+".FKIKBlend")`<10)
	{
	warning ("Could not switch IK2FK, because \"FKIKBlend\" is not \"10\"\n");
	return;
	}

int $autoKey=`autoKeyframe -q -st`;

currentTime (`currentTime -q` -1);
setAttr ($controlCurve+".FKIKBlend") $BlendInverse;
if ($autoKey && !$isSplineIK)
	{
	setKeyframe ($controlCurve+".FKIKBlend");
	setKeyframe ($poleCurve+".follow");	

	setKeyframe ($nameSpace+"FK"+$startJoint+$side+".rotate");
	setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".rotate");
	setKeyframe ($nameSpace+"FK"+$endJoint+$side+".rotate");
	setKeyframe ($nameSpace+"IK"+$IK+$side+".translate");
	setKeyframe ($nameSpace+"IK"+$IK+$side+".rotate");
	setKeyframe ($nameSpace+"Pole"+$IK+$side+".translate");

	if (`objExists ($nameSpace+"IKXToes"+$side)`)
		{
		setKeyframe ($nameSpace+"FKToes"+$side+".rotate");
		if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
			setKeyframe ($nameSpace+"IK"+$IK+$side+".roll");
		}
	}
if ($autoKey && $isSplineIK)
	{
	setKeyframe ($controlCurve+".FKIKBlend");
	for ($i=0;$i<size($chainJoints);$i++)
		if (`objExists ($nameSpace+"FK"+$chainJoints[$i]+$side)`)
			{
			setKeyframe ($nameSpace+"FK"+$chainJoints[$i]+$side+".t");
			setKeyframe ($nameSpace+"FK"+$chainJoints[$i]+$side+".r");
			}
	for ($i=1;$i<$numIkCtrls+1;$i++)
		if (`objExists ("IK"+$IK+$i+$side)`)
			{
			setKeyframe ("IK"+$IK+$i+$side+".t");
			setKeyframe ("IK"+$IK+$i+$side+".r");
			if (`attributeExists "stiff" ("IK"+$IK+$i+$side)`)
				setKeyframe ("IK"+$IK+$i+$side+".stiff");
			}
	}

currentTime (`currentTime -q` +1);
asAlignFKIK $name $IK $side $W2K;
setAttr ($controlCurve+".FKIKBlend") $Blend;

if ($autoKey && !$isSplineIK)
	{
	setAttr ($poleCurve+".follow") 0;

	setKeyframe ($controlCurve+".FKIKBlend");
	setKeyframe ($poleCurve+".follow");

	setKeyframe ($nameSpace+"FK"+$startJoint+$side+".rotate");
	setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".rotate");
	setKeyframe ($nameSpace+"FK"+$endJoint+$side+".rotate");
	setKeyframe ($nameSpace+"IK"+$IK+$side+".translate");
	setKeyframe ($nameSpace+"IK"+$IK+$side+".rotate");
	setKeyframe ($nameSpace+"Pole"+$IK+$side+".translate");
	if (`objExists ($nameSpace+"IKXToes"+$side)`)
		{
		setKeyframe ($nameSpace+"FKToes"+$side+".rotate");
		if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
			setKeyframe ($nameSpace+"IK"+$IK+$side+".roll");
		}
	}
if ($autoKey && $isSplineIK)
	{
	setKeyframe ($controlCurve+".FKIKBlend");
	for ($i=0;$i<size($chainJoints);$i++)
		if (`objExists ($nameSpace+"FK"+$chainJoints[$i]+$side)`)
			{
			setKeyframe ($nameSpace+"FK"+$chainJoints[$i]+$side+".t");
			setKeyframe ($nameSpace+"FK"+$chainJoints[$i]+$side+".r");
			}
	for ($i=1;$i<$numIkCtrls+1;$i++)
		if (`objExists ("IK"+$IK+$i+$side)`)
			{
			setKeyframe ("IK"+$IK+$i+$side+".t");
			setKeyframe ("IK"+$IK+$i+$side+".r");
			if (`attributeExists "stiff" ("IK"+$IK+$i+$side)`)
				setKeyframe ("IK"+$IK+$i+$side+".stiff");
			}
	}

select $sel;
}

global proc string[] asgetChainJoints (string $startJoint, string $endJoint)
{
int $startJointIsParentNr;
string $chainJoints[];
string $tempString[]=`ls -l $endJoint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	$startJointIsParentNr=$i;
	if ($tempString[$i]==$startJoint)
		{
		break;
		}
	}
for ($i=$startJointIsParentNr;$i<size($tempString);$i++)
	$chainJoints[size($chainJoints)]=$tempString[$i];
return $chainJoints;
}

global proc asPopulateNameSpaceMenu (string $name)
{
string $optionMenu=$name+"OptionMenu";
string $nameSpacesList[]=`namespaceInfo -lon`;
$nameSpacesList=`stringArrayRemove {"UI"} $nameSpacesList`;
$nameSpacesList[size($nameSpacesList)]="";
string $itemList[]=`optionMenu -q -ils $optionMenu`;
$nameSpacesList=`sort $nameSpacesList`;
for ($item in $itemList)
	deleteUI $item;

for ($nameSpace in $nameSpacesList)
	if (`objExists ($nameSpace+":Main")`)
		if (`attributeExists "version" ($nameSpace+":Main")`)
			if (`asFilterCheck $name $nameSpace`)
				menuItem -p $optionMenu -l ($nameSpace+":");

if (!`optionMenu -q -ni ($name+"OptionMenu")`)
	{
	if ($name=="bodySetup" || `gmatch $name "asPoser*"`)
		menuItem -p $optionMenu -l "None";
	else
		menuItem -p $optionMenu -l ":";
	}
}

global proc int asFilterCheck (string $name, string $nameSpace)
{
int $result=0;
string $filterString=`optionVar -q ("asSelectorFilter_"+$name)`;
if ($filterString=="" || $filterString=="0")
	return 1;
string $references[]=`file -q -r`;
for ($i=0;$i<size($references);$i++)
	{
	$refNameSpace=`file -q -ns $references[$i]`;
	if ($refNameSpace==$nameSpace)
		if (`gmatch $references[$i] $filterString`)
			$result=1;
	}
return $result;
}

global proc asFilterNameSpaceMenuUI (string $name)
{
string $filterString=`optionVar -q ("asSelectorFilter_"+$name)`;
if ($filterString=="0")
	$filterString="";
if (`window -q -ex ("SelectorFilter_"+$name)`)
	deleteUI ("SelectorFilter_"+$name);
window ("SelectorFilter_"+$name);
columnLayout;
textFieldGrp -tx $filterString -cc ("asSetFilterNameSpaceMenu "+$name) -l "Reference File Filter. (e.g. *characters*)" -cw 1 200 ("asSelectorFilterTextFieldGrp_"+$name);
showWindow;
}

global proc asSetFilterNameSpaceMenu (string $name)
{
string $filterString=`textFieldGrp -q -tx ("asSelectorFilterTextFieldGrp_"+$name)`;
optionVar -sv ("asSelectorFilter_"+$name) $filterString;
asPopulateNameSpaceMenu $name;
}

global proc asSetNameSpaceFromSelection (string $uiName)
{
asPopulateNameSpaceMenu $uiName;
string $sel[]=`ls -sl`;
string $tempString[],$ils[];
if (size($sel))
	{
	tokenize $sel[0] ":" $tempString;
	$ils=`optionMenu -q -ils ($uiName+"OptionMenu")`;
	for ($i=0;$i<size($ils);$i++)
		if (`menuItem -q -l $ils[$i]`==($tempString[0]+":"))
			{
			optionMenu -e -sl ($i+1) ($uiName+"OptionMenu");
			asSelChange;
			}
	}
print "// Setting nameSpace from selected object\n";
}

global proc asCopyToClipBoard (string $uiName, int $anim)
{
string $cmd=`asPoserGetCmd $uiName $anim`;
if (!$anim)
	menuItem -e -en 1 -c $cmd ($uiName+"PosePaste");
else
	menuItem -e -en 1 -c ($cmd+" 0") ($uiName+"AnimPaste");
}

global proc string[] asGetControlSetsFromUI (string $uiName)
{
int $selectedTabIndex;
string $controlSets[];
string $tempString[],$tabLabels[];
string $controlSetsText;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (`text -q -ex ($uiName+"ControlSetsText")`)//Selector
	{
	$controlSetsText=`text -q -l ($uiName+"ControlSetsText")`;
	tokenize $controlSetsText $tempString;
	for ($i=0;$i<size($tempString);$i++)
		if (`objExists ($nameSpace+$tempString[$i])`)
			$controlSets[size($controlSets)]=$nameSpace+$tempString[$i];
	}
else if ($uiName=="asPicker" && `tabLayout -q -ex asPickerTabLayout`)//Picker
	{
	$tabLabels=`tabLayout -q -tl asPickerTabLayout`;
	$selectedTabIndex=`tabLayout -q -selectTabIndex asPickerTabLayout`;
	if (`gmatch $tabLabels[$selectedTabIndex-1] "*face*"`)
		$controlSets[0]=$nameSpace+"FaceControlSet";
	}
else if ($uiName=="asPoserDefault" && `menuItem -q -ex asPoserControlSetsMenu`)//PoserDesigner
	{
	$tempString=`menu -q -ia asPoserControlSetsMenu`;
	for ($i=0;$i<size($tempString);$i++)
		if (`menuItem -q -cb $tempString[$i]`)
			$controlSets[size($controlSets)]=$nameSpace+`menuItem -q -l $tempString[$i]`;
	}
else
	$controlSets[0]=$nameSpace+"ControlSet";

return $controlSets;
}

global proc asDeleteStaticChannels (string $uiName)
{
if (`confirmDialog -title "Confirm" -message 
	("Clean animation ?\n"
	+"This will delete static channels,\n"
	+"which means remove all animation where the value is not changing")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
string $sel[]=`ls -sl`;
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
select $controlSets;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
print ("// Static channels cleaned\n");
select $sel;
}
	
global proc string asPoserGetCmd (string $uiName, int $anim)
{
global string $gChannelBoxName;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $selectedMainAttrs[]=`channelBox -q -sma $gChannelBoxName`;
string $selectedShapeAttrs[]=`channelBox -q -ssa $gChannelBoxName`;
string $selectedHistoryAttrs[]=`channelBox -q -sha $gChannelBoxName`;
string $selectedOutputAttrs[]=`channelBox -q -soa $gChannelBoxName`;
string $selectedAttrs[];
$selectedAttrs=`stringArrayCatenate $selectedMainAttrs $selectedShapeAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedHistoryAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedOutputAttrs`;
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
int $onlySel;
if ($uiName=="asPoserDefault")
	{
	if (`checkBox -q -ex asPoserOnlySel`)
		$onlySel=`checkBox -q -v asPoserOnlySel`;
	}
else if ($altButton || $ctrlButton)
	$onlySel=1;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $cmd;
string $controls[],$buffer[];
int $weightedTangents[];
int $onlyOneObj,$onlyOneAttr;
string $connectObj;
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
if (!$onlySel && !size($controlSets))
	error "No ControlSets";

//determine the name for poserAnimFile
string $animationFile,$animationFilePath;
string $gridOrder[];
int $childNum;
if (`gmatch $uiName "asPoser*"`)
	{
	$gridOrder=`gridLayout -q -go ($uiName+"GridLayout")`;
	for ($i=1;$i<size($gridOrder)+1;$i++)
		if (`gmatch $gridOrder[$i-1] "asPoser*"`)
			$childNum=$i;
	$childNum++;

	$animationFile="untitled_"+$childNum;
	$animationFilePath=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
	}
else
	{
	$animationFile="ClipBoard";
	$animationFilePath=`internalVar -utd`+"AdvancedSkeleton/Selector/";
	}

string $animCurves[];

if ($onlySel)
	{
	for ($i=$y=0;$i<size($sel);$i++)
		{
		if (`gmatch $sel[$i] ($nameSpace+"*")`)
			{
			tokenize $sel[$i] ":" $buffer;
			$controls[$y]=$buffer[size($buffer)-1];
			$y++;
			}
		}
	}
else
	{
	if (!`objExists $controlSets[0]`)
		error ("Object :\""+$controlSets[0]+"\" does not exists !\n");
	$controls=`sets -q $controlSets`;
	for ($i=0;$i<size($controls);$i++)
		$controls[$i]=`substitute  $nameSpace $controls[$i] ""`;
	}
string $attrs[];
if (size($controls)<1)
	error "No Controls Available!";
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Storing Data" -bp -ii 1 -min 0 -max (size($controls)) $gMainProgressBar;
select -cl;

if ($anim)
	{
	createNode -n poserAnimationInfo transform;
	addAttr -ln "cmd" -dt "string" poserAnimationInfo;
	select poserAnimationInfo;
	}

	{
for ($obj in $controls)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		error "Interrupted";
	$allKeyableAttrs=`listAttr -k -m -sn ($nameSpace+$obj)`;
	if ($onlySel && (size($selectedAttrs)>0))
		$attrs=$selectedAttrs;
	else
		$attrs=$allKeyableAttrs;
	for ($attr in $attrs)
		for ($allKeyableAttr in $allKeyableAttrs)
			{
			if (`getAttr -l ($nameSpace+$obj+"."+$attr)`)
				continue;
			if ($attr==$allKeyableAttr)
				{
				if (!$anim)
					$cmd+=$obj+"."+$attr+" "+`getAttr ($nameSpace+$obj+"."+$attr)`+";";
				else
					{
					//Animation
					$animCurves=`listConnections -type animCurve -s 1 -d 0 ($nameSpace+$obj+"."+$attr)`;
					for ($y=0;$y<size($animCurves);$y++)
						{
						select -add $animCurves[$y];
						$cmd+=$obj+"."+$attr+" "+`getAttr ($nameSpace+$obj+"."+$attr)`+" "+$animCurves[$y]+";";
						}
					}
				}
			}
		}
	}

if ($anim)
	{
	setAttr -type "string" poserAnimationInfo.cmd $cmd;
	if (!`file -q -ex $animationFilePath`)
		sysFile -md $animationFilePath;
	file -f -op "v=0" -typ "mayaAscii" -es ($animationFilePath+$animationFile+".ma");
	delete poserAnimationInfo;
	}

if ($cmd!="")
	{
	if (!$anim)
		$cmd="asSetAttrs "+$uiName+" \""+$cmd+"\"";
	else
		$cmd="asLoadAttrs "+$uiName;
	}

select $sel;
return $cmd;
}

global proc asSetAttrs (string $uiName, string $cmds)
{
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
string $buffer[],$buffer2[];
string $objAttr;
float $value;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning;
string $warningMsg="The following attributes can not be set:";

for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$value=$buffer2[1];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	if (($ctrlButton||$altButton) && `gmatch $objAttr "*Main.*"`)
		continue;
	if (`objExists $objAttr`)
		catch (`eval ("setAttr "+$objAttr+" "+$value)`);
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asLoadAttrs (string $uiName, int $childNum)
{
string $sel[]=`ls -sl`;
int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -e -st 0;
createNode -n tempXform transform;
int $shiftButton,$ctrlButton,$altButton;
if (`getModifiers` %  2)
	$shiftButton=1;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
float $timeOffset=0;
if ($shiftButton)
	$timeOffset=`currentTime -q`;
string $buffer[],$buffer2[],$buffer3[],$tempString[];
string $obj,$attr,$objAttr,$animCurve,$newAnimCurve;
float $value;

string $animationFile,$projectName;

if ($childNum==0)
	{
	$projectName="Selector";
	$animationFile=`internalVar -utd`+"AdvancedSkeleton/Selector/ClipBoard.ma";
	}
else
	{
	string $icon=`iconTextButton -q -i ($uiName+"IconTextButton"+$childNum)`;
	string $tempString[];
	tokenize $icon "/" $tempString;
	$projectName=$tempString[size($tempString)-2];
	$animationFile=`substitute "[.][a-z][a-z][a-z]" $icon ".ma"`;
	}
file -r -type "mayaAscii" -namespace $projectName -options "v=0;p=17" $animationFile;

string $cmds=`getAttr ($projectName+":poserAnimationInfo.cmd")`;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning;
string $warningMsg="The following attributes can not be set:";
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	tokenize $objAttr "." $buffer3;
	$obj=$buffer3[0];
	$attr=$buffer3[1];
	$value=$buffer2[1];
	$animCurve=$buffer2[2];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	if (($ctrlButton||$altButton) && `gmatch $objAttr "*Main.*"`)
		continue;
	if (`objExists $objAttr`)
		{
		catch (`eval ("setAttr "+$objAttr+" "+$value)`);
		if (!`attributeExists $attr tempXform`)
			addAttr -k 1 -ln $attr -at double tempXform;
		connectAttr -f ($projectName+":"+$animCurve+".output") ("tempXform."+$attr);
		copyKey -time ":" -hierarchy none -at $attr tempXform;
		pasteKey -option merge -copies 1 -connect 0 -timeOffset $timeOffset -floatOffset 0 -valueOffset 0 {$objAttr};
		}
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;

if (`objExists tempXform`)
	delete tempXform;
file -rr  $animationFile;
select $sel;
if ($autoKey)
	autoKeyframe -e -st 1;
}

global proc asKeyAttrs (string $uiName, string $cmds)
{
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
string $buffer[],$buffer2[],$spaceBuffer[];
string $objAttr,$previousObjAttr,$restOfBuffers;
float $time,$value,$currentValue;
float $currentTime=`currentTime -q`;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning,$firstValueSet;
string $warningMsg="The following attributes can not be keyed:";
float $firstValue;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	$restOfBuffers="";
	if ($objAttr!=$previousObjAttr)
		$firstValueSet=0;
	$previousObjAttr=$objAttr;
	for ($y=1;$y<size($buffer2);$y++)
		$restOfBuffers+=$buffer2[$y]+" ";
	if (`objExists $objAttr`)
		{
		tokenize $restOfBuffers $spaceBuffer;
		for ($y=0;$y<size($spaceBuffer);$y++)
			{
			//TimeOffset
			if ($spaceBuffer[$y]=="-t" && ($ctrlButton||$altButton))
				{
				$time=$spaceBuffer[$y+1];
				$spaceBuffer[$y+1]=$time+$currentTime;
				}
			//ValueOffset
			if ($spaceBuffer[$y]=="-v" && $ctrlButton)
				{
				$value=$spaceBuffer[$y+1];
				$currentValue=`getAttr $objAttr`;
				if (!$firstValueSet)
				$firstValue=$value;
				$firstValueSet=1;
				$spaceBuffer[$y+1]=$value+$currentValue-$firstValue;
				}
			}
		$restOfBuffers="";
		for ($y=0;$y<size($spaceBuffer);$y++)
			$restOfBuffers+=$spaceBuffer[$y]+" ";
		eval ($restOfBuffers+$objAttr);
		}
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asPoseView (string $uiName, int $childNum)
{
string $icon=`iconTextButton -q -i ($uiName+"IconTextButton"+$childNum)`;
int $anim=`rowColumnLayout -q -ann ($uiName+"RowColumnLayout"+$childNum)`;
string $tempString[];
tokenize $icon "/" $tempString;
string $projectName=$tempString[size($tempString)-2];

string $mediaFile;
if ($anim)
	$mediaFile=`substitute "[.][a-z][a-z][a-z]" $icon ".avi"`;
else
	$mediaFile=`substitute "[.][a-z][a-z][a-z]" $icon ".jpg"`;
print ("// "+$mediaFile+"\n");
system ("load "+$mediaFile);
}

global proc asPoseObjects (string $uiName, string $button,string $action)
{
string $cmd=`iconTextButton -q -c $button`;
string $buffer[],$buffer2[];
string $objAttr,$value;
tokenize $cmd "\"" $buffer;
$cmd=$buffer[1];
int $numTok=`tokenize $cmd ";" $buffer`;
int $showWarning;
string $warningMsg="The following objects can not be found:";
if ($action==" select -add")
select -cl;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$value=$buffer2[1];
	tokenize $objAttr "." $buffer2;
	$obj=$buffer2[0];
	if ($action!=" select -add")
		$obj=$objAttr;
	$obj=`asPoserResolveNameSpace $uiName $obj`;
	if (`objExists $obj`)
		eval ($action+" "+$obj);
	else
		{
		$showWarning=1;
		$warningMsg+=$obj+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asMirrorOptions (string $uiName)
{
if (`window -q -ex asMirrorOptions`)
	deleteUI asMirrorOptions;
window -t "Mirror Options" asMirrorOptions;
columnLayout -adj 1;
	separator -h 25 -st "none";
	rowLayout -nc 4 -cw 1 40;
		text -l "side:";
		radioCollection asMOSideRadioCollection;
		radioButton -label "Swap" asMOSideFlip;
		radioButton -label "Right To Left" asMOSideR2L;
		radioButton -label "Left To Right" asMOSideL2R;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "axis:";
		radioCollection asMOAxisRadioCollection;
		radioButton -label "X" asMOAxisX;
		radioButton -label "Y" asMOAxisY;
		radioButton -label "Z" asMOAxisZ;
		radioCollection -e -sl "asMOAxisX" asMOAxisRadioCollection;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "space:";
		radioCollection asMOSpaceRadioCollection;
		radioButton -label "World" asMOSpaceWorld;
		radioButton -label "Main" asMOSpaceMain;
		radioButton -label "RootX_M" asMOSpaceCenter;
		radioCollection -e -sl "asMOSpaceWorld" asMOSpaceRadioCollection;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "control:";
		radioCollection asMOSelOnlyRadioCollection;
		radioButton -label "All" asMOSelOnlyAll;
		radioButton -label "Selected" asMOSelOnlySel;
		radioCollection -e -sl "asMOSelOnlyAll" asMOSelOnlyRadioCollection;
		setParent..;

separator -st "none" -h 25;
button -w 100 -l "Mirror" -c ("asMirror "+$uiName);
showWindow;

string $optionVars[]={"asMOSide","asMOSpace","asMOAxis","asMOSelOnly"};
string $cia[];
string $radioCollection,$selected,$optionVarString;
for ($i=0;$i<size($optionVars);$i++)
	{
	$radioCollection=$optionVars[$i]+"RadioCollection";
	$cia=`radioCollection -q -cia $radioCollection`;
	$selected=$cia[0];
	if (`optionVar -ex $optionVars[$i]`)
		{
		$optionVarString=`optionVar -q $optionVars[$i]`;
		for ($y=0;$y<size($cia);$y++)
			if (`gmatch $cia[$y] ("*"+$optionVarString)`)
				$selected=`optionVar -q $optionVars[$i]`;
		}
	radioCollection -e -sl $selected $radioCollection;
	}
}

global proc asMirror (string $uiName)
{
//if (!`window -q -ex $uiName`)
//	error ("Window : "+$uiName+" not found !");
string $side="asMOSideR2L";
string $space="asMOSpaceMain";
string $axis="asMOAxisX";
string $selOnly="asMOSelOnlyAll";
if (`window -q -ex asMirrorOptions`)
	{
	$side=`radioCollection -q -sl asMOSideRadioCollection`;
	$space=`radioCollection -q -sl asMOSpaceRadioCollection`;
	$axis=`radioCollection -q -sl asMOAxisRadioCollection`;
	$selOnly=`radioCollection -q -sl asMOSelOnlyRadioCollection`;
	optionVar -sv asMOSide $side;
	optionVar -sv asMOSpace $space;
	optionVar -sv asMOAxis $axis;
	optionVar -sv asMOSelOnly $selOnly;
	}
if (`optionVar -ex asMOSide`)
	$side=`optionVar -q asMOSide`;
if (`optionVar -ex asMOSpace`)
	$space=`optionVar -q asMOSpace`;
if (`optionVar -ex asMOAxis`)
	$axis=`optionVar -q asMOAxis`;
if (`optionVar -ex asMOSelOnly`)
	$selOnly=`optionVar -q asMOSelOnly`;
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;
string $sortedControls[];
if (`stringArrayCount "Main" $controls`)
	$sortedControls={"Main","RootX_M","RootExtraX_M"};

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Spine*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];
for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Leg_*")` || `gmatch $controls[$i] ($nameSpace+"IK*Arm_*")` || `gmatch $controls[$i] ($nameSpace+"Pole*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];
for ($i=0;$i<size($controls);$i++)
	if (!`stringArrayCount $controls[$i] $sortedControls`)
		$sortedControls[size($sortedControls)]=$controls[$i];
$controls=$sortedControls;
if ($selOnly=="asMOSelOnlySel")
	$controls=$sel;
string $allKeyableAttrs[],$tempString[];
string $source,$dest,$destAttr,$cmd,$loc1,$loc2;
float $pos[3],$rot[3];
int $wsXform[];
int $flip,$isFaceControl,$wsXformAttr;
string $flipAxis,$t0;
if ($axis=="asMOAxisX")
	{$flipAxis="X";$t0="tx";}
if ($axis=="asMOAxisY")
	{$flipAxis="Y";$t0="ty";}
if ($axis=="asMOAxisZ")
	{$flipAxis="Z";$t0="tz";}

createNode -n flipGroup transform;
if ($space=="asMOSpaceCenter")
	parent flipGroup ($nameSpace+"RootX_M");
if ($space=="asMOSpaceMain")
	parent flipGroup ($nameSpace+"Main");
xform -os -t 0 0 0 -ro 0 0 0 flipGroup;
if ($space=="asMOSpaceCenter" || $space=="asMOSpaceMain")
	parent -w flipGroup;
for ($i=0;$i<size($controls);$i++)
	{
	if ($side!="asMOSideFlip")
		if (`gmatch $controls[$i] "*_M"` || `gmatch $controls[$i] "*Main"`)
			continue;
	if ($side=="asMOSideR2L")
		{
		if (`gmatch $controls[$i] "*_L"`)
			continue;
		$dest=`substitute "_R" $controls[$i] "_L"`;
		}
	else if ($side=="asMOSideL2R")
		{
		if (`gmatch $controls[$i] "*_R"`)
			continue;
		$dest=`substitute "_L" $controls[$i] "_R"`;
		}
	else if ($side=="asMOSideFlip")
		{
		if (!`gmatch $controls[$i] "*_L"` && !`gmatch $controls[$i] "*_R"` && !`gmatch $controls[$i] "*_M"`)
			continue;
		if (`gmatch $controls[$i] "*FKExtraSpine1_M"`)
			continue;
		if (`gmatch $controls[$i] "*_L"`)
			$dest=`substitute "_L" $controls[$i] "_R"`;
		if (`gmatch $controls[$i] "*_R"`)
			$dest=`substitute "_R" $controls[$i] "_L"`;
		if (`gmatch $controls[$i] "*_M"`)
			$dest=$controls[$i];
		}
	if (!`objExists $dest`)
		continue;
	$isFaceControl=0;
	if (`objExists ($nameSpace+"FaceControlSet")`)
		if (`sets -im ($nameSpace+"FaceControlSet") $controls[$i]`)
			$isFaceControl=1;
	$source=$controls[$i];
	$allKeyableAttrs=`listAttr -k -m -sn $controls[$i]`;
	for ($y=0;$y<size($allKeyableAttrs);$y++)
		{
		$destAttr=$allKeyableAttrs[$y];
		if			(`gmatch $destAttr "*_R*"`) $destAttr=`substitute "_R" $destAttr "_L"`;
		else if (`gmatch $destAttr "*_L*"`) $destAttr=`substitute "_L" $destAttr "_R"`;		
		$flip=1;
		if (`gmatch $controls[$i] ($nameSpace+"FK*_L")` || `gmatch $controls[$i] ($nameSpace+"FK*_R")`
		 || `gmatch $controls[$i] ($nameSpace+"Bend*_L")` || `gmatch $controls[$i] ($nameSpace+"Bend*_R")`)
		 	{
		 	if ($destAttr=="tx" || $destAttr=="ty" || $destAttr=="tz")
		 		$flip=-1;
		 	}
		else
			if ($destAttr=="tz" || $destAttr=="rx" || $destAttr=="ry")
				$flip=-1;
		if ($isFaceControl)
			$flip=1;
		$wsXformAttr=0;
		if (`gmatch $controls[$i] ($nameSpace+"Aim*")` || `gmatch $controls[$i] ($nameSpace+"IK*")` || `gmatch $controls[$i] ($nameSpace+"Pole*")` || `gmatch $controls[$i] ($nameSpace+"RootX_M*")`)
			$wsXform[$i]=1;
		if ($destAttr=="tx" || $destAttr=="ty" || $destAttr=="tz"
			||$destAttr=="rx" || $destAttr=="ry" || $destAttr=="rz")
			if ($wsXform[$i])
				$wsXformAttr=1;
		if (!$wsXformAttr)
			if (`getAttr -se ($dest+"."+$destAttr)`)
				$cmd+="setAttr "+$dest+"."+$destAttr+" "+(`getAttr ($source+"."+$allKeyableAttrs[$y])`*$flip)+";";
		}

	if ($wsXform[$i])
		{
		$tempString=`spaceLocator`;
		$loc1=$tempString[0];
		$tempString=`spaceLocator`;
		$loc2=$tempString[0];
		parent $loc2 $loc1;
		parent $loc1 $source;
		xform -os -t 0 0 0 -ro 0 0 0 $loc1;
		setAttr ($loc1+".rotateOrder") `getAttr ($source+".rotateOrder")`;
		setAttr ($loc2+".rotateOrder") `getAttr ($source+".rotateOrder")`;
		setAttr ("flipGroup.scale"+$flipAxis) 1;
		parent $loc1 flipGroup;
		setAttr ("flipGroup.scale"+$flipAxis) -1;
		setAttr ($loc1+".scaleX") -1;
		$pos=`xform -q -ws -t $loc2`;
		$rot=`xform -q -ws -ro $loc2`;
		$cmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" -ro "+$rot[0]+" "+$rot[1]+" "+$rot[2]+" "+$dest+";";
		}

	if (`attributeExists "mirror" $controls[$i]`)
		setAttr ($controls[$i]+".mirror") 0;
	}
delete flipGroup;
if ($cmd!="")
	eval ($cmd);
select $sel;
}

global proc asGoToBuildPose (string $uiName)
{
int $ctrlButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
string $nameSpace;
string $controlSets[];
if ($uiName=="bodySetup")
	{
	$nameSpace="";
	$controlSets[0]="ControlSet";
	}
else if ($uiName=="faceSetup")
	{
	$nameSpace="";
	$controlSets[0]="FaceControlSet";
	}
else
	{
	$nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
	$controlSets=`asGetControlSetsFromUI $uiName`;
	}
if ($nameSpace==":")
	$nameSpace="";

string $buildPose="buildPose";
if (`gmatch $controlSets[0] "*FaceControlSet"`)
    $buildPose="faceBuildPose";

string $tempString[],$tempString2[],$buffer[];
string $setAttrCmd,$cmd;


$setAttrCmd=`getAttr ($nameSpace+$buildPose+".udAttr")`;
tokenize $setAttrCmd ";" $tempString;
for ($y=0;$y<size($tempString);$y++)
	{
	$cmd=$tempString[$y];
	if ($cmd=="")
		continue;
	if ($nameSpace!="")
		{
		tokenize $cmd $buffer;
		if (`gmatch $cmd "xform*"`)
			$substituteWordNr=size($buffer)-1;
		else
			$substituteWordNr=1;
		$cmd="";
		for ($z=0;$z<size($buffer);$z++)
			{
			if ($z==$substituteWordNr)
				$cmd+=$nameSpace;
			$cmd+=$buffer[$z]+" ";
			}
		}
	if ($ctrlButton)
		if (`gmatch $cmd "*Main.*"`)
			continue;
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
	}

//run
string $run,$fitTopNode,$objAttr;
for ($i=0;$i<size($controlSets);$i++)
	{
	if (`gmatch $controlSets[$i] "*ControlSet"`)
		if (`objExists ($nameSpace+"FitSkeleton")`)
			$fitTopNode=$nameSpace+"FitSkeleton";
	if (`gmatch $controlSets[$i] "*FaceControlSet"`)
		$fitTopNode=($nameSpace+"FaceFitSkeleton");
	}

if (`objExists $fitTopNode`)
	if (`attributeExists "run" $fitTopNode`)
		{
		$run=`getAttr ($fitTopNode+".run")`;
		if ($nameSpace=="")
			catch (`eval ($run)`);
		else
			{
			tokenize $run ";" $tempString;
			for ($i=0;$i<size($tempString);$i++)
				{
				tokenize $tempString[$i] $tempString2;
				$objAttr=`substitute "\"" $tempString2[1] ""`;
				$objAttr=`substitute "\"" $objAttr ""`;
				$cmd=$tempString2[0]+" "+$nameSpace+$objAttr+" "+$tempString2[2]+";";
				catch (`eval ($cmd)`);
				}
			}
		}
}

global proc asPoserupdateGridBlock (string $uiName, int $childNum)
{
string $existingPopUpMenus[]=`control -q -pma ($uiName+"IconTextButton"+$childNum)`;
for ($pop in $existingPopUpMenus)
	deleteUI $pop;

int $anim=`rowColumnLayout -q -ann ($uiName+"RowColumnLayout"+$childNum)`;
string $button=$uiName+"IconTextButton"+$childNum;
string $viewCmd="asPoseView "+$uiName+" "+$childNum;
string $selectCmd="asPoseObjects "+$uiName+" "+$button+"\" select -add\"";
string $keyCmd="asPoseObjects "+$uiName+" "+$button+" setKeyframe";
string $linearKeyCmd="asPoseObjects "+$uiName+" "+$button+" \"setKeyframe -itt linear -ott linear\"";

popupMenu -p ($uiName+"IconTextButton"+$childNum);
	menuItem -l "View" -c $viewCmd;
	if (!$anim)
		{
		menuItem -d 1;
		menuItem -l "Select" -c $selectCmd;
		menuItem -l "Key" -c $keyCmd;
		menuItem -l "LinearKey" -c $linearKeyCmd;
		}
	if ($uiName=="asPoserDefault")
		{
		menuItem -d 1;
		menuItem -l "Label Button" -c ("asPoserRename "+$childNum);
		menuItem -l "Remove Button" -c ("asPoserDeletePose "+$uiName+" "+$childNum);
		menuItem -l "Update icon" -c ("asPoserSnapShoot "+$uiName+" "+$childNum+" "+$anim+" 1 0");
		if ($anim)
			menuItem -l "Update movie" -c ("asPoserSnapShoot "+$uiName+" "+$childNum+" "+$anim+" 0 1");
		}
}

global proc string asPoserResolveNameSpace (string $uiName, string $obj)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
return ($nameSpace+$obj);
}

global proc asDynRemove (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (!size($sel))
	error ("nothing selected");
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] ($nameSpace+"FK*")`)
		error ($sel[$i]+" is not a FK control");
for ($i=0;$i<size($sel);$i++)
	{
	string $dynObj="dynamics"+`substitute ($nameSpace+"FK") $sel[$i] ""`;
	if(`objExists $dynObj`)
		{
		delete $dynObj;
		print ("// Dynamics for "+$sel[$i]+" removed\n");
		}
	else
		print ("// No dynamics for "+$sel[$i]+" found\n");
	}
}

global proc asDynAdd (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (!size($sel))
	error ("nothing selected");
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] ($nameSpace+"FK*")`)
		error ($sel[$i]+" is not a FK control");
global string $gSelect;
setToolTo $gSelect;

string $deformJoints[];
for ($i=0;$i<size($sel);$i++)
	{
	$deformJoints[$i]=`substitute ($nameSpace+"FK") $sel[$i] ($nameSpace+"")`;
	if (`objExists ("dynamics"+$deformJoints[$i])`)
		error ("dynamics for "+$deformJoints[$i]+" already exists");
	}
$dynSortedDeformJoints=`asResolveDynJoints $nameSpace $deformJoints`;
//Also add end joint, to get dynamics rotation on last selected FK
string $tempString[]=`listRelatives -c -type joint $dynSortedDeformJoints[size($dynSortedDeformJoints)-1]`;
if ($tempString[0]!="" && size($deformJoints)>1)
	{
	string $tempString2[]=`listConnections ($tempString[0]+".rx")`;
	if ($tempString2[0]=="")
		$dynSortedDeformJoints[size($dynSortedDeformJoints)]=$tempString[0];
	}
asDynAddChain $nameSpace $dynSortedDeformJoints;
}

global proc asDynAddChain (string $nameSpace, string $dynSortedDeformJoints[])
{
string $dynJoints[],$tempString[];
string $name;
for ($i=0;$i<size($dynSortedDeformJoints);$i++)
	{
	select $dynSortedDeformJoints[$i];
	$dynJoints[$i]="dyn"+`substitute $nameSpace $dynSortedDeformJoints[size($dynSortedDeformJoints)-1] ""`+$i;
	joint -n $dynJoints[$i];
	}
string $startJoint=$dynJoints[0];
string $endJoint=$dynJoints[size($dynJoints)-1];

string $dynTopNode="dynamics"+`substitute $nameSpace $dynSortedDeformJoints[size($dynSortedDeformJoints)-1] ""`;
if (!`objExists "Dynamics"`)
	createNode -n Dynamics transform;
createNode -n ($dynJoints[0]+"Offset") transform;
int $foundParentFK;
string $parentFK,$fk;
string $joint=$dynSortedDeformJoints[0];
while($parentFK=="")
	{
	$tempString=`listRelatives -type joint -p $joint`;
	if ($tempString[0]=="")
		$parentFK=$nameSpace+"RootX_M";
	else
		{
		$joint=$tempString[0];
		if ($nameSpace=="")
			$fk="FK"+$joint;
		else
			$fk=`substitute $nameSpace $joint ($nameSpace+"FK")`;
		if (`objExists $fk`)
			$parentFK=$fk;
		}
		
	}
parentConstraint $parentFK ($dynJoints[0]+"Offset");
createNode -n $dynTopNode transform;
parent ($dynJoints[0]+"Offset") $dynTopNode;
parent $dynTopNode Dynamics;
setAttr ($dynTopNode+".overrideEnabled") 1;
setAttr ($dynTopNode+".overrideDisplayType") 2;

for ($i=1;$i<size($dynJoints);$i++)
	parent $dynJoints[$i] $dynJoints[$i-1];
$tempString=`ikHandle -n ("DynIKHandle"+$endJoint) -ns 2 -sol ikSplineSolver -sj $startJoint -ee $endJoint`;
rename $tempString[1] ("DynIKEffector"+$endJoint);
string $ikCurve=`rename $tempString[2] ("DynIKCurve"+$endJoint)`;
parent ("DynIKHandle"+$endJoint) $dynTopNode;

parent $dynJoints[0] ($dynJoints[0]+"Offset");

//remove existing
string $dynNodes[]={("DynParticle"+$endJoint),("DynIKCurveSoft"+$endJoint),("DynParticleArrayMapper"+$endJoint),("DynParticleRamp"+$endJoint)};
for ($node in $dynNodes)
	if (`objExists $node`)
		delete $node;

//$numCv
int $numCv;
$form=`getAttr ($ikCurve+".form")`;
$spans=`getAttr ($ikCurve+".spans")`;
$degrees=`getAttr ($ikCurve+".degree")`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;

//soft
$tempString=`soft -d -g 1 -c ("DynIKCurve"+$endJoint)`;
rename $tempString[0] ("DynParticle"+$endJoint);
$tempString=`listRelatives -p ("DynParticle"+$endJoint)`;
rename $tempString[0] ("DynIKCurveSoft"+$endJoint);
rename ("copyOfDynIKCurve"+$endJoint)  ("copyOfDynIKCurveDeform"+$endJoint);
parent ("DynIKCurveSoft"+$endJoint) ("copyOfDynIKCurveDeform"+$endJoint) $dynTopNode;

//mass
for ($i=0;$i<$numCv;$i++)
	{
	float $massPP=($i+0.00)/$numCv;
	if ($massPP==0)
		$massPP=0.01;
	particle -e -or $i -at mass -fv $massPP ("DynParticle"+$endJoint);
	}

//arrayMapper
$tempString=`arrayMapper -target ("DynParticle"+$endJoint) -destAttr goalPP -inputV mass -type ramp`;
rename $tempString[0] ("DynParticleArrayMapper"+$endJoint);

$tempString=`listConnections -s 1 -d 0 ("DynParticleArrayMapper"+$endJoint+".computeNodeColor")`;
rename $tempString[0] ("DynParticleRamp"+$endJoint);
removeMultiInstance -break true ("DynParticleRamp"+$endJoint+".colorEntryList[1]");
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[0].position") 0;
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[2].position") 1;
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[0].color") -type double3 1 1 1 ;
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[2].color") -type double3 0 0 0;

int $arrayNr=size($dynSortedDeformJoints)-1;
string $fkEnd;
if ($nameSpace=="")
	$fkEnd="FK"+$dynSortedDeformJoints[$arrayNr];
else
	$fkEnd=`substitute $nameSpace $dynSortedDeformJoints[$arrayNr] ($nameSpace+"FK")`;
//`FK-less` end-joint might have been added
if (!`objExists $fkEnd`)
	{
	if ($nameSpace=="")
		$fkEnd="FK"+$dynSortedDeformJoints[$arrayNr-1];
	else
		$fkEnd=`substitute $nameSpace $dynSortedDeformJoints[$arrayNr-1] ($nameSpace+"FK")`;
	}

if (!`attributeExists blend $fkEnd`)
	addAttr -k 1 -ln blend -at double -min 0 -max 1 -dv 1 $fkEnd;
if (!`attributeExists baseGoal $fkEnd`)
	addAttr -k 1 -ln baseGoal -at double -min 0 -max 1 -dv 1 $fkEnd;
if (!`attributeExists tipGoal $fkEnd`)
	addAttr -k 1 -ln tipGoal -at double -min 0 -max 1 -dv 0.6 $fkEnd;
if (!`attributeExists conserve $fkEnd`)
	addAttr -k 1 -ln conserve -at double -min 0 -max 1 -dv 0.75 $fkEnd;
connectAttr ($fkEnd+".baseGoal") ("DynParticleArrayMapper"+$endJoint+".maxValue");
connectAttr ($fkEnd+".tipGoal") ("DynParticleArrayMapper"+$endJoint+".minValue");
connectAttr ($fkEnd+".conserve") ("DynParticle"+$endJoint+".conserve");

//skinCurve
select -cl;
string $fkx;
for ($i=0;$i<size($dynSortedDeformJoints);$i++)
	{
	if ($nameSpace=="")
		$fkx="FKX"+$dynSortedDeformJoints[$i];
	else
		$fkx=`substitute $nameSpace $dynSortedDeformJoints[$i] ($nameSpace+"FKX")`;
	if (`objExists $fkx`)
		select -add $fkx;
	}
select -add ("copyOfDynIKCurveDeform"+$endJoint);
newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false";

//pairBlend
for ($i=0;$i<size($dynSortedDeformJoints);$i++)
	{
	if ($i>0)
		{
		$tempString[0]=`pairBlend -nd $dynSortedDeformJoints[$i] -at tx -at ty -at tz`;
		rename $tempString[0] ("parBlendT"+$dynJoints[$i]);
		connectAttr -f ($dynJoints[$i]+".translate") ("parBlendT"+$dynJoints[$i]+".inTranslate2");
		connectAttr ($fkEnd+".blend") ("parBlendT"+$dynJoints[$i]+".weight");
		}
	$tempString[0]=`pairBlend -nd $dynSortedDeformJoints[$i] -at rx -at ry -at rz`;
	rename $tempString[0] ("parBlendR"+$dynJoints[$i]);
	connectAttr -f ($dynJoints[$i]+".rotate") ("parBlendR"+$dynJoints[$i]+".inRotate2");
	connectAttr ($fkEnd+".blend") ("parBlendR"+$dynJoints[$i]+".weight");
	}

setAttr -l 1 ($startJoint+"Offset.v") 0;
setAttr -l 1 ("DynIKHandle"+$endJoint+".v") 0;
setAttr -l 1 ("copyOfDynIKCurveDeform"+$endJoint+".v") 0;

select $fkEnd;
}

global proc string[] asResolveDynJoints (string $nameSpace, string $joints[])
{
string $dynJoints[];
string $jointLongNames[],$tempStringA[],$tempStringB[];
for ($i=0;$i<size($joints);$i++)
	{
	$tempStringA=`ls -l $joints[$i]`;
	$jointLongNames[$i]=$tempStringA[0];
	}
string $sorted[]=`sort $jointLongNames`;
for ($i=1;$i<size($sorted);$i++)
	{
	$tempStringA=`ls $sorted[$i]`;
	$tempStringB=`ls $sorted[$i-1]`;
	if (!`gmatch $sorted[$i] ($sorted[$i-1]+"*")`)
	error ("\""+$tempStringA[0]+"\" is not a child of \""+$tempStringB[0]+"\", select controls in same hiarchy");
	}

string $dynEndJointLongName=$sorted[size($sorted)-1];
$tempStringA=`ls -sn $dynEndJointLongName`;
$dynJoints[0]=$tempStringA[0];
string $joint=$dynJoints[0];
int $reachedStartJoint,$reachedParentOfStartJoint;
while (!$reachedStartJoint)
	{
	$tempStringA=`listRelatives -p -f -type joint $joint`;
	if (!size($tempStringA))
		break;
	$jointLongName=$tempStringA[0];
	$tempStringA=`ls -sn $tempStringA[0]`;
	$joint=$tempStringA[0];
	if (size($joints)==1)
		{
		//single control selected
		if (!`stringArrayCount $jointLongName $sorted`)
			if (!`gmatch $joint "*Part[0-9]*"`)
				$reachedStartJoint=1;
		}
	else
		{
		//several controls selected
		if ($jointLongName==$sorted[0])
			$reachedStartJoint=1;
		}
	$dynJoints[size($dynJoints)]=$joint;
	}
string $dynJointReverse[];
for ($i=size($dynJoints)-1;$i>-1;$i--)
	$dynJointReverse[size($dynJointReverse)]=$dynJoints[$i];
return $dynJointReverse;
}

global proc asParentAdd (string $uiName, int $extra)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $tempString[];
string $child;

if (size($sel)<2) error "Select at least 2 objects";

string $parent=$sel[size($sel)-1];
print ("$parent="+$parent+"\n");
for ($i=0;$i<size($sel)-1;$i++)
	{
	$child=$sel[$i];
	if ($extra)
		{
		$tempString=`listRelatives -p $child`;
		if (`gmatch $tempString[0] "*Extra*"`)
			$child=$tempString[0];
		else
			print ("// No Extra control found for \""+$child+"\".\n");
		}
	$tempString=`parentConstraint -mo $parent $child`;
	parent -w $tempString[0];
	}
}

global proc asAutoSwitchFKIK ()
{
string $sel[]=`ls -sl`;
string $name,$nameSpace,$fkIkCtrl,$side,$ik2fk;
float $curFKIKBlend;
string $tempString[],$tempString2[],$fkIkCtrls[];
print "asAutoSwitchFKIK;\n";
for ($i=0;$i<size($sel);$i++)
	{
    if (`gmatch $sel[$i] "*FKIK*"`)
        {
        $fkIkCtrls[size($fkIkCtrls)]=$sel[$i];
        break;
        }
    $tempString[0]=$sel[$i];
    for ($y=0;$y<99;$y++)
        {
        $tempString=`listRelatives -p $tempString[0]`;
        if ($tempString[0]=="") break;
        $tempString2=`listConnections -s 1 -d 0 ($tempString[0]+".v")`;
        if ($tempString2[0]=="") continue;
        if (`objectType $tempString2[0]`!="condition") continue;
        $tempString2=`listConnections -s 1 -d 0 ($tempString2[0]+".firstTerm")`;
        if ($tempString2[0]=="") continue;
        $fkIkCtrls[size($fkIkCtrls)]=$tempString2[0];
        }
	}
if (size($fkIkCtrls)==0)
    error "First select a control that is part of FK/IK setup";
for ($i=0;$i<size($fkIkCtrls);$i++)
    {
		$nameSpace="";
		$fkIkCtrl="";
		$side="";
		$name=$fkIkCtrls[$i];
		tokenize $fkIkCtrls[$i] ":" $tempString;
		if (size($tempString)>1)
			{
			$nameSpace=":"+$tempString[0];
			$name=$tempString[1];
			}
		tokenize $name "_" $tempString;
		$fkIkCtrl=$tempString[0];
		$side="_"+$tempString[1];
		$curFKIKBlend=`getAttr ($fkIkCtrls[$i]+".FKIKBlend")`;
		if ($curFKIKBlend>0 && $curFKIKBlend<5) setAttr ($fkIkCtrls[$i]+".FKIKBlend") 0;
		if ($curFKIKBlend>5 && $curFKIKBlend<10) setAttr ($fkIkCtrls[$i]+".FKIKBlend") 10;
		if ($curFKIKBlend>5) $ik2fk="IK2FK";
		else $ik2fk="FK2IK";
    asSwitchFKIK $fkIkCtrls[$i] `substitute "FKIK" $fkIkCtrl ""` $side $ik2fk;
    }
}

global proc asAutoSwitchPivot ()
{
string $sel[]=`ls -sl`;
if (size($sel)!=2)
	error "Select 1 target object + 1 control";
string $tempString[];
string $target=$sel[0];
string $control=$sel[1];
string $extraControl;
if (!`gmatch $control "*_*"` && `gmatch $target "*_*"`)//selection order was reversed
	{
	$target=$sel[1];
	$control=$sel[0];
	}
if (`gmatch $control "*Extra*"`)//extraControl was selected
	{
	$tempString=`listRelatives -c -type transform $control`;
	$control=$tempString[0];
	}
$tempString=`listRelatives -p $control`;
$extraControl=$tempString[0];
if (!`objExists $extraControl`)
	error ("parent of \""+$control+"\" is not a valid ExtraControl");
float $pos[]=`xform -q -ws -t $control`;
float $rot[]=`xform -q -ws -ro $control`;
float $extraPos[]=`xform -q -ws -t $extraControl`;
float $extraRot[]=`xform -q -ws -ro $extraControl`;
float $targetPos[]=`xform -q -ws -t $target`;
float $targetRot[]=`xform -q -ws -ro $target`;

print "asAutoSwitchPivot;\n";

int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -st 0;
currentTime (`currentTime -q` -1);
setKeyframe ($extraControl+".t") ($extraControl+".r") ($control+".t") ($control+".r");

currentTime (`currentTime -q` +1);
xform -ws -t $targetPos[0] $targetPos[1] $targetPos[2] -ro $targetRot[0] $targetRot[1] $targetRot[2] $extraControl;
xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] $control;
setKeyframe ($extraControl+".t") ($extraControl+".r") ($control+".t") ($control+".r");

if ($autoKey)
	autoKeyframe -st 1;

select $extraControl;
print ("// \""+$extraControl+"\" aligned to \""+$target+"\".\n");
}

global proc asAnimBake (string $uiName)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $tempString[]=`ls -type transform ($nameSpace+"FKIK*")`;
string $FkIks[];
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists FKIKBlend $tempString[$i]`)
		if (!`gmatch $tempString[$i] "FKIKSp*ine*"`)
			$FkIks[size($FkIks)]=`substitute ($nameSpace+"FKIK") $tempString[$i] ""`;

if (`window -q -ex asAnimBake`)
    deleteUI asAnimBake;
window -t Bake asAnimBake;
formLayout asAnimBakeFormLayout;
columnLayout;
text -l "Bake:";
optionMenu asAnimBakeOptionMenu;
	menuItem -l "AnimationControls to BakeSkeleton";
	menuItem -l "MotionCapture to FKControls";
	menuItem -l "ExtraControls to Controls";
	for ($i=0;$i<size($FkIks);$i++)
		menuItem -l ("FK to IK : "+$FkIks[$i]);
	for ($i=0;$i<size($FkIks);$i++)
		menuItem -l ("IK to FK : "+$FkIks[$i]);

separator -h 10;
setParent..;
button -l "Ok, Bake" -c ("asAnimBakeGo "+$uiName) asAnimBakeOkButton;

formLayout -e
	-af asAnimBakeOkButton "bottom" 0
	-af asAnimBakeOkButton "left" 0
	-af asAnimBakeOkButton "right" 0
	asAnimBakeFormLayout;

showWindow;
}

global proc asAnimBakeGo (string $uiName)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $bake=`optionMenu -q -v asAnimBakeOptionMenu`;
string $limb;

if ($bake=="AnimationControls to BakeSkeleton")
	asAnimBakeSkeleton $uiName;
if ($bake=="MotionCapture to FKControls")
	asAnimBakeMoCapToFk $uiName;
if ($bake=="ExtraControls to Controls")
	asAnimBakeExtra $uiName;
if (`gmatch $bake "FK to IK : *"`)
	{
	$limb=`substitute "FK to IK : " $bake ""`;
	asAnimBakeFKIK $limb 1 $uiName;
	}
if (`gmatch $bake "IK to FK : *"`)
	{
	$limb=`substitute "IK to FK : " $bake ""`;
	asAnimBakeFKIK $limb 0 $uiName;
	}
}

global proc asAnimBakeExtra (string $uiName)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
float $curTime=`currentTime -q`;

string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;
string $tempString[],$tempString2[],$tempString3[],$extraControls[],$bakeControls[],$animCurves[];
for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"FKExtra*")` || `gmatch $controls[$i] ($nameSpace+"RootExtraX*")`)
		$extraControls[size($extraControls)]=$controls[$i];

for ($i=0;$i<size($extraControls);$i++)
	{
	$controls[$i]=`substitute "Extra" $extraControls[$i] ""`;
	$bakeControls[$i]=$extraControls[$i]+"BAKER";
	$tempString=`listRelatives -p $extraControls[$i]`;
	createNode -n $bakeControls[$i] -p $tempString[0] transform;
	setAttr ($bakeControls[$i]+".rotateOrder") `getAttr ($controls[$i]+".rotateOrder")`;
	$tempString=`listRelatives -c -type transform $extraControls[$i]`;
	parentConstraint $tempString[0] $bakeControls[$i];
	scaleConstraint $tempString[0] $bakeControls[$i];
	}

//Bake
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $bakeControls;
currentTime $curTime;
select $bakeControls;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";

//remove existing animation
for ($i=0;$i<size($extraControls);$i++)
	{
	$animCurves=`listConnections -s 1 -d 0 -type animCurve $extraControls[$i]`;
	if (size($animCurves)) delete $animCurves;
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $extraControls[$i];
	$animCurves=`listConnections -s 1 -d 0 -type animCurve $controls[$i]`;
	if (size($animCurves)) delete $animCurves;
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $controls[$i];
	}
//asGoToBuildPose bodySetup;

//Use baked animCurves
for ($i=0;$i<size($extraControls);$i++)
	{
	$animCurves=`listConnections -s 1 -d 0 -type animCurve $bakeControls[$i]`;
	for ($y=0;$y<size($animCurves);$y++)
		{
		$tempString=`listConnections -s 0 -d 1 -p 1 -c 1 $animCurves[$y]`;
		tokenize $tempString[1] "[.]" $tempString2;
		connectAttr $tempString[0] ($controls[$i]+"."+$tempString2[1]);
		tokenize $tempString[0] "[.]" $tempString3;
		rename $tempString3[0] ($controls[$i]+"_"+$tempString2[1]);
		}
	}
delete $bakeControls;
}

global proc asAnimBakeMoCapToFk (string $uiName)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";

string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;
string $bakeControls[];
for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"FKExtra*")` || `gmatch $controls[$i] ($nameSpace+"RootExtraX*")`)
		$bakeControls[size($bakeControls)]=$controls[$i];

//Bake
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $bakeControls;
select $bakeControls;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";

if (`objExists MoCap`)
	delete MoCap;
else
	print ("// \"MoCap\" Skeleton not found, and not deleted, you must manually delete your MoCap skeleton to see the baked animation.\n");
select -cl;
}

global proc asAnimBakeFKIK (string $limb, int $Fk2Ik, string $uiName)
{
global int $asBakeFKIK;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
int $numChar=size($limb);
string $side=`substring $limb ($numChar-1) $numChar`;
string $sideLessLimb=`substring $limb 1 ($numChar-2)`;
float $curTime=`currentTime -q`;
float $start=`playbackOptions -q -min`;
float $end=`playbackOptions -q -max`;
currentTime $start;
if ($Fk2Ik)
	{
	setAttr ($nameSpace+"FKIK"+$limb+".FKIKBlend") 0;
	asSwitchFK2IK `substitute "asSelector" $uiName ""` {("FKIK"+$limb)};
	}
else
	{
	setAttr ($nameSpace+"FKIK"+$limb+".FKIKBlend") 10;
	asSwitchIK2FK `substitute "asSelector" $uiName ""` {("FKIK"+$limb)};
	}
$asBakeFKIK=1;
for ($i=$start;$i<$end+1;$i++)
	{
	currentTime $i;
	if ($Fk2Ik)
		asAlignFKIK `substitute "asSelector" $uiName ""` $sideLessLimb $side FK2IK;
	else
		asAlignFKIK `substitute "asSelector" $uiName ""` $sideLessLimb $side IK2FK;
	}
currentTime $curTime;
$asBakeFKIK=0;
}

global proc asAnimBakeSkeleton (string $uiName)
{
if (`confirmDialog -title "Confirm" -message 
	("Bake character ?\n"
	+"This creates a single joint chain for game engine export\n"
	+"The rig controllers will no longer work")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $name=`substitute ":" $nameSpace ""`;
string $bakeNameSpace=$name+"Bake:";
namespace -add ($name+"Bake");
namespace -set ($name+"Bake");
$tempString=`listRelatives -c ($nameSpace+"DeformationSystem")`;
$tempString=`duplicate $tempString[0]`;
string $topBakeJoint=$tempString[0];
parent -w $topBakeJoint;
$tempString=`listRelatives -ad $topBakeJoint`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`!="joint")
		delete $tempString[$i];
string $allBakeJoints[]=`listRelatives -ad -type joint $topBakeJoint`;
$allBakeJoints[size($allBakeJoints)]=$topBakeJoint;
sets -rm ($nameSpace+"DeformSet") $allBakeJoints;
//Disable Skincluster
string $skinClusters[]=`ls -type skinCluster`;
for ($i=0;$i<size($skinClusters);$i++)
    setAttr ($skinClusters[$i]+".nodeState") 1;
//Constraint bakeSkeleton
string $deformJoints[]=`listRelatives -ad -type joint ($nameSpace+"DeformationSystem")`;
for ($i=0;$i<size($deformJoints);$i++)
    {
		if ($nameSpace=="")
			$bakeDeformJoint=$bakeNameSpace+$deformJoints[$i];
		else
			$bakeDeformJoint=`substitute $nameSpace $deformJoints[$i] $bakeNameSpace`;
    parentConstraint $deformJoints[$i] $bakeDeformJoint;
//    scaleConstraint $deformJoints[$i] $bakeDeformJoint;//caues issues with overall scale
    }
//Bake
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $allBakeJoints;
//Transfer deformation to bake skeleton
for ($i=0;$i<size($deformJoints);$i++)
{
    $tempString=`listConnections -s 0 -d 1 -p 1 -c 1 $deformJoints[$i]`;
    for ($y=0;$y<size($tempString);$y=$y+2)
        {        
        if ($nameSpace=="")
        	$newSource=$bakeNameSpace+$tempString[$y];
				else
	        $newSource=`substitute $nameSpace $tempString[$y] $bakeNameSpace`;
        catch (`connectAttr -f $newSource $tempString[$y+1]`);
        }
}
//Enable Skincluster
for ($i=0;$i<size($skinClusters);$i++)
    setAttr ($skinClusters[$i]+".nodeState") 0;

namespace -set ":";
select $allBakeJoints;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
select $topBakeJoint;
print ("// Selected joint chain is ready for export, add geometry to selection and export\n");
}

global proc asDynBake (string $uiName)
{
if (`confirmDialog -title "Confirm" -message "Bake all dynamics ?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
asDynUnBake $uiName;
string $softDynCurves[]=`ls -type nurbsCurve "DynIKCurveSoftdyn*"`;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl 0 -preserveOutsideKeys 0 -sparseAnimCurveBake false -controlPoints true -shape false $softDynCurves;
}

global proc asDynUnBake (string $uiName)
{
string $softDynCurves[]=`ls -type nurbsCurve "DynIKCurveSoftdyn*"`;
string $particles;
int $spans,$degrees,$numCv;
for ($i=0;$i<size($softDynCurves);$i++)
	{
	$particles=`substitute "DynIKCurveSoft" $softDynCurves[$i] "DynParticle"`;
	$particles=`substitute "Shape" $particles ""`;
	if (!`isConnected ($particles+".targetGeometry") ($softDynCurves[$i]+".create")`)
		connectAttr ($particles+".targetGeometry") ($softDynCurves[$i]+".create");
	if (size(`listConnections -type animCurve $softDynCurves[$i]`))
		delete `listConnections -type animCurve $softDynCurves[$i]`;
	$spans=`getAttr ($softDynCurves[$i]+".spans")`;
	$degrees=`getAttr ($softDynCurves[$i]+".degree")`;
	$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv;$y++)
		setAttr ($softDynCurves[$i]+".cv["+$y+"]") 0 0 0;
	}
}

global proc asJointsVisibilityToggle (string $uiName)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (!`objExists ($nameSpace+"Main")`)
	return;
string $joints[]=`listRelatives -type joint -ad ($nameSpace+"Main")`;
int $onOff=1;
string $tempString[]=`listRelatives -type joint -c ($nameSpace+"DeformationSystem")`;
if (`objExists $tempString[0]`)
	if (`getAttr ($tempString[0]+".drawStyle")`==0)
		$onOff=0;
int $drawStyle=0;
if (!$onOff)
	$drawStyle=2;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".drawStyle") $drawStyle;
}

global proc asControlsVisibilityToggle ()
{
int $vis;
string $motionSystems[]=`ls -r 1 MotionSystem FaceMotionSystem`;
for ($i=0;$i<size($motionSystems);$i++)
    {
    if ($i==0)
        $vis=!(`getAttr ($motionSystems[$i]+".v")`);
    setAttr ($motionSystems[$i]+".v") $vis;
    }
}

global proc asSetupControlVisibilityHotKeyDialog ()
{
if (`confirmDialog -title "Confirm Control Visibility HotKey"
	-message ("Add toggle of control-visibility to the \"~\" hotkey.\n"
	+"For easy toggling visibility of controls.\n"
	+"Holding down the \"~\" key (next to the \"number 1\" on the keyboard) to see and select controls.\n"
	+"As you let go, controls will again be hidden.\n"
	+"The idea is to work without the `visual clutter` of the controls.\n"
	+"Tip: Ctrl+\"\~\" will leave the controls visible")
	-button "Confirm" -button "Cancel" -defaultButton "Confirm"
	-cancelButton "Cancel" -dismissString "Cancel"`!="Confirm")
	return;
asSetupControlVisibilityHotKey;
}

global proc asSetupControlVisibilityHotKey ()
{
if (!`runTimeCommand -q -ex advancedSkeletonVisibilitySwitch`)
	{
	nameCommand -ann "advancedSkeletonVisibilitySwitch" -c "advancedSkeletonVisibilitySwitch" advancedSkeletonVisibilitySwitchNameCommand;
	runTimeCommand -annotation "switches the visibility of controls" -category "User"
		-command ("int $vis;\nstring $motionSystems[]=`ls -r 1 MotionSystem FaceMotionSystem`;\nfor ($i=0;$i<size($motionSystems);$i++)\n    {\n    if ($i==0)\n        $vis=!(`getAttr ($motionSystems[$i]+\".v\")`);\n    setAttr ($motionSystems[$i]+\".v\") $vis;\n    }")
		advancedSkeletonVisibilitySwitch;
	}
hotkey -keyShortcut "`"  -name "advancedSkeletonVisibilitySwitchNameCommand" -releaseName "advancedSkeletonVisibilitySwitchNameCommand";
hotkey -keyShortcut "\`" -name "advancedSkeletonVisibilitySwitchNameCommand" -releaseName "advancedSkeletonVisibilitySwitchNameCommand";
hotkey -keyShortcut "`"  -ctrlModifier -name "advancedSkeletonVisibilitySwitchNameCommand";
hotkey -keyShortcut "\`" -ctrlModifier -name "advancedSkeletonVisibilitySwitchNameCommand";
}

global proc asVisualizeGimbalLock (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
int $fromSelection;
int $buildGimbal[];
float $scale;
float $bb[];
string $name,$lookForVisConnectionOnObject;
string $tempString[];
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;

if (`objExists GimbalLockVisualizers`)
	{
	delete GimbalLockVisualizers;
	return;
	}
createNode -n GimbalLockVisualizers transform;
if ($sel[0]!="")
	if (`stringArrayCount $sel[0] $controls`)
		$fromSelection=1;
for ($i=0;$i<size($controls);$i++)
	{
	if ($controls[$i]==$nameSpace+"Main")
		continue;
	$tempString=`listRelatives -s $controls[$i]`;
	if ($tempString[0]!="")
		if (`objectType $tempString[0]`=="nurbsCurve")
			{
			if ($fromSelection)
				if (`stringArrayCount $controls[$i] $sel`)
					$buildGimbal[$i]=1;
			if (!$fromSelection)
				$buildGimbal[$i]=1;
			}
	}
for ($i=0;$i<size($controls);$i++)
	{
	if (!$buildGimbal[$i])
		continue;
	$name=$controls[$i];
	createNode -n ($name+"Constraint") -p GimbalLockVisualizers transform;
	createNode -n ($name+"Offset") -p ($name+"Constraint") transform;

	polyCylinder -n ($name+"Cones") -r 0.3 -h 2.5 -sx 10 -sy 2 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 0;
	scale -r -p 0 0 0 0 0 0 ($name+"Cones.vtx[10:19]");
	parent ($name+"Cones") ($name+"Offset");
	if (`objExists asGreenSG`)
		sets -e -forceElement asGreenSG ($name+"Cones");

	polyTorus -n ($name+"Torus") -r 1 -sr 0.03 -tw 0 -sx 30 -sy 6 -ax 0 1 0 -cuv 1 -ch 0;
	parent ($name+"Torus") ($name+"Offset");
	if (`objExists asRedSG`)
		sets -e -forceElement asRedSG ($name+"Torus");

	polyCylinder -n ($name+"Arrow") -r 0.06 -h 2 -sx 10 -sy 3 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 0;
	rotate -r 0 0 90 ($name+"Arrow.vtx[0:41]");
	move -r 1 0 0 ($name+"Arrow.vtx[0:41]");
	scale -r -p 0 0 0 1 0 0 ($name+"Arrow.vtx[0:9]") ($name+"Arrow.vtx[40]");
	move -r 0.35 0 0 ($name+"Arrow.vtx[10:19]");
	scale -r -p 0 0 0 1 1.75 1.75 ($name+"Arrow.vtx[10:19]");
	move -r 1 0 0 ($name+"Arrow.vtx[20:29]");
	parent ($name+"Arrow") ($name+"Offset");
	if (`objExists asGreen2SG`)
		sets -e -forceElement asGreen2SG ($name+"Arrow");
	orientConstraint $name ($name+"Arrow");

	$tempString=`listRelatives -p $name`;
	parentConstraint $tempString[0] ($name+"Constraint");
	$tempString=`listRelatives -s $name`;
	$bb=`xform -q -bb ($tempString[0]+".cv[0:999]")`;
	$scale=(($bb[3]-$bb[0])+($bb[4]-$bb[1])+($bb[5]-$bb[2]))/5.0;
	setAttr -type float3 ($name+"Offset.s") $scale $scale $scale;
	$lookForVisConnectionOnObject=$name;
	$tempString=`listConnections -p 1 ($lookForVisConnectionOnObject+".v")`;
	for ($y=0;$y<20;$y++)
		{
		if ($tempString[0]!="")
			{
			connectAttr $tempString[0] ($name+"Offset.v");
			break;
			}
		$tempString=`listRelatives -p $lookForVisConnectionOnObject`;
		if ($tempString[0]=="")
			break;
		$lookForVisConnectionOnObject=$tempString[0];
		$tempString=`listConnections -p 1 ($lookForVisConnectionOnObject+".v")`;
		}
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 0 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 2 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 5 -cd ($name+".rotateOrder") ($name+"Cones.rx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 2 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 4 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 5 -cd ($name+".rotateOrder") ($name+"Cones.rz");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 2 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 5 -cd ($name+".rotateOrder") ($name+"Torus.rx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 0 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 2 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 3 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 5 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	}
select $sel;
}

global proc int asHaveAnimation (string $node)
{
int $haveAnimation=0;
string $nodeType;
string $tempString[]=`listConnections -s 1 -d 0 $node`;

for ($i=0;$i<size($tempString);$i++)
	{
	$nodeType=`objectType $tempString[$i]`;
	if (`gmatch $nodeType "animCurve*"`)
		{
		$haveAnimation=1;
		break;
		}
	}
return $haveAnimation;
}

global proc string asSelectorScriptLocation ()
{
string $whatIs=`whatIs asSelectorScriptLocation`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
if ($numTok<2)
	if (`about -win`)
		$numTok=`tokenize $fullPath "\\" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder)`;
return $scriptLocation;
}
//-- ASTools Procedures Ends Here --//

//-- ASSelector Procedures Starts Here --//
global proc asSelectorDesigner ()
{
asShowSelJob;
string $controlSets[]=`asGetControlSets`;
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Selector/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $fileList[]=`getFileList -fld ($iconDir+"/")`;
for ($file in $fileList)
	eval ("sysFile -del \""+$iconDir+"/"+$file+"\"");

if (`window -q -ex asSelectorDefault`)
	deleteUI asSelectorDefault;
window -w 640 -h 480 -mb 1 -t "SelectorDesigner :untitled" asSelectorDefault;

columnLayout -m 0 asSelectorColumnLayout;
	text -l (`internalVar -utd`+"AdvancedSkeleton/Selector/") asSelectorProjectPath;
	text -l "untitled" asSelectorProjectName;
	intField -v 640 asSelectorWidth;
	intField -v 480 asSelectorHeight;
	setParent..;

menu "File";
	menuItem -sm 1 -l ControlSets asSelectorControlSetsMenu;
		menuItem -cb 1 -l ControlSet asSelectorControlSetsMenuItemControlSet;
		menuItem -cb 0 -l FaceControlSet asSelectorControlSetsMenuItemFaceControlSet;
		setParent -menu ..;
	menuItem -c "asSave Selector" "Save";
	menuItem -c "asfileBrowse Selector SaveAs" "Save As";
	menuItem -c "astoShelf Selector" "Put on shelf";

menu "Edit";
	menuItem -sm 1 "Colors";
		menuItem -c "asSelectorBackgroundSetColor asSelectorSelColor" "set Selected Color";
		menuItem -c "asSelectorBackgroundSetColor asSelectorKeyColor" "set Keyed Color";

menu "Layout";
	menuItem -c "asSDNewLayout 0" -l "New Empty Layout";
	menuItem -c "asSDNewLayout 1" -l "New Biped Layout";
	menuItem -c "asSDNewLayout 2" -l "New Face Layout";

menu "Buttons";
	menuItem -c "asSDNewButtton Object 50 50 100 100" -l "Create New Button";

menu "Render";
	menuItem -c "asSDRender 1" -l "Render Background";
	menuItem -c "asfileBrowse Selector Import" -l "Import  Background";
	menuItem -d 1;
	menuItem -c "asSDRender 0" -l "Render Buttons";

columnLayout -adj 1;
rowLayout -nc 5 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 65 -cw 4 50 -cw 5 60;
optionMenu -cc asSelChange asSelectorDefaultOptionMenu;
button -l "set" -c "asSetNameSpaceFromSelection asSelectorDefault";
checkBox -v `optionVar -q asShowSelection` -onc "optionVar -iv asShowSelection 1;asSelChangeToggle;" -ofc "optionVar -iv asShowSelection 0;asSelChangeToggle;" -l Selection asSelectorSelectionCheckBox;
checkBox -v `optionVar -q asShowKeyed` -onc "optionVar -iv asShowKeyed 1;asSelChangeToggle;" -ofc "optionVar -iv asShowKeyed 0;asSelChangeToggle;" -l Keyed asSelectorKeyedCheckBox;
checkBox -v `optionVar -q asShowExtra` -onc "optionVar -iv asShowExtra 1;asSelChangeToggle;" -ofc "optionVar -iv asShowExtra 0;asSelChangeToggle;" -l Extra asSelectorbipedExtraCheckBox;
setParent..;

formLayout asSelectorDefaultFormLayout;
setParent..;
asPopulateNameSpaceMenu "asSelectorDefault";

columnLayout -m 0 asSelectorColumnLayout;
	text -l (`internalVar -utd`+"AdvancedSkeleton/Selector/") asSelectorProjectPath;
	text -l "untitled" asSelectorProjectName;
	text -l "640" asSelectorBackgroundWidth;
	text -l "480" asSelectorBackgroundHeight;

showWindow;
}

global proc asSDNewLayout (int $LayoutType)
{
if (`objExists SelectorLayout`)
	if (`confirmDialog -t "Confirm"
	-m "SelectorLayout already exists, this will replace the current Layout"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;

float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
string $tempString[];

select -cl;
string $deleteObjs[]={"SelectorLayout","Template","SelectorLayoutShader","SelectorLayoutSG","SelectorIcons"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

createNode -n SelectorLayout transform;
polyCube -n Button_Template -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
addAttr -ln label -dt "string" Button_Template;
addAttr -ln multiObjs -dt "string" Button_Template;
polyProjection -ch 0 -type Planar -ibd on -md z Button_Template.f[0];
setAttr Button_Template.sz 0.001;
parent Button_Template SelectorLayout;
setAttr SelectorLayout.tz ($height/2);
setAttr -l 1 -k 0 Button_Template.tz;
setAttr -l 1 -k 0 Button_Template.rx;
setAttr -l 1 -k 0 Button_Template.ry;
setAttr -l 1 -k 0 Button_Template.rz;
setAttr -l 1 -k 0 Button_Template.sz;
//setAttr -l 1 -k 0 Button_Template.v;

shadingNode -n SelectorLayoutShader -asShader lambert;
sets -renderable true -noSurfaceShader true -empty -name SelectorLayoutSG;
connectAttr -f SelectorLayoutShader.outColor SelectorLayoutSG.surfaceShader;
setAttr SelectorLayoutShader.transparency -type double3 0.8 0.8 0.8; 
sets -e -forceElement SelectorLayoutSG Button_Template;

setAttr Button_TemplateShape.overrideEnabled 1;
setAttr Button_TemplateShape.overrideColor 15;
setAttr Button_TemplateShape.primaryVisibility 0;
//setAttr Button_TemplateShape.overrideShading 0;
setAttr Button_TemplateShape.castsShadows 0;
setAttr Button_TemplateShape.receiveShadows 0;
setAttr Button_TemplateShape.visibleInReflections 0;
setAttr Button_TemplateShape.visibleInRefractions 0;
setAttr Button_TemplateShape.overrideEnabled 1;
setAttr Button_TemplateShape.motionBlur 0;
setAttr Button_TemplateShape.smoothShading 0;
//setAttr Button_TemplateShape.doubleSided 0;

//SelectorWindow
duplicate -n SelectorWindow Button_Template;
setAttr SelectorWindowShape.overrideShading 0;
setAttr SelectorWindow.sx 640;
setAttr SelectorWindow.sy 480;
move -r 0 240 0 SelectorWindow.vtx[0:7];
setAttr -type float3 SelectorLayout.s ($height*0.002083) ($height*0.002083) ($height*0.002083);

//WindowCorner
createNode -n WindowCorner -p SelectorWindow transform;
setAttr -type float3 WindowCorner.t -0.5 1 0;
setAttr -type float3 WindowCorner.s (1.0/640) (-1.0/480) 1;

//Prep Button_Template
move -r (`getAttr SelectorLayout.sx`/2.0) (`getAttr SelectorLayout.sy`/2.0) 0 Button_Template.vtx[0:7];
parent Button_Template WindowCorner;
setAttr Button_Template.tx -150;
setAttr Button_Template.ty 50;
setAttr Button_Template.sx 100;
setAttr Button_Template.sy 100;
setAttr Button_Template.v 0;

createNode -n LoadingSelectorLayout transform;
select -cl;
if ($LayoutType==1)
	{
	asSDNewButtton FKElbow_R 136 78 72 27;
	asSDNewButtton FKShoulder_R 210 75 64 32;
	asSDNewButtton FKWrist_R 92 68 43 43;
	asSDNewButtton RootX_M 188 228 70 24;
		setAttr -type "string" Button_RootX_M.label Root;
	asSDNewButtton FKRoot_M 270 190 100 38;
	asSDNewButtton FKSpine1_M 270 149 100 38;
	asSDNewButtton FKChest_M 270 108 100 38;
	asSDNewButtton FKHip_R 267 234 48 106;
	asSDNewButtton FKKnee_R 275 346 39 104;
	asSDNewButtton FKAnkle_R 275 451 39 26;
	asSDNewButtton FKToes_R 243 461 30 14;
	asSDNewButtton FKScapula_R 277 67 25 41;
	asSDNewButtton FKNeck_M 304 79 30 26;
	asSDNewButtton FKHead_M 291 3 56 56;

	asSDNewButtton IKArm_R 92 10 43 43;
	asSDNewButtton PoleArm_R 160 22 30 30;
	asSDNewButtton FKIKArm_R 216 21 30 30;
	asSDNewButtton IKLeg_R 205 405 43 43;
	asSDNewButtton PoleLeg_R 210 333 30 30;
	asSDNewButtton FKIKLeg_R 210 261 30 30;
	asSDNewButtton RollHeel_R 215 452 24 24;
	asSDNewButtton RollToes_R 188 452 24 24;
	asSDNewButtton RollToesEnd_R 160 452 24 24;

	asSDNewButtton HipSwinger_M 205 161 43 43;

	asSDNewButtton Main 20 10 43 20;
		setAttr -type "string" Button_Main.label Main;

	asSDNewButtton FKWrist_R 6 330 140 100;
	asSDNewButtton FKIndexFinger1_R 114 268 32 58;
	asSDNewButtton FKMiddleFinger1_R 78 268 32 58;
	asSDNewButtton FKRingFinger1_R 43 268 32 58;
	asSDNewButtton FKPinkyFinger1_R 6 268 32 58;
	asSDNewButtton FKIndexFinger2_R 114 211 32 52;
	asSDNewButtton FKMiddleFinger2_R 78 211 32 52;
	asSDNewButtton FKRingFinger2_R 43 211 32 52;
	asSDNewButtton FKPinkyFinger2_R 6 211 32 52;
	asSDNewButtton FKIndexFinger3_R 114 167 32 40;
	asSDNewButtton FKMiddleFinger3_R 78 167 32 40;
	asSDNewButtton FKRingFinger3_R 43 167 32 40;
	asSDNewButtton FKPinkyFinger3_R 6 167 32 40;
	asSDNewButtton FKThumbFinger1_R 149 330 32 66;
	asSDNewButtton FKThumbFinger2_R 149 272 32 52;
	asSDNewButtton FKThumbFinger3_R 149 225 32 41;
	asSDNewButtton Fingers_R 31 436 91 24;
		setAttr -type "string" Button_Fingers_R.label Fingers;

	asSDNewButtton FKSpine 188 129 70 24;
		setAttr -type "string" Button_FKSpine.label Spine;
		setAttr -type "string" Button_FKSpine.multiObjs "FKChest_M FKSpine1_M FKRoot_M";
	asSDNewButtton IKSpine1_M 390 204 30 30;
	asSDNewButtton IKSpine2_M 390 164 30 30;
	asSDNewButtton IKSpine3_M 390 127 30 30;
	asSDNewButtton FKIKSpine_M 425 163 30 30;
	}
if ($LayoutType==2)
	{
	asSDNewButtton squashTop_M 44 59 73 22;
	asSDNewButtton squashMiddle_M 44 85 73 22;
	asSDNewButtton squashBase_M 44 111 73 22;
	asSDNewButtton EyeBrowRegion_R 120 116 35 30;
	asSDNewButtton EyeRegion_R 117 161 41 51;
	asSDNewButtton AimEye_M 61 200 44 101;
	asSDNewButtton AimEye_R 36 220 23 19;
	asSDNewButtton AimEye_L 108 220 23 19;
	asSDNewButtton FKFaceUpper_M 139 236 48 28;
	asSDNewButtton FKFaceMiddle_M 147 275 48 28;
	asSDNewButtton FKFaceLower_M 150 310 57 28;
	asSDNewButtton upperLipRegion_M 129 344 77 17;
	asSDNewButtton LipRegion_M 129 362 77 17;
	asSDNewButtton lowerLipRegion_M 129 380 77 17;
	asSDNewButtton FaceControlSet 79 8 67 47;
	asSDNewButtton FKTongue0_M 43 326 77 17;
	asSDNewButtton FKTongue1_M 43 358 77 17;
	asSDNewButtton FKTongue2_M 43 389 77 17;
	asSDNewButtton FKTongue3_M 43 419 77 17;
	asSDNewButtton FKJaw_M 241 449 156 28;
	asSDNewButtton FKTeethUpper_M 427 348 69 20;
	asSDNewButtton FKTeethLower_M 427 377 69 20;
	asSDNewButtton ctrlBrow_R 534 75 41 48;
	asSDNewButtton ctrlBrow_L 588 75 41 48;
	asSDNewButtton ctrlEye_R 534 130 41 48;
	asSDNewButtton ctrlEye_L 588 130 41 48;
	asSDNewButtton ctrlCheek_R 534 188 41 48;
	asSDNewButtton ctrlCheek_L 588 188 41 48;
	asSDNewButtton ctrlNose_R 534 245 41 48;
	asSDNewButtton ctrlNose_L 588 245 41 48;
	asSDNewButtton ctrlMouth_M 555 302 54 65;
	asSDNewButtton ctrlMouthCorner_R 534 377 41 48;
	asSDNewButtton ctrlMouthCorner_L 588 377 41 48;
	asSDNewButtton ctrlBox 512 432 125 21;
	asSDNewButtton EyeBrowInner_R 280 102 24 30;
	asSDNewButtton EyeBrowMid1_R 256 99 19 23;
	asSDNewButtton EyeBrowMid2_R 237 100 19 23;
	asSDNewButtton EyeBrowMid3_R 217 106 19 23;
	asSDNewButtton EyeBrowOuter_R 203 121 19 23;
	asSDNewButtton upperLid_R 247 138 24 30;
	asSDNewButtton upperOuterLid_R 226 152 17 21;
	asSDNewButtton lowerOuterLid_R 229 197 17 21;
	asSDNewButtton lowerLid_R 247 198 24 30;
	asSDNewButtton lowerInnerLid_R 275 197 17 21;
	asSDNewButtton upperInnerLid_R 277 152 17 21;
	asSDNewButtton outerLid_R 217 179 15 18;
	asSDNewButtton innerLid_R 289 179 15 18;
	asSDNewButtton CheekRaiser_R 232 232 24 30;
	asSDNewButtton Cheek_R 211 277 24 30;
	asSDNewButtton NoseCorner_R 276 266 20 25;
	asSDNewButtton Nostril_R 297 256 14 17;
	asSDNewButtton Nose_M 310 267 19 24;
	asSDNewButtton NoseUnder_M 310 294 19 19;
	asSDNewButtton NoseSide_R 283 234 14 17;
	asSDNewButtton NoseMiddle_M 310 216 19 19;
	asSDNewButtton upperLip_M 310 333 19 24;
	asSDNewButtton lowerLip_M 310 365 19 24;
	asSDNewButtton Lip_R 260 337 19 24;
	asSDNewButtton upperLipA_R 294 330 15 18;
	asSDNewButtton upperLipB_R 277 330 15 18;
	asSDNewButtton lowerLipA_R 292 364 15 18;
	asSDNewButtton lowerLipB_R 275 356 15 18;
	asSDNewButtton Line_R 244 326 15 18;
	asSDNewButtton EyeBrowMiddle_M 310 112 19 19;
	}

//SelectorIcons
asFitModeEnsureShaders;
createNode -n SelectorIcons transform;
setAttr SelectorIcons.tz ($height/2.2);
connectAttr SelectorLayout.s SelectorIcons.s;
createNode -n SelectorIconsWindow -p SelectorIcons transform;
connectAttr SelectorWindow.t SelectorIconsWindow.t;
connectAttr SelectorWindow.s SelectorIconsWindow.s;
createNode -n WindowIconsCorner -p SelectorIconsWindow transform;
connectAttr WindowCorner.t WindowIconsCorner.t;
connectAttr WindowCorner.s WindowIconsCorner.s;
createNode -n MirroredIcons -p WindowIconsCorner transform;
setAttr MirroredIcons.tx `getAttr SelectorWindow.sx`;
setAttr MirroredIcons.sx -1;

if ($LayoutType==1)
	{
	asSDNewIcon IKArm_R asRedSG sphere;
	asSDNewIcon PoleArm_R asRedSG cross;
	asSDNewIcon FKIKArm_R asBlueSG cross;
	asSDNewIcon IKLeg_R asRedSG sphere;
	asSDNewIcon PoleLeg_R asRedSG cross;
	asSDNewIcon FKIKLeg_R asBlueSG cross;
	asSDNewIcon RollHeel_R asRedSG torus;
	asSDNewIcon RollToes_R asRedSG torus;
	asSDNewIcon RollToesEnd_R asRedSG torus;
	asSDNewIcon HipSwinger_M asGreen2SG torus;
	asSDNewIcon IKSpine1_M asRedSG sphere;
	asSDNewIcon IKSpine2_M asRedSG sphere;
	asSDNewIcon IKSpine3_M asRedSG sphere;
	asSDNewIcon FKIKSpine_M asBlueSG cross;
	}

if (`objExists LoadingSelectorLayout`) delete LoadingSelectorLayout;

select SelectorLayout;
}

global proc asSDNewIcon (string $name, string $shader, string $shape)
{
string $buttonIcon="ButtonIcon_"+$name;
int $numLetters=`size($buttonIcon)`;
string $buttonIconLeft=`substring $buttonIcon 1 ($numLetters-2)`+"_L";
if ($shape=="sphere")
	polySphere -n $buttonIcon -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 0;
if ($shape=="cross")
	{
	polyCube -n $buttonIcon -w 1 -h 1 -d 1 -sx 3 -sy 3 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
	scale -r -p 0 0 0 0.333 0.333 0.333 ($buttonIcon+".vtx[0]") ($buttonIcon+".vtx[3]") ($buttonIcon+".vtx[12]")
		($buttonIcon+".vtx[15:16]") ($buttonIcon+".vtx[19]") ($buttonIcon+".vtx[28]") ($buttonIcon+".vtx[31]");
	scale -r -p 0 0 0 2.5 2.5 2.5 ($buttonIcon+".vtx[0:99]");
	scale -r -p 0 0 0 1 0.5 1 ($buttonIcon+".vtx[0]") ($buttonIcon+".vtx[3:12]") ($buttonIcon+".vtx[15:16]")
		($buttonIcon+".vtx[19:28]") ($buttonIcon+".vtx[31]");
	scale -r -p 0 0 0 0.5 1 1 ($buttonIcon+".vtx[0:3]") ($buttonIcon+".vtx[5:6]") ($buttonIcon+".vtx[9:10]")
		($buttonIcon+".vtx[12:19]") ($buttonIcon+".vtx[21:22]") ($buttonIcon+".vtx[25:26]") ($buttonIcon+".vtx[28:31]");
	}
if ($shape=="torus")
	polyTorus -n $buttonIcon -r 1 -sr 0.1 -tw 0 -sx 20 -sy 20 -ax 0 0 1 -cuv 1 -ch 0;
parent $buttonIcon WindowIconsCorner;
sets -e -forceElement $shader $buttonIcon;
move -r 1 -1 0 ($buttonIcon+".vtx[0:999]");
scale -r -p 0 0 0 0.5 0.5 0.5 ($buttonIcon+".vtx[0:999]");
scale -r -p 0.5 -0.5 0 0.75 0.75 0.75 ($buttonIcon+".vtx[0:999]");
connectAttr ("Button_"+$name+".t") ($buttonIcon+".t");
connectAttr ("Button_"+$name+".sx") ($buttonIcon+".sx");
connectAttr ("Button_"+$name+".sy") ($buttonIcon+".sy");
setAttr ($buttonIcon+".sz") 1000;
if (`gmatch $buttonIcon "*_R"`)
	{
	instance -n $buttonIconLeft $buttonIcon;
	parent $buttonIconLeft MirroredIcons;
	connectAttr ($buttonIcon+".t") ($buttonIconLeft+".t");
	connectAttr ($buttonIcon+".sy") ($buttonIconLeft+".sy");
	connectAttr ($buttonIcon+".sz") ($buttonIconLeft+".sz");
	createNode -n ($buttonIcon+"Reverse") reverse;
	connectAttr ($buttonIcon+".sx") ($buttonIcon+"Reverse.inputX");
	connectAttr ($buttonIcon+"Reverse.outputX") ($buttonIconLeft+".sx");
	}
	
}

global proc asSDNewButtton (string $name,int $x, int $y, int $width, int $height)
{
if (!`objExists Button_Template`)
	error "\"Button_Template\" Not found";
string $multiObjString;
string $sel[]=`ls -sl`;
string $buttonName="Button_"+$name;
if ($sel[0]!="" && !`gmatch $sel[0] "Button*"` && $sel[0]!="SelectorWindow" && $sel[0]!="SelectorLayout")
	{
	string $nameSpace=`optionMenu -q -v asSelectorDefaultOptionMenu`;
	if ($nameSpace==":")
		$buttonName="Button_"+$sel[0];
	else
		$buttonName="Button_"+`substitute $nameSpace $sel[0] ""`;
	createNode -n SelectorSampler -p WindowCorner transform;
	pointConstraint $sel[0] SelectorSampler;
	dgdirty -a;
	$x=`getAttr SelectorSampler.tx`-($width/2);
	$y=`getAttr SelectorSampler.ty`-($height/2);
	delete SelectorSampler;
	if (size($sel)>1)
		for ($i=0;$i<size($sel);$i++)
			$multiObjString+=`substitute $nameSpace $sel[$i] ""`+" ";
	}
//unique buttonName
if (`objExists $buttonName`)
	for ($i=1;$i<10;$i++)
		{
		$buttonName=`substitute "Button" $buttonName ""`;
		if (`gmatch $buttonName "[1-9]*"`)
			$buttonName=`substring $buttonName 2 99`;
		$buttonName="Button"+$i+$buttonName;
		if (!`objExists $buttonName`)
			break;
		}

string $tempString[]=`duplicate -n $buttonName Button_Template`;
$buttonName=$tempString[0];
if (!`attributeExists mirror $buttonName`)
	addAttr -k 1 -ln mirror -at bool -dv 1 $buttonName;
setAttr ($buttonName+".v") 1;
setAttr ($buttonName+".tx") $x;
setAttr ($buttonName+".ty") $y;
setAttr ($buttonName+".sx") $width;
setAttr ($buttonName+".sy") $height;
if ($multiObjString!="")
	setAttr -type "string" ($buttonName+".multiObjs") $multiObjString;

//Middle Constraint
if (`gmatch $buttonName "*_M"` && !`objExists LoadingSelectorLayout`)
	{
	if (`objExists ($buttonName+"MultiplyDivide")`) delete ($buttonName+"MultiplyDivide");
	if (`objExists ($buttonName+"PlusMinusAverage")`) delete ($buttonName+"PlusMinusAverage");
	createNode -n ($buttonName+"MultiplyDivide") multiplyDivide;
	createNode -n ($buttonName+"PlusMinusAverage") plusMinusAverage;
	setAttr ($buttonName+"PlusMinusAverage.operation") 2;
	connectAttr ($buttonName+".scale.scaleX") ($buttonName+"MultiplyDivide.input1Y");
	setAttr -type float3 ($buttonName+"MultiplyDivide.input2") 2 2 2;
	setAttr ($buttonName+"MultiplyDivide.operation") 2;
	connectAttr ($buttonName+"MultiplyDivide.outputY") ($buttonName+"PlusMinusAverage.input1D[1]");
//	setAttr ($buttonName+"PlusMinusAverage.input1D[0]") (`getAttr SelectorWindow.scale.scaleX`/2.0);
	setAttr ($buttonName+"PlusMinusAverage.input1D[0]") 320;
	connectAttr ($buttonName+"PlusMinusAverage.output1D") ($buttonName+".tx");
	}

select $buttonName;
}

global proc int asSelectorBackgroundImport (string $fileName, string $fileType)
{
eval ("renderWindowEditor -e -loadImage \""+$fileName+"\" renderView");
asSDRender 2;
return 1;
}

global proc asSDRender (int $background)
{
global string $gMove;
setToolTo $gMove;
if (!`objExists SelectorWindow`)
	{
	if (`confirmDialog -t "Confirm"
	-m "No Layout found. Create New one ?"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
	asSDNewLayout 0;
	}
if (`objExists SelectorCamera`)
	delete SelectorCamera;
int $renderViewIconized=1;
if (`window -q -ex renderViewWindow`)
	$renderViewIconized=`window -q -i renderViewWindow`;
else if ($background)
	RenderViewWindow;
int $x,$y,$width,$height,$numLetters;
int $windowWidth=`getAttr SelectorWindow.sx`;
int $windowHeight=`getAttr SelectorWindow.sy`;
float $widthFloat,$heightFloat;
float $windowCornerWidth=`getAttr WindowCorner.sx`;
float $windowCornerHeight=`getAttr WindowCorner.sy`;
$windowCornerHeight=`abs($windowCornerHeight)`;
int $doMirrorBox[];
float $pos[];
string $sel[]=`ls -sl`;
string $projectName=`text -q -l asSelectorProjectName`;
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Selector/untitled/";
//string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Selector/"+$projectName+"/";
//string $iconDir=`text -q -l asSelectorProjectPath`+$projectName+"/";
string $bgImageFile=$iconDir+"untitled_background.png";
string $bgImageFile32=$iconDir+"untitled_background32.png";
string $cmd,$keyCmd,$linearKeyCmd,$labelAttr,$iol,$multiObjAttr,$ann,$fileName;
string $alignFK2IKCmd,$alignIK2FKCmd,$switchFK2IKCmd,$switchIK2FKCmd;
string $annBuffer[],$tempString[];
string $renderBoxes[]=`listRelatives -c WindowCorner`;
string $renderBoxObjs[]=$renderBoxes;
for ($i=0;$i<size($renderBoxes);$i++)
	{
	if (`gmatch $renderBoxes[$i] "Button_*"`)
		$renderBoxObjs[$i]=`substring $renderBoxes[$i] 8 999`;
	if (`gmatch $renderBoxes[$i] "Button?_*"`)
		$renderBoxObjs[$i]=`substring $renderBoxes[$i] 9 999`;
//	if (`gmatch $renderBoxes[$i] "*_R"` && `getAttr ($renderBoxes[$i]+".tx")`<$windowWidth/2)
	if (`gmatch $renderBoxes[$i] "*_R"` && `getAttr ($renderBoxes[$i]+".tx")`<320)
		{
		$numLetters=`size($renderBoxes[$i])`;
		$mirrorBox=`substring $renderBoxes[$i] 1 ($numLetters-2)`+"_L";
		if (`objExists $mirrorBox`)
			continue;
		if (`attributeExists mirror $renderBoxes[$i]`)
			if (`getAttr ($renderBoxes[$i]+".mirror")`==0)
				continue;

		$doMirrorBox[$i]=1;
		$doMirrorBox[size($renderBoxes)]=1;
		$renderBoxes[size($renderBoxes)]=$mirrorBox;
		}
	}

string $deleteObjs[]={"SelectorScaleSampler","SelectorCamera","SelectorFileNode","SelectorFilePlace",
	"SelectorRampU","SelectorRampV","SelectorLayeredTexture"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

float $color[3]=`displayRGBColor -q "background"`;
if (!`optionVar -ex asSelectorBGColor`)
	{
	optionVar -fv asSelectorBGColor $color[0];
	optionVar -fva asSelectorBGColor $color[1];
	optionVar -fva asSelectorBGColor $color[2];
	}
if (!`optionVar -ex asSelectorDefaultColor`)
	{
	optionVar -fv asSelectorDefaultColor 1;
	optionVar -fva asSelectorDefaultColor 1;
	optionVar -fva asSelectorDefaultColor 1;
	}
if (!`optionVar -ex asSelectorSelColor`)
	{
	optionVar -fv asSelectorSelColor 0.2;
	optionVar -fva asSelectorSelColor 0.8;
	optionVar -fva asSelectorSelColor 0.2;
	}
if (!`optionVar -ex asSelectorKeyColor`)
	{
	optionVar -fv asSelectorKeyColor 1;
	optionVar -fva asSelectorKeyColor 0.4;
	optionVar -fva asSelectorKeyColor 0.4;
	}
float $bgColor[3]=`optionVar -q asSelectorBGColor`;
float $selColor[3]=`optionVar -q asSelectorSelColor`;
float $keyColor[3]=`optionVar -q asSelectorKeyColor`;

$tempString=`formLayout -q -ca asSelectorDefaultFormLayout`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!$background && $tempString[$i]=="asSelectorDefaultBGPicture")
		continue;
	deleteUI $tempString[$i];
	}

if ($background)
	{
	if (`text -q -l asSelectorBackgroundWidth`) text -e -l $windowWidth asSelectorBackgroundWidth;
	if (`text -q -l asSelectorBackgroundHeight`) text -e -l $windowHeight asSelectorBackgroundHeight;

	createNode -n SelectorScaleSampler transform;
	$tempString=`camera -centerOfInterest 5 -focalLength 35 -lensSqueezeRatio 1 -cameraScale 1 -horizontalFilmAperture 1.4173 -horizontalFilmOffset 0 -verticalFilmAperture 0.9449 -verticalFilmOffset 0 -filmFit Fill -overscan 1 -motionBlur 0 -shutterAngle 144 -nearClipPlane 0.1 -farClipPlane 10000 -orthographic 1 -orthographicWidth 30 -panZoomEnabled 0 -horizontalPan 0 -verticalPan 0 -zoom 1`;
	rename $tempString[0] SelectorCamera;
	float $restoreRenderWidth=`getAttr defaultResolution.width`;
	float $restoreRenderHeight=`getAttr defaultResolution.height`;
	float $restoreRenderAspectLock=`getAttr defaultResolution.aspectLock`;
	int $restoreFormat=`getAttr "defaultRenderGlobals.imageFormat"`;
	setAttr defaultRenderGlobals.imageFormat 32;
	
	setAttr "defaultResolution.aspectLock" 0;
	setAttr defaultResolution.width $windowWidth;
	setAttr defaultResolution.height $windowHeight;
	setAttr "defaultResolution.aspectLock" 1;
	setAttr defaultResolution.deviceAspectRatio ($windowWidth/($windowHeight+0.00));
	
	select SelectorWindow.vtx[0:99];
	$pos=`manipMoveContext -q -position "Move"`;
	xform -ws -t $pos[0] $pos[1] $pos[2] SelectorCamera;
	move -r 0 0 1.1 SelectorCamera;
	delete `scaleConstraint SelectorWindow SelectorScaleSampler`;
	setAttr SelectorCameraShape.orthographicWidth `getAttr SelectorScaleSampler.sx`;
	if ($background==1)
		renderWindowRenderCamera render renderView SelectorCamera;
	eval ("renderWindowEditor -e -wi \""+$bgImageFile+"\" renderView");
	setParent asSelectorDefaultFormLayout;

	image -en 0 -w $windowWidth -h $windowHeight -i $bgImageFile asSelectorDefaultBGPicture;
	reloadImage $bgImageFile asSelectorDefaultBGPicture;
	formLayout -e -af asSelectorDefaultBGPicture "left" 0 -af asSelectorDefaultBGPicture "top" 0 asSelectorDefaultFormLayout;
	//32
	string $fileNode=`createNode file`;
	setAttr -type "string" ($fileNode+".fileTextureName") $bgImageFile;
	select $fileNode;
	eval ("convertSolidTx -sp 1 -al 1 -rx 32 -ry 32 -n asTempSolidTx32 -fil \"png\" -fin \""+$bgImageFile32+"\"");
	delete $fileNode asTempSolidTx32;
	evalDeferred -lp ("window -e -w "+$windowWidth+" -h "+$windowHeight+" asSelectorDefault");
	
	setAttr defaultResolution.width $restoreRenderWidth;
	setAttr defaultResolution.height $restoreRenderHeight;
	setAttr defaultResolution.aspectLock $restoreRenderAspectLock;
	setAttr defaultRenderGlobals.imageFormat $restoreFormat;
	delete SelectorCamera SelectorScaleSampler;
	if ($renderViewIconized)
		window -e -i 1 renderViewWindow;
	}

for ($i=0;$i<size($renderBoxes);$i++)
	{
	$guiBox=$renderBoxes[$i];
	if (`gmatch $renderBoxes[$i] "*_L"` && $doMirrorBox[$i])
		{
		$numLetters=`size($renderBoxes[$i])`;
		$guiBox=`substring $renderBoxes[$i] 1 ($numLetters-2)`+"_R";
		}
	$x=`getAttr ($guiBox+".tx")`*$windowWidth*$windowCornerWidth;
	$y=`getAttr ($guiBox+".ty")`*$windowHeight*$windowCornerHeight;
	
	$widthFloat=`getAttr ($guiBox+".sx")`*$windowWidth*$windowCornerWidth;
	$width=`asRoundOff $widthFloat 0`;
	$heightFloat=`getAttr ($guiBox+".sy")`*$windowHeight*$windowCornerHeight;
	$height=`asRoundOff $heightFloat 0`;
	if (`gmatch $renderBoxes[$i] "*_L"` && $doMirrorBox[$i])
		$x=$windowWidth-$x-$width;
	if ($x<0 || $x>$windowWidth || $y<0 || $y>$windowHeight)
		continue;
	if ($background)
		continue;
	if ($bgImageFile=="" || !`file -q -ex $bgImageFile`)
		error "No background image, Render a background first";
	$iol="";
	$labelAttr=`getAttr ($guiBox+".label")`;
	if ($labelAttr!="")
		$iol=$labelAttr;
	$ann=$renderBoxObjs[$i];
	$fileName=$ann;
	$multiObjAttr=`getAttr ($guiBox+".multiObjs")`;
	if ($multiObjAttr!="")
		{
		$ann=$multiObjAttr;
		if (`gmatch $renderBoxes[$i] "*_L"`)
			{
			tokenize $ann $tempString;
			$ann="";
			for ($z=0;$z<size($tempString);$z++)
				$ann+=`substitute "_R" $tempString[$z] "_L"`+" ";
			}
		$fileName="combo"+$x+$y;
		}

	createNode -n SelectorFileNode file;
	setAttr -type "string" SelectorFileNode.fileTextureName $bgImageFile;
	float $pictureWidth=`getAttr SelectorFileNode.outSizeX`;
	float $pictureHeight=`getAttr SelectorFileNode.outSizeY`;
	createNode -n SelectorFilePlace place2dTexture;
	connectAttr SelectorFilePlace.outUV SelectorFileNode.uvCoord; connectAttr -f SelectorFilePlace.outUvFilterSize SelectorFileNode.uvFilterSize; 
	connectAttr -f SelectorFilePlace.coverage SelectorFileNode.coverage; connectAttr -f SelectorFilePlace.translateFrame SelectorFileNode.translateFrame; 
	connectAttr -f SelectorFilePlace.rotateFrame SelectorFileNode.rotateFrame; connectAttr -f SelectorFilePlace.mirrorU SelectorFileNode.mirrorU; 
	connectAttr -f SelectorFilePlace.mirrorV SelectorFileNode.mirrorV; connectAttr -f SelectorFilePlace.stagger SelectorFileNode.stagger; 
	connectAttr -f SelectorFilePlace.wrapU SelectorFileNode.wrapU; connectAttr -f SelectorFilePlace.wrapV SelectorFileNode.wrapV; 
	connectAttr -f SelectorFilePlace.repeatUV SelectorFileNode.repeatUV; connectAttr -f SelectorFilePlace.vertexUvOne SelectorFileNode.vertexUvOne; 
	connectAttr -f SelectorFilePlace.vertexUvTwo SelectorFileNode.vertexUvTwo; connectAttr -f SelectorFilePlace.vertexUvThree SelectorFileNode.vertexUvThree; 
	connectAttr -f SelectorFilePlace.vertexCameraOne SelectorFileNode.vertexCameraOne; connectAttr -f SelectorFilePlace.noiseUV SelectorFileNode.noiseUV; 
	connectAttr -f SelectorFilePlace.offset SelectorFileNode.offset; connectAttr -f SelectorFilePlace.rotateUV SelectorFileNode.rotateUV;
	setAttr SelectorFilePlace.offsetU (($x+1)/$pictureWidth);
	setAttr SelectorFilePlace.offsetV (($pictureHeight-($y-1+$height))/$pictureHeight);
	setAttr SelectorFilePlace.repeatV (($height-2)/$pictureHeight);
	setAttr SelectorFilePlace.repeatU (($width-2)/$pictureWidth);

	createNode -n SelectorRampU ramp;
	createNode -n SelectorRampV ramp;
	setAttr SelectorRampU.type 1;
	setAttr SelectorRampU.interpolation 0;
	setAttr SelectorRampU.colorEntryList[1].color -type double3 0.75 0.75 0.75;
//	if ($width>2)
		setAttr SelectorRampU.colorEntryList[1].position (1-(1.00000/$width));
	setAttr SelectorRampU.colorEntryList[0].color -type double3 0 0 0;
	setAttr SelectorRampV.type 0;
	setAttr SelectorRampV.interpolation 0;
	setAttr SelectorRampV.colorEntryList[0].color -type double3 0.75 0.75 0.75;
//	if ($height>2)
		setAttr SelectorRampV.colorEntryList[1].position (1.00000/$height);
	connectAttr SelectorRampU.outColor SelectorRampV.colorEntryList[1].color;
	setAttr SelectorRampU.colorEntryList[0].position (1.00000/$width);
	setAttr SelectorRampU.colorEntryList[2].color -type double3 0.75 0.75 0.75;
	setAttr SelectorRampV.colorEntryList[0].position (1-(1.00000/$height));
	setAttr SelectorRampV.colorEntryList[2].color -type double3 0.75 0.75 0.75;


	createNode -n SelectorLayeredTexture layeredTexture;
	setAttr SelectorLayeredTexture.inputs[0].color -type double3 1 1 1 ;
	connectAttr SelectorRampV.outColorR SelectorLayeredTexture.inputs[0].alpha;
	connectAttr -f SelectorFileNode.outAlpha SelectorLayeredTexture.inputs[1].alpha;
	connectAttr -f SelectorFileNode.outColor SelectorLayeredTexture.inputs[1].color;

	string $buttonImageFileOffK0=$iconDir+$projectName+"_"+$fileName+"_OffK0.png";
	string $buttonImageFileOffK1=$iconDir+$projectName+"_"+$fileName+"_OffK1.png";
	string $buttonImageFileOnK0=$iconDir+$projectName+"_"+$fileName+"_OnK0.png";
	string $buttonImageFileOnK1=$iconDir+$projectName+"_"+$fileName+"_OnK1.png";
	
	//Off K0 version
	select SelectorLayeredTexture;
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOffK0+"\"");
	delete asTempSolidTx;

	//add tint now, so that selection/keyed buttons (with blank space background) are also visible
	setAttr SelectorLayeredTexture.inputs[2].alpha 0.3;
	
	//Off K1 version
	setAttr SelectorFileNode.colorOffset -type double3 0.27 0.27 0.27;
	setAttr SelectorFileNode.colorGain -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOffK1+"\"");
	delete asTempSolidTx;
	
	//On K0 version
	setAttr SelectorFileNode.colorOffset -type double3 0.27 0.27 0.27;
	setAttr SelectorFileNode.colorGain -type double3 $selColor[0] $selColor[1] $selColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 $selColor[0] $selColor[1] $selColor[2];
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOnK0+"\"");
	delete asTempSolidTx;
	
	//On K1 version
	setAttr SelectorFileNode.colorOffset -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	setAttr SelectorFileNode.colorGain -type double3 $selColor[0] $selColor[1] $selColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 ($selColor[0]+$keyColor[0]) ($selColor[1]+$keyColor[1]) ($selColor[2]+$keyColor[2]);
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOnK1+"\"");
	delete asTempSolidTx;
	for ($q=0;$q<size($deleteObjs);$q++)
		if (`objExists $deleteObjs[$q]`)
			delete $deleteObjs[$q];


	if (`control -q -ex $renderBoxes[$i]`)
		deleteUI $renderBoxes[$i];
	setParent asSelectorDefaultFormLayout;

	//Update cmd, popUp
	$alignFK2IKCmd=$alignIK2FKCmd=$switchFK2IKCmd=$switchIK2FKCmd="";
	if (`gmatch $renderBoxObjs[$i] "FKIK*"` && !`gmatch $renderBoxObjs[$i] "FKIKSp*ine*"`)
		{
		$alignFK2IKCmd="asAlignFK2IK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$alignIK2FKCmd="asAlignIK2FK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$switchFK2IKCmd="asSwitchFK2IK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$switchIK2FKCmd="asSwitchIK2FK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		}
	$cmd="asSelect \"Default\" {\""+$ann+"\"};";
	if (`gmatch $ann "* *"`)
		{
		tokenize $ann $annBuffer;
		$cmd="asSelect \"Default\" {";
		for ($q=0;$q<size($annBuffer);$q++)
			{
			$cmd+="\""+$annBuffer[$q]+"\"";
			if ($q<size($annBuffer)-1)
				$cmd+=",";
			}
		$cmd+="};";
		}
	$keyCmd="asKey \"Default\" {\""+$renderBoxObjs[$i]+"\"};";
	$linearKeyCmd="asLinearKey \"Default\" {\""+$renderBoxObjs[$i]+"\"};";

	$buttonName=$renderBoxObjs[$i]+":"+$x+":"+$y;
	iconTextButton -w $width -h $height -i $buttonImageFileOffK0 -iol $iol -c $cmd -ann $ann $buttonName;
	reloadImage $buttonImageFileOffK0 $buttonName;
	formLayout -e -af $buttonName "left" $x -af $buttonName "top" $y asSelectorDefaultFormLayout;

	popupMenu -p $buttonName;
		menuItem -l "Key" -c $keyCmd;
		menuItem -l "LinearKey" -c $linearKeyCmd;
		menuItem -d 1;
		menuItem -l "Label Button" -c ("asLabelButton \""+$buttonName+"\"");
//		menuItem -l "Remove Button" -c ("asDeleteButton \""+$buttonName+"\"");
		if ($alignFK2IKCmd!="")
			{
			menuItem -d 1;
			menuItem -sm 1 -l "Align";
				menuItem -l "FK2IK" -c $alignFK2IKCmd;
				menuItem -l "IK2FK" -c $alignIK2FKCmd;
				setParent -menu ..;
			menuItem -sm 1 -l "Switch";
				menuItem -l "FK2IK" -c $switchFK2IKCmd;
				menuItem -l "IK2FK" -c $switchIK2FKCmd;
			}
	}


select $sel;
}

global proc asLabelButton (string $button)
{
string $result=`promptDialog -t "Label" -b "Ok"  -b "Cancel" -db "Ok" -cb "Cancel" -ds "Cancel"`;
if ($result!="Ok")
	return;
iconTextButton -e -iol (`promptDialog -q -tx`) $button;
if (`promptDialog -q -tx`=="All")
	iconTextButton -e -ann "ControlSet" $button;
//asSelectorRefresh;
}
//-- ASSelectorDesigner Procedures Ends Here --//

//-- ASPoserDesigner Procedures Starts Here --//
global proc asPoserDesigner ()
{
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $fileList[]=`getFileList -fld ($iconDir+"/")`;
for ($file in $fileList)
	eval ("sysFile -del \""+$iconDir+"/"+$file+"\"");
string $buttonImageFileExt="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$buttonImageFileExt="png";
int $nc=`optionVar -q asPoserNc`;
if ($nc<1)
	$nc=4;
int $nr=`optionVar -q asPoserNr`;
if ($nr<1)
	$nr=2;
string $poserText=`optionVar -q asPoserText`;
if ($poserText=="0")
	$poserText="Pose";
int $onlySel=`optionVar -q asPoserOnlySel`;
int $anim=`optionVar -q asPoserAnim`;
int $renderView=`optionVar -q asPoserRenderView`;
string $controlSets[]=`asGetControlSets`;

if (`window -q -ex asPoserDefault`)
	deleteUI asPoserDefault;
window -mb 1 -t "PoserDesigner :untitled" asPoserDefault;
menu "File";
	menuItem -c "evalDeferred asPoserDesigner" "New";
	menuItem -c "asfileBrowse Poser Open" "Open";
	menuItem -sm 1 -l "ControlSets" asPoserControlSetsMenu;
		menuItem -cb 1 -l ControlSet asPoserControlSetsMenuItemControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if ($controlSets[$i]!="ControlSet")
				menuItem -cb 0 -l $controlSets[$i] ("asPoserControlSetsMenuItem"+$controlSets[$i]);
		setParent -menu ..;
	menuItem -d 1;
	menuItem -c "asSave Poser" "Save";
	menuItem -c "asfileBrowse Poser SaveAs" "Save As";
	menuItem -c "astoShelf Poser" "Put on shelf";
	setParent -menu ..;
	menuItem -d 1;
	menuItem -c "deleteUI asPoserDefault" "Close";
	setParent -menu ..;
formLayout asPoserDefaultFormLayout;
	text -vis 0 -l (`internalVar -utd`+"AdvancedSkeleton/Poser/") asPoserProjectPath;
	text -vis 0 -l ("untitled") asPoserProjectName;
	rowLayout -adj 1 -nc 8 -cw 2 90 -cw 3 80 -cw 4 90 -cw 5 50 -cw 6 20 -cw 7 25 asPoserDefaultRowLayout;
		optionMenu asPoserDefaultOptionMenu;
		button -l "    New Pose    " -c "asNewPose {} 0";
		textField -w 70 -tx $poserText -cc asPoserUpdateGrid asPoserTextField;
		checkBox -v $onlySel -l "only selected" -cc asPoserUpdateGrid asPoserOnlySel;
		checkBox -v $anim -l "anim" -cc asPoserUpdateGrid asPoserAnim;
		intField -w 20 -v $nc -cc asPoserUpdateGrid asPoserNc;
		intField -w 20 -v $nr -cc asPoserUpdateGrid asPoserNr;
		checkBox -v $renderView -l "renderView" -cc asPoserUpdateGrid asPoserRenderView;
		setParent..;
//	scrollLayout -dgc asPoserDgc -dpc asPoserDpc asPoserDefaultScrollayout;
//	cannot use scrollLayout cause it returns incorrect drop coordinates when scrolled.
	columnLayout -dgc asPoserDgc -dpc asPoserDpc asPoserDefaultScrollayout;
		gridLayout -h (90*$nr) -nc $nc -nr $nr -cw 110 -ch 90 asPoserDefaultGridLayout;

formLayout -e
	-af asPoserDefaultRowLayout "top" 0
	-ac asPoserDefaultScrollayout "top" 0 asPoserDefaultRowLayout
	-af asPoserDefaultScrollayout "bottom" 0
	-af asPoserDefaultScrollayout "left" 0
	-af asPoserDefaultScrollayout "right" 0
	asPoserDefaultFormLayout;

asPopulateNameSpaceMenu "asPoserDefault";

//Remove Old Icons
string $oldFilesList[]=`getFileList -fld $iconDir`;
for ($file in $oldFilesList)
	sysFile -del ($iconDir+$file);

showWindow asPoserDefault;
}

global proc asNewPose (string $loadData[], int $anim)
{
global int $asfileLoading;
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $setParent=`setParent -q`;
string $uiName,$image,$label,$cmd,$mayaFile,$loadingMayaFile;
int $nc,$nr,$numTok,$singleAttr;
float $range[2]={0,1};
string $buffer[];
if ($loadData[0]=="" || $asfileLoading)
	{
	$nc=`intField -q -v asPoserNc`;
	$nr=`intField -q -v asPoserNr`;
	$uiName="asPoserDefault";
	}
else
	$uiName=$loadData[0];
string $ext="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext="png";
string $gridOrder[]=`gridLayout -q -go ($uiName+"GridLayout")`;
int $lastFilled,$childNum;
//Find Last filled
for ($i=1;$i<size($gridOrder)+1;$i++)
	if (`gmatch $gridOrder[$i-1] "asPoser*"`)
		$lastFilled=$i;
$childNum=$lastFilled+1;

//Total full
if ($childNum>($nc*$nr) && $loadData[0]=="")
	error "Grid is full, extend rows or columns !\n";

if ($loadData[0]=="")
	{
	if (`optionMenu -q -v asPoserDefaultOptionMenu`=="None")
		error "No Character In The Scene\n";
	$anim=`checkBox -q -v asPoserAnim`;
	$cmd=`asPoserGetCmd $uiName $anim`;
	if ($cmd=="")
		error "No valid objects !\n";
	$image=`asPoserSnapShoot $uiName $childNum $anim 1 1`;
	if ($anim && $cmd!="")
		$cmd+=" "+$childNum;
	if (`about -mac`)
		showWindow asPoserDefault;
	$label=`textField -q -tx asPoserTextField`;
	}
else
	{
	$childNum=$loadData[4];
	$numTok=`tokenize $loadData[1] "/" $buffer`;
	$image=$iconDir+"untitled_"+$childNum+"."+$ext;
	sysFile -cp $image $loadData[1];
	$mayaFile=`substitute "[.][a-z][a-z][a-z]" $image ".ma"`;
	$loadingMayaFile=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".ma"`;
	if (`file -q -ex $loadingMayaFile`)
		sysFile -cp $mayaFile $loadingMayaFile;
	$jpg=`substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
	$loadingJpg=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".jpg"`;
	if (`file -q -ex $loadingJpg`)
		sysFile -cp $jpg $loadingJpg;
	$avi=`substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
	$loadingAvi=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".avi"`;
	if (`file -q -ex $loadingAvi`)
		sysFile -cp $avi $loadingAvi;
	$label=$loadData[2];
	$cmd=$loadData[3];
	if ($asfileLoading)
		$cmd=`substitute $loadData[0] $cmd $uiName`;
	$anim=$loadData[5];
	}
$numTok=`tokenize $cmd ";" $buffer`;
if ($numTok==2)
	$singleAttr=1;
setParent ($uiName+"GridLayout");
columnLayout ($uiName+"ColumnLayout"+$childNum);
gridLayout -e -pos ($uiName+"ColumnLayout"+$childNum) $childNum ($uiName+"GridLayout");
rowColumnLayout -ann $anim -nc 2 -cw 1 100 -cw 2 15 ($uiName+"RowColumnLayout"+$childNum);
	iconTextButton -w 100 -h 75 -i $image -c $cmd ($uiName+"IconTextButton"+$childNum);
	floatSlider -m 0 -w 10 -h 75 -hr 0 ($uiName+"FloatSlider"+$childNum);
	text -h 15 -al "center" -fn "smallBoldLabelFont" -l $label ($uiName+"Text"+$childNum);
if ($anim)
	text -e -bgc 1 0 0 ($uiName+"Text"+$childNum);
if ($loadData[0]=="" || $asfileLoading)
	{
	asPoserupdateGridBlock $uiName $childNum;
	iconTextButton -e -dgc asPoserDgc -dpc asPoserDpc ($uiName+"IconTextButton"+$childNum);
	}

//connectControl
string $connectToObj,$connectToAttr,$resolvedDestination;
string $allKeyableAttrs[];
if ($singleAttr)
	{
	tokenize $cmd "\"" $buffer;
	tokenize $buffer[1]  $buffer;
	tokenize $buffer[0] "." $buffer;
	$connectToObj=$buffer[0];
	$connectToAttr=$buffer[1];
	$resolvedObj=`asPoserResolveNameSpace $uiName $connectToObj`;
	if (`objExists $resolvedObj`)
		$allKeyableAttrs=`listAttr -k -m -sn $resolvedObj`;

	for ($allKeyableAttr in $allKeyableAttrs)
		if ($connectToAttr==$allKeyableAttr)
			if (`getAttr -se ($resolvedObj+"."+$connectToAttr)`)
					{
					if (`attributeQuery -n $resolvedObj -ex $connectToAttr`)
						if (!`attributeQuery -n $resolvedObj -re $connectToAttr`)
							break;
					if (`attributeQuery -n $resolvedObj -ex $connectToAttr`)
						$range=`attributeQuery -n $resolvedObj -r $connectToAttr`;
					else
						//probably a muli attr  e.g. blenShape target..using range 0->1
						$range={0,1};
					floatSlider -ann ($connectToObj+"."+$connectToAttr) -e -m 1 -min $range[0] -max $range[1] ($uiName+"FloatSlider"+$childNum);
					connectControl ($uiName+"FloatSlider"+$childNum) ($resolvedObj+"."+$connectToAttr);
					text -e -l $connectToAttr ($uiName+"Text"+$childNum);
					}
	}
setParent $setParent;
}

global proc asPoserUpdateGrid ()
{
int $nc=`intField -q -v asPoserNc`;
optionVar -iv asPoserNc $nc;
int $nr=`intField -q -v asPoserNr`;
optionVar -iv asPoserNr $nr;
string $poserText=`textField -q -tx asPoserTextField`;
optionVar -sv asPoserText $poserText;
int $onlySel=`checkBox -q -v asPoserOnlySel`;
optionVar -iv asPoserOnlySel $onlySel;
int $anim=`checkBox -q -v asPoserAnim`;
optionVar -iv asPoserAnim $anim;
int $renderView=`checkBox -q -v asPoserRenderView`;
optionVar -iv asPoserRenderView $renderView;

if ($nc<1)
	{
	intField -e -v 1 asPoserNc;
	asPoserUpdateGrid;
	return;
	}
if ($nr<1)
	{
	intField -e -v 1 asPoserNr;
	asPoserUpdateGrid;
	return;
	}
gridLayout -e -nc $nc -nr $nr -w (110*$nc) -h (90*$nr) asPoserDefaultGridLayout;
}

global proc asPoserRename (int $childNum)
{
if (!`text -q -ex ("asPoserDefaultText"+$childNum)`)
	error "Cant find `text` uiElement\n";
string $oldname=`text -q -l ("asPoserDefaultText"+$childNum)`;
string $result=`promptDialog -m "Name:" -tx $oldname -t ("AdvancedSkeleton") -b "Ok" -b "Cancel" -db "Ok" -cb "Cancel" -ds "Cancel"`;
if ($result=="Cancel")
	return;
string $newName=`promptDialog -q -tx`;
text -e -l $newName ("asPoserDefaultText"+$childNum);
}

global proc asPoserDeletePose (string $uiName, int $num)
{
string $image=`iconTextButton -q -i ($uiName+"IconTextButton"+$num)`;
$jpgImage=`substitute "[.]png" $image ".jpg"`;
$jpgImage=`substitute "[.]xpm" $jpgImage ".jpg"`;
sysFile -del $image;
sysFile -del $jpgImage;

evalDeferred ("deleteUI "+$uiName+"ColumnLayout"+$num);
}

global proc string asPoserSnapShoot (string $uiName, int $childNum, int $anim, int $updateIcon, int $updateMovie)
{
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
int $renderView=`checkBox -q -v asPoserRenderView`;
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;

int $curFrame=`currentTime -q`;
int $startFrame=$endFrame=$curFrame;
int $currFormat=`getAttr "defaultRenderGlobals.imageFormat"`;
string $huds[]=`headsUpDisplay -listHeadsUpDisplays`;
int $hudStates[];
for ($i=0;$i<size($huds);$i++)
	{
	$hudStates[$i]=`headsUpDisplay -q -vis $huds[$i]`;
	headsUpDisplay -e -vis 0 $huds[$i];
	}
string $ext;
if (`asMayaVersionAsFloat`>=2011)
	{
	$ext="png";
	setAttr "defaultRenderGlobals.imageFormat" 32;
	}
else
	{
	$ext="xpm";
	setAttr -type "string" defaultRenderGlobals.imfPluginKey "xpm";
	setAttr defaultRenderGlobals.imageFormat 50;
	}
string $fileName=$iconDir+"untitled_"+$childNum;
string $iconImage=$fileName+"."+$ext;
string $blastImage=$fileName+"."+`asDoPadd $curFrame 4`;
string $blastMovie=$fileName+".avi";
string $largeImage=$fileName+".jpg";
string $bgImageFile32=$iconDir+"untitled_background32."+$ext;
int $iconExists;
if (`file -q -ex $iconImage`)
	$iconExists=1;
		
if ($renderView && $updateIcon)
	{
	if (`renderWindowEditor -q -nim renderView`<0)
		error ("No Image In RenderView\n");
	eval ("renderWindowEditor -e -wi \""+$iconImage+"\" renderView");
	asPoserResizeImage 100 75 $iconImage $iconImage;
	setAttr defaultRenderGlobals.imageFormat 8;
	evalEcho ("renderWindowEditor -e -wi \""+$largeImage+"\" renderView");
	}
if (!$renderView && $updateIcon)
	{
	playblast -w 100 -h 75 -compression "png" -p 100 -st $curFrame -et $curFrame -f $fileName -fmt image -fo -clearCache 0 -viewer 0 -showOrnaments 0;
	sysFile -ren $iconImage ($blastImage+"."+$ext);
	}

setAttr defaultRenderGlobals.imageFormat 8;

if ($anim && $updateMovie)
	playblast -p 100 -st `playbackOptions -q -min` -et `playbackOptions -q -max` -f $fileName -fmt movie -fo -clearCache 0 -viewer 0 -showOrnaments 0;
else if ($updateIcon)
	{
	playblast -p 100 -compression "png" -st $curFrame -et $curFrame -f $fileName -fmt image -fo -clearCache 0 -viewer 0 -showOrnaments 0;
	sysFile -ren $largeImage ($blastImage+".jpg");
	}
setAttr defaultRenderGlobals.imageFormat $currFormat;
for ($i=0;$i<size($huds);$i++)
	headsUpDisplay -e -vis $hudStates[$i] $huds[$i];


if (`about -linux`)
	$iconImage=`asConvertToXpm $iconImage`;

//32x32
if (!`file -q -ex $bgImageFile32`)
	{
	asPoserResizeImage 32 32 $iconImage $bgImageFile32;
	if (`about -linux`)
		asConvertToXpm $bgImageFile32;
	}

if ($iconExists)
	reloadImage $iconImage ($uiName+"IconTextButton"+$childNum);
return $iconImage;
}

global proc asPoserResizeImage (int $x, int $y, string $inputImage, string $outputImage)
{
string $sel[]=`ls -sl`;
string $buttonImageFileExt="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$buttonImageFileExt="png";
string $uniqueFileName=`asUniqueFile $inputImage`;
string $fileNode=`createNode file`;
setAttr -type "string" ($fileNode+".fileTextureName") $uniqueFileName;
eval ("convertSolidTx -sp 1 -al 1 -rx "+$x+" -ry "+$y+" -n asTempSolidTx32 -fil \""+$buttonImageFileExt+"\" -fin \""+$outputImage+"\"");
delete $fileNode asTempSolidTx32;
sysFile -del $uniqueFileName;
select $sel;
}

global proc string asDoPadd (int $frameNr,int $padding)
{
string $frameName;
string $padd="";
string $neg="";
string $frameNrAsString=$frameNr;
for ($i=0;$i<$padding;$i++)
	$padd=$padd+"0";
//move the negative symbol to start of string//
if ($frameNr<0)
	$neg="-";
int $nr=`size ($frameNrAsString)`;
if ($padding>$nr)
	$frameName=$neg+`substring $padd ($nr+1) 999`+abs($frameNr);
else
	$frameName=$frameNr;
return $frameName;
}

global proc string[] asPoserDgc (string $dragControl, int $x, int $y, int $mods) 
{
string $return[];
$return[0]=$x;
$return[1]=$y;
$return[2]=$mods;
return $return;
}

global proc asPoserDpc (string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) 
{
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
if (`gmatch $dropControl "*IconTextButton*"`)
	return;
int $left=$msgs[0];
int $top=$msgs[1];

int $nc=`intField -q -v asPoserNc`;
int $nr=`intField -q -v asPoserNr`;
	
string $match=`match "[0-9]+$" $dragControl`;
int $oldChildNum=$match;
int $newRowNum=ceil(($x+0.00)/110);
int $newColNum=ceil(($y+0.00)/90);
int $newChildNum=$newRowNum+(($newColNum-1)*$nc);
if ($newChildNum==$oldChildNum)
	return;
if ($newChildNum>($nc*$nr))
	error "out of grid, extend rows or columns !\n";
string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
if (`gmatch $gridOrder[$newChildNum-1] "asPoser*"`)
	error "grid position is occupied !\n";
gridLayout -e -pos ("asPoserDefaultColumnLayout"+$oldChildNum) $newChildNum asPoserDefaultGridLayout;

//rename UI elements
string $children[]=`layout -q -ca ("asPoserDefaultColumnLayout"+$oldChildNum)`;
$children[size($children)]="asPoserDefaultColumnLayout"+$oldChildNum;
string $grandChildren[]=`layout -q -ca $children[0]`;
string $allChildren[]=`stringArrayCatenate $children $grandChildren`;
string $tempString[];
string $cmd;
int $numDigitsInIldChildNum=size($match);
int $numDigitsInChild;
int $numDigitsInImage;
string $newChildName,$image,$animFile,$newAnimFile;
string $ext="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext="png";
for ($child in $allChildren)
	{
	$numDigitsInChild=size($child);
	string $newChildName=`substring $child 1 ($numDigitsInChild-$numDigitsInIldChildNum)`+$newChildNum;
	renameUI $child $newChildName;

	//rename bitmaps
	if (!`iconTextButton -q -ex $newChildName`)
		continue;
	$image=`iconTextButton -q -i $newChildName`;
	$numDigitsInImage=size($image);
	$newImage=`substring ("\""+$image+"\"") 2 ($numDigitsInImage-3-$numDigitsInIldChildNum)`+$newChildNum+"."+$ext;
	if (`file -q -ex $image` && $newImage!=$image)
		{
		eval ("sysFile -ren \""+$newImage+"\"  \""+$image+"\"");
		iconTextButton -e -i $newImage $newChildName;
		reloadImage $newImage $newChildName;
		$jpg=`substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
		if (`file -q -ex $jpg`)
			sysFile -ren `substitute "[.][a-z][a-z][a-z]" $newImage ".jpg"` `substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
		$avi=`substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
		if (`file -q -ex $avi`)
			sysFile -ren `substitute "[.][a-z][a-z][a-z]" $newImage ".avi"` `substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
		}
	//rename anim files
	$animFile=$iconDir+"untitled_"+$oldChildNum+".ma";
	$newAnimFile=$iconDir+"untitled_"+$newChildNum+".ma";
	if (`file -q -ex $animFile` && $newAnimFile!=$animFile)
		eval ("sysFile -ren \""+$newAnimFile+"\"  \""+$animFile+"\"");
	//update animation command
	$cmd=`iconTextButton -q -c $newChildName`;
	tokenize $cmd $tempString;
	if ($tempString[0]=="asLoadAttrs")
		{
		$cmd=$tempString[0]+" "+$tempString[1]+" "+$newChildNum;
		iconTextButton -e -c $cmd $newChildName;
		}
	}
string $uiName="asPoserDefault";
asPoserupdateGridBlock $uiName $newChildNum;
}
//-- ASPoserDesigner Procedures Ends Here --//
//-- ASWalkDesigner Procedures Start Here --//
global proc asWalkDesigner ()
{
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
//create, connectControl, and delete, to disable.
int $mixerExisted=1;
if (!`objExists WalkDesignerMotionMixer`)
	{
	createNode -n WalkDesignerMotionMixer transform;
	addAttr -k 1 -dv 1 -ln "speed" -at double WalkDesignerMotionMixer;
	$mixerExisted=0;
	}
if (`window -q -ex asWalkDesigner`)
	deleteUI asWalkDesigner;
window -mb 1 -t WalkDesigner asWalkDesigner;
formLayout asWDFormLayout;
columnLayout;
optionMenu -w 200 asWalkDesignerOptionMenu;
button -l "Start" -c asWDStart;
columnLayout asWDMixerColumnLayout;
for($i=0;$i<size($motions);$i++)
	{
	if(!$mixerExisted)
		addAttr -k 1 -ln $motions[$i] -at double WalkDesignerMotionMixer;
	rowLayout -nc 2 -cw2 240 100;
		floatSliderGrp -label $motions[$i] -field true -cw 1 80 -cw 2 50 -cw 3 100 -min 0 -max 1 ("asWDField"+$i);
		connectControl ("asWDField"+$i) ("WalkDesignerMotionMixer."+$motions[$i]);
		button -l "solo" -c ("asWDSolo "+$i);
		setParent..;
	}
floatSliderGrp -cc asWDSpeedChange -pre 2 -v 1 -label "speed" -field true -cw 1 40 -cw 2 40 -cw 3 180 -min 0.01 -max 2 asWDSpeedField;
connectControl asWDSpeedField WalkDesignerMotionMixer.speed;
if (`asIsMayaLT`)
	floatSliderGrp -e -en 0 asWDSpeedField;
setParent..;

frameLayout -w 279 -cll 1 -cl 1 -l "Baking";
columnLayout;
//text -l "baking:";
checkBox -cc asWDSpeedChange -l "loop animation (curves > post infinity > cycle)" -v 1 -onc "intField -e -en 0 asWDLoopsIntField" -ofc "intField -e -en 1 asWDLoopsIntField" asWDLoopCheckBox;
text -l "or";
rowLayout -nc 3;
	text -l "loop animation";
	intField -cc asWDSpeedChange -en 0 -w 30 -min 1 -v 1 asWDLoopsIntField;
	text -l "times";
	setParent..;
button -l "Ok, Bake keys onto character" -c asWDBake;
setParent..;
setParent..;
setParent..;
button -l "Cancel and Close" -c asWDFinish asWDClose;
formLayout -e 
	-attachForm asWDClose "bottom" 0
	-attachForm asWDClose "left" 0
	-attachForm asWDClose "right" 0
	asWDFormLayout;

asPopulateNameSpaceMenu "asWalkDesigner";
if(!$mixerExisted)
	delete WalkDesignerMotionMixer;
showWindow;
}

global proc asWDBake ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";

float $defaultEndTime=`getAttr WalkDesignerMotionMixer.defaultEndTime`;
float $speed=`getAttr WalkDesignerMotionMixer.speed`;
float $endTime=$defaultEndTime*(1.0/$speed);

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
select -cl;
string $allFkControls[];
for($i=0;$i<size($consts);$i++)
	{
	string $fkControl=$nameSpace+"FK"+$consts[$i];
	if ($consts[$i]=="Root_M")
		$fkControl=$nameSpace+"RootX_M";
	if (!`objExists $fkControl`)
		continue;
	$allFkControls[size($allFkControls)]=$fkControl;
	select -add $fkControl;
	}

if (!`checkBox -q -v asWDLoopCheckBox`)
	{
	setAttr "walkDesignerClip.postCycle" 9999;
	$endTime=$endTime*`intField -q -v asWDLoopsIntField`;
	}

bakeResults -simulation true -t ("0:"+$endTime)
	-sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false 
	-removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at "rx" -at "ry" -at "rz";
select ($nameSpace+"RootX_M");
bakeResults -simulation true -t ("0:"+$endTime)
	-sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false 
	-removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at "tx" -at "ty" -at "tz";
if (`checkBox -q -v asWDLoopCheckBox`)
	{
	select $allFkControls;
	setInfinity -poi cycle;
	}
asWDFinish;
}

global proc asWDSpeedChange ()
{
if (!`objExists WalkDesignerMotionMixer` || !`objExists walkDesignerClip`)
	return;
float $defaultEndTime=`getAttr WalkDesignerMotionMixer.defaultEndTime`;
float $speed=`getAttr WalkDesignerMotionMixer.speed`;
float $endTime=$defaultEndTime*(1.0/$speed);
if (!`checkBox -q -v asWDLoopCheckBox`)
	{
	setAttr "walkDesignerClip.postCycle" 9999;
	$endTime=$endTime*`intField -q -v asWDLoopsIntField`;
	}
playbackOptions -min 0 -ast 0 -aet $endTime -max $endTime;
setAttr walkDesignerClip.scale (1.0/$speed);
}

global proc asWDStart ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";
if (!`objExists ($nameSpace+"Main")`)
	error ("AdvancedSkeleton not found in your scene");
float $charHeight=`getAttr ($nameSpace+"Main.height")`;

string $motionFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asMotion.ma";
if (!`file -q -ex $motionFile`)
	error ("Not found:"+$motionFile);
if (`objExists WalkDesignerMotionMixer`)
	error ("\"WalkDesignerMotionMixer\", already exists, delete this object, before starting again");
if (!`file -q -ex $motionFile`)
	error ("Required motion file not found:\""+$motionFile+"\"");
string $tempString[]=`ls "asMotion:*"`;
if (size($tempString))
	delete $tempString;
if (`namespace -ex "asMotion"`)
	if (catchQuiet (`namespace -dnc -rm "asMotion"`))
		{ 
		//Maya2012 and older dont have namespace -dnc, so we work around the problems of empty nameSpaces not agknowlowdge their empty
		for($i=0;$i<99;$i++)
			if (!`namespace -ex ("tempNameSpace"+$i)`)
				break;
		namespace -ren asMotion ("tempNameSpace"+$i);
		}
if (`namespace -ex "asMotion"`)
	error "Unable to remove namespace \"asMotion\", try restarting Maya";

file -ns "asMotion" -i $motionFile;
setAttr asMotion:Group.v 0;
setAttr -type float3 asMotion:Group.s ($charHeight/12.0) ($charHeight/12.0) ($charHeight/12.0);

createNode -n WalkDesignerMotionMixer transform;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.tx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.ty;setAttr -l 1 -k 0 WalkDesignerMotionMixer.tz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.rx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.ry;setAttr -l 1 -k 0 WalkDesignerMotionMixer.rz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.sx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.sy;setAttr -l 1 -k 0 WalkDesignerMotionMixer.sz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.v;
addAttr -k 1 -ln "speed" -dv 1 -at double WalkDesignerMotionMixer;
addAttr -k 0 -ln defaultEndTime -at double WalkDesignerMotionMixer;
parent "asMotion:Group" WalkDesignerMotionMixer;

select -hi "asMotion:Group";
select -d "asMotion:Group";
if (!`asIsMayaLT`)
	{
	character -name walkDesignerSet -excludeVisibility -excludeScale;
	clip -name walkDesignerClip -sc 1 -allAbsolute -animCurveRange walkDesignerSet;
	setAttr walkDesignerClip.postCycle 9999;
	}

if (`objExists ($nameSpace+"FKIKLeg_R")`) setAttr ($nameSpace+"FKIKLeg_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKLeg_L")`) setAttr ($nameSpace+"FKIKLeg_L.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_R")`) setAttr ($nameSpace+"FKIKArm_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_L")`) setAttr ($nameSpace+"FKIKArm_L.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKSpine_M")`) setAttr ($nameSpace+"FKIKSpine_M.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKShoulder_R")`) if (`attributeExists "Global"  ($nameSpace+"FKShoulder_R")`) setAttr ($nameSpace+"FKShoulder_R.Global") 0;
if (`objExists ($nameSpace+"FKShoulder_L")`) if (`attributeExists "Global"  ($nameSpace+"FKShoulder_L")`) setAttr ($nameSpace+"FKShoulder_L.Global") 0;
if (`objExists ($nameSpace+"FKWrist_R")`) if (`attributeExists "Global"  ($nameSpace+"FKWrist_R")`) setAttr ($nameSpace+"FKWrist_R.Global") 0;
if (`objExists ($nameSpace+"FKWrist_L")`) if (`attributeExists "Global"  ($nameSpace+"FKWrist_L")`) setAttr ($nameSpace+"FKWrist_L.Global") 0;
if (`objExists ($nameSpace+"FKHead_M")`) if (`attributeExists "Global"  ($nameSpace+"FKHead_M")`) setAttr ($nameSpace+"FKHead_M.Global") 0;

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
string $orientConstraint,$pointConstraint;

for($i=0;$i<size($motions);$i++)
	{
	addAttr -k 1 -ln $motions[$i] -at double WalkDesignerMotionMixer;
	for($y=0;$y<size($consts);$y++)
		{
		$fkControl=$nameSpace+"FK"+$consts[$y];
		if ($consts[$y]=="Root_M")
			{
			$fkControl=$nameSpace+"RootX_M";
			$tempString=`pointConstraint ("asMotion:"+$motions[$i]+":"+$consts[$y]) $fkControl`;
			$pointConstraint=$tempString[0];
			}
		if (!`objExists $fkControl`)
			continue;
		$tempString=`orientConstraint ("asMotion:"+$motions[$i]+":"+$consts[$y]) $fkControl`;
		$orientConstraint=$tempString[0];
		setAttr ($orientConstraint+".interpType") 2;

		if ($consts[$y]=="Root_M")
			{
			setAttr RootX_M_orientConstraint1.offsetX -90;
			setAttr RootX_M_orientConstraint1.offsetY -90;
			connectAttr ("WalkDesignerMotionMixer."+$motions[$i]) ($pointConstraint+"."+$consts[$y]+"W"+$i);
			}
		connectAttr ("WalkDesignerMotionMixer."+$motions[$i]) ($orientConstraint+"."+$consts[$y]+"W"+$i);
		}
	connectControl ("asWDField"+$i) ("WalkDesignerMotionMixer."+$motions[$i]);
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  $side="_R";
	if ($b==-1) $side="_L";
	setAttr ("FKHip"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKKnee"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKAnkle"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKToes"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKShoulder"+$side+"_orientConstraint1.offsetX") -90;
	setAttr ("FKElbow"+$side+"_orientConstraint1.offsetX") -90;
	setAttr ("FKWrist"+$side+"_orientConstraint1.offsetX") -90;
	}

connectControl asWDSpeedField WalkDesignerMotionMixer.speed;

if (`attributeExists walk_male WalkDesignerMotionMixer`)
	setAttr WalkDesignerMotionMixer.walk_male 1;
currentTime 0;
if (`objExists ($nameSpace+"FKAnkle_R")` && `objExists ($nameSpace+"Ankle")`)
	{
	float $anklePos[3]=`xform -q -ws -t ($nameSpace+"FKAnkle_R")`;
	float $fitAnklePos[3]=`xform -q -ws -t ($nameSpace+"Ankle")`;
	float $offset=$anklePos[1]-$fitAnklePos[1];
	setAttr asMotion:Group.ty ($offset*-1);
	}
float $tempFloats[]=`keyframe -index 1 -q  -tc asMotion:Group.timing`;
float $endTime=$tempFloats[0];
playbackOptions -min 0 -ast 0 -aet $endTime -max $endTime;
setAttr WalkDesignerMotionMixer.defaultEndTime $endTime;
select -cl;
}

global proc asWDSolo (int $num)
{
if (!`objExists WalkDesignerMotionMixer`)
	error ("WalkDesignerMotionMixer not found");
float $value;
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
for($i=0;$i<size($motions);$i++)
	{
	if ($i==$num)
		$value=1;
	else
		$value=0;
	floatSliderGrp -e -v $value ("asWDField"+$i);
	setAttr ("WalkDesignerMotionMixer."+$motions[$i]) $value;
	}
}

global proc asWDFinish ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";

if (`objExists walkDesignerSet`)
	delete walkDesignerSet;
if (`objExists WalkDesignerMotionMixer`)
	delete WalkDesignerMotionMixer;

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Chest_M","Chest_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
string $tempString[];
string $attrs[]={"tx","ty","tz","rx","ry","rz"};
for($y=0;$y<size($consts);$y++)
	{
	$fkControl=$nameSpace+"FK"+$consts[$y];
	if ($consts[$y]=="Root_M")
		$fkControl=$nameSpace+"RootX_M";
	if (!`objExists $fkControl`)
		continue;
	for($i=0;$i<size($attrs);$i++)
		{
		$tempString=`listConnections ($fkControl+"."+$attrs[$i])`;
		if (!size($tempString))
			setAttr ($fkControl+"."+$attrs[$i]) 0;
		}
	}
deleteUI asWalkDesigner;
}
//-- ASWalkDesigner Procedures Ends Here --//
//-- ASModelCleaner Procedures Starts Here --//
global proc asModelCleaner ()
{
if (`window -ex modelCleaner`)
	deleteUI modelCleaner;

window -s 1 -title "Model Cleaner" modelCleaner;
columnLayout;
	separator -st none -h 10;
	text -l "This will cleanup your model.\n";
	if (!`pluginInfo -q -l objExport`)
		{
		text -l "The objExport plugin must be loaded:";
		button -l "load objExport plugin" -c "loadPlugin objExport;print (\"// OK, objExport plugin loaded\\n\")";
		separator -h 10 -st none;
		}
	text -l "Create top level group, called \"geo\":";
	button -c modelCleanGreateGeo -label "Create";
	separator -st none -h 10;
	text -l "Now ready for Clean.";
	text -fn "smallBoldLabelFont" -l "(Save your scene first, for safe keeping)\n";
	button -w 230 -c modelCleanGo -ann "clean model" -label "Clean";
showWindow modelCleaner;
}

global proc modelCleanGreateGeo ()
{
if (!`objExists |geo`)
	createNode -n geo transform;
string $tempString[];
string $topLevXforms[]=`ls -as -l`;
for($i=0;$i<size($topLevXforms);$i++)
	{
	if ($topLevXforms[$i]=="|geo")
		continue;
	$tempString=`listRelatives -s $topLevXforms[$i]`;
	if (`size ($tempString)`==0 || `objectType $tempString[0]`=="mesh")
		parent $topLevXforms[$i] |geo;
	}
select |geo;
}

global proc modelCleanGo ()
{
global string $gMainProgressBar;
global string $gMainPane;
string $sceneName=`file -q -sn`;
string $references[];
string $allReferences[]=`file -q -r`;
for ($i=0;$i<size($allReferences);$i++)
	if (!`file -q -deferReference $allReferences[$i]`)
		$references[size($references)]=$allReferences[$i];

select -cl;

string $sceneFile=`file -q -sn`;
string $tmpFile=`internalVar -utd`+"AdvancedSkeleton/modelCleaner/tmp.ma";
if (`asIsMayaLT`)
	$tmpFile=`internalVar -utd`+"AdvancedSkeleton/modelCleaner/tmp.mlt";
int $eyeCandy=0;
int $moreThanOneWithSameName;
string $plugins[]=`pluginInfo -q -ls`;
string $parent[],$tempString[],$longNames[],$buffer[],$oldShapeName[],$partitionPlugs[],$creaseMembers[],$objFileName[];
float $temp[];
float $perspPos[]=`getAttr persp.translate`;
float $perspRot[]=`getAttr persp.rotate`;
int $isGroup[];
int $doubleSided[];
for ($plug in $plugins)
	if (!`stringArrayCount "objExport" $plugins`)
	error "You Must Load the \"objExport\" plugin !";

string $tempDir=`internalVar -utd`+"AdvancedSkeleton/modelCleaner/";
if (!`file -q -ex $tempDir`)
	sysFile -md $tempDir;

//Pre Flight Check
if (!`objExists geo`)
	error "group \"geo\" does not exists !\n";
string $all[]=`ls -noIntermediate`;
for ($obj in $all)
	{
	if (`gmatch $obj "*|*"`)
		{
		$tempString=`listRelatives -ap $obj`;
		if (size($tempString)==1)
			{
			select -add $obj;
			$moreThanOneWithSameName=1;
			}
		}
	}
if ($moreThanOneWithSameName)
	modelCleanMakeUniqueNames;
if (`objExists "polySurface1"`)
	{
	select "polySurface1";
	error "Illegal objectName \"polySurface1\"";
	}

//delete imagePlanes
string $imagePlanes[]=`ls -type imagePlane`;
if (size($imagePlanes))
	delete $imagePlanes;

//delete unused refNodes
deleteUnusedRefNodes;

//unParent all place3dTextures
string $place3ds[]=`ls -type place3dTexture`;
for ($i=0;$i<size($place3ds);$i++)
{
$tempString=`listRelatives -p $place3ds[$i]`;
if(size($tempString))
	parent -w $place3ds[$i];
}

//remove old files
string $fileList[]=`getFileList -fs "*.obj" -fld $tempDir`;
for($i=0;$i<size( $fileList);$i++)
{
	if (`file -q -ex ($tempDir+$fileList[$i])`)
		sysFile -del ($tempDir+$fileList[$i]);
}

//Remove nameSpaces
$all=`ls -type transform`;
for ($i=0;$i<size($all);$i++)
    if (`gmatch $all[$i] "*:*"`)
        {
        tokenize $all[$i] ":" $tempString;
        rename $all[$i] $tempString[size($tempString)-1];
        }

//rename Shapes to match name of their Xform
string $meshes[]=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
    if (`objExists $meshes[$i]`)
    	{
    	$tempString=`listRelatives -p $meshes[$i]`;
    	rename $meshes[$i] ($tempString[0]+"TEMPShape");
    	}
$meshes=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
    if (`objExists $meshes[$i]`)
    	{
	    $tempString=`listRelatives -p $meshes[$i]`;
    	rename $meshes[$i] ($tempString[0]+"Shape");
    	}

DeleteAllHistory;

//createShaderAssigner
string $assigned[], $shadingEngines[], $namespaces[];
string $allTrns[]=`ls -type transform`;
string $place3dTextures[]=`ls -type place3dTexture`;
if (`objExists shaderAssign`) 
	delete shaderAssign;
createNode -n shaderAssign transform;
addAttr -ln notes -dt "string" shaderAssign;
$shadingEngines=`ls -type shadingEngine`;
string $connections = ("global proc cleanConnectFileNodes(string $namespace1, string $namespace2) {\n");
for ($i=0;$i<size($shadingEngines);$i++) {
	if (`gmatch $shadingEngines[$i] "initial*"`)
		continue;
	$assigned=`sets -q $shadingEngines[$i]`;
	for ($z=0;$z<size($assigned);$z++)
		{
		//per face assigment
//		tokenize $assigned[$z] "." $tempString;
//		$assigned[$z]=$tempString[0];
		}
	$assigned=`stringArrayRemoveDuplicates $assigned`;
	for ($z=0;$z<size($assigned);$z++) 
		{
//		$tempString=`listRelatives -p $assigned[$z]`;
//		$connections+=("catch(`sets -e -fe ($namespace1 + \"" +$shadingEngines[$i]+"\") ($namespace2 + \""+$tempString[0]+"\")`);\n");
		$connections+=("catch(`sets -e -fe ($namespace1 + \"" +$shadingEngines[$i]+"\") ($namespace2 + \""+$assigned[$z]+"\")`);\n");
		}
}
for ($z=0;$z<size($place3dTextures);$z++) {
	$tempString=`listConnections -p 1 ($place3dTextures[$z]+".worldInverseMatrix")`;
	$connections+=("catch(`connectAttr ($namespace2 + \"" +$place3dTextures[$z]+".worldInverseMatrix\") ($namespace1 + \""+$tempString[0]+"\")`);\n");
}
$connections += ("}\n");
setAttr -type "string" shaderAssign.notes $connections;

//exportShaders
string $hyperShadePanelMelFile="C:/Program Files/Autodesk/Maya2012/scripts/others/hyperShadePanel.mel";
if (`file -q -ex$hyperShadePanelMelFile `)
eval ("source \""+$hyperShadePanelMelFile+"\"");
hyperShadePanelMenuCommand("", "deleteUnusedNodes");
string $shadingNodes[]=`lsThroughFilter -na DefaultAllShadingNodesFilter`;
string $objectType;
select -cl;
for ($i=0;$i<size($shadingNodes);$i++)
	{
	$objectType=`objectType $shadingNodes[$i]`;
	if ($objectType=="camera" || `gmatch $objectType "*Light"`)
		continue;
	select -add -ne $shadingNodes[$i];
	}
select -add shaderAssign;
lockNode -l 0 renderPartition;
if (`file -q -ex $tmpFile`)
	sysFile -del $tmpFile;
if (`asIsMayaLT`)
	file -op "v=0;" -typ "mayaLT" -es $tmpFile;
else
	file -op "v=0;p=17" -typ "mayaAscii" -es $tmpFile;

//delete intermediateObjects meshes
$tempString=`ls -intermediateObjects -type mesh`;
if (size($tempString))
	delete $tempString;

// SelectAllPolygonGeometry;
select geo;
select -hi;
string $selAll[]=`ls -l -sl -type transform`;

// read all attribute + their values, to restore after obj import
 string $userAttrs[],$addAttrCmds[];
string $cmd,$sn,$ln,$at,$kk,$dv,$minMax;
float $range[2];
string $shapes[];
string $selAllInclShapes[]=$selAll;
for ($i=0;$i<size($selAll);$i++)
	{
	$tempString=`listRelatives -s $selAll[$i]`;
	if (`objExists $tempString[0]`)
		$shapes[`size($shapes)`]=$tempString[0];
	}
appendStringArray $selAllInclShapes $shapes `size($shapes)`;
for ($i=0;$i<size($selAllInclShapes);$i++)
	{
 	$userAttrs=`listAttr -ud -s $selAllInclShapes[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		if (`getAttr -type ($selAllInclShapes[$i]+"."+$userAttrs[$y])`=="message")
			continue;
		$tempString=`listAttr -sn ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		if (`gmatch $at "*Array"` || `gmatch $at "*dataCompound"`)
			continue;
		$dv=`getAttr ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$kk=`getAttr -k ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$l=`getAttr -l ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		$minMax="";
		if (`attributeQuery -re -n $selAllInclShapes[$i] $ln`)
			{
			$range=`attributeQuery -r -n $selAllInclShapes[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		if ($at=="string")
			$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$selAllInclShapes[$i]+"`)"
					+"	addAttr -k "+$kk+" -sn "+$sn+" -ln "+$ln+" -dt \""+$at+"\" "+$minMax+" "+$selAllInclShapes[$i]+";"
					+"setAttr -l "+$l+" -type \"string\" "+$selAllInclShapes[$i]+"."+$sn+" \""+`encodeString $dv`+"\";";
		else
			$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$selAllInclShapes[$i]+"`)"
					+"	addAttr -k "+$kk+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$selAllInclShapes[$i]+";";
		}
	}

// read smooth level
$shapes=`ls -ni -type mesh`;
for ($y=0;$y<size($shapes);$y++)
	{
	if (!`attributeExists "displaySmoothMesh" $shapes[$y]`)
		continue;
	if (!`getAttr -l ($shapes[$y]+".displaySmoothMesh")`)
		continue;
	$smoothLevel=`getAttr ($shapes[$y]+".smoothLevel")`;
	$smoothLock=`getAttr -l ($shapes[$y]+".smoothLevel")`;
	$addAttrCmds[size($addAttrCmds)]="setAttr -l "+$smoothLock+" "+$shapes[$y]+".smoothLevel "+$smoothLevel+";";
	$dispResolution=`getAttr ($shapes[$y]+".dispResolution")`;
	$displaySmoothMesh=`getAttr ($shapes[$y]+".displaySmoothMesh")`;
	$displaySmoothMeshLock=`getAttr -l ($shapes[$y]+".displaySmoothMesh")`;
	$addAttrCmds[size($addAttrCmds)]="setAttr "+$shapes[$y]+".dispResolution "+$dispResolution+";";
	$addAttrCmds[size($addAttrCmds)]="setAttr -l "+$displaySmoothMeshLock+" "+$shapes[$y]+".displaySmoothMesh "+$displaySmoothMesh+";";
	}

// select non-instanced geometry
select geo;
select -hi;
string $sel[]=`ls -sl -type transform`;
string $selLong[]=`ls -l -sl -type transform`;
string $selShort[]=$sel;
string $children[];

evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "ObjExporting" -bp -ii 1 -min 0 -max (size($sel)) $gMainProgressBar;
for ($i=0;$i<size($sel);$i++)
{
	if (`progressBar -q -ic $gMainProgressBar`)
	{
		break;progressBar -e -ep $gMainProgressBar;
	}
	progressBar -e -s 1 $gMainProgressBar;

	if (`gmatch $obj "*:*"`)
		continue;

	if (`gmatch $selShort[$i] "*|*"`)
		{
		tokenize $selShort[$i] "|" $tempString;
		$selShort[$i]=$tempString[size($tempString)-1];
		}
	select $sel[$i];
	$tempString=`listRelatives -s $sel[$i]`;
	$oldShapeName[$i]=$tempString[0];
	makeIdentity -a 1 -t 1 -r 1 -s 1 $sel[$i];
//		polySetToFaceNormal -setUserNormal;
	DeleteAllHistory;
	if (size(`ls -type nurbsCurve`))
		delete `ls -type nurbsCurve`;
	$tempString=`listRelatives -f -s $sel[$i]`;
	if (size($tempString)==0)
		$isGroup[$i]=1;
	$doubleSided[$i]=1;
	if (`objExists $tempString[0]`)
		if (`attributeExists doubleSided $tempString[0]`)
			$doubleSided[$i]=`getAttr ($tempString[0]+".doubleSided")`;
	$tempString=`listRelatives -p $sel[$i]`;
	if ($tempString[0]!="")
		$parent[$i]=$tempString[0];

	if (`file -q -ex ($tempDir+$sel[$i]+".obj")`)
		sysFile -del ($tempDir+$sel[$i]+".obj");
	if (`file -q -ex ($tempDir+$sel[$i]+".obj")`)
		print ("// Unable to delete "+$tempDir+$sel[$i]+".obj!\n");
	clear $children;
	$children=`listRelatives -f -type transform -c $sel[$i]`;
	if (size($children))
		$children=`parent -w $children`;
	select $sel[$i];
	$objFileName[$i]=`substituteAllString $selLong[$i] "|" "!"`;
	if (`gmatch $objFileName[$i] "!*"`)
		$objFileName[$i]=`substring $objFileName[$i] 2 999`;
	print ("// Exporting: "+$tempDir+$objFileName[$i]+".obj\n");
//		if ($eyeCandy)
//			FrameSelected;
	file -op "groups=0;ptgroups=0;materials=0;smoothing=1;normals=0;" -typ "OBJexport" -pr -es ($tempDir+$objFileName[$i]+".obj");
	if (size($children))
		parent $children $sel[$i];
}
progressBar -e -ep $gMainProgressBar;

//NewScene;
// select -all;delete;
string $filename = `file -q -exn`;
$mayaFileType = `file -q -type`;
file -f -new;
file -type $mayaFileType;
file -rn $filename;
setAttr -type float3 persp.translate $perspPos[0] $perspPos[1] $perspPos[2];
setAttr -type float3 persp.rotate $perspRot[0] $perspRot[1] $perspRot[2];
if ($eyeCandy)
	{
	setNamedPanelLayout "Single Perspective View";
	string $modelPanel=`paneLayout -q -p1 $gMainPane`;
	modelEditor -e -da "smoothShaded" $modelPanel;
	}

//Create groups
for ($i=0;$i<size($sel);$i++)
{
	if ($isGroup[$i])
		createNode -n $sel[$i] transform;
}
for ($i=0;$i<size($sel);$i++)
{
	if ($isGroup[$i])
		{
		if (`objExists $parent[$i]`)
			parent $sel[$i] $parent[$i];
		continue;
		}
print ("// importing: "+$tempDir+$objFileName[$i]+".obj\n");
file -i -type "OBJ" -rpr "DUP" -options "mo=0;lo=1" ($tempDir+$objFileName[$i]+".obj");
$existing[0]="polySurfaceShape1";
$tempString=`listRelatives -p $existing[0]`;
rename $tempString[0] $selShort[$i];

if (`objExists $parent[$i]`)
	parent ("|"+$selShort[$i]) $parent[$i];
if (!$doubleSided[$i])
	setAttr ($sel[$i]+".doubleSided") $doubleSided[$i];
select $sel[$i];
if ($eyeCandy)
	FrameSelected;

// restore original shape name
if (`objExists $sel[$i]`)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	if (`objExists $tempString[0]`)
		{
		setAttr ($tempString[0]+".visibleInReflections") 1;
		setAttr ($tempString[0]+".visibleInRefractions") 1;
		if ($tempString[0]!=$oldShapeName[$i])
			{
			print ("// Renaming "+$tempString[0]+" to "+$oldShapeName[$i]+"\n");
			rename $tempString[0] $oldShapeName[$i];
			}
		}
	}
}

// restore added attributes
for ($cmd in $addAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

// restore bits in sets
if (`gmatch $sceneName "*/library/set/*"`)
	file -import -type "mayaAscii" -ra false -rpr "export" -options "v=0"  -pr -loadReferenceDepth "all" ($tempDir+"setReferences.ma");

//remove files
$fileList=`getFileList -fs "*.obj" -fld $tempDir`;
for($i=0;$i<size( $fileList);$i++)
{
	if (`file -q -ex ($tempDir+$fileList[$i])`)
		sysFile -del ($tempDir+$fileList[$i]);
}

//Import & Assign texturess
file -i $tmpFile;
eval `getAttr shaderAssign.notes`;
cleanConnectFileNodes "" "";
delete shaderAssign;

//set default UI
select -cl;
setNamedPanelLayout "Four View";
FrameAllInAllViews;

if (`window -ex modelCleaner`)
	deleteUI modelCleaner;

print ("// Cleaning finished.\n");
}


global proc deleteUnusedRefNodes ()
{
string $allReferences[]=`file -q -r`;

string $realRefNodes[];
for ($y=0;$y<size($allReferences);$y++)
    $realRefNodes[size($realRefNodes)]=`file -q -rfn $allReferences`;
string $refNodes[]=`ls -type reference`;
for ($y=0;$y<size($refNodes);$y++)
    if (!`stringArrayCount $refNodes[$y] $realRefNodes`)
        {
        lockNode -l 0 $refNodes[$y];
        delete $refNodes[$y];
        }
}

global proc modelCleanMakeUniqueNames ()
{
SelectAllGeometry;
string $alls[]=`ls -sl`;
string $alls2[],$tempString[];
string $suffix;
int $clash;
for ($i=0;$i<size($alls);$i++)
    {
    $break=0;
    SelectAllGeometry;
    select -d $alls[$i];
    $alls2=`ls -sl -sn`;
    $suffix="";
    $clash=0;
    tokenize $alls[$i] "|" $tempString;
    $newName=$tempString[size($tempString)-1]+$suffix;
    for ($z=0;$z<size($alls2);$z++)
        {
        tokenize $alls2[$z] "|" $tempString;
        if ($newName==$tempString[size($tempString)-1])
            {
            for ($aa=0;$aa<999;$aa++)
            if (!`objExists ($newName+$aa)`)
                {
                print("// rename "+$alls[$i]+" "+$alls[$i]+"1\n");                
                rename $alls[$i] ($newName+$aa);
                $break=1;
                break;         
                }
            if ($break)
                break;
            }
        if ($break)
            break;
        }
    }
}
//-- ASModelCleaner Procedures Ends Here --//
//-- ASFace Procedures Starts Here --//
global proc asCreateFaceFitSkeleton ()
{
if (`objExists FaceGroup`)
	if (`confirmDialog -t "Confirm"
	-m "FaceFitSkeleton already exists, this will reset the FaceFitSkeleton"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
if (`objExists FaceGroup`)
	delete FaceGroup;
createNode -n FaceGroup transform;
setAttr -l 1 FaceGroup.inheritsTransform 0;
if (`objExists "|Group"`)
	parent FaceGroup "|Group";
if (`objExists FaceFitSkeleton`)
	delete FaceFitSkeleton;
string $tempString[]=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FaceFitSkeleton;
parent FaceFitSkeleton FaceGroup;
setAttr FaceFitSkeletonShape.overrideEnabled 1;
setAttr FaceFitSkeletonShape.overrideColor 13;
scale -r -p 0 0 0 0.5 0.5 0.5 FaceFitSkeleton.cv[0:7];
duplicate -n FaceFitSkeletonHeight FaceFitSkeleton;
parent FaceFitSkeletonHeight FaceFitSkeleton;
parent -add -s FaceFitSkeletonHeightShape FaceFitSkeleton;
delete FaceFitSkeletonHeight;
move -r 0 1.5 0 FaceFitSkeletonHeightShape.cv[0:7];
setAttr -k 0 -l 1 FaceFitSkeleton.tx;setAttr -k 1 -l 0 FaceFitSkeleton.ty 8;setAttr -k 0 -l 1 FaceFitSkeleton.tz;
setAttr -k 0 -l 1 FaceFitSkeleton.rx;setAttr -k 0 -l 1 FaceFitSkeleton.ry 0;setAttr -k 0 -l 1 FaceFitSkeleton.rz;
setAttr -k 0 FaceFitSkeleton.sx;setAttr -k 0 FaceFitSkeleton.rz;
connectAttr FaceFitSkeleton.sy FaceFitSkeleton.sx;
connectAttr FaceFitSkeleton.sy FaceFitSkeleton.sz;
if (`objExists Head_M` && `objExists Neck_M`)
	{
	float $temp1[]=`xform -q -ws -t Head_M`;
	float $temp2[]=`xform -q -ws -t Neck_M`;
	setAttr FaceFitSkeleton.ty (($temp1[1]+$temp2[1])/2.0);
	}
if (`objExists Main`)
	if (`attributeExists height Main`)
		setAttr FaceFitSkeleton.sy (`getAttr Main.height`/5.0);

asFaceEnsureFitBase;
select FaceFitSkeleton;
}

global proc asFaceFitJawCurves ()
{
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $lowerEyeLidOuterNumCVs=`getAttr lowerEyeLidOuterCurve.spans`+1;
float $pos[],$posA[],$posB[],$posC[];
float $scale=`asFaceGetScale`;
string $curveCmd;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];

createNode -n FaceFitJawCurves -p FaceFitSkeleton transform;

//create Jaw weight-curves : JawCurve
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t JawCorner`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t Jaw`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurve;
setAttr JawCurveShape.overrideEnabled 1;
setAttr JawCurveShape.overrideColor 14;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 3 -d 3 -tol 0.01 JawCurve;
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t JawCurve.cv[1]`;
xform -ws -t $posA[0] $posB[1] $posA[2] JawCurve.cv[1];
$posA=`xform -q -ws -t Cheek`;
$posB=`xform -q -ws -t JawCurve.cv[3]`;
xform -ws -t $posA[0] $posB[1] $posA[2] JawCurve.cv[3];
$posA=`xform -q -ws -t Jaw`;
$posB=`xform -q -ws -t JawCurve.cv[4]`;
xform -ws -t $posB[0] $posB[1] $posA[2] JawCurve.cv[4];
asCurveOffsetMesh JawCurve $geometry ($scale/150.0);

//create Jaw weight-curves : JawCurve50
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t Cheek`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs]`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurveMid;
setAttr JawCurveMidShape.overrideEnabled 1;
setAttr JawCurveMidShape.overrideColor 13;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.01 JawCurveMid;

asCurveOffsetMesh JawCurveMid $geometry ($scale/150.0);

//create Jaw weight-curves : JawCurveTop
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t NoseCorner`;
$posC=`xform -q -ws -t Cheek`;
$posD=`xform -q -ws -t CheekRaiser`;
$curveCmd+=" -p "+(($posA[0]+$posC[0])/2.0)+" "+(($posA[1]+$posD[1])/2.0)+" "+(($posA[2]+$posC[2])/2.0)+" ";
$posA=`xform -q -ws -t CheekRaiser`;
$curveCmd+=" -p "+(($posA[0]+$posC[0])/2.0)+" "+$posD[1]+" "+(($posA[2]+$posC[2])/2.0)+" ";
$pos=`xform -q -ws -t NoseCorner`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t NoseUnder`;
$curveCmd+=" -p 0 "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurveTop;
setAttr JawCurveTopShape.overrideEnabled 1;
setAttr JawCurveTopShape.overrideColor 6;
asCurveOffsetMesh JawCurveTop $geometry ($scale/150.0);

//create Jaw weight-curves : JawCurveBottom
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t JawCurve.cv[1]`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+($pos[2]-($scale/20.0))+" ";
$posA=`xform -q -ws -t Jaw`;
$posB=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$posB[0]+" "+$posA[1]+" "+($pos[2]-($scale/20.0))+" ";
$pos=`xform -q -ws -t Throat`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurveBottom;
setAttr JawCurveBottomShape.overrideEnabled 1;
setAttr JawCurveBottomShape.overrideColor 6;
asCurveOffsetMesh JawCurveBottom $geometry ($scale/150.0);

parent JawCurve JawCurveMid JawCurveTop JawCurveBottom FaceFitJawCurves;

if (`checkBox -q -ex asFaceFitJawCurves`)
	checkBox -e -ed 1 -v 1 asFaceFitJawCurves;
select -cl;
}

global proc asFaceDesignMouthOpen ()
{
float $scale=`asFaceGetScale`;
//float $posA[]=`xform -q -ws -t lowerLipMain0`;
int $lowerLipMainNumCVs=`getAttr lowerLipMainCurve.spans`+1;
float $posA[]=`xform -q -ws -t lowerLipMainCurve.cv[0]`;
float $posB[]=`xform -q -ws -t lowerLipMainCurve.cv[$lowerLipMainNumCVs]`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];

createNode -n LipDeformations -p FaceBuildInProgress transform;
if (`objExists tempTargetFullMesh`)
	duplicate -n LipDeform tempTargetFullMesh;
else
	duplicate -n LipDeform tempTarget;
setAttr LipDeform.v 1;
parent LipDeform LipDeformations;
sets -e -forceElement initialShadingGroup LipDeform;
setAttr LipDeform.tx $posA[0];

select -r LipDeform;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
rename $tempString[0] mouthOpenSoftMod;
rename $tempString[1] mouthOpenSoftModHandle;
$tempString=`listConnections mouthOpenSoftMod.message`;
rename $tempString[0] mouthOpenSoftModSet;
setAttr -type float3 mouthOpenSoftModHandleShape.origin $posA[0] $posA[1] $posA[2];
setAttr mouthOpenSoftMod.falloffCenter $posA[0] $posA[1] $posA[2];
xform -piv $posA[0] $posA[1] $posA[2] mouthOpenSoftModHandle;
setAttr mouthOpenSoftMod.falloffMode 1;
setAttr mouthOpenSoftMod.falloffRadius ((0-$posB[0])*2);

//topVtx pos before move softMod
createNode -n closestSampler2 closestPointOnMesh;
connectAttr -f LipDeform.outMesh closestSampler2.inMesh;
$posA=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
setAttr -type float3 closestSampler2.inPosition $posA[0] $posA[1] $posA[2];
string $topVtx="LipDeform.vtx["+`getAttr closestSampler2.result.closestVertexIndex`+"]";
$posA=`xform -q -ws -t $topVtx`;
delete closestSampler2;

setAttr mouthOpenSoftModHandle.ty ($scale/-10.0);
setAttr "mouthOpenSoftMod.falloffCurve[1].falloffCurve_FloatValue" 1;

//increase radius, until topVtx is included
setAttr mouthOpenSoftMod.falloffRadius 0;
$posA=`xform -q -ws -t $topVtx`;
float $radius=(0-$posB[0])*2;
setAttr mouthOpenSoftMod.falloffRadius $radius;
for ($i=0;$i<99;$i++)
	{
	$posB=`xform -q -ws -t $topVtx`;
	if ($posB[1]-$posA[1]!=0)
		break;
	$radius+=($scale/1000.0)*$i;
	setAttr mouthOpenSoftMod.falloffRadius $radius;
	}
setAttr "mouthOpenSoftMod.falloffCurve[1].falloffCurve_FloatValue" 0.05;
setAttr "mouthOpenSoftMod.falloffCurve[0].falloffCurve_FloatValue" 0.95;

//Delete `all-except-lips` from LipDeform
select lipArea;
$tempString=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	select -add `substitute $geometry $tempString[$i] LipDeform`;
ConvertSelectionToContainedFaces;
//InvertSelection;
asInvertSelection;
delete;

setAttr mouthOpenSoftModHandle.ty 0;
parentConstraint -mo Jaw_M mouthOpenSoftModHandle;
scaleConstraint -mo Jaw_M mouthOpenSoftModHandle;

select lipArea;
$tempString=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	select -add `substitute $geometry $tempString[$i] JawOpenRegion`;
ConvertSelectionToContainedFaces;
delete;
//sets -e -forceElement "asBlankSG" `ls -sl`;
string $historyNodes[]=`listHistory JawOpenRegion`;
for ($y=0;$y<size($historyNodes);$y++)
	if (`nodeType $historyNodes[$y]`=="deleteComponent")
		rename $historyNodes[$y] JawOpenRegionDeleteComponent;


playbackOptions -min 0 -max 30 -ast 0 -aet 30;

setKeyframe -v 0 -t 0 ctrlMouth_M.ty;setKeyframe -v -1 -t 30 ctrlMouth_M.ty;

setKeyframe -v 0 -t 0 Jaw_M.ty;setKeyframe -v -0.5 -t 30 Jaw_M.ty;
setKeyframe -v 0 -t 0 Jaw_M.tz;setKeyframe -v 0.5 -t 30 Jaw_M.tz;
setKeyframe -v 0 -t 0 Jaw_M.rx;setKeyframe -v 15 -t 30 Jaw_M.rx;

setKeyframe -v 1 -t 0 Jaw_M.sx;setKeyframe -v 1 -t 0 Jaw_M.sx;
setKeyframe -v 1 -t 0 Jaw_M.sy;setKeyframe -v 1 -t 0 Jaw_M.sy;
setKeyframe -v 1 -t 0 Jaw_M.sz;setKeyframe -v 1 -t 0 Jaw_M.sz;

setAttr -l 1 Jaw_M.tx;
setAttr -l 1 Jaw_M.ry;
setAttr -l 1 Jaw_M.rz;
}

global proc asFaceAssist (string $section)
{
int $spans,$degree,$numCVs;
float $scale=`asFaceGetScale`;
string $tempString[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $part="Main";
if ($section=="Lip") $part="Outer";

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	$spans=`getAttr ($upperLower+$section+$part+"Curve.spans")`;
	$degree=`getAttr ($upperLower+$section+$part+"Curve.degree")`;
	$numCVs=$spans+$degree;
	$middleCvNr=($numCVs-1)/2;
	float $posA[]=`xform -q -ws -t ($upperLower+$section+$part+"Curve.cv["+$middleCvNr+"]")`;
//	float $posA[]=`xform -q -ws -t ($upperLower+$section+$part+"3")`;
	if ($section=="Lip")
		$posA=`xform -q -ws -t ($upperLower+$section+$part+"Curve.cv[0]")`;
	float $posB[]=`xform -q -ws -t ($upperLower+$section+$part+"Curve.cv["+($numCVs-1)+"]")`;
	select -r $geometry;
	$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
	rename $tempString[0] ($upperLower+"TempSoftMod");
	rename $tempString[1] ($upperLower+"TempSoftModHandle");
	setAttr -type float3 ($upperLower+"TempSoftModHandleShape.origin") $posA[0] $posA[1] $posA[2];
	setAttr ($upperLower+"TempSoftMod.falloffCenter") $posA[0] $posA[1] $posA[2];
	xform -piv $posA[0] $posA[1] $posA[2] ($upperLower+"TempSoftModHandle");
	setAttr ($upperLower+"TempSoftMod.falloffMode") 1;
	setAttr ($upperLower+"TempSoftMod.falloffRadius") ($posA[0]-$posB[0]);
	move -r 0 ($scale/30.0*$upperLowerFactor) ($scale/10.0) ($upperLower+"TempSoftModHandle");
	setAttr ($upperLower+"TempSoftMod.falloffCurve[3].falloffCurve_FloatValue") 1;
	setAttr ($upperLower+"TempSoftMod.falloffCurve[3].falloffCurve_Position") 0.5;
	setAttr ($upperLower+"TempSoftMod.falloffCurve[3].falloffCurve_Interp") 2;
	}
}

global proc asCreateFaceFit (string $section,string $part,int $upAndLo,int $mainAndOuter,int $isSphere)
{
int $nr,$sideVtxNr,$topVtxNr,$noseVtxNr,$lidInnerVtxNr,$lidOuterVtxNr,$numSel,$previousNumSel;
//int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $selCompNrs[];
float $scale=`asFaceGetScale`;
float $dist,$dist2,$maxDist,$minPosX,$maxPosY,$teethColliderScaleFactor,$falloffRadius;
float $pos[],$posA[],$posB[],$selPosX[],$selPosY[],$bb[];
string $upperLower,$growStartPos,$areaMeshShader,$closestSampler,$nearestVtx;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tempString[],$tempString2[],$borderVtxs[];
//currentTime 0;

if (`objExists ("FaceFit"+$section+$part)`)
	error ("FaceFit"+$section+$part+" Already Exists");

string $geometry=`textField -q -tx asFaceGeometryTextField`;

if ($section=="Tongue" || $section=="TeethCollider")
	select -cl;

string $sel[]=`ls -sl -fl`;
int $numSelEdges[];
if (!`gmatch $sel[0] "*[.]*"` && $section!="Tongue" && $section!="TeethCollider")
	{
	error "No edge or vertex selected";
	$numSelEdges=`polyEvaluate -edgeComponent`;
	}

if (`objExists upperTempSoftModHandle`) delete upperTempSoftModHandle;
if (`objExists lowerTempSoftModHandle`) delete lowerTempSoftModHandle;

int $edgeSelection,$vertexSelection,$startVxtSelected,$endVxtSelected;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*[.]e*"`)
		$edgeSelection=1;
	if (`gmatch $sel[$i] "*[.]vtx*"`)
		{
		$vertexSelection=1;
		if ($startVxtSelected)
			$endVxtSelected=1;
		$startVxtSelected=1;
		}
	}

if ($section=="Jaw" && `objExists FKJaw_M`)
	if (!`asFaceRemoveBodyJaw`)
		return;

if (!`objExists FaceFitSkeleton`)
	asCreateFaceFitSkeleton;

asFitModeEnsureShaders;

spaceLocator -n templateLoc;
setAttr -type float3 templateLocShape.localScale (0.035*$scale) (0.035*$scale) (0.035*$scale);
setAttr templateLocShape.overrideEnabled 1;
setAttr templateLocShape.overrideColor 17;

createNode -n ("FaceFit"+$section+$part) -p FaceFitSkeleton transform;
addAttr -k 1 -min 0 -dv 1 -ln radius -at double ("FaceFit"+$section+$part);
if ($section=="EyeBrow")
	setAttr ("FaceFit"+$section+$part+".radius") 2.5;
createNode -n ("FaceFit"+$section+$part+"Geo") -p ("FaceFit"+$section+$part) transform;
if (!$isSphere)
	setAttr ("FaceFit"+$section+$part+"Geo.inheritsTransform") 0;
createNode -n ("FaceFit"+$section+$part+"Curve") -p ("FaceFit"+$section+$part) transform;
setAttr ("FaceFit"+$section+$part+"Curve.inheritsTransform") 0;
//setAttr ("FaceFit"+$section+$part+"Curve.v") 0;
createNode -n ("FaceFit"+$section+$part+"Loc") -p ("FaceFit"+$section+$part) transform;

if ($isSphere)
	{
	duplicate -n $section templateLoc;
	parent ($section) ("FaceFit"+$section+$part);

	sphere -n ($section+"Sphere") -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r (0.02*$scale) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0;
	parent ($section+"Sphere") ("FaceFit"+$section+$part);
	connectAttr ($section+".t") ($section+"Sphere.t");
	connectAttr ($section+".r") ($section+"Sphere.r");
	connectAttr ($section+".s") ($section+"Sphere.s");
	setAttr ($section+"SphereShape.overrideEnabled") 1;
	setAttr ($section+"SphereShape.overrideDisplayType") 2;

	addAttr -k 1 -min 0 -dv 1 -ln "falloffRadius" -at double $section;
	addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 $section;
	}

if (`checkBox -q -ex ("asFaceFit"+$section+$part)`)
	checkBox -e -ed 1 -v 1 ("asFaceFit"+$section+$part);

if ($section=="Tongue")
	{
	$pos=`xform -q -ws -t FaceFitSkeleton`;
	$tempString[0]=`curve -d 1 
		-p 0 ($pos[1]+$scale/10.0) 0
		-p 0 ($pos[1]+$scale/5.0) ($scale/5.0)
		-p 0 ($pos[1]+$scale/5.0) ($scale/3.0)
		-p 0 ($pos[1]+$scale/5.5) ($scale/2.5)
		-p 0 ($pos[1]+$scale/7.0) ($scale/2.2)`;
	rename $tempString[0] TongueCurve;
	parent TongueCurve FaceFitTongueCurve;
	setAttr TongueCurve.inheritsTransform 0;
//	setAttr TongueCurveShape.dispCV 1;
	setAttr TongueCurveShape.overrideEnabled 1;
	setAttr TongueCurveShape.overrideColor 13;//Yellow
	for ($i=0;$i<5;$i++)
		{
		duplicate -n ("Tongue"+$i) templateLoc;
		parent ("Tongue"+$i) FaceFitTongueLoc;
		$pos=`xform -q -ws -t ("TongueCurve.cv["+$i+"]")`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ("Tongue"+$i);
		connectAttr -f ("Tongue"+$i+"Shape.worldPosition[0]") ("TongueCurveShape.controlPoints["+$i+"]");
		}
	select -cl;
	for ($i=0;$i<5;$i++)
		select -add ("Tongue"+$i);
	}

if ($section=="TeethCollider")
	{
	cylinder -n TeethCollider -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 180 -r 1 -hr 2 -d 3 -ut 0 -tol 0.01 -s 4 -nsp 2 -ch 1;
	parent TeethCollider FaceFitTeethColliderGeo;
	sets -e -forceElement "asGreen2SG" TeethCollider;
	setAttr -type float3 TeethCollider.s ($scale/5.0) ($scale/5.0) ($scale/5.0);
	makeIdentity -a 1 -t 1 -r 1 -s 1 TeethCollider;
	setAttr TeethColliderShape.curvePrecisionShaded 4;
	$pos=`xform -q -ws -t JawPivot`;
	$posA=`xform -q -ws -t upperLipMainCurve.cv[0] `;
	xform -ws -t 0 $posA[1] $pos[2] TeethCollider;
	if (`objExists $upperTeeth`)
		{
		$bb=`xform -q -ws -bb $upperTeeth`;
		xform -ws -t 0 $posA[1] $bb[2] TeethCollider;
		$pos=`xform -q -ws -t TeethCollider`;
		$posA=`xform -q -ws -t TeethCollider.cv[4][3]`;
		$teethColliderScaleFactor=($bb[5]-$pos[2]) / ($posA[2]-$pos[2]);
		setAttr -type float3 TeethCollider.s $teethColliderScaleFactor ($teethColliderScaleFactor*1.13) ($teethColliderScaleFactor*1.13);
		setAttr TeethCollider.sx 1;
		$posA=`xform -q -ws -t TeethCollider.cv[4][6]`;
		$teethColliderScaleFactor=($bb[0]-$pos[0]) / ($posA[0]-$pos[0]);
		setAttr TeethCollider.sx $teethColliderScaleFactor;
		}
	}

delete templateLoc;

//EdgeSelection based placement
if (!$edgeSelection && !$vertexSelection)
	return;

addAttr -ln selection -dt "string" ("FaceFit"+$section+$part);
$tempString[0]="";
for ($i=0;$i<size($sel);$i++)
	$tempString[0]=$tempString[0]+$sel[$i]+" ";
setAttr -type "string" ("FaceFit"+$section+$part+".selection") $tempString[0];

int $around;
float $minPos[3]={999,999,999};
float $maxPos[3]={-999,-999,-999};
string $minXVtx,$maxXVtx,$minYVtx,$maxYVtx,$minZVtx,$maxZVtx;

if ($isSphere)
	{
	for ($i=0;$i<size($sel);$i++)
		{
		if (!$vertexSelection && `gmatch $sel[$i] "*[.]e*"`)
			{
			select $sel[$i];ConvertSelectionToVertices;$tempString=`ls -sl`;
			$pos=`xform -q -ws -t $tempString[0]`;
			}
		if ($vertexSelection && `gmatch $sel[$i] "*[.]vtx*"`)
			$pos=`xform -q -ws -t $sel[$i]`;
		}
	if ($section=="Nose" || $section=="Jaw" || $section=="NoseUnder" || $section=="Throat")
		$pos[0]=0;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($section+$part);
	sets -e -forceElement "asBlue2SG" ($section+"Sphere");
	select -cl;
	return;
	}

//if ($section=="Lip" && $part=="Main")//special case, LipMain, Open mouth, to correctly distinguish upper from lower
//	asFaceAssist Lip;

select $sel;
ConvertSelectionToVertices;
$tempString=`ls -sl -fl`;

if ($section=="Lip" && $part=="Outer")//special case, Outer Lip: deselect `lowest half` of vtx, to ensure $maxXVtx not found on lowerLip
	asFaceDeselectLowestHalfOfVtx;

for ($y=0;$y<size($tempString);$y++)
	{
	$pos=`xform -q -ws -t $tempString[$y]`;
	if ($pos[0]<$minPos[0]) {$minPos[0]=$pos[0];$minXVtx=$tempString[$y];}
	if ($pos[1]<$minPos[1]) {$minPos[1]=$pos[1];$minYVtx=$tempString[$y];}
	if ($pos[2]<$minPos[2]) {$minPos[2]=$pos[2];$minZVtx=$tempString[$y];}
	if ($pos[0]>$maxPos[0] && $pos[0]<0.001) {$maxPos[0]=$pos[0];$maxXVtx=$tempString[$y];}
	if ($pos[1]>$maxPos[1] && $pos[0]<0.001) {$maxPos[1]=$pos[1];$maxYVtx=$tempString[$y];}
	if ($pos[2]>$maxPos[2] && $pos[0]<0.001) {$maxPos[2]=$pos[2];$maxZVtx=$tempString[$y];}
	}


//special case, LipMain, cleanup assist
if (`objExists upperTempSoftModHandle`) delete upperTempSoftModHandle;
if (`objExists lowerTempSoftModHandle`) delete lowerTempSoftModHandle;

string $startVxt=$maxXVtx;
string $endVxt=$minXVtx;
if ($section=="SmileCrease" || $section=="SmileFold")
	{
	$startVxt=$maxYVtx;
	$endVxt=""; // mean we will find $endVxt while traversing the edge-selection
	//deselect any left side
	select $sel;
	polySelectConstraint -m 3 -t 0x8000 -d 3 -db 0 99 -da 1 0 0 -dp 98.99 0 0;
	$tempString=`ls -sl`;
	polySelectConstraint -m 0;
	select $sel;
	select -d $tempString;
	$sel=`ls -sl -fl`;
	}
if ($section=="SmileFold")
	{
	$falloffRadius=1;
	if (`objExists upperLipOuterCurve`)
		{
		$pos=`xform -q -ws -t upperLipOuterCurve.cv[99]`;
		$falloffRadius=$pos[0]/-2.0;
		}
	addAttr -k 1 -ln dropoffDistance -at double -dv $falloffRadius FaceFitSmileFold;
	}
//fake a `spesified vtx`, for `Main` & `Inner` & `EyeLidDroopy` to match `Outer`.
$alignWithCurve="upper"+$section+"OuterCurve";
if ($section=="EyeLidDroopy")
	$alignWithCurve="upperEyeLidOuterCurve";
if (($part=="Main" || $part=="Inner" || $section=="EyeLidDroopy") && `objExists $alignWithCurve` && !$startVxtSelected)
	{
	$closestSampler=`createNode -n closestSampler closestPointOnMesh`;
	connectAttr ($geometry+".outMesh") ($closestSampler+".inMesh");
	$posA=`xform -q -ws -t ($alignWithCurve+".cv[0]")`;
	setAttr -type float3 ($closestSampler+".inPosition") $posA[0] $posA[1] $posA[2];
	string $outerStartVtx=$geometry+".vtx["+`getAttr ($closestSampler+".result.closestVertexIndex")`+"]";
	delete $closestSampler;
	float $closestDist=999;//$closestDist is numEdges to reach
	select $sel;
	ConvertSelectionToVertices;
	string $loopVtxs[]=`ls -sl -fl`;
	for ($i=0;$i<size($loopVtxs);$i++)
		{
		select $loopVtxs[$i];
		for ($y=0;$y<10;$y++)
			{
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			select -d $loopVtxs[$i];
			$tempString=`ls -sl -fl`;
			for ($z=0;$z<size($tempString);$z++)
				{
				if ($tempString[$z]==$outerStartVtx)
					{
					if ($y<$closestDist)
						{
						$startVxt=$loopVtxs[$i];
						$closestDist=$y;
						}
					break;
					}
				}
			}
		}
	select $sel;
	select -add $startVxt;
	$startVxtSelected=1;
	$sel=`ls -sl -fl`;//Update $sel, as if the vtx was selected to start with
	}
//$startVxt(& end) spesified as a vtx selected
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*[.]vtx*"`)
		{
		if ($startVxt!="" && $endVxtSelected)
			$endVxt=$startVxt;
		if ($startVxtSelected)
			$startVxt=$sel[$i];
		}
//Ensure start&end are not swapped
if ($startVxt!="" && $endVxt!="")
	{
	$posA=`xform -q -ws -t $startVxt`;
	$posB=`xform -q -ws -t $endVxt`;
	if ($posA[0]<$posB[0])
		{
		$tempString[0]=$startVxt;
		$startVxt=$endVxt;
		$endVxt=$tempString[0];
		}
	}
string $vtxs[],$previousVtxs[];
$around=0;
if ($startVxt!="")
	{
	//find new $endVxt, by traversing the edge-selection
	select $startVxt;
	for ($y=0;$y<99;$y++)
		{
		ConvertSelectionToEdges;
		$tempString=`ls -sl -fl`;
		for ($z=0;$z<size($tempString);$z++)
			if (!`stringArrayCount $tempString[$z] $sel`)
				select -d $tempString[$z];
		if (size(`ls -sl -fl`)==$numSelEdges[0])
			$around=1;
		
		ConvertSelectionToVertices;
		$vtxs=`ls -sl -fl`;

		if ($around)
			{
			select $vtxs;
			select -d $previousVtxs;
			$tempString=`ls -sl -fl`;
			$endVxt=$tempString[0];
			break;
			}
		$previousVtxs=$vtxs;
		}
	}

select $startVxt;
ConvertSelectionToEdges;
$tempString=`ls -sl -fl`;
for ($y=0;$y<size($tempString);$y++)
	{
	if (!`stringArrayCount $tempString[$y] $sel`)
		select -d $tempString[$y];
	}
$tempString=`ls -sl -fl`;
string $edge1=$tempString[0];
string $edge2=$tempString[1];

//start leftwards
if ($edge2!="")
	{
	$posA=`xform -q -ws -t $edge1`;
	$posB=`xform -q -ws -t $edge2`;
	if (($posA[0]+$posA[3]) > ($posB[0]+$posB[3]))
		{
		$tempString[0]=$edge1;
		$edge1=$edge2;
		$edge2=$tempString[0];
		}
	}

string $prevVtxs[],$vtxs1[],$vtxs2[];

//get $edges1[]
$curveCmd="curve -n faceLoopCurve1 -d 1 ";
$pos=`xform -q -ws -t $startVxt`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
select $startVxt;
$prevVtxs[0]=$startVxt;
$vtxs1[size($vtxs1)]=$startVxt;
string $coveredEdges[];

$around=0;
for ($i=0;$i<199;$i++)
	{
	ConvertSelectionToEdges;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (!`stringArrayCount $tempString[$y] $sel` || $tempString[$y]==$edge2)
			select -d $tempString[$y];
		}
	$tempString=`ls -sl -fl`;
	$coveredEdges[size($coveredEdges)]=$tempString[0];
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	if ($endVxt=="")
		{
		if  (size($coveredEdges)==size($sel))
			$around=1;
		}
	else
		{
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $endVxt $tempString`)
				$around=1;
		}
	select -d $prevVtxs;
	$prevVtxs=$tempString;
	$tempString2=`ls -sl -fl`;
	if ($tempString2[0]=="")
		break;
	$vtxs1[size($vtxs1)]=$tempString2[0];
	$pos=`xform -q -ws -t $tempString2[0]`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	select $tempString;
	if ($around)
		{
		if ($endVxt=="")
			$endVxt=$tempString2[0];
		break;
		}
	}

ConvertSelectionToContainedEdges;
string $edges1[]=`ls -sl -fl`;
eval $curveCmd;

if ($section=="ForeHead" && !`objExists ForeHeadFromEdges`)
	{
	if (size($sel)!=3)
		error "Exactly 3 vertices must be selected";
	$closestSampler=`createNode -n closestSampler closestPointOnMesh`;
	connectAttr ($geometry+".outMesh") ($closestSampler+".inMesh");
	for ($i=0;$i<size($sel);$i++)
		{
		tokenize $sel[$i] "[" $tempString;
		tokenize $tempString[1] "]" $tempString;
		$selCompNrs[$i]=$tempString[0];
		$pos=`xform -q -ws -t $sel[$i]`;
		$selPosX[$i]=$pos[0];
		$selPosY[$i]=$pos[1];
		}
	//find $sideVtxNr
	for ($i=0;$i<size($sel);$i++)
		{
		if ($selPosX[$i]<$minPosX)
			{
			$sideVtxNr=$selCompNrs[$i];
			$minPosX=$selPosX[$i];
			}
		}
	//find $topVtxNr
	for ($i=0;$i<size($sel);$i++)
		{
		if ($selCompNrs[$i]==$sideVtxNr) continue;
		if ($selPosY[$i]>$maxPosY)
			{
			$topVtxNr=$selCompNrs[$i];
			$maxPosY=$selPosY[$i];
			}
		}
	//find $noseVtxNr
	for ($i=0;$i<size($sel);$i++)
		{
		if ($selCompNrs[$i]==$sideVtxNr) continue;
		if ($selCompNrs[$i]==$topVtxNr) continue;
		$noseVtxNr=$selCompNrs[$i];
		}
	//find $lidInnerVtxNr
	$pos=`xform -q -ws -t upperEyeLidOuterCurve.cv[0]`;
	setAttr -type float3 ($closestSampler+".inPosition") $pos[0] $pos[1] $pos[2];
	$lidInnerVtxNr=`getAttr ($closestSampler+".result.closestVertexIndex")`;
	//find $lidOuterVtxNr
	int $upperEyeLidOuterSpans=`getAttr upperEyeLidOuterCurve.spans`;
	$pos=`xform -q -ws -t ("upperEyeLidOuterCurve.cv["+$upperEyeLidOuterSpans+"]")`;
	setAttr -type float3 ($closestSampler+".inPosition") $pos[0] $pos[1] $pos[2];
	$lidOuterVtxNr=`getAttr ($closestSampler+".result.closestVertexIndex")`;

	select `ls -o $sel[0]`;
	select `polySelect -q -asSelectString -shortestEdgePath $lidInnerVtxNr $noseVtxNr`;
	if (!size(`ls -sl`))
		{
		delete FaceFitForeHead faceLoopCurve1;
		error ("Unable to determine ForeHead area, try selecting the complete edgeBorder manually\n"
			+"and then type:asForeHeadFromEdges;");
		}
	select -add `polySelect -q -asSelectString -shortestEdgePath $noseVtxNr $topVtxNr`;
	select -add `polySelect -q -asSelectString -shortestEdgePath $topVtxNr $sideVtxNr`;
	select -add `polySelect -q -asSelectString -shortestEdgePath $sideVtxNr $lidOuterVtxNr`;
	$sel=`ls -sl -fl`;

	delete faceLoopCurve1;
	DuplicateCurve;
	$tempString=`ls -sl`;
	attachCurve -n faceLoopCurve1 -ch 1 -rpo 0 -kmk 1 -m 1 -bb 0.5 -bki 0 -p 0.1;
	delete $tempString;
	delete $closestSampler;
	}


if ($upAndLo)
	{
	//get $edges2[]
	$curveCmd="curve -n faceLoopCurve2 -d 1 ";
	$around=0;
	select $startVxt;
	$pos=`xform -q -ws -t $startVxt`;
	if ($section!="Lip")
		{
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		$prevVtxs[0]=$startVxt;
		$vtxs2[size($vtxs2)]=$startVxt;
		}
	for ($i=0;$i<199;$i++)
		{
		ConvertSelectionToEdges;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			{
			if (!`stringArrayCount $tempString[$y] $sel` || $tempString[$y]==$edge1)
				select -d $tempString[$y];
			}
		ConvertSelectionToVertices;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $endVxt $tempString`)
				$around=1;
		select -d $prevVtxs;
		$prevVtxs=$tempString;
		$tempString2=`ls -sl -fl`;
		if (!`size($tempString2)`)
			error "Not a complete edgeloop";
		$pos=`xform -q -ws -t $tempString2[0]`;
		if ($pos[0]<0.001)
			$vtxs2[size($vtxs2)]=$tempString2[0];
		if ($section=="Lip" && $pos[0]>0.001) //only rightSide for Lip-curve
			;
		else
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		select $tempString;
		if ($around)
			break;
		}

	ConvertSelectionToContainedEdges;
	eval $curveCmd;

	$tempString=`listRelatives -s faceLoopCurve1`;
	rename $tempString[0] faceLoopCurve1Shape;
	$tempString=`listRelatives -s faceLoopCurve2`;
	rename $tempString[0] faceLoopCurve2Shape;

	int $OneIsUpper;
	select $edges1;
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		if (`stringArrayCount $maxYVtx $tempString`)
			$OneIsUpper=1;

	//Special case detection of $OneIsUpper, on LipOuter
	if ($section=="Lip" && $part=="Outer")
		{
		$posA=`xform -q -ws -t $vtxs1[0]`;
		$posB=`xform -q -ws -t $vtxs2[0]`;
		if ($posA[1]>$posB[1])
			$OneIsUpper=1;
		else
			$OneIsUpper=0;
		}

	//Special case detection of $OneIsUpper, on LipMain, as LowerVtx can be higher than UpperVtx
	if ($section=="Lip" && $part=="Main" && `objExists upperLipOuterCurve`)
		{
		$tempString[0]=`asGetFaceFitSelection upperLipOuterCurve`;
		$tempString=`stringToStringArray $tempString[0] " "`;
		string $upperOuterLipVtxZero=$tempString[0];
		select $upperOuterLipVtxZero;
		for ($y=0;$y<10;$y++)
			{
			GrowPolygonSelectionRegion;
			$tempString=`ls -sl -fl`;
			if (`stringArrayCount $vtxs1[0] $tempString`)
				{
				$OneIsUpper=1;
				break;
				}
			if (`stringArrayCount $vtxs2[0] $tempString`)
				{
				$OneIsUpper=0;
				break;
				}
			}
		}

	//Same Special case detection for LipInner, but refering looking for LipMain
	if ($section=="Lip" && $part=="Inner" && `objExists upperLipMainCurve`)
		{
		$tempString[0]=`asGetFaceFitSelection upperLipMainCurve`;
		$tempString=`stringToStringArray $tempString[0] " "`;
		string $upperOuterLipVtxZero=$tempString[0];
		select $upperOuterLipVtxZero;
		for ($y=0;$y<10;$y++)
			{
			GrowPolygonSelectionRegion;
			$tempString=`ls -sl -fl`;
			if (`stringArrayCount $vtxs1[0] $tempString`)
				{
				$OneIsUpper=1;
				break;
				}
			if (`stringArrayCount $vtxs2[0] $tempString`)
				{
				$OneIsUpper=0;
				break;
				}
			}
		}

	string $upperVtxs[],$lowerVtxs[];
	if ($OneIsUpper)
		{
		$upperVtxs=$vtxs1;
		$lowerVtxs=$vtxs2;
		rename faceLoopCurve1 ("upper"+$section+$part+"Curve");
		rename faceLoopCurve2 ("lower"+$section+$part+"Curve");
		}
	else
		{
		$upperVtxs=$vtxs2;
		$lowerVtxs=$vtxs1;
		rename faceLoopCurve1 ("lower"+$section+$part+"Curve");
		rename faceLoopCurve2 ("upper"+$section+$part+"Curve");
		}
	}
if (!$upAndLo)
	{
	$tempString=`listRelatives -s faceLoopCurve1`;
	rename $tempString[0] faceLoopCurve1Shape;
	rename faceLoopCurve1 ($section+$part+"Curve");
	}


for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if (!$upAndLo) $upperLower="";
	if (!$upAndLo && $upperLowerFactor==-1) continue;

	parent ($upperLower+$section+$part+"Curve") ("FaceFit"+$section+$part+"Curve");
	makeIdentity -a 1 -t 1 -r 1 -s 1 ("FaceFit"+$section+$part);
//	setAttr ($upperLower+$section+$part+"CurveShape.dispCV") 1;
	setAttr ($upperLower+$section+$part+"CurveShape.overrideEnabled") 1;
	setAttr ($upperLower+$section+$part+"CurveShape.overrideColor") 17;//Yellow

	//Colors
	if ($part=="Main")
		setAttr ($upperLower+$section+$part+"CurveShape.overrideColor") 13;//Red
	if ($part=="Outer")
		setAttr ($upperLower+$section+$part+"CurveShape.overrideColor") 14;//Green
	if ($part=="Inner")
		setAttr ($upperLower+$section+$part+"CurveShape.overrideColor") 15;//Blue

	}


if ($mainAndOuter==0) $part="";
else $parts={"Main","Outer"};
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if ($upAndLo==0) $upperLower="";
	if ($upAndLo==0 && $upperLowerFactor==-1)
		continue;
	if ($isSphere)
		continue;

	if ($upperLower=="upper" || !$upAndLo)
		{
		$tempString=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r ($scale/400.0) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
		rename $tempString[0] ($section+"Profile"+$part);
		parent ($section+"Profile"+$part) ("FaceFit"+$section+$part+"Curve");
		connectAttr -f ("FaceFit"+$section+$part+".radius") ($section+"Profile"+$part+".sx");
		connectAttr -f ("FaceFit"+$section+$part+".radius") ($section+"Profile"+$part+".sy");
		connectAttr -f ("FaceFit"+$section+$part+".radius") ($section+"Profile"+$part+".sz");
		}
	extrude -n ($upperLower+$section+"Cylinder"+$part) -ch true -rn false -po 0 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 0 ($section+"Profile"+$part) ($upperLower+$section+$part+"Curve");
	setAttr ($upperLower+$section+"Cylinder"+$part+".overrideEnabled") 1;
	setAttr ($upperLower+$section+"Cylinder"+$part+".overrideDisplayType") 2;

	setAttr ($upperLower+$section+"Cylinder"+$part+"Shape.curvePrecisionShaded") 4;
	parent ($upperLower+$section+"Cylinder"+$part) ("FaceFit"+$section+$part+"Geo");

	//ensure outwards normals
	$posA=`xform -q -ws -t ($upperLower+$section+"Cylinder"+$part+".cv[6][0]")`;
	$posB=`xform -q -ws -t ($upperLower+$section+"Cylinder"+$part+".cv[6][1]")`;
	if ($posA[1]>$posB[1])
		reverseSurface -d 0 -ch 1 -rpo 1 ($upperLower+$section+"Cylinder"+$part);

	//Colors
	if ($part=="Main")
		{
		sets -e -forceElement "asRedSG" ($upperLower+$section+"Cylinder"+$part);
		if ($upperLower=="lower")
			sets -e -forceElement "asRed2SG" ($upperLower+$section+"Cylinder"+$part);
		}

	if ($part=="Outer")
		{
		sets -e -forceElement "asGreenSG" ($upperLower+$section+"Cylinder"+$part);
		if ($upperLower=="lower")
			sets -e -forceElement "asGreen2SG" ($upperLower+$section+"Cylinder"+$part);
		}

	if ($part=="Inner" || $section=="EyeLidDroopy" || $section=="SmileCrease")
		{
		sets -e -forceElement "asBlueSG" ($upperLower+$section+"Cylinder"+$part);
		if ($upperLower=="lower")
			sets -e -forceElement "asBlue2SG" ($upperLower+$section+"Cylinder"+$part);
		}

	if ($section=="Tongue" || $section=="SmileFold")
		sets -e -forceElement "asRedSG" ($section+"Cylinder"+$part);
	}

if ($section=="ForeHead" || ($section=="EyeLid" && $part=="Inner") || ($section=="Lip" && $part=="Inner"))
	{
	select $sel;
	$tempString=`ls -sl -fl`;
	if ($section=="ForeHead")
		{
		$areaMeshShader="asGreenSG";
		sets -e -forceElement "asGreenSG" ($section+"Cylinder"+$part);
		asFaceReSelect EyeLid "Outer";
		$growStartPos="EyeBrowInner";
		}
	if (($section=="EyeLid" && $part=="Inner") || ($section=="Lip" && $part=="Inner"))
		{
		$areaMeshShader="asRedSG";
		loft -n tempLoft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true ("upper"+$section+"OuterCurve") ("upper"+$section+"MainCurve") ("upper"+$section+"InnerCurve");
//		$growStartPos="tempLoft.cv["+(`getAttr tempLoftShape.su`/2)+"][2]";
		$growStartPos="upper"+$section+"MainCurve.cv["+(`getAttr ("upper"+$section+"MainCurve.spans")`/2)+"]";
		asFaceReSelect $section "Outer";
		}
	select -add $tempString;
	ConvertSelectionToVertices;
	$borderVtxs=`ls -sl -fl`;
	if (`objExists closestSampler`) delete closestSampler;
	createNode -n closestSampler closestPointOnMesh;
	connectAttr ($geometry+".outMesh") closestSampler.inMesh;
	$pos=`xform -q -ws -t $growStartPos`;

	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	if (`objExists tempLoft`) delete tempLoft;
	select ($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
	for ($i=0;$i<199;$i++)
		{
		GrowPolygonSelectionRegion;
		select -d $borderVtxs;
		$previousNumSel=$numSel;
		$tempString=`ls -sl -fl`;
		$numSel=size($tempString);
		if ($numSel==$previousNumSel)
			break;
		}
	delete closestSampler;
	ConvertSelectionToFaces;
	$tempString=`ls -sl -fl`;
	polyCube -n ($section+$part+"AreaMesh") -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
	sets -e -forceElement $areaMeshShader ($section+$part+"AreaMesh");
	connectAttr ($geometry+".outMesh") ($section+$part+"AreaMesh.inMesh");
	refresh;
	disconnectAttr ($geometry+".outMesh") ($section+$part+"AreaMesh.inMesh");
	parent ($section+$part+"AreaMesh") ("FaceFit"+$section+$part+"Geo");
	select `asobjSetCast "" $tempString ($section+$part+"AreaMesh")`;
	asInvertSelection;
	delete;
	refresh;
	}

select ("FaceFit"+$section+$part);
print ("// FaceFit"+$section+$part+" created.\n");
}

global proc asFaceDeselectLowestHalfOfVtx ()
{
$tempString=`ls -sl -fl`;
float $tys[];
float $tysAverage;
for ($y=0;$y<size($tempString);$y++)
	{
	$pos=`xform -q -ws -t $tempString[$y]`;
	$tys[$y]=$pos[1];
	$tysAverage+=$tys[$y];
	}
$tysAverage=$tysAverage/size($tempString);
select -cl;
for ($y=0;$y<size($tempString);$y++)
	if ($tys[$y]>$tysAverage)
		select -add $tempString[$y];
}

global proc asForeHeadFromEdges ()
{
string $sel[]=`ls -sl`;
createNode -n ForeHeadFromEdges transform;
select $sel;
asCreateFaceFit ForeHead "" 0 0 0;
delete ForeHeadFromEdges;
}

global proc int asFaceRemoveBodyJaw ()
{
int $return=0;
string $dialog="OK";
if (!`objExists headTopology`)
	$dialog=`confirmDialog -t "Confirm"
	-m "This will replace the Jaw from the Body-setup"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog=="OK")
	$return=1;

string $skinClusters[]=`ls -type skinCluster`;
for ($i=0;$i<size($skinClusters);$i++)
	if (`objExists Jaw_M`) asRemoveInfluence Jaw_M $skinClusters[$i];

if (`objExists FKOffsetJaw_M`) delete FKOffsetJaw_M;
if (`objExists Jaw_M`) delete Jaw_M;
if (`objExists Jaw`) delete Jaw;

asRemoveUnusedfromBuildPose bodySetup;
return $return;
}

global proc asDeleteAdvancedFace ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $keepBuildPoseInfo;
string $tempString[],$tempString2[],$faceSCs[];
if (!`objExists FaceMotionSystem`)
	return;

//Add headJoint as inf, if all bound joints will be deleted, to keep skinCluster.
int $haveKeepJoint;
$tempString=`ls -type skinCluster`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im FaceAllSet $tempString[$i]`)
		$faceSCs[size($faceSCs)]=$tempString[$i];
for ($i=0;$i<size($faceSCs);$i++)
	{
	$tempString=`listConnections ($faceSCs[$i]+".matrix")`;
	$haveKeepJoint=0;
	for ($y=0;$y<size($tempString);$y++)
		if (!`sets -im FaceAllSet $tempString[$y]`)
			$haveKeepJoint=1;
	if (!$haveKeepJoint)
		{
		skinCluster -e -ai $headJoint -lw false -wt 1 $faceSCs[$i];
		}
	}

//lockWeights all but headJoint
$tempString=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!=$headJoint)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 1;
//remove previous inf`s
//select `listRelatives -ad -type joint $headJoint`;
//$tempString=`ls -sl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im FaceAllSet $tempString[$i]`)
		{
		select $geometry $tempString[$i];
		RemoveInfluence;
		skinPercent -normalize 1 $skinCluster $geometry;
		}
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists lockInfluenceWeights $tempString[$i]`)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 0;
delete `sets -q -nodesOnly FaceAllSet`;
if (`objExists FaceAllSet`)
	delete `sets -q -nodesOnly FaceAllSet`;

//Normalize SkinClusters
$tempString=`ls -type skinCluster`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -s 0 -d 1 ($tempString[$i]+".outputGeometry[0]")`;
	if (`objExists $tempString2[0]`)
		catchQuiet (`skinPercent -normalize 1 $tempString[$i] $tempString2[0]`);
	}

if (!`checkBox -q -v asFaceKeepBuildPose`)
	if (`attributeExists run FaceFitSkeleton`)
		setAttr -type "string" FaceFitSkeleton.run "";
if (`checkBox -q -v asFaceKeepBuildPose`)
	$keepBuildPoseInfo=", and build pose stored in the \"FaceFitSkeleton.run\" attribute";

if (`objExists asFaceDeltaMush`)
	delete asFaceDeltaMush;

asFaceUpdateFitFace;

if (`attributeExists buildStep FaceFitSkeleton`)
	setAttr FaceFitSkeleton.buildStep 0;
asUpdateButtonEnables;
asFaceUpdateInfo 1;
print ("// Existing AdvancedFace removed"+$keepBuildPoseInfo+".\n");
}

global proc asFaceUpdateFitFace ()
{
//v5.351 to v5.352
if (`attributeExists version FaceGroup`)
	if (`getAttr FaceGroup.version`<5.352 && `asGetScriptVersion`>=5.352)
		{
		if (`objExists FaceFitEyeBrowOuter` && `objExists EyeBrowOuterCurve`) delete FaceFitEyeBrowOuter;
		if (`objExists FaceFitEyeBrowMain`) delete FaceFitEyeBrowMain;
		if (`objExists FaceFitEyeLidInner`)
			{
			asFaceReSelect EyeLid "Inner";
			delete FaceFitEyeLidInner;
			asCreateFaceFit EyeLid "Inner" 1 1 0;
			}
		if (`objExists FaceFitLipInner`)
			{
			asFaceReSelect Lip "Inner";
			delete FaceFitLipInner;
			asCreateFaceFit Lip "Inner" 1 1 0;
			}
		if (`objExists FaceFitAnimateFit`) delete FaceFitAnimateFit;
		}

//v5.354 to v5.355
if (`asGetScriptVersion`>=5.355)
	{
	string $oldNames[]={"cheek","line","cheekRaiser","noseCorner"};
	string $newNames[]={"Cheek","Line","CheekRaiser","NoseCorner"};
	for ($i=0;$i<size($oldNames);$i++)
		if (`objExists ("FaceFit"+$oldNames[$i])`)
			{
			asFaceReSelect $oldNames[$i] "";
			delete ("FaceFit"+$oldNames[$i]);
			asCreateFaceFit $newNames[$i] "" 0 0 1;
			}
	}
select -cl;
}

global proc asStepBuildComplete (int $stepBuild)
{
if ($stepBuild==0)
	return;

if (`objExists FaceFitSkeleton`)
	{
	if (!`attributeExists buildStep FaceFitSkeleton`)
		addAttr -ln "buildStep" -at long -dv 0 FaceFitSkeleton;
	setAttr FaceFitSkeleton.buildStep $stepBuild;
	}
print ("// Face step:"+$stepBuild+" complete.\n");
asFaceUpdateInfo 1;
}

global proc asBuildAdvancedFace ()
{
string $tempString[];
string $stepBuildText;

for ($i=1;$i<99;$i++)
	{
	if (!`text -q -ex ("stepBuild"+$i+"Text")`)
		break;
	$stepBuildText=`text -q -l ("stepBuild"+$i+"Text")`;
	tokenize $stepBuildText ":" $tempString;
	$proc="asFace"+`strip $tempString[1]`;
	print ("// Execute Step:"+$stepBuildText+"\n");
	eval ($proc);
	}
}

global proc asFacePrep ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $tempInts[];
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $lowerEyeLidOuterNumCVs=`getAttr lowerEyeLidOuterCurve.spans`+1;
int $vtxNrA,$vtxNrB,$vtxNrC,$vtxNrD,$numVtx;
float $pos[];
float $scale=`asFaceGetScale`;
string $tempString[],$smileCreaseVtxs[];

//check that names are avaiable
string $names[]={"Face","Face_M"};
for ($i=0;$i<size($names);$i++)
	if (`objExists $names[$i]`)
		{
		select `ls $names[$i]`;
		error ("A object with the name:\""+$names[$i]+"\" already exists, rename this to somthing else, before running the Build.\n");
		}

if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;

select -ne `ls -o`;
select -ne -d `ls -type objectSet`;
select -ne -d `ls -type partition`;
sets -n allBeforeFaceBuild;
select -cl;
asSetFixedWrapOptions;
asFaceEnsureAdvancedBase;


//Switching to DQ-blend, make black mesh in Maya2016 and above, so deformUserNormals=off if normals!=locked
$tempInts=`polyNormalPerVertex -q -allLocked ($geometry+".vtx[0]")`;
print ($tempInts[0]+"\n");
if (!$tempInts[0])
	setAttr ($skinCluster+".deformUserNormals") 0;

//set DualQuaternian blend, and use dq for eyeLids
$tempInts=`polyEvaluate -v $geometry`;
$numVtx=$tempInts[0];
for ($y=0;$y<$numVtx;$y++)
	setAttr ($skinCluster+".bw["+$y+"]") 0;
setAttr ($skinCluster+".skinningMethod") 2;


//Face_M joint 
select -cl;
joint -n Face_M;
asAlign Face_M $headJoint 1 0 0 0;
move -r 0 0 ($scale*0.1) Face_M;
parent Face_M $headJoint;
setAttr Face_M.segmentScaleCompensate 0;
setAttr Face_M.v 0;

//Make sure defined skinCluster is correct
$tempString=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="skinCluster")
		if ($tempString[$y]!=$skinCluster)
			{
			print ("// Updated SkinCluster info, used to be:\""+$skinCluster+"\", now it is:\""+$tempString[$y]+"\".\n");
			$skinCluster=$tempString[$y];
			textField -e -tx $skinCluster asFaceSkinClusterTextField;
			}

//Disable any deltaMush
$tempString=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="wbDeltaMush" || `objectType $tempString[$y]`=="deltaMush")
		setAttr ($tempString[$y]+".envelope") 0;

//teethSets, for tracking on cut-out objects
sets -em -n upperTeethSet;
sets -em -n lowerTeethSet;
sets -add FaceBuildingSets upperTeethSet lowerTeethSet;
if ($upperTeeth!="") {eval ("select "+$upperTeeth);sets -add upperTeethSet;}
if ($lowerTeeth!="") {eval ("select "+$lowerTeeth);sets -add lowerTeethSet;}

// Unlock All SkinInfluences
if (`objExists DeformSet`)
	{
	$deformJointsList=`sets -q "DeformSet"`;
	for ($i=0;$i<size($deformJointsList);$i++)
		if (`attributeExists lockInfluenceWeights $deformJointsList[$i]`)
			if (`getAttr ($deformJointsList[$i]+".lockInfluenceWeights")`)
				setAttr ($deformJointsList[$i]+".lockInfluenceWeights") 0;
	}

select $geometry;
//blendShape -n asFaceBS -frontOfChain;

createNode -n closestSamplerFitSelection closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSamplerFitSelection.inMesh;

//vtxsFromLipToNose
if (!`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	addAttr -ln "vtxsFromLipToNose" -at long -dv 3 FaceFitSkeleton;
$pos=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
$vtxNrA=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
$pos=`xform -q -ws -t NoseUnder`;
setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
$vtxNrB=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
$vtxsFromLipToNose=1;
select ($geometry+".vtx["+$vtxNrA+"]");
for ($i=0;$i<25;$i++)
	{
	polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion;
	$tempString=`ls -sl -fl`;
	if (`stringArrayCount ($geometry+".vtx["+$vtxNrB+"]") $tempString`)
		break;
	if ($i>0)
		$vtxsFromLipToNose++;
	}
$vtxsFromLipToNose++;
if (`objExists SmileCreaseCurve`) // (use lipCnr to SmileCrease, if SmileCrease exists)
	{
	eval ("select "+`asGetFaceFitSelection SmileCreaseCurve`);
	
	ConvertSelectionToVertices;
	$smileCreaseVtxs=`ls -sl -fl`;
	$pos=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs-1]`;
	setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
	$vtxNrA=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
	select ($geometry+".vtx["+$vtxNrA+"]");
	for ($i=0;$i<25;$i++)
		{
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $tempString[$y] $smileCreaseVtxs`)
				{
				$vtxsFromLipToNose=$i+1;
				$i=99;
				break;
				}
		}
	}
select -cl;
setAttr FaceFitSkeleton.vtxsFromLipToNose $vtxsFromLipToNose;

//vtxsFromLipCornerToNoseCorner (or to lowerEyeLid or to JawPivot)
if (!`attributeExists vtxsFromLipCornerToNoseCorner FaceFitSkeleton`)
	addAttr -ln "vtxsFromLipCornerToNoseCorner" -at long -dv 3 FaceFitSkeleton;
$pos=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs-1]`;
setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
$vtxNrA=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
$pos=`xform -q -ws -t NoseCorner`;
setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
$vtxNrB=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
$pos=`xform -q -ws -t lowerEyeLidOuterCurve.cv[($lowerEyeLidOuterNumCVs-1)/2]`;
setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
$vtxNrC=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
$pos=`xform -q -ws -t JawPivot`;
setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
$vtxNrD=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
$vtxsFromLipCornerToNoseCorner=1;
select ($geometry+".vtx["+$vtxNrA+"]");
for ($i=0;$i<25;$i++)
	{
	polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion;
	$tempString=`ls -sl -fl`;
	if (`stringArrayCount ($geometry+".vtx["+$vtxNrB+"]") $tempString`)
		break;
	if (`stringArrayCount ($geometry+".vtx["+$vtxNrC+"]") $tempString`)
		break;
	if (`stringArrayCount ($geometry+".vtx["+$vtxNrD+"]") $tempString`)
		break;
	if ($i>0)
		$vtxsFromLipCornerToNoseCorner++;
	}

delete closestSamplerFitSelection;

$vtxsFromLipCornerToNoseCorner++;
select -cl;
setAttr FaceFitSkeleton.vtxsFromLipCornerToNoseCorner $vtxsFromLipCornerToNoseCorner;

setAttr -l 0 FaceFitSkeleton.v;
setAttr -l 1 FaceFitSkeleton.v 0;

asFaceFaceTargets;

asUpdateButtonEnables;
select FaceGroup;
}

global proc asFaceCtrlBox ()
{
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
if (`objExists ctrlBoxOffset`)
	delete ctrlBoxOffset;
float $scale=`asFaceGetScale`/3.0;
float $temp[];
string $tempString[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $midHeadPos[]=`asGetMidHeadPos`;
float $boxTZ=($midHeadPos[2]+($scale*1.3));
if (`objExists FitEyeBall`)
	{
	$temp=`xform -q -ws -t FitEyeBall`;
	$boxTZ=$temp[2];
	}

$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBox;
createNode -n ctrlBoxOffset transform;
parent ctrlBox ctrlBoxOffset;
parent ctrlBoxOffset FaceMotionFollowHead;
//parentConstraint -mo $headJoint ctrlBoxOffset;
//scaleConstraint -mo $headJoint ctrlBoxOffset;
addAttr -k 1 -ln "limits" -at bool -dv true ctrlBox;

//Expand length down
move -r 0 -0.4 0 ctrlBoxShape.cv[2:3];
xform -ws -t ($scale*1.8) ($midHeadPos[1]-(0.3*$scale)) $boxTZ ctrlBox;
xform -s ($scale/2.0) $scale ($scale/2.0) ctrlBox;
makeIdentity -a 1 -t 0 -r 0 -s 1 ctrlBox;

//ctrlBoxTemplate
$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBoxTemplate;
parent ctrlBoxTemplate ctrlBox;
setAttr -type float3 ctrlBoxTemplate.t 0 0 0;
setAttr -type float3 ctrlBoxTemplate.s ($scale/6.0) ($scale/6.0) ($scale/6.0);
setAttr ctrlBoxTemplateShape.overrideEnabled 1;
setAttr ctrlBoxTemplateShape.overrideDisplayType 2;

//ctrlTemplate
duplicate -n ctrlTemplate ctrlBoxTemplate;
parent ctrlTemplate ctrlBoxTemplate;
transformLimits -tx -1 1 -ty -1 1 -tz 0 0 -etx 1 1 -ety 1 1 -etz 1 1 ctrlTemplate;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransYLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransYLimitEnable`);
setAttr ctrlTemplateShape.overrideDisplayType 0;
setAttr ctrlTemplate.rz 45;
setAttr -type float3 ctrlTemplate.s 0.2 0.2 0.2;
setAttr ctrlTemplateShape.overrideEnabled 0;
//setAttr ctrlTemplateShape.overrideColor 17;
makeIdentity -a 1 -t 0 -r 1 -s 1 ctrlTemplate;
setAttr -l 1 -k 0 ctrlTemplate.tz;
setAttr -l 1 -k 0 ctrlTemplate.rx;
setAttr -l 1 -k 0 ctrlTemplate.ry;
setAttr -l 1 -k 0 ctrlTemplate.rz;
setAttr -l 1 -k 0 ctrlTemplate.sx;
setAttr -l 1 -k 0 ctrlTemplate.sy;
setAttr -l 1 -k 0 ctrlTemplate.sz;
setAttr -l 1 -k 0 ctrlTemplate.v;
sets -add FaceControlSet ctrlTemplate;

asFaceCreateCtrlBox "Brow_R" ($scale*-0.25) ($scale*0.75) 0;
asFaceCreateCtrlBox "Brow_L" ($scale*0.25) ($scale*0.75) 0;
asFaceCreateCtrlBox "Eye_R" ($scale*-0.25) ($scale*0.38) 0;
asFaceCreateCtrlBox "Eye_L" ($scale*0.25) ($scale*0.38) 0;
asFaceCreateCtrlBox "Cheek_R" ($scale*-0.25) 0 1;
asFaceCreateCtrlBox "Cheek_L" ($scale*0.25) 0 1;
asFaceCreateCtrlBox "Nose_R" ($scale*-0.25) ($scale*-0.22) 1;
asFaceCreateCtrlBox "Nose_L" ($scale*0.25) ($scale*-0.22) 1;
asFaceCreateCtrlBox "Mouth_M" 0 ($scale*-0.4) 2;
asFaceCreateCtrlBox "MouthCorner_R" ($scale*-0.25) ($scale*-1) 0;
asFaceCreateCtrlBox "MouthCorner_L" ($scale*0.25) ($scale*-1) 0;
scale -r 2 2 2 ctrlBoxMouth_M;

setAttr -l 0 -k 1 ctrlEye_L.sx;setAttr -l 0 -k 1 ctrlEye_L.sy;setAttr -l 0 -k 1 ctrlEye_L.sz;
setAttr -l 0 -k 1 ctrlEye_R.sx;setAttr -l 0 -k 1 ctrlEye_R.sy;setAttr -l 0 -k 1 ctrlEye_R.sz;

addAttr -k 1 -ln "ACtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "BCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "CCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "AimCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "TeethCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "TongueCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "RegionCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "SquashCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "CustomCtrlVis" -at bool -dv true ctrlBox;
if (`objExists TeethCollider`)
	addAttr -k 0 -ln "TeethColliderVis" -at bool -dv false ctrlBox;
//addAttr -k 1 -ln "RenderSpheres" -at bool -dv true ctrlBox;
/*
addAttr -ln "colors" -k 1 -at double ctrlBox;
setAttr -l 1 ctrlBox.colors;
addAttr -k 1 -ln "ACtrlColor" -at long -min 1 -max 17 -dv 14 ctrlBox;
addAttr -k 1 -ln "BCtrlColor" -at long -min 1 -max 17 -dv 13 ctrlBox;
addAttr -k 1 -ln "CCtrlColor" -at long -min 1 -max 17 -dv 6 ctrlBox;
addAttr -k 1 -ln "CtrlBoxColor" -at long -min 1 -max 17 -dv 17 ctrlBox;
addAttr -k 1 -ln "AimCtrlColor" -at long -min 1 -max 17 -dv 17 ctrlBox;
addAttr -k 1 -ln "RegionCtrlColor" -at long -min 1 -max 17 -dv 17 ctrlBox;
addAttr -k 1 -ln "SquashCtrlColor" -at long -min 1 -max 17 -dv 13 ctrlBox;
addAttr -k 1 -ln "CustomCtrlColor" -at long -min 1 -max 17 -dv 13 ctrlBox;
*/
setAttr ctrlBox.AimCtrlVis 0;
setAttr ctrlBox.RegionCtrlVis 0;

setAttr ctrlBox.overrideEnabled 1;
setAttr ctrlBox.overrideColor 17;

$tempString=`listAttr -k ctrlBox`;
for ($i=0;$i<size($tempString);$i++)
	setAttr -k 0 -cb 1 ("ctrlBox."+$tempString[$i]);

delete ctrlBoxTemplate;

spaceLocator -n tempLoc;
setAttr tempLoc.v 0;
createNode -n tempLocFlip -p FaceMotionSystem transform;
parent tempLoc tempLocFlip;
select ctrlBox;
}

global proc asFaceFaceTargets ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;

//create faceTargets by wrapping
createNode -n faceTargets -p FaceBuildInProgress transform;
setAttr faceTargets.v 0;
duplicate -n tempTarget $geometry;
asLockAttr tempTarget 0 0 0 0;
//sets -remove jawArea tempTarget.vtx[0:99999];
parent tempTarget faceTargets;
$tempString=`listRelatives -s -f tempTarget`; 
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];

setAttr tempTarget.v 0;
duplicate -n target_default tempTarget;
createNode -n tempNearestPointOnCurve nearestPointOnCurve;
select -cl;
}



global proc asFaceEyeBall ()
{
int $lowerEyeLidMainNumCVs=`getAttr lowerEyeLidMainCurve.spans`+1;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $eyeBallPos[3]=`xform -q -ws -t FitEyeBall`;
float $posA[],$posB[];
float $pos[3];
float $scale=`asFaceGetScale`;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
string $tempString[];


//create FaceUpperLower first
for ($a=0;$a<3;$a++)
	{
	if ($a==0) $upperLower="upper";
	if ($a==1) $upperLower="middle";
	if ($a==2) $upperLower="lower";

	select -cl;
	joint -n ($upperLower+"Face"+"Joint_M");
	parent ($upperLower+"Face"+"Joint_M") Face_M;
	$posA=`xform -q -ws -t lowerEyeLidMainCurve.cv[$lowerEyeLidMainNumCVs/2]`;
	$posB=`xform -q -ws -t JawPivot`;
	xform -ws -t 0 $posA[1] $posB[2] ($upperLower+"Face"+"Joint_M");
	move -r 0 (($faceFitScale/-10.0)*$a) 0 ($upperLower+"Face"+"Joint_M");

	$tempString=`circle -c 0 0 0 -nr 0 1 0 -sw 180 -r 4 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
	rename $tempString[0] ($upperLower+"Face"+"_M");
	connectAttr ctrlBox.RegionCtrlVis ($upperLower+"Face"+"_MShape.overrideVisibility");
	scale -r -p 0 0 0 (-3.2*$posB[0]/$faceFitScale) (-3.2*$posB[0]/$faceFitScale) (-3.2*$posB[0]/$faceFitScale) ($upperLower+"Face"+"_M.cv[0:99]");
	rotate -r 0 -90 0 ($upperLower+"Face"+"_M.cv[0:99]");
	sets -add FaceControlSet ($upperLower+"Face"+"_M");
	setAttr ($upperLower+"Face"+"_MShape.overrideEnabled") 1;
	setAttr ($upperLower+"Face"+"_MShape.overrideColor") 17;
	createNode -n ($upperLower+"FaceOffset_M") transform;
	parent ($upperLower+"Face"+"_M") ($upperLower+"FaceOffset_M");
	parent ($upperLower+"FaceOffset_M") Regioncontrols;
	asAlign ($upperLower+"FaceOffset_M") ($upperLower+"Face"+"Joint_M") 1 0 0 0;
	parentConstraint ($upperLower+"Face"+"_M") ($upperLower+"Face"+"Joint_M");
	connectAttr ($upperLower+"Face"+"_M.s") ($upperLower+"Face"+"Joint_M.s");
	setAttr -type float3 ($upperLower+"FaceOffset_M.s") ($faceFitScale/10.0) ($faceFitScale/10.0) ($faceFitScale/10.0);

	skinCluster -e -dr 4 -lw false -wt 0 -ai ($upperLower+"Face"+"Joint_M") $skinCluster;
	}



createNode -n EyeSetup -p FaceDeformationSystem transform;
string $eye,$eyeBallSkinCluster;
string $eyeGeos[];

//EyeAimSetup
createNode -n EyeAimSetup -p EyeSetup transform;
createNode -n EyeAimFollowHead -p EyeAimSetup transform;
createNode -n EyeAimStatic -p EyeAimSetup transform;
parentConstraint $headJoint EyeAimFollowHead;
asAlign EyeAimStatic $headJoint 1 1 0 0;
//scaleConstraint $headJoint EyeAimFollowHead;
connectAttr MainAndHeadScaleMultiplyDivide.output EyeAimFollowHead.s;
$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] AimEye_M;
setAttr AimEye_MShape.overrideEnabled 1;
connectAttr ctrlBox.AimCtrlVis AimEye_MShape.overrideVisibility;
//connectAttr ctrlBox.AimCtrlColor AimEye_MShape.overrideColor;
setAttr AimEye_MShape.overrideColor 17;
sets -add FaceControlSet AimEye_M;
//scale -r -p 0 0 0 ($scale/10.0) ($scale/10.0) ($scale/10.0) AimEye_M.cv[0:4];
createNode -n AimAimAt -p EyeAimSetup transform;
xform -ws -t 0 $eyeBallPos[1] $eyeBallPos[2] AimAimAt;
//aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject AimAimAt AimAimAt AimEye_M;
//setAttr -k 0 AimEye_M.rx;setAttr -k 0 AimEye_M.ry;setAttr -k 0 AimEye_M.rz;
createNode -n AimEyeOffset_M transform;
createNode -n AimEyeFollow_M transform;
parent AimEyeFollow_M Aimcontrols;
asAlign AimEyeFollow_M $headJoint 1 1 0 0;
parent AimEye_M AimEyeOffset_M;
setAttr -type float3 AimEyeOffset_M.s ($faceFitScale/10.0) ($faceFitScale/10.0) ($faceFitScale/10.0);
asAlign AimEyeOffset_M AimEyeFollow_M 1 0 0 0;
parent AimEyeOffset_M AimEyeFollow_M;
xform -ws -t 0 $eyeBallPos[1] ($eyeBallPos[2]+$scale) AimEyeOffset_M;
createNode -n AimEyeUpVec -p FitEyeBall transform;
parent AimEyeUpVec EyeAimFollowHead;
/*
addAttr -k 1 -ln aim -at double -min 0 -max 10 -dv 10 AimEye_M;
createNode -n eyeAimSetRange setRange;
setAttr eyeAimSetRange.minX 0;
setAttr eyeAimSetRange.maxX 1;
setAttr eyeAimSetRange.oldMinX 0;
setAttr eyeAimSetRange.oldMaxX 10;
connectAttr AimEye_M.aim eyeAimSetRange.value.valueX;
*/
addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 AimEye_M;
createNode -n eyeAimFollowSetRange setRange;
setAttr eyeAimFollowSetRange.minX 0;setAttr eyeAimFollowSetRange.minY 1;
setAttr eyeAimFollowSetRange.maxX 1;setAttr eyeAimFollowSetRange.maxY 0;
setAttr eyeAimFollowSetRange.oldMinX 0;setAttr eyeAimFollowSetRange.oldMinY 0;
setAttr eyeAimFollowSetRange.oldMaxX 10;setAttr eyeAimFollowSetRange.oldMaxY 10;
connectAttr AimEye_M.follow eyeAimFollowSetRange.value.valueX;
connectAttr AimEye_M.follow eyeAimFollowSetRange.value.valueY;
//parentConstraint -mo $headJoint FaceGroup AimEyeFollow_M;
parentConstraint $headJoint EyeAimStatic AimEyeFollow_M;
connectAttr eyeAimFollowSetRange.outValue.outValueY AimEyeFollow_M_parentConstraint1.EyeAimStaticW1;
connectAttr eyeAimFollowSetRange.outValue.outValueX ("AimEyeFollow_M_parentConstraint1."+$headJoint+"W0");
//scaleConstraint $headJoint AimEyeFollow_M;
//connectAttr MainAndHeadScaleMultiplyDivide.output AimEyeFollow_M.s;

for ($b=1;$b>-2;$b=$b-2)
	{
	if (!`objExists FitEyeBall`)
		continue;
	if ($b==1) $side="_R"; else $side="_L";

	select upperFaceJoint_M;
	joint -n ("Eye"+$side);
	setAttr ("Eye"+$side+".rotateOrder") 2;
	xform -ws -t ($eyeBallPos[0]*$b) $eyeBallPos[1] $eyeBallPos[2] ("Eye"+$side);
	delete `orientConstraint FitEyeBall  ("Eye"+$side)`;
	makeIdentity -a 1 -t 0 -r 1 -s 0 ("Eye"+$side);
	setAttr ("Eye"+$side+".segmentScaleCompensate") 0;
	joint -n ("EyeEnd"+$side);
	if (`objExists DeformSet`)
		sets -add DeformSet ("EyeEnd"+$side);
	setAttr ("EyeEnd"+$side+".tx") (`getAttr FitEyeBall.sx`*1.55);

	$eyeJoint="Eye"+$side;
	$eye=`textField -q -tx ("asFaceEye"+$side+"TextField")`;
	if ($eye=="")
		continue;
	tokenize $eye " " $tempString;
	clear $eyeGeos;
	for ($i=0;$i<size($tempString);$i++)
		$eyeGeos[$i]=$tempString[$i];

	for ($i=0;$i<size($eyeGeos);$i++)
		{
		$haveSkinCluster=0;
		$historyNodes=`listHistory $eyeGeos[$i]`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$eyeBallSkinCluster=$historyNodes[$y];
				}
	
		if ($haveSkinCluster)
			{
			skinCluster -e -lw true -wt 0 -ai $eyeJoint $eyeBallSkinCluster;
			if (`attributeExists lockInfluenceWeights $eyeJoint`)
				setAttr ($eyeJoint+".lockInfluenceWeights") 0;
			skinPercent -tv $eyeJoint 1 $eyeBallSkinCluster $eyeGeos[$i];
			}
		else
			{
			select $eyeJoint $eyeGeos[$i];
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			for ($y=0;$y<size($tempString);$y++)
				rename $tempString[$y] ("eyeSC"+$side);
			}
		}
//	connectAttr ("ctrlEye"+$side+".sx") ($eyeJoint+".sz");
//	connectAttr ("ctrlEye"+$side+".sy") ($eyeJoint+".sy");
//	connectAttr ("ctrlEye"+$side+".sz") ($eyeJoint+".sx");
	//SDK
	asFaceBsSdk ("ctrlEye"+$side+".tx") 1 ($eyeJoint+".ry") -30;
	asFaceBsSdk ("ctrlEye"+$side+".tx") -1 ($eyeJoint+".ry") 30;
	asFaceBsSdk ("ctrlEye"+$side+".ty") 1 ($eyeJoint+".rz") -30;
	asFaceBsSdk ("ctrlEye"+$side+".ty") -1 ($eyeJoint+".rz") 30;
	//Look-at
	createNode -n ("EyeOffset"+$side) -p ("Eye"+$side) transform;
	parent ("EyeOffset"+$side) EyeAimFollowHead;

	createNode -n ("AimOffsetEye"+$side) -p AimEye_M transform;
//	duplicate -n ("AimOffsetEye"+$side) ("EyeOffset"+$side);
	parent ("AimOffsetEye"+$side) ("Eye"+$side);
	setAttr ("AimOffsetEye"+$side+".tx") $scale;
	parent ("AimOffsetEye"+$side) AimEye_M;

	duplicate -n ("AimEye"+$side) AimEye_M;
	delete `listRelatives -c -fullPath -type transform ("AimEye"+$side)`;
	parent -r ("AimEye"+$side) ("AimOffsetEye"+$side);
	connectAttr ctrlBox.AimCtrlVis ("AimEye"+$side+"Shape.overrideVisibility");
//	connectAttr ctrlBox.AimCtrlColor ("AimEye"+$side+"Shape.overrideColor");

	$pos=`xform -q -ws -t AimEye_MShape.cv[4]`;
	$pos[0]*=$b;
	xform -ws -t $pos[0] ($pos[1]+($scale*0.03)) $pos[2] ("AimEye"+$side+".cv[0]");
	xform -ws -t $pos[0] ($pos[1]+($scale*-0.03)) $pos[2] ("AimEye"+$side+".cv[1]");
	xform -ws -t $pos[0] $pos[1] $pos[2] ("AimEye"+$side+".cv[2]");
	xform -ws -t ($pos[0]+($scale*0.03)) $pos[1] $pos[2] ("AimEye"+$side+".cv[3]");
	xform -ws -t ($pos[0]+($scale*-0.03)) $pos[1] $pos[2] ("AimEye"+$side+".cv[4]");

	duplicate -n ("EyeAim"+$side) ("EyeOffset"+$side);
	setAttr ("EyeAim"+$side+".rotateOrder") `getAttr ("Eye"+$side+".rotateOrder")`;
	parent ("EyeAim"+$side) ("EyeOffset"+$side);
/*
	createNode -n ("EyeAimBlend"+$side) blendColors;
	connectAttr ("EyeAim"+$side+".rotate") ("EyeAimBlend"+$side+".color1");
	connectAttr ("Eye"+$side+"_rotateY.output") ("EyeAimBlend"+$side+".color2G");
	connectAttr ("Eye"+$side+"_rotateZ.output") ("EyeAimBlend"+$side+".color2B");
	connectAttr -f ("EyeAimBlend"+$side+".outputR") ("Eye"+$side+".rx");
	connectAttr -f ("EyeAimBlend"+$side+".outputG") ("Eye"+$side+".ry");
	connectAttr -f ("EyeAimBlend"+$side+".outputB") ("Eye"+$side+".rz");
*/
	createNode -n ("EyeAimAdd"+$side) plusMinusAverage;
	connectAttr ("EyeAim"+$side+".rx") ("EyeAimAdd"+$side+".input3D[0].input3Dx");
	connectAttr ("EyeAim"+$side+".ry") ("EyeAimAdd"+$side+".input3D[0].input3Dy");
	connectAttr ("EyeAim"+$side+".rz") ("EyeAimAdd"+$side+".input3D[0].input3Dz");
	connectAttr ("Eye"+$side+"_rotateY.output") ("EyeAimAdd"+$side+".input3D[1].input3Dy");
	connectAttr ("Eye"+$side+"_rotateZ.output") ("EyeAimAdd"+$side+".input3D[1].input3Dz");
	connectAttr -f ("EyeAimAdd"+$side+".output3D.output3Dx") ("Eye"+$side+".rx");;
	connectAttr -f ("EyeAimAdd"+$side+".output3D.output3Dy") ("Eye"+$side+".ry");;
	connectAttr -f ("EyeAimAdd"+$side+".output3D.output3Dz") ("Eye"+$side+".rz");;

	aimConstraint -aimVector 1 0 0 -worldUpType objectrotation -worldUpObject AimEyeUpVec -worldUpVector 0 1 0 ("AimEye"+$side) ("EyeAim"+$side);
	parent -w ("EyeAim"+$side);
	asAlign ("EyeOffset"+$side) ("EyeAim"+$side) 1 1 0 0;
	parent ("EyeAim"+$side) ("EyeOffset"+$side);
//	connectAttr eyeAimSetRange.outValue.outValueX ("EyeAimBlend"+$side+".blender");
	}

select -r ctrlEye_R ctrlEye_L;
}

global proc asFaceEyeLid ()
{
global string $gMainProgressBar;
int $tempInts[];
int $numSelVtx,$prevNumSelVtx,$twoWayVtxInside;
float $pos[],$posA[],$posB[],$values[];
float $maxValue,$maxValue2;
string $upperLower,$mainDroopy,$droopySuffix,$lidJoint,$eyeJoint,$maxTransform,$maxTransform2,$ctrlParent,$cmd;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$infs[],$transforms[];
string $outerVtxs[],$mainVtxs[],$innerVtxs[],$droopyVtxs[];
string $upLoOuterVtxs[],$upLoMainVtxs[],$upLoInnerVtxs[],$upLoDroopyVtxs[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`asFaceGetScale`;

setAttr ctrlEye_L.tx 0;setAttr ctrlEye_L.ty 0;
setAttr ctrlEye_R.tx 0;setAttr ctrlEye_R.ty 0;

createNode -n LidSetup -p FaceDeformationSystem transform;

//EyeRegion
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	asCreateFaceController "EyeRegion" $side 4;
	parent ("EyeRegionOffset"+$side) upperFace_M;
	$pos=`xform -q -ws -t ("Eye"+$side)`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("EyeRegionOffset"+$side);
	scale -r -p $pos[0] $pos[1] $pos[2] 6 6 6 ("EyeRegion"+$side+".cv[0:7]");
//	$posB=`xform -q -ws -t NoseCorner`;
//	select ("EyeRegion"+$side+".cv[0:7]");
//	move -z $posB[2];
	asFacePlaceCtrlByProjection ("EyeRegion"+$side);
	pointConstraint ("EyeRegion"+$side) ("Eye"+$side);
	connectAttr ("EyeRegion"+$side+".sx") ("Eye"+$side+".sz");
	connectAttr ("EyeRegion"+$side+".sy") ("Eye"+$side+".sy");
	connectAttr ("EyeRegion"+$side+".sz") ("Eye"+$side+".sx");
	if (`objExists FaceFitEyeLidDroopy`)
		{
		createNode -n ("LidDroopyDrive"+$side) -p ("EyeRegion"+$side) transform;
		createNode -n ("LidDroopy"+$side) -p ("LidDroopyDrive"+$side) transform;
		}
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	createNode -n ("LidSetup"+$side) transform;
//	asAlign ("LidSetup"+$side) ("Eye"+$side) 1 1 0 0;
	parentConstraint ("EyeRegion"+$side) ("LidSetup"+$side);
	scaleConstraint ("EyeRegion"+$side) ("LidSetup"+$side);
	parent ("LidSetup"+$side) FaceDeformationSystem;
	}

//createNode -n tempNearestPointOnCurve nearestPointOnCurve;

//Setup Lid
int $numLid;
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
progressBar -e -st ("Setup EyeLid") -bp -ii 0 -min 0 -max 4 $gMainProgressBar;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	$eyeJoint="Eye"+$side;

	select -cl;
	joint -n ("LidJoints"+$side);
	setAttr ("LidJoints"+$side+".segmentScaleCompensate") 0;
	asAlign ("LidJoints"+$side) $eyeJoint 1 0 0 0;
	parent ("LidJoints"+$side) upperFaceJoint_M;
	parentConstraint ("EyeRegion"+$side) ("LidJoints"+$side);
	connectAttr ("EyeRegion"+$side+".sx") ("LidJoints"+$side+".sx");
	connectAttr ("EyeRegion"+$side+".sy") ("LidJoints"+$side+".sy");
	connectAttr ("EyeRegion"+$side+".sz") ("LidJoints"+$side+".sz");
//	scaleConstraint ("EyeRegion"+$side) ("LidJoints"+$side);
	skinCluster -e -dr 4 -lw true -wt 0 -ai ("LidJoints"+$side) $skinCluster;

	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("blink"+$side) -at double LidSetup;
	addAttr -dv 0.2 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("blinkCenter"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLid"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLid"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLidOut"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLidOut"+$side) -at double LidSetup;
//	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLidFollow"+$side) -at double LidSetup;
//	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLidFollow"+$side) -at double LidSetup;
//	if (`objExists FaceFitEyeLidDroopy`)
//		addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lidDroopyFollow"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLidOutAuto"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLidOutAuto"+$side) -at double LidSetup;

	createNode -n ("blinkCenterReverse"+$side) reverse;
	connectAttr ("LidSetup.blinkCenter"+$side) ("blinkCenterReverse"+$side+".inputX");

	createNode -n ("LidLocs"+$side) transform;
	setAttr ("LidLocs"+$side+".inheritsTransform") 0;
	parent ("LidLocs"+$side) LidSetup;
//	setAttr -l 1 ("LidLocs"+$side+".v") 0;
	createNode -n ("LidCurves"+$side) transform;
//	parent ("LidCurves"+$side) LidSetup;//nope, will not work with headscaling
//	parent ("LidCurves"+$side) ("LidSetup"+$side);//nope, will not work with EyeRegion
	parent ("LidCurves"+$side) FaceDeformationSystemFollowHead;
	for ($a=0;$a<2;$a++)
		{
		if ($a==0) {$mainDroopy="Main";$droopySuffix="";}
		if ($a==1) {$mainDroopy="Droopy";$droopySuffix="Droopy";}
		if ($mainDroopy=="Droopy" && !`objExists FaceFitEyeLidDroopy`)
			continue;

		for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
			{
			progressBar -e -s 1 $gMainProgressBar;
			if ($upperLowerFactor==1) $upperLower="upper";
			else $upperLower="lower";

			duplicate -n ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side) ($upperLower+"EyeLid"+$mainDroopy+"Curve");
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.004 ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side);	

			//rebuild another curve, for getting good placements for the cv`s
			rebuildCurve -n ($upperLower+"EyeLid"+$mainDroopy+"RebuiltSamplerCurve") -ch 1 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.0001 ($upperLower+"EyeLid"+$mainDroopy+"Curve") ;
			connectAttr -f ($upperLower+"EyeLid"+$mainDroopy+"RebuiltSamplerCurveShape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
			setAttr tempPointOnCurveInfo.parameter 0.25;
			$pos=`getAttr tempPointOnCurveInfo.position`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[1]");
			setAttr tempPointOnCurveInfo.parameter 0.75;
			$pos=`getAttr tempPointOnCurveInfo.position`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[3]");
			disconnectAttr ($upperLower+"EyeLid"+$mainDroopy+"RebuiltSamplerCurveShape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
			delete ($upperLower+"EyeLid"+$mainDroopy+"RebuiltSamplerCurve");

			//Might need to flip over Left curve here
			if ($side=="_L")
				scale -r -p 0 0 0 -1 1 1 ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[0:4]");
			parent ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side) ("LidCurves"+$side);

			//make Tweaked-Shape, so each cv is zero position at the correct place
			createNode -n ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+"TweakedShape") -p ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side) nurbsCurve;
			connectAttr -f ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+"Shape.worldSpace[0]") ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+"TweakedShape.create");
			setAttr ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+"Shape.intermediateObject") 1;

			duplicate -n ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side) ($upperLower+"EyeLid"+$mainDroopy+"Curve");
			parent -w ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side);
			if ($side=="_L")
				scale -r -p 0 0 0 -1 1 1 ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side+".cv[0:999]");

			duplicate -n ($upperLower+"EyeLid"+$mainDroopy+"Curve1"+$side) ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side);
			parent ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side) ("LidCurves"+$side);

			if ($mainDroopy=="Main")
				{
				duplicate -n ($upperLower+"EyeLidOuterCurve1"+$side) ($upperLower+"EyeLidOuterCurve");
				parent -w ($upperLower+"EyeLidOuterCurve1"+$side);
				if ($side=="_L")
					scale -r -p 0 0 0 -1 1 1 ($upperLower+"EyeLidOuterCurve1"+$side+".cv[0:999]");
				}

			$numLid=`getAttr ($upperLower+"EyeLid"+$mainDroopy+"Curve.spans")`+1;
			for ($i=0;$i<$numLid;$i++)
				{
				select -cl;
				joint -n ($upperLower+"Lid"+$mainDroopy+$i+$side);
				setAttr ($upperLower+"Lid"+$mainDroopy+$i+$side+".radius") ($scale/10.0);
				$pos=`xform -q -ws -t ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side+".cv["+$i+"]")`;
				xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid"+$mainDroopy+$i+$side);
				parent ($upperLower+"Lid"+$mainDroopy+$i+$side) ("LidJoints"+$side);

				spaceLocator -n ($upperLower+"Lid"+$mainDroopy+"Loc"+$i+$side);
				setAttr -type float3 ($upperLower+"Lid"+$mainDroopy+"Loc"+$i+$side+".localScale") ($scale/100.0) ($scale/100.0) ($scale/100.0);
				parent ($upperLower+"Lid"+$mainDroopy+"Loc"+$i+$side) ("LidLocs"+$side);
				createNode -n ($upperLower+"Lid"+$mainDroopy+"Poci"+$i+$side) pointOnCurveInfo;
				setAttr ($upperLower+"Lid"+$mainDroopy+"Poci"+$i+$side+".turnOnPercentage") 1;
				setAttr ($upperLower+"Lid"+$mainDroopy+"Poci"+$i+$side+".parameter") ($i/($numLid-1.00));
				connectAttr ($upperLower+"Lid"+$mainDroopy+"Poci"+$i+$side+".position") ($upperLower+"Lid"+$mainDroopy+"Loc"+$i+$side+".translate");
				connectAttr ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side+"Shape.worldSpace[0]") ($upperLower+"Lid"+$mainDroopy+"Poci"+$i+$side+".inputCurve");

				if ($mainDroopy=="Main")
					{
					createNode -n ($upperLower+"Lid"+$mainDroopy+$i+"Aim"+$side) transform;
					parent ($upperLower+"Lid"+$mainDroopy+$i+"Aim"+$side) ("LidSetup"+$side);
					setAttr -type float3 ($upperLower+"Lid"+$mainDroopy+$i+"Aim"+$side+".t") 0 0 0;
					aimConstraint -worldUpType objectrotation -worldUpObject ("LidSetup"+$side) -worldUpVector 0 1 0 ($upperLower+"Lid"+$mainDroopy+"Loc"+$i+$side) ($upperLower+"Lid"+$mainDroopy+$i+"Aim"+$side);
					createNode -n ($upperLower+"Lid"+$mainDroopy+$i+"AimEnd"+$side) -p ($upperLower+"Lid"+$mainDroopy+$i+"Aim"+$side) transform;
					xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid"+$mainDroopy+$i+"AimEnd"+$side);
					parentConstraint ($upperLower+"Lid"+$mainDroopy+$i+"AimEnd"+$side) ($upperLower+"Lid"+$mainDroopy+$i+$side);
					}
				else
					pointConstraint ($upperLower+"Lid"+$mainDroopy+"Loc"+$i+$side) ($upperLower+"Lid"+$mainDroopy+$i+$side);
				}

			if ($mainDroopy=="Main")
				{
				for ($i=0;$i<$numLid;$i++)
					{



					//LidOut
					if ($i>0 && $i<$numLid-1)
						{
						createNode -n ($upperLower+"LidOutMult"+$i+$side) multiplyDivide;
						float $factor;
						if ($i<($numLid/2)) $factor=`smoothstep 0 $numLid $i`;
						else $factor=`smoothstep 0 $numLid ($numLid-1-$i)`;
						$factor=$factor*($scale/3.0);
						setAttr ($upperLower+"LidOutMult"+$i+$side+".input1X") $factor;
						connectAttr ("LidSetup."+$upperLower+"LidOut"+$side) ($upperLower+"LidOutMult"+$i+$side+".input2X");

						createNode -n ($upperLower+"LidOutMultAutoA"+$i+$side) multiplyDivide;
						setAttr ($upperLower+"LidOutMultAutoA"+$i+$side+".input1X") $factor;
						connectAttr ("LidSetup."+$upperLower+"LidOutAuto"+$side) ($upperLower+"LidOutMultAutoA"+$i+$side+".input2X");

						createNode -n ($upperLower+"LidOutMultAutoB"+$i+$side) multiplyDivide;
						connectAttr ($upperLower+"LidOutMultAutoA"+$i+$side+".outputX") ($upperLower+"LidOutMultAutoB"+$i+$side+".input1X");
						connectAttr ("LidSetup.blink"+$side) ($upperLower+"LidOutMultAutoB"+$i+$side+".input2X");

						createNode -n ($upperLower+"LidOut"+$i+$side) plusMinusAverage;
						setAttr ($upperLower+"LidOut"+$i+$side+".input1D[0]") `getAttr ($upperLower+"Lid"+$mainDroopy+$i+"AimEnd"+$side+".tx")`;
						connectAttr ($upperLower+"LidOutMult"+$i+$side+".outputX") ($upperLower+"LidOut"+$i+$side+".input1D[1]");
						connectAttr ($upperLower+"LidOutMultAutoB"+$i+$side+".outputX") ($upperLower+"LidOut"+$i+$side+".input1D[2]");

						connectAttr ($upperLower+"LidOut"+$i+$side+".output1D") ($upperLower+"Lid"+$mainDroopy+$i+"AimEnd"+$side+".tx");
						}
					}
			
				if ($upperLower=="upper")
					duplicate -n ("closedLid"+$mainDroopy+"Curve2"+$side) ("upperLid"+$mainDroopy+"Curve2"+$side);
				if ($upperLower=="lower")
					{
					select -r ("upperLid"+$mainDroopy+"Curve2"+$side) ("lowerLid"+$mainDroopy+"Curve2"+$side) ("closedLid"+$mainDroopy+"Curve2"+$side);
					blendShape -n ("closedLidCurveCloseBS"+$side) -frontOfChain -w 0 0.5 -w 1 0.5;
					connectAttr ("LidSetup.blinkCenter"+$side) ("closedLidCurveCloseBS"+$side+".upperLid"+$mainDroopy+"Curve2"+$side);
					connectAttr ("blinkCenterReverse"+$side+".outputX") ("closedLidCurveCloseBS"+$side+".lowerLid"+$mainDroopy+"Curve2"+$side);
					}
				duplicate -n ($upperLower+"LidCurveClose"+$side) ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side);
				select -r ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side) ("closedLid"+$mainDroopy+"Curve2"+$side) ($upperLower+"LidCurveClose"+$side);
				blendShape -n ($upperLower+"LidCurveCloseBS"+$side) -frontOfChain -w 0 0.5 -w 1 0.5;

				createNode -n ($upperLower+"CloseLidCurveMixer"+$side) plusMinusAverage;
				connectAttr ("LidSetup.blink"+$side) ($upperLower+"CloseLidCurveMixer"+$side+".input1D[0]");
				connectAttr ("LidSetup."+$upperLower+"Lid"+$side) ($upperLower+"CloseLidCurveMixer"+$side+".input1D[1]");
				connectAttr ($upperLower+"CloseLidCurveMixer"+$side+".output1D") ($upperLower+"LidCurveCloseBS"+$side+".closedLid"+$mainDroopy+"Curve2"+$side);

				createNode -n ($upperLower+"blinkReverse"+$side) reverse;
				connectAttr ($upperLower+"CloseLidCurveMixer"+$side+".output1D") ($upperLower+"blinkReverse"+$side+".inputX");
				connectAttr ($upperLower+"blinkReverse"+$side+".outputX") ($upperLower+"LidCurveCloseBS"+$side+"."+$upperLower+"Lid"+$mainDroopy+"Curve2"+$side);
				}

			//wireDeform in WorldSpace, since wireDefomer does not work well with 180 rotation, and extreme scaling.
			createNode -n ("LidWireWS"+$side) -p ("LidCurves"+$side) transform;
			duplicate -n ($upperLower+"Lid"+$mainDroopy+"Curve1OS"+$side) ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side);
			parent ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side) ("LidWireWS"+$side);
			if ($mainDroopy=="Main")
				{
				wire -n ($upperLower+"Lid"+$mainDroopy+"CurveWire"+$side) -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w ($upperLower+"LidCurveClose"+$side) ($upperLower+"Lid"+$mainDroopy+"Curve1OS"+$side);
				connectAttr ($upperLower+"blinkReverse"+$side+".outputX") ($upperLower+"Lid"+$mainDroopy+"CurveWire"+$side+".scale[0]");
				}
			else
				wire -n ($upperLower+"Lid"+$mainDroopy+"CurveWire"+$side) -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w ($upperLower+"LidDroopyCurve2"+$side) ($upperLower+"Lid"+$mainDroopy+"Curve1OS"+$side);
			setAttr ($upperLower+"Lid"+$mainDroopy+"CurveWire"+$side+".dropoffDistance[0]") 20;
			connectAttr ($upperLower+"Lid"+$mainDroopy+"Curve1OS"+$side+"Shape.worldSpace[0]") ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side+"Shape.create");

			$ctrlParent="EyeRegion"+$side;
			if ($mainDroopy=="Droopy")
				$ctrlParent="LidDroopy"+$side;

			//inner & Outer Lid
			if ($upperLower=="upper")
				{
				asPingPong ("upperLid"+$mainDroopy+"Curve2"+$side+".ep[0]") ("innerLid"+$droopySuffix) 1 $side 3 1 0;
				asParentPingPong ("innerLid"+$droopySuffix) $side $ctrlParent;
				createNode -n ("innerLid"+$droopySuffix+"JointOffset"+$side) transform;
				asAlign ("innerLid"+$droopySuffix+"JointOffset"+$side) ("innerLid"+$droopySuffix+"Joint"+$side) 1 0 0 0;
				parent -r ("innerLid"+$droopySuffix+"Joint"+$side) ("innerLid"+$droopySuffix+"JointOffset"+$side);
				setAttr -type float3 ("innerLid"+$droopySuffix+"Joint"+$side+".jointOrient") 0 0 0;

				asPingPong ("upperLid"+$mainDroopy+"Curve2"+$side+".ep[2]") ("outerLid"+$droopySuffix) 1 $side 3 1 0;
				asParentPingPong ("outerLid"+$droopySuffix) $side $ctrlParent;
				createNode -n ("outerLid"+$droopySuffix+"JointOffset"+$side) transform;
				asAlign ("outerLid"+$droopySuffix+"JointOffset"+$side) ("outerLid"+$droopySuffix+"Joint"+$side) 1 0 0 0;
				parent -r ("outerLid"+$droopySuffix+"Joint"+$side) ("outerLid"+$droopySuffix+"JointOffset"+$side);
				setAttr -type float3 ("outerLid"+$droopySuffix+"Joint"+$side+".jointOrient") 0 0 0;
				}

			//Lid
			asPingPong ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".ep[1]") ($upperLower+"Lid"+$droopySuffix) 1 $side 1 1 0;
			asParentPingPong ($upperLower+"Lid"+$droopySuffix) $side $ctrlParent;
			createNode -n ($upperLower+"Lid"+$droopySuffix+"JointOffset"+$side) transform;
			asAlign ($upperLower+"Lid"+$droopySuffix+"JointOffset"+$side) ($upperLower+"Lid"+$droopySuffix+"Joint"+$side)  1 0 0 0;
			parent -r ($upperLower+"Lid"+$droopySuffix+"Joint"+$side) ($upperLower+"Lid"+$droopySuffix+"JointOffset"+$side);
			setAttr -type float3 ($upperLower+"Lid"+$droopySuffix+"Joint"+$side+".jointOrient") 0 0 0;

			//inner (inbetween) Lid
			asPingPong ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[1]") ($upperLower+"InnerLid"+$droopySuffix) 1 $side 2 1 0;
			asParentPingPong ($upperLower+"InnerLid"+$droopySuffix) $side $ctrlParent;
			createNode -n ($upperLower+"InnerLid"+$droopySuffix+"JointOffset"+$side) transform;
			asAlign ($upperLower+"InnerLid"+$droopySuffix+"JointOffset"+$side) ($upperLower+"InnerLid"+$droopySuffix+"Joint"+$side)  1 0 0 0;
			parent -r ($upperLower+"InnerLid"+$droopySuffix+"Joint"+$side) ($upperLower+"InnerLid"+$droopySuffix+"JointOffset"+$side);
			setAttr -type float3 ($upperLower+"InnerLid"+$droopySuffix+"Joint"+$side+".jointOrient") 0 0 0;
			parentConstraint -mo ($upperLower+"Lid"+$droopySuffix+$side) ("innerLid"+$droopySuffix+$side) ($upperLower+"InnerLid"+$droopySuffix+"Offset"+$side);
			setAttr ($upperLower+"InnerLid"+$droopySuffix+"Offset"+$side+"_parentConstraint1.innerLid"+$droopySuffix+$side+"W1") 0.5;

			//outer (inbetween) Lid
			asPingPong ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[3]") ($upperLower+"OuterLid"+$droopySuffix) 1 $side 2 1 0;
			asParentPingPong ($upperLower+"OuterLid"+$droopySuffix) $side $ctrlParent;
			createNode -n ($upperLower+"OuterLid"+$droopySuffix+"JointOffset"+$side) transform;
			asAlign ($upperLower+"OuterLid"+$droopySuffix+"JointOffset"+$side) ($upperLower+"OuterLid"+$droopySuffix+"Joint"+$side)   1 0 0 0;
			parent -r ($upperLower+"OuterLid"+$droopySuffix+"Joint"+$side) ($upperLower+"OuterLid"+$droopySuffix+"JointOffset"+$side);
			setAttr -type float3 ($upperLower+"OuterLid"+$droopySuffix+"Joint"+$side+".jointOrient") 0 0 0;
			parentConstraint -mo ($upperLower+"Lid"+$droopySuffix+$side) ("outerLid"+$droopySuffix+$side) ($upperLower+"OuterLid"+$droopySuffix+"Offset"+$side);
			setAttr ($upperLower+"OuterLid"+$droopySuffix+"Offset"+$side+"_parentConstraint1.outerLid"+$droopySuffix+$side+"W1") 0.5;

			connectAttr ("outerLid"+$droopySuffix+"Joint"+$side+".t") ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[4]");
			connectAttr ($upperLower+"OuterLid"+$droopySuffix+"Joint"+$side+".t") ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[3]");
			connectAttr ($upperLower+"Lid"+$droopySuffix+"Joint"+$side+".t") ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[2]");
			connectAttr ($upperLower+"InnerLid"+$droopySuffix+"Joint"+$side+".t") ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[1]");
			connectAttr ("innerLid"+$droopySuffix+"Joint"+$side+".t") ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[0]");


			//now after binding the curve, we can parent the joints
			if ($upperLower=="upper")
				parent ("innerLid"+$droopySuffix+"JointOffset"+$side) ("outerLid"+$droopySuffix+"JointOffset"+$side) FaceDeformationSystemFollowHead;
			parent ($upperLower+"Lid"+$droopySuffix+"JointOffset"+$side) ($upperLower+"InnerLid"+$droopySuffix+"JointOffset"+$side) ($upperLower+"OuterLid"+$droopySuffix+"JointOffset"+$side) FaceDeformationSystemFollowHead;

			if ($mainDroopy=="Droopy")
				continue;

			// LidControlFollow
			addAttr -k 0 -ln ($upperLower+"FollowY") -at double ($upperLower+"Lid"+$side);
			addAttr -k 0 -ln ($upperLower+"FollowZ") -at double ($upperLower+"Lid"+$side);
			createNode -n ($upperLower+"FollowMultiplyDivide"+$side) multiplyDivide;
			connectAttr -f ("Eye"+$side+".r") ($upperLower+"FollowMultiplyDivide"+$side+".input1");
			connectAttr -f ($upperLower+"FollowMultiplyDivide"+$side+".outputY") ($upperLower+"Lid"+$side+"."+$upperLower+"FollowY");
			connectAttr -f ($upperLower+"FollowMultiplyDivide"+$side+".outputZ") ($upperLower+"Lid"+$side+"."+$upperLower+"FollowZ");
			asFaceAddDrive ($upperLower+"Lid") $side ($upperLower+"Lid") $side -0.005 {"ty"} {$upperLower+"FollowZ"};
			asFaceAddDrive ($upperLower+"Lid") $side ($upperLower+"Lid") $side ($b*0.002) {"tx"} {$upperLower+"FollowY"};
			}
		}
	}


//ctrlLid attributes
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	if (!`attributeExists blink ("ctrlEye"+$side)`)
		addAttr -ln "blink"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists blinkCenter ("ctrlEye"+$side)`)
		addAttr -ln "blinkCenter" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists upperLid ("ctrlEye"+$side)`)
		addAttr -ln "upperLid" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLid ("ctrlEye"+$side)`)
		addAttr -ln "lowerLid" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists upperLidOut ("ctrlEye"+$side)`)
		addAttr -ln "upperLidOut" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLidOut ("ctrlEye"+$side)`)
		addAttr -ln "lowerLidOut" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists blinkDriven ("ctrlEye"+$side)`)
		{
		addAttr -ln "eyeDriven" -k 1 -at double ("ctrlEye"+$side);
		setAttr -l 1 ("ctrlEye"+$side+".eyeDriven");
		}
	if (!`attributeExists upperLidFollow ("ctrlEye"+$side)`)
		{
		addAttr -ln "upperLidFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 -dv 10 ("ctrlEye"+$side);
		connectAttr -f ("ctrlEye"+$side+".upperLidFollow") ("upperFollowMultiplyDivide"+$side+".input2Y");
		connectAttr -f ("ctrlEye"+$side+".upperLidFollow") ("upperFollowMultiplyDivide"+$side+".input2Z");
		}
	if (!`attributeExists lowerLidFollow ("ctrlEye"+$side)`)
		{
		addAttr -ln "lowerLidFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 -dv 3 ("ctrlEye"+$side);
		connectAttr -f ("ctrlEye"+$side+".lowerLidFollow") ("lowerFollowMultiplyDivide"+$side+".input2Y");
		connectAttr -f ("ctrlEye"+$side+".lowerLidFollow") ("lowerFollowMultiplyDivide"+$side+".input2Z");
		}
	if (`objExists FaceFitEyeLidDroopy`)
		if (!`attributeExists lidDroopyFollow ("ctrlEye"+$side)`)
			addAttr -ln "lidDroopyFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists blinkDriven ("ctrlEye"+$side)`)
		{
		addAttr -ln "blinkDriven" -k 1 -at double ("ctrlEye"+$side);
		setAttr -l 1 ("ctrlEye"+$side+".blinkDriven");
		}
	if (!`attributeExists upperLidOutAuto ("ctrlEye"+$side)`)
		addAttr -ln "upperLidOutAuto" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLidOutAuto ("ctrlEye"+$side)`)
		addAttr -ln "lowerLidOutAuto" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);

	if (`objExists LidSetup`)
		{
		asFaceBsSdk ("ctrlEye"+$side+".blink") 10 ("LidSetup.blink"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".blink") -10 ("LidSetup.blink"+$side) -1;
		asFaceBsSdk ("ctrlEye"+$side+".blinkCenter") 10 ("LidSetup.blinkCenter"+$side) 1;
		setAttr ("ctrlEye"+$side+".blinkCenter") 0.2;
		asFaceBsSdk ("ctrlEye"+$side+".upperLid") 10 ("LidSetup.upperLid"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".upperLid") -10 ("LidSetup.upperLid"+$side) -1;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLid") 10 ("LidSetup.lowerLid"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLid") -10 ("LidSetup.lowerLid"+$side) -1;
/*
		setAttr ("LidSetup.upperLidFollow"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".upperLidFollow") 10 ("LidSetup.upperLidFollow"+$side) 1;
		setAttr ("ctrlEye"+$side+".upperLidFollow") 10;
		setAttr ("LidSetup.lowerLidFollow"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLidFollow") 10 ("LidSetup.lowerLidFollow"+$side) 1;
		setAttr ("ctrlEye"+$side+".lowerLidFollow") 3;
*/
		setAttr ("LidSetup.upperLidOut"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".upperLidOut") 10 ("LidSetup.upperLidOut"+$side) 1;
		setAttr ("LidSetup.lowerLidOut"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLidOut") 10 ("LidSetup.lowerLidOut"+$side) 1;
		setAttr ("LidSetup.upperLidOutAuto"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".upperLidOutAuto") 10 ("LidSetup.upperLidOutAuto"+$side) 1;
		setAttr ("LidSetup.lowerLidOutAuto"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLidOutAuto") 10 ("LidSetup.lowerLidOutAuto"+$side) 1;
		}
	}

//Drive
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	if (!`objExists FaceFitEyeLidDroopy`)
		continue;

	asFaceAddDrive LidDroopy $side Eye $side (0.003*$b) {"tx"} {"ry"};
	asFaceAddDrive LidDroopy $side Eye $side -0.003 {"ty"} {"rz"};

	setAttr ("ctrlEye"+$side+".lidDroopyFollow") 5;
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v 0 -cd ("ctrlEye"+$side+".lidDroopyFollow") ("Eye"+$side+".LidDroopy"+"_tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 10 -v (0.006*$b) -cd ("ctrlEye"+$side+".lidDroopyFollow") ("Eye"+$side+".LidDroopy"+"_tx");
	setAttr ("Eye"+$side+"_LidDroopy"+"_tx.preInfinity") 4;
	setAttr ("Eye"+$side+"_LidDroopy"+"_tx.postInfinity") 4;
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v 0 -cd ("ctrlEye"+$side+".lidDroopyFollow") ("Eye"+$side+".LidDroopy"+"_ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 10 -v -0.006 -cd ("ctrlEye"+$side+".lidDroopyFollow") ("Eye"+$side+".LidDroopy"+"_ty");
	setAttr ("Eye"+$side+"_LidDroopy"+"_ty.preInfinity") 4;
	setAttr ("Eye"+$side+"_LidDroopy"+"_ty.postInfinity") 4;
	}

//eyeLidArea set
eval ("select "+`asGetFaceFitSelection FaceFitEyeLidOuterCurve`);
$outerVtxs=`ls -sl -fl`;
eval ("select "+`asGetFaceFitSelection FaceFitEyeLidMainCurve`);
$mainVtxs=`ls -sl -fl`;
eval ("select "+`asGetFaceFitSelection FaceFitEyeLidInnerCurve`);
$innerVtxs=`ls -sl -fl`;
if (`objExists ($upperLower+"EyeLidDroopyCurve")`)
	{
	eval ("select "+`asGetFaceFitSelection FaceFitEyeLidDroopyCurve`);
	$droopyVtxs=`ls -sl -fl`;
	}
select $mainVtxs;
for ($i=0;$i<20;$i++)
	{
	polySelectConstraint -pp 1 -t 0x0001;
	select -d $outerVtxs $innerVtxs;
	}
select -add $mainVtxs;
sets -n eyeLidArea;
sets -add FaceAreas eyeLidArea;

//Add joint as influences
string $addInfCmd="skinCluster -e ";
for ($a=0;$a<2;$a++)
	{
	if ($a==0) $mainDroopy="Main";
	if ($a==1) $mainDroopy="Droopy";
	if ($mainDroopy=="Droopy" && !`objExists FaceFitEyeLidDroopy`)
		continue;


	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
			{
			if ($upperLowerFactor==1) {$upperLower="upper";}
			else {$upperLower="lower";}

			$numLid=`getAttr ($upperLower+"EyeLid"+$mainDroopy+"Curve.spans")`+1;
			for ($i=0;$i<$numLid;$i++)
				{
				progressBar -e -s 1 $gMainProgressBar;
				$addInfCmd+=" -ai "+$upperLower+"Lid"+$mainDroopy+$i+$side;
				}
			}
		}
	}
$addInfCmd+=" -lw false -wt 0 "+$skinCluster;
eval ($addInfCmd);

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSampler.inMesh;

//Full weight for $mainVtxs & $innerVtxs
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		$numLid=`getAttr ($upperLower+"EyeLidMainCurve.spans")`+1;
		if ($upperLowerFactor==1) {$upperLower="upper";}
		else {$upperLower="lower";}

		$tempString[0]=`asGetFaceFitSelection ($upperLower+"EyeLidMainCurve")`;
		$upLoMainVtxs=`stringToStringArray $tempString[0] " "`;
		$tempString[0]=`asGetFaceFitSelection ($upperLower+"EyeLidInnerCurve")`;
		$upLoInnerVtxs=`stringToStringArray $tempString[0] " "`;

		for ($i=0;$i<size($upLoMainVtxs);$i++)
			{
			//MainVtxs
			$pos=`xform -q -ws -t $upLoMainVtxs[$i]`;
			setAttr -type float3 closestSampler.inPosition ($pos[0]*$b) $pos[1] $pos[2];
			skinPercent -tv ($upperLower+"LidMain"+$i+$side) 1 $skinCluster ($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
			//InnerVtxs
			if (!`objExists $upLoInnerVtxs[$i]`)
				continue;
			$pos=`xform -q -ws -t $upLoInnerVtxs[$i]`;
			setAttr -type float3 closestSampler.inPosition ($pos[0]*$b) $pos[1] $pos[2];
			skinPercent -tv ($upperLower+"LidMain"+$i+$side) 1 $skinCluster ($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
			}

		//DroopyVtxs
		if (!`objExists ($upperLower+"EyeLidDroopyCurve")`)
			continue;
		$tempString[0]=`asGetFaceFitSelection ($upperLower+"EyeLidDroopyCurve")`;
		$upLoDroopyVtxs=`stringToStringArray $tempString[0] " "`;
		for ($i=0;$i<size($upLoDroopyVtxs);$i++)
			{
			$pos=`xform -q -ws -t $upLoDroopyVtxs[$i]`;
			setAttr -type float3 closestSampler.inPosition ($pos[0]*$b) $pos[1] $pos[2];
			skinPercent -tv ($upperLower+"LidDroopy"+$i+$side) 1 $skinCluster ($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
			}
		}
	}
//Full weight for Inbetween $mainVtxs & $innerVtxs
select $outerVtxs;
skinPercent -tv LidJoints_R 1 $skinCluster;

$tempString[0]=`asGetFaceFitSelection upperEyeLidMainCurve`;
string $upperMainVtxs[]=`stringToStringArray $tempString[0] " "`;
select $upperMainVtxs[size($upperMainVtxs)/2];
ConvertSelectionToEdges;
ConvertSelectionToVertices;
select -d $upperMainVtxs;
string $twoWayVtx[]=`ls -sl -fl`;
for ($a=0;$a<size($twoWayVtx);$a++)
	{
	select $twoWayVtx[$a];
	for ($y=0;$y<10;$y++)
		{
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		select -d $mainVtxs;
		$tempString=`ls -sl -fl`;
		for ($i=0;$i<size($tempString);$i++)
			if (`stringArrayCount $tempString[$i] $innerVtxs`)
				{
				$twoWayVtxInside=$a;
				break;
				}
		}
	}
select $twoWayVtx[$twoWayVtxInside];
$prevNumSelVtx=1;
for ($i=0;$i<100;$i++)
	{
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $mainVtxs $innerVtxs;
	$numSelVtx=size(`ls -sl -fl`);
	if ($numSelVtx==$prevNumSelVtx)
		break;
	$prevNumSelVtx=$numSelVtx;
	}
$tempString=`ls -sl -fl`;

//changed Hammer for flood once, now chaning back..And back again.
asSmoothFlood $headJoint "" 100;
//weightHammerVerts;
//Hardening these inside-eyeLid-weights.
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	$transforms=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $tempString[$i]`;
	$values=`skinPercent -ignoreBelow 0.001 -q -v $skinCluster $tempString[$i]`;
	$maxValue=0;
	for ($z=0;$z<size($transforms);$z++)
		{
		if ($values[$z]>$maxValue)
			{
			$maxValue=$values[$z];
			$maxTransform=$transforms[$z];
			}
		}
	skinPercent -tv $maxTransform 1 $skinCluster $tempString[$i];
	}

if (size($twoWayVtx)>1)
	{
	select $twoWayVtx[!$twoWayVtxInside];
	//$prevNumSelVtx=0;
	$prevNumSelVtx=1;
	for ($i=0;$i<100;$i++)
		{
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		select -d $mainVtxs $outerVtxs;
		$numSelVtx=size(`ls -sl -fl`);
		if ($numSelVtx==$prevNumSelVtx)
			break;
		$prevNumSelVtx=$numSelVtx;
		}
	$tempString=`ls -sl -fl`;
	//latest findings is for hammer to work better on outside-eyeLid
	weightHammerVerts;
	}

//Droopy falloff
if (`objExists ($upperLower+"EyeLidDroopyCurve")`)
	{
	select $droopyVtxs;
	for ($i=1;$i<99;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion;
		select -d $droopyVtxs;
		$tempString=`ls -sl -fl`;
		for ($y=1;$y<size($tempString);$y++)
			if (`stringArrayCount $tempString[$y] $mainVtxs`)
				{
				$i=99;
				break;
				}
		}
	}
select -d $mainVtxs;
//GrowPolygonSelectionRegion;
//select -d $droopyVtxs;
weightHammerVerts;

//set DualQuaternian blend, and use dq for eyeLids
select eyeLidArea;
$tempString=`ls -sl -fl`;
$cmd="";
for ($y=0;$y<size($tempString);$y++)
	{
	tokenize $tempString[$y] "[" $tempString2;
	tokenize $tempString2[1] "]" $tempString3;
	$cmd+="setAttr "+$skinCluster+".bw["+$tempString3[0]+"] 1;";
	}
eval ($cmd);

copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
//copySkinWeights cmd seem to erroneously `swap` dqblend weights insteas if mirror, so re-run after mirror.
eval ($cmd);

//delete EyeLidSkinCage_R;
delete upperEyeLidMainCurve1_R upperEyeLidOuterCurve1_R lowerEyeLidMainCurve1_R lowerEyeLidOuterCurve1_R;
delete upperEyeLidMainCurve1_L upperEyeLidOuterCurve1_L lowerEyeLidMainCurve1_L lowerEyeLidOuterCurve1_L;
if (`objExists FaceFitEyeLidDroopy`)
	{
	delete upperEyeLidDroopyCurve1_R lowerEyeLidDroopyCurve1_R;
	delete upperEyeLidDroopyCurve1_L lowerEyeLidDroopyCurve1_L;
	}
select eyeLidArea;

if (`objExists closestSampler`) delete closestSampler;
progressBar -e -ep $gMainProgressBar;

select -r ctrlEye_R ctrlEye_L;
}

global proc asFaceEyeBrow ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`asFaceGetScale`;
int $type;
string $tempString[],$eyeBrowFullWeightVtxs[],$infJoints[];

string $eyeBrows[]={"EyeBrowInner","EyeBrowOuter"};
for ($a=1;$a<4;$a++)
	if (`objExists ("EyeBrowMid"+$a)`)
		$eyeBrows[size($eyeBrows)]=("EyeBrowMid"+$a);
if (`objExists EyeBrowMiddle`)
$eyeBrows[size($eyeBrows)]="EyeBrowMiddle";

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	//EyeBrowRegion
	asCreateFaceController "EyeBrowRegion" $side 4;
	parent ("EyeBrowRegionOffset"+$side) upperFace_M;
	$posA=`xform -q -ws -t EyeBrowInner`;
	$posB=`xform -q -ws -t EyeBrowOuter`;
	$pos[0]=($posA[0]+$posB[0])/(2.0*$b);$pos[1]=($posA[1]+$posB[1])/2.0;$pos[2]=($posA[2]+$posB[2])/2.0;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("EyeBrowRegionOffset"+$side);
	scale -r -p $pos[0] $pos[1] $pos[2] 6 2 6 ("EyeBrowRegion"+$side+".cv[0:7]");
//	move -r 0 0 ($scale/10.0) ("EyeBrowRegion"+$side+".cv[0:7]");
	asFacePlaceCtrlByProjection ("EyeBrowRegion"+$side);
//	connectAttr ctrlBox.RegionCtrlVis ("EyeBrowRegion"+$side+"Shape.overrideVisibility");

	for ($c=0;$c<size($eyeBrows);$c++)
		{
		if (`gmatch $eyeBrows[$c] "*Middle*"`)
			{
			if ($b==1) $side="_M";
			if ($b==-1) continue;			
			}

		$type=1;
		if ($c>0) $type=2;
		if ($c==size($eyeBrows)-1) $type=3;
		asPingPong $eyeBrows[$c] $eyeBrows[$c] $b $side $type 1 0;
		parent ($eyeBrows[$c]+"Joint"+$side) upperFaceJoint_M;
		skinCluster -e -dr 4 -lw false -wt 0 -ai ($eyeBrows[$c]+"Joint"+$side) $skinCluster;
		if ($side!="_M")
			parent ($eyeBrows[$c]+"Offset"+$side) ("EyeBrowRegion"+$side);

		if ($side=="_L")
			continue;

		eval ("select "+`asGetFaceFitSelection $eyeBrows[$c]`);
		$tempString=`ls -sl`;
		$eyeBrowFullWeightVtxs=`stringArrayCatenate $eyeBrowFullWeightVtxs $tempString`;
		skinPercent -tv ($eyeBrows[$c]+"Joint"+$side) 1 $skinCluster;
		}
	}

createNode -n eyeBrowArea objectSet;
sets -add FaceAreas eyeBrowArea;
sets -add eyeBrowArea $eyeBrowFullWeightVtxs;

duplicate -n ForeHeadAreaMeshMirror ForeHeadAreaMesh;
setAttr ForeHeadAreaMeshMirror.sx -1;
eval ("select "+`asGetFaceFitSelection ForeHeadAreaMesh`);
eval ("select -add "+`asGetFaceFitSelection ForeHeadAreaMeshMirror`);
eval ("select -d "+`asGetFaceFitSelection FaceFitEyeLidOuterCurve`);
select -d $eyeBrowFullWeightVtxs;
weightHammerVerts;
delete ForeHeadAreaMeshMirror;


copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;


//Drive
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	if (`objExists ("EyeBrowMid1"+$side)`)
		asFaceAddDrive "EyeBrowMid1" $side "EyeBrowInner" $side 0.3 {} {};

	asFaceAddDrive EyeBrowRegion $side ctrlBrow $side 0.84 {"ty"} {};
	asFaceAddDrive EyeBrowRegion $side ctrlBrow $side -15 {"rz"} {"tx"};
	}

if (`objExists EyeBrowMiddle_M`)
	{
	createNode -n EyeBrowMiddleStatic_M -p upperFace_M transform;
	delete `pointConstraint EyeBrowInnerJoint_R EyeBrowInnerJoint_L EyeBrowMiddleStatic_M`;
	pointConstraint -mo EyeBrowInnerJoint_R EyeBrowInnerJoint_L EyeBrowMiddleStatic_M EyeBrowMiddleOffset_M;
	addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 EyeBrowMiddle_M;
	asUnitConvertAndReverse EyeBrowMiddle_MFollow EyeBrowMiddle_M.follow;
	connectAttr EyeBrowMiddle_MFollowUnitConversion.output EyeBrowMiddleOffset_M_pointConstraint1.EyeBrowInnerJoint_RW0;
	connectAttr EyeBrowMiddle_MFollowUnitConversion.output EyeBrowMiddleOffset_M_pointConstraint1.EyeBrowInnerJoint_LW1;
	connectAttr EyeBrowMiddle_MFollowReverse.outputX EyeBrowMiddleOffset_M_pointConstraint1.EyeBrowMiddleStatic_MW2;
//	asFaceAddDrive "EyeBrowMiddle" "_M" "EyeBrowInner" "_R" 0.3 {"ty"} {};
//	asFaceAddDrive "EyeBrowMiddle" "_M" "EyeBrowInner" "_L" 0.3 {"ty"} {};
	}

select -cl;
}

global proc asEyeBrowSkinning2 ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`asFaceGetScale`;
float $falloffRadius;
float $posA[],$posB[],$values[];
int $overTreshold;
string $side;
string $sel[]=`ls -sl`;
string $tempString[],$infs[];

eval ("select "+`asGetFaceFitSelection ForeHeadAreaMesh`);
skinPercent -tv $headJoint 1 $skinCluster;

string $eyeBrows[]={"EyeBrowOuter"};
for ($a=1;$a<4;$a++)
	if (`objExists ("EyeBrowMid"+$a)`)
		$eyeBrows[size($eyeBrows)]=("EyeBrowMid"+$a);
if (`objExists EyeBrowMiddle`)
$eyeBrows[size($eyeBrows)]="EyeBrowMiddle";
$eyeBrows[size($eyeBrows)]="EyeBrowInner";

if (`objExists TempPos`) delete TempPos;
createNode -n TempPos transform;

for ($c=0;$c<size($eyeBrows);$c++)
	{
	if ($eyeBrows[$c]=="EyeBrowMiddle")
		$side="_M";
	else
		$side="_R";

	$posA=`xform -q -ws -t $eyeBrows[$c]`;
	xform -ws -t $posA[0] $posA[1] $posA[2] TempPos;
	select upperEyeLidOuterCurve TempPos;
	geometryConstraint -weight 1;
	delete TempPos_geometryConstraint1;
	$posB=`xform -q -ws -t TempPos`;
	if ($eyeBrows[$c]=="EyeBrowInner")
	if ($eyeBrows[$c]=="EyeBrowMiddle")
		{$posB=`xform -q -ws -t EyeBrowInner`;$posB[0]=$posB[0]*2;}
	$falloffRadius=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($side=="_L")
		$falloffRadius=0;
	asSkinWeightBySoftMod ($eyeBrows[$c]+"Joint"+$side)  $geometry $skinCluster $falloffRadius 1;
	}


//Hammer below 50% vtx
eval ("select "+`asGetFaceFitSelection ForeHeadAreaMesh`);
$tempString=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	{
	$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $tempString[$i]`;
	$values=`skinPercent -ignoreBelow 0.001 -q -v $skinCluster $tempString[$i]`;
	$overTreshold=0;
	for ($y=0;$y<size($infs);$y++)
		{
		if (!`gmatch $infs[$y] "EyeBrow*"`)
			continue;
		if ($values[$y]>0.50)
			{
			$overTreshold=1;
			break;
			}
		}
	if (!$overTreshold)
		select -add $tempString[$i];
	}
select -d eyeLidArea;
weightHammerVerts;

delete TempPos;
select $sel;
}

global proc asFaceLip ()
{
global string $gSelect;
global string $artSelectObject;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $outerNumCv,$ctrlNr,$type,$numCvs;
int $innerVtxNr[],$outerVtxNr[],$mainVtxNr[];
float $scale=`asFaceGetScale`;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $dist,$currentValue,$factor,$lipDistOffsetScale;
float $pos[],$posA[],$posB[],$posC[],$libBShapePos[];
string $startVtx,$endVtx,$inOutMain,$side,$inf,$ctrl,$cd,$setRange,$plusMinusAverage;
string $tempString[],$tempString2[],$tempString3[],$completedVtxs[],$endingVtxs[],$allLoopVtxs[],$lipArea[],$lipPress[];
string $xyz[]={"x","y","z"};

//lockWeights all but headJoint
$tempString=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!=$headJoint)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 1;

eval ("select "+`asGetFaceFitSelection LipInnerAreaMesh`);
$lipArea=`ls -sl -fl`;
createNode -n lipArea objectSet;
sets -add FaceAreas lipArea;
sets -add lipArea $lipArea;

addAttr -k 1 -ln zip_R -at double -min 0 -max 10 -dv 0 ctrlMouth_M;
addAttr -k 1 -ln zip_L -at double -min 0 -max 10 -dv 0 ctrlMouth_M;
addAttr -k 1 -ln lipStretchedSqueeze -at double -min -10 -max 10 -dv 5 ctrlMouth_M;
//addAttr -k 1 -ln seal -at double -min 0 -max 10 -dv 0 ctrlMouth_M;
//asUnitConvertAndReverse seal ctrlMouth_M.seal;

createNode -n LipSetup transform;
parent LipSetup FaceDeformationSystem;

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr ($geometry+".outMesh") closestSampler.inMesh;
createNode -n closestNurbsSampler closestPointOnSurface;
createNode -n LipConstruction transform;

select -cl;
joint -n LipJoints_M;
select lipArea;
$pos=`xform -q -bb`;
xform -ws -t (($pos[0]+$pos[3])/2.0) (($pos[1]+$pos[4])/2.0) (($pos[2]+$pos[5])/2.0) LipJoints_M;
parent LipJoints_M lowerFaceJoint_M;

//LipRegion
$posA=`xform -q -ws -t upperLipMainCurve.cv[0]`;
$posB=`xform -q -ws -t lowerLipMainCurve.cv[0]`;
$pos[0]=0;$pos[1]=($posA[1]+$posB[1])/2.0;$pos[2]=($posA[2]+$posB[2])/2.0;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	asCreateFaceController ($upperLower+"LipRegion") "_M" 4;
	scale -r -p 0 0 0 5 5 5 ($upperLower+"LipRegion_M.cv[0:7]");
	scale -r -p 0 0 0 1 -1 1 ($upperLower+"LipRegion_M.cv[4:6]");
	if ($upperLower=="lower")
		rotate -r -p 0 0 0 -os 0 0 180 ($upperLower+"LipRegion_M.cv[0:7]");
	}


asCreateFaceController "LipRegion" "_M" 4;
//parent LipRegionOffset_M Regioncontrols;
scale -r -p 0 0 0 6 6 6 LipRegion_M.cv[0:7];
parent upperLipRegionOffset_M lowerLipRegionOffset_M LipRegion_M;
xform -ws -t 0 $pos[1] $pos[2] LipRegionOffset_M;
move -r 0 0 ($scale/10.0) LipRegion_M.cv[0:99] upperLipRegion_M.cv[0:99] lowerLipRegion_M.cv[0:99];


for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	//Create BuildCurves (based on ordered selection)
	for ($a=0;$a<3;$a++)
		{
		if ($a==0) $inOutMain="Inner";if ($a==1) $inOutMain="Outer";if ($a==2) $inOutMain="Main";

		$curveCmd="curve -d 1 ";
//		eval ("select "+`getAttr ("FaceFitLip"+$inOutMain+"."+$upperLower+"Selection")`);
		eval ("select "+`asGetFaceFitSelection ($upperLower+"Lip"+$inOutMain+"Curve")`);

		string $loopVtxs[]=`ls -sl -fl`;
		clear $completedVtxs;
//		$tempString[0]=`getAttr ("FaceFitLip"+$inOutMain+"."+$upperLower+"Selection")`;
		$tempString[0]=`asGetFaceFitSelection ($upperLower+"Lip"+$inOutMain+"Curve")`;
		$tempString=`stringToStringArray $tempString[0] " "`;
		select $tempString[0];
		for ($i=0;$i<size($loopVtxs);$i++)
			{
			$tempString=`ls -sl -fl`;
			if (size($tempString)==0)
				continue;
			$completedVtxs=`stringArrayCatenate $completedVtxs $tempString`;
			$pos=`xform -q -ws -t $tempString`;
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			$tempString=`ls -sl -fl`;
			for ($y=0;$y<size($tempString);$y++)
				if (!`stringArrayCount $tempString[$y] $loopVtxs`)
					select -d $tempString[$y];
			select -d $completedVtxs;
			}
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] ($upperLower+"Lip"+$inOutMain+"BuildCurve");
		parent ($upperLower+"Lip"+$inOutMain+"BuildCurve") LipConstruction;
		}
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;

	//Create Joints & CenterCurve
	$curveCmd="curve -d 1 ";
	for ($i=0;$i<$outerNumCv;$i++)
		{
		select LipJoints_M;
		joint -n ($upperLower+"LipJoint"+$i);
		$posA=`xform -q -ws -t ($upperLower+"LipOuterBuildCurve.cv["+$i+"]")`;
		$posB=`xform -q -ws -t ($upperLower+"LipInnerBuildCurve.cv["+$i+"]")`;
		$posC=`xform -q -ws -t ($upperLower+ "LipMainBuildCurve.cv["+$i+"]")`;
		$pos={(($posA[0]+$posB[0]+$posC[0])/3.0),(($posA[1]+$posB[1]+$posC[1])/3.0),(($posA[2]+$posB[2]+$posC[2])/3.0)};
		xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LipJoint"+$i);
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		}
	$tempString[0]=`eval ($curveCmd)`;
	rename $tempString[0] ($upperLower+"LipCenterBuildCurve");
	parent ($upperLower+"LipCenterBuildCurve") LipConstruction;
	}

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;

	//Mirror joints 
	for ($i=0;$i<$outerNumCv;$i++)
		{
		if ($i==0) $side="_M";
		else $side="_R";
	
		rename ($upperLower+"LipJoint"+$i) ($upperLower+"LipJoint"+$i+$side);
		if ($side=="_R")
			{
			duplicate -n ($upperLower+"LipJoint"+$i+"_L") ($upperLower+"LipJoint"+$i+"_R");
			$pos=`xform -q -ws -t ($upperLower+"LipJoint"+$i+"_L")`;
			xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] ($upperLower+"LipJoint"+$i+"_L");
			}
		}
	}

createNode -n LipFollicles -p LipSetup transform;
createNode -n LipZip -p LipSetup transform;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;

	//Ribbon
	duplicate -n ($upperLower+"LipCenterBuildCurve_L") ($upperLower+"LipCenterBuildCurve");
	setAttr ($upperLower+"LipCenterBuildCurve_L.sx") -1;
	attachCurve -ch 0 -n ($upperLower+"LipCenterBuildCurve_M") -rpo 0 -kmk 1 -m 1 -bb 0.5 -bki 0 -p 0.1 ($upperLower+"LipCenterBuildCurve_L") ($upperLower+"LipCenterBuildCurve");

	//LipZip
	duplicate -n ($upperLower+"LipZipCenterCurve_M") ($upperLower+"LipCenterBuildCurve_M");
	parent ($upperLower+"LipZipCenterCurve_M") LipSetup;

	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.000393701 ($upperLower+"LipCenterBuildCurve_M");
	offsetCurve -ch 1 -n ($upperLower+"LipCenterBuildCurveA_M") -rn false -cb 2 -st true -cl true -cr 0 -d ($scale/38.0)  -tol 1 -sd 5 -ugn false ($upperLower+"LipCenterBuildCurve_M");
	offsetCurve -ch 1 -n ($upperLower+"LipCenterBuildCurveB_M") -rn false -cb 2 -st true -cl true -cr 0 -d ($scale/-38.0) -tol 1 -sd 5 -ugn false ($upperLower+"LipCenterBuildCurve_M");
	loft -ch 0 -n ($upperLower+"LipCenterPlane") -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true ($upperLower+"LipCenterBuildCurveA_M") ($upperLower+"LipCenterBuildCurveB_M");
	parent ($upperLower+"LipCenterPlane") LipSetup;
	connectAttr -f ($upperLower+"LipCenterPlaneShape.worldSpace[0]") closestNurbsSampler.inputSurface;
	parent ($upperLower+"LipCenterBuildCurve_M") LipSetup;
	parent ($upperLower+"LipCenterBuildCurveA_M") ($upperLower+"LipCenterBuildCurveB_M") LipConstruction;

	for ($b=1;$b>-2;$b=$b-2)
		{
		for ($i=0;$i<$outerNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;

			$tempString[0]=`createNode follicle`;
			$tempString=`listRelatives -p $tempString[0]`;
			rename $tempString[0] ($upperLower+"follicle"+$i+$side);
			parent ($upperLower+"follicle"+$i+$side) LipFollicles;
			setAttr ($upperLower+"follicle"+$i+$side+".collide") 0;
			connectAttr ($upperLower+"LipCenterPlane.local") ($upperLower+"follicle"+$i+$side+".inputSurface");
			connectAttr ($upperLower+"LipCenterPlane.worldMatrix[0]") ($upperLower+"follicle"+$i+$side+".inputWorldMatrix");
			connectAttr -f ($upperLower+"follicle"+$i+$side+".outTranslate") ($upperLower+"follicle"+$i+$side+".t");
			connectAttr -f ($upperLower+"follicle"+$i+$side+".outRotate") ($upperLower+"follicle"+$i+$side+".r");

			$pos=`xform -q -ws -t ($upperLower+"LipJoint"+$i+$side)`;
			setAttr -type float3 closestNurbsSampler.inPosition $pos[0] $pos[1] $pos[2];
			setAttr ($upperLower+"follicle"+$i+$side+".parameterU") `getAttr closestNurbsSampler.parameterU`;
			setAttr ($upperLower+"follicle"+$i+$side+".parameterV") `getAttr closestNurbsSampler.parameterV`;
			pointConstraint ($upperLower+"follicle"+$i+$side) ($upperLower+"LipJoint"+$i+$side);
			orientConstraint ($upperLower+"follicle"+$i+$side) ($upperLower+"LipJoint"+$i+$side);

			//LipZip
			createNode -n ($upperLower+"LipZip"+$i+$side) -p LipZip transform;
			asAlign ($upperLower+"LipZip"+$i+$side) ($upperLower+"follicle"+$i+$side) 1 1 0 0;
			createNode -n ($upperLower+"LipZipPoci"+$i+$side) pointOnCurveInfo;
			connectAttr -f ($upperLower+"LipZipCenterCurve_M.worldSpace[0]") ($upperLower+"LipZipPoci"+$i+$side+".inputCurve");
			if ($side=="_L")
				$cv=(`getAttr ($upperLower+"LipZipCenterCurve_M.spans")`/2)-$i;
			else
				$cv=$i+(`getAttr ($upperLower+"LipZipCenterCurve_M.spans")`/2);
			
			setAttr ($upperLower+"LipZipPoci"+$i+$side+".parameter") $cv;
			connectAttr ($upperLower+"LipZipPoci"+$i+$side+".position") ($upperLower+"LipZip"+$i+$side+".t");

			$pos=`xform -q -ws -t ($upperLower+"follicle"+$i+$side) `;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LipZipCenterCurve_M.cv["+$cv+"]");

			pointConstraint ($upperLower+"LipZip"+$i+$side) ($upperLower+"LipJoint"+$i+$side);
			$factor=((1.0/$outerNumCv))*10;
			$cd="ctrlMouth_M.zip"+$side;
			if ($side=="_M")
				$cd="ctrlMouth_M.zip_R";
			setDrivenKeyframe -itt "flat" -ott "flat" -dv (10-($factor*0.8*$i)) -v 1 -cd $cd ($upperLower+"LipJoint"+$i+$side+"_pointConstraint1."+$upperLower+"LipZip"+$i+$side+"W1");
			setDrivenKeyframe -itt "flat" -ott "flat" -dv (10-(($factor*$i)+$factor)) -v 0 -cd $cd ($upperLower+"LipJoint"+$i+$side+"_pointConstraint1."+$upperLower+"LipZip"+$i+$side+"W1");
			setDrivenKeyframe -itt "flat" -ott "flat" -dv (10-($factor*0.8*$i)) -v 0 -cd $cd ($upperLower+"LipJoint"+$i+$side+"_pointConstraint1."+$upperLower+"follicle"+$i+$side+"W0");
			setDrivenKeyframe -itt "flat" -ott "flat" -dv (10-(($factor*$i)+$factor)) -v 1 -cd $cd ($upperLower+"LipJoint"+$i+$side+"_pointConstraint1."+$upperLower+"follicle"+$i+$side+"W0");

			}
		}
	}

//Bind
select `listRelatives -ad -type joint LipJoints_M`;
select -add LipJoints_M;
$tempString=`ls -sl`;
for ($i=0;$i<size($tempString);$i++)
	skinCluster -e  -dr 4 -lw false -wt 0 -ai $tempString[$i] $skinCluster;
setAttr LipJoints_M.lockInfluenceWeights 1;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;

	for ($b=1;$b>-2;$b=$b-2)
		{
		//Hard weights
		for ($a=0;$a<3;$a++)
			{
			if ($a==0) $inOutMain="Inner";if ($a==1) $inOutMain="Outer";if ($a==2) $inOutMain="Main";
	
			for ($i=0;$i<$outerNumCv;$i++)
				{
				if ($b==1) $side="_R";
				else $side="_L";
				if ($i==0) $side="_M";
				if ($i==0 && $b==-1) continue;

				$pos=`xform -q -ws -t ($upperLower+"Lip"+$inOutMain+"BuildCurve.cv["+$i+"]")`;
				setAttr -type float3 closestSampler.inPosition ($pos[0]*$b) $pos[1] $pos[2];
				select ($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
				catchQuiet (`skinPercent -tv ($upperLower+"LipJoint"+$i+$side) 1 $skinCluster`);
	
				if ($inOutMain=="Inner") $innerVtxNr[$i]=`getAttr closestSampler.result.closestVertexIndex`;
				if ($inOutMain=="Outer") $outerVtxNr[$i]=`getAttr closestSampler.result.closestVertexIndex`;
				if ($inOutMain=="Main") $mainVtxNr[$i]=`getAttr closestSampler.result.closestVertexIndex`;
				}
			}
	
		//shortestEdgePath vtxs
		for ($i=0;$i<$outerNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;

			select `polySelect -q -asSelectString -shortestEdgePath $outerVtxNr[$i] $mainVtxNr[$i]`;//outer -> main
			ConvertSelectionToVertices;
			catchQuiet (`skinPercent -tv ($upperLower+"LipJoint"+$i+$side) 1 $skinCluster`);
			select `polySelect -q -asSelectString -shortestEdgePath $innerVtxNr[$i] $mainVtxNr[$i]`;//inner -> main
			ConvertSelectionToVertices;
			catchQuiet (`skinPercent -tv ($upperLower+"LipJoint"+$i+$side) 1 $skinCluster`);
			}
		}
	}
//hammer any leftovers
select -cl;
for ($i=0;$i<size($lipArea);$i++)
	{
	if (`skinPercent -transform LipJoints_M -ignoreBelow 1 -query -value $skinCluster $lipArea[$i]`)
		select -add $lipArea[$i];
	}
if (size(`ls -sl`))
	weightHammerVerts;

copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;


//create clusters & pingPongs
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	for ($i=0;$i<7;$i++)
		{
		if ($i==0) {$ctrl="Lip";$side="_L";$type=1;}
		if ($i==1) {$ctrl=$upperLower+"LipB";$side="_L";$type=2;}
		if ($i==2) {$ctrl=$upperLower+"LipA";$side="_L";$type=2;}
		if ($i==3) {$ctrl=$upperLower+"Lip";$side="_M";$type=1;}
		if ($i==4) {$ctrl=$upperLower+"LipA";$side="_R";$type=2;}
		if ($i==5) {$ctrl=$upperLower+"LipB";$side="_R";$type=2;}
		if ($i==6) {$ctrl="Lip";$side="_R";$type=1;}

		select -r ($upperLower+"LipCenterPlane.cv["+$i+"][4]");

		$tempString=`newCluster " -envelope 1"`;
		rename $tempString[0] ($upperLower+$ctrl+"Cluster"+$side);
		rename $tempString[1] ($upperLower+$ctrl+"ClusterHandle"+$side);
		parent ($upperLower+$ctrl+"ClusterHandle"+$side) LipSetup;
		$tempString=`listConnections ($upperLower+$ctrl+"Cluster"+$side+".message")`;
		rename $tempString[0] ($upperLower+$ctrl+"ClusterSet"+$side);
		sets -add ($upperLower+$ctrl+"ClusterSet"+$side) ($upperLower+"LipCenterPlane.cv["+$i+"][0:3]");
		sets -add ($upperLower+$ctrl+"ClusterSet"+$side) ($upperLower+"LipCenterBuildCurve_M.cv["+$i+"]");

		if (`objExists TempPos`) delete TempPos;
		createNode -n TempPos transform;
//		$pos=`xform -q -ws -piv ($upperLower+$ctrl+"ClusterHandle"+$side)`;
//		xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
		if ($i<4)
			{
			createNode -n tempMotionPath motionPath;
			setAttr tempMotionPath.fractionMode 1;
			connectAttr ($upperLower+"LipOuterCurve.worldSpace") tempMotionPath.geometryPath;
			connectAttr tempMotionPath.allCoordinates TempPos.t;
			if ($i==1)//$libBShapePos
				{
				setAttr tempMotionPath.uValue 0.8;
				$libBShapePos=`xform -q -ws -t TempPos`;
				}
			if ($i==0) setAttr tempMotionPath.uValue 1;
			if ($i==1) setAttr tempMotionPath.uValue 1;
			if ($i==2) setAttr tempMotionPath.uValue 0.4;
			if ($i==3) setAttr tempMotionPath.uValue 0;
			$pos=`xform -q -ws -t TempPos`;
			delete tempMotionPath;
			xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] TempPos;
			}
		else
			{
			asAlign TempPos ($ctrl+"_L") 1 0 0 0;
			setAttr TempPos.tx (`getAttr TempPos.tx`*-1);
			}

		if (($i==0 || $i==6) && $upperLower=="lower")
			;//No need of controller
		else
			{
			asPingPong TempPos $ctrl 1 $side $type 1 0;
			parent ($ctrl+"Joint"+$side) FaceDeformationSystemFollowHead;
			parent ($ctrl+"Offset"+$side) ($upperLower+"LipRegion_M");
			}
		delete TempPos;

		if ($ctrl==$upperLower+"LipB")//$libBShapePos
			{
			$pos=`xform -q -ws -t ($ctrl+$side)`;
			if ($side=="_L") move -r (($libBShapePos[0]*-1)-$pos[0]) ($libBShapePos[1]-$pos[1]) ($libBShapePos[2]-$pos[2]) ($ctrl+$side+".cv[0:99]");
			if ($side=="_R") move -r (($libBShapePos[0]* 1)-$pos[0]) ($libBShapePos[1]-$pos[1]) ($libBShapePos[2]-$pos[2]) ($ctrl+$side+".cv[0:99]");

			asFacePlaceCtrlByProjection ($ctrl+$side);
			}

		parent ($upperLower+$ctrl+"ClusterHandle"+$side) ($ctrl+$side);
		setAttr -l 1 ($upperLower+$ctrl+"ClusterHandle"+$side+".v") 0;
		}
	}

//Press & Roll
if (`objExists TempPos`) delete TempPos;
createNode -n TempPos transform;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	addAttr -k 1 -ln press -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ($upperLower+"Lip_M");
	createNode -n ($upperLower+"LipPressPlusMinusAverage") plusMinusAverage;
	connectAttr ($upperLower+"Lip_M.press") ($upperLower+"LipPressPlusMinusAverage.input1D[0]");

	$lipPress={($upperLower+$upperLower+"LipClusterHandle"),($upperLower+$upperLower+"LipAClusterHandle"),($upperLower+$upperLower+"LipBClusterHandle"),($upperLower+"LipClusterHandle")};
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";

		for ($i=0;$i<size($lipPress);$i++)
			{
			if ($i==0) {if ($side=="_R") $side="_M";if ($side=="_L") continue;}
			else {if ($b==1) $side="_R";else $side="_L";}

			$currentValue=`getAttr ($lipPress[$i]+$side+".ty")`;
			$posA=`xform -q -ws -piv ($lipPress[$i]+$side)`;
			xform -ws -t $posA[0] $posA[1] $posA[2] TempPos;
			delete `geometryConstraint -weight 1 upperLipMainCurve TempPos`;
			$posB=`xform -q -ws -piv TempPos`;
			$deltaValue=$posB[1]-$posA[1];
			setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v $currentValue -cd ($upperLower+"Lip_M.press") ($lipPress[$i]+$side+".ty");
			setDrivenKeyframe -itt "linear" -ott "linear" -dv 10 -v ($currentValue+$deltaValue) -cd ($upperLower+"Lip_M.press") ($lipPress[$i]+$side+".ty");
			setAttr ($lipPress[$i]+$side+"_translateY.preInfinity") 4;
			setAttr ($lipPress[$i]+$side+"_translateY.postInfinity") 4;
			}
		}
	}
delete TempPos;

createNode -n ScaleLip_R -p LipSetup transform;connectAttr Lip_R.s ScaleLip_R.s;
createNode -n ScaleLip_L -p LipSetup transform;connectAttr Lip_L.s ScaleLip_L.s;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	addAttr -k 1 -ln roll -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ($upperLower+"Lip_M");
	createNode -n ($upperLower+"ScaleLip_M") -p LipSetup transform;connectAttr ($upperLower+"Lip_M.s") ($upperLower+"ScaleLip_M.s");
	createNode -n ($upperLower+"LipRollPlusMinusAverage") plusMinusAverage;
	connectAttr ($upperLower+"Lip_M.roll") ($upperLower+"LipRollPlusMinusAverage.input1D[0]");

	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;
	for ($b=1;$b>-2;$b=$b-2)
		{
		for ($i=0;$i<$outerNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;

			//Press
			createNode -n ($upperLower+"LipJoint"+$i+$side+"PressUnitConversion") unitConversion;
			setAttr ($upperLower+"LipJoint"+$i+$side+"PressUnitConversion.conversionFactor") (1*`smoothstep 0 1 (1-((1/($outerNumCv-1.0)*$i)))`);
			connectAttr ($upperLower+"LipPressPlusMinusAverage.output1D") ($upperLower+"LipJoint"+$i+$side+"PressUnitConversion.input");

			$setRange=$upperLower+"LipJoint"+$i+$side+"PressSetRange";
			createNode -n $setRange setRange;
			setAttr ($setRange+".minX") 2;
			setAttr ($setRange+".maxX") 0;
			setAttr ($setRange+".oldMinX") -10;
			setAttr ($setRange+".oldMaxX") 10;
			connectAttr ($upperLower+"LipJoint"+$i+$side+"PressUnitConversion.output") ($setRange+".value.valueX");
			connectAttr ($setRange+".outValue.outValueX") ($upperLower+"LipJoint"+$i+$side+".sz");

			//Roll
			createNode -n ($upperLower+"LipJoint"+$i+$side+"RollUnitConversion") unitConversion;
			setAttr ($upperLower+"LipJoint"+$i+$side+"RollUnitConversion.conversionFactor") ($upperLowerFactor*-0.15*`smoothstep 0 1 (1-((1/($outerNumCv-1.0)*$i)))`);
			connectAttr ($upperLower+"LipRollPlusMinusAverage.output1D") ($upperLower+"LipJoint"+$i+$side+"RollUnitConversion.input");
			connectAttr ($upperLower+"LipJoint"+$i+$side+"RollUnitConversion.output") ($upperLower+"LipJoint"+$i+$side+"_orientConstraint1.offsetX");
			}
		}
	}

//LipMix
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	createNode -n ("LipMix"+$side) -p ("LipSideReverse"+$side)  transform;
	parent ("upperLipClusterHandle"+$side) ("lowerLipClusterHandle"+$side) ("LipMix"+$side);
	}


//TeethCollider
if (`objExists TeethCollider`)
	{
	createNode -n TeethColliderSetup -p LipSetup transform;
	duplicate -n TeethCollider_M TeethCollider;
	parent TeethCollider_M lowerFace_M;
	connectAttr ctrlBox.TeethColliderVis TeethCollider_M.v;

	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";

// add teethSlide attrs
	addAttr -k 1 -ln teethSlide -at double -min 0 -max 10 -dv 10 ("Lip"+$side);
	setAttr ("Lip"+$side+".teethSlide") 0;
	asUnitConvertAndReverse ("TeethSlide"+$side) ("Lip"+$side+".teethSlide");

		createNode -n ("LipTeethSlideConstrained"+$side) -p ("LipSideReverse"+$side)  transform;
		geometryConstraint TeethCollider_M ("LipTeethSlideConstrained"+$side);
		normalConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("Lip"+$side) -worldUpVector 0 1 0 TeethCollider_M ("LipTeethSlideConstrained"+$side);
		pointConstraint ("Lip"+$side) ("LipTeethSlideConstrained"+$side);
		createNode -n ("LipTeethSlide"+$side) -p ("Lip"+$side)  transform;
		parent ("LipTeethSlide"+$side) ("LipTeethSlideConstrained"+$side);
//		createNode -n ("LipMix"+$side) -p ("LipDrive"+$side)  transform;
		parentConstraint ("Lip"+$side) ("LipTeethSlide"+$side) ("LipMix"+$side);
		connectAttr ("TeethSlide"+$side+"Reverse.outputX") ("LipMix"+$side+"_parentConstraint1.Lip"+$side+"W0");
		connectAttr ("TeethSlide"+$side+"UnitConversion.output") ("LipMix"+$side+"_parentConstraint1.LipTeethSlide"+$side+"W1");
		}
	}
else
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";

		parentConstraint ("Lip"+$side) ("LipMix"+$side);
		}
	}

//interdependent lip-ctrl behaviours
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";

		createNode -n ($upperLower+"LipBCnr"+$side) -p ($upperLower+"LipBSideReverse"+$side) transform;
		parent ($upperLower+"LipBDrive"+$side) ($upperLower+"LipBCnr"+$side);
		connectAttr ("LipMix"+$side+".t") ($upperLower+"LipBCnr"+$side+".t");
		connectAttr ("LipMix"+$side+".r") ($upperLower+"LipBCnr"+$side+".r");
//		parentConstraint ("Lip"+$side) ($upperLower+"LipBCnr"+$side);nope, break teethSlide

		//lipA to partially follow MiddleCtrol & lipB
		createNode -n ($upperLower+"LipBConstraintTo"+$side) -p FaceDeformationSystemFollowHead transform;
		asAlign ($upperLower+"LipBConstraintTo"+$side) ($upperLower+"LipB"+$side) 1 0 0 0;
		parentConstraint ($upperLower+"LipB"+$side) ($upperLower+"LipBConstraintTo"+$side);
		if ($side=="_R")
			setAttr -type float3 ($upperLower+"LipBConstraintTo"+$side+"_parentConstraint1.target[0].targetOffsetRotate") 180 0 0;
		parentConstraint -mo ($upperLower+"Lip_M") ($upperLower+"LipBConstraintTo"+$side) ($upperLower+"LipAOffset"+$side);
		}
	}

//Add attrs for mix of local xform with sdk
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	createNode -n ("LipWsOffset"+$side) -p ("Lip"+$side) transform;
	parent ("LipWsOffset"+$side) Acontrols;
	createNode -n ("LipWs"+$side) -p ("LipWsOffset"+$side) transform;
	pointConstraint ("LipMix"+$side) ("LipWs"+$side);
	
	for ($z=0;$z<size($xyz);$z++)
		{
		addAttr -k 0 -ln ("mixT"+$xyz[$z]) -at double ("Lip"+$side);
		connectAttr ("LipWs"+$side+".t"+$xyz[$z]) ("Lip"+$side+".mixT"+$xyz[$z]);
		}
	addAttr -k 0 -ln mixDist -at double ("Lip"+$side);
	createNode -n ("Lip"+$side+"Dist") distanceBetween;
	connectAttr -f ("Lip"+$side+".mixTx") ("Lip"+$side+"Dist.point1X");
	connectAttr -f ("Lip"+$side+".mixTy") ("Lip"+$side+"Dist.point1Y");
	connectAttr -f ("Lip"+$side+".mixTz") ("Lip"+$side+"Dist.point1Z");
	connectAttr -f ("Lip"+$side+"Dist.distance") ("Lip"+$side+".mixDist");
	}

//stretching of lips to drive `press` & `roll`
createNode -n LipDist distanceBetween;
createNode -n LipDistOffset -p FaceDeformationSystemFollowHead transform;
createNode -n LipStretch_R -p LipDistOffset transform;
createNode -n LipStretch_L -p LipDistOffset transform;
pointConstraint LipMix_R LipStretch_R;
pointConstraint LipMix_L LipStretch_L;
connectAttr LipStretch_R.tx LipDist.point1X;connectAttr LipStretch_R.ty LipDist.point1Y;connectAttr LipStretch_R.tz LipDist.point1Z;
connectAttr LipStretch_L.tx LipDist.point2X;connectAttr LipStretch_L.ty LipDist.point2Y;connectAttr LipStretch_L.tz LipDist.point2Z;
$lipDistOffsetScale=`getAttr LipDist.distance`/1.0;
setAttr -type float3 LipDistOffset.s $lipDistOffsetScale $lipDistOffsetScale $lipDistOffsetScale;
createNode -n LipDistMultiplyDivide multiplyDivide;
createNode -n LipPlusMinusAverage plusMinusAverage;
connectAttr -f LipDist.distance LipPlusMinusAverage.input1D[0];
setAttr LipPlusMinusAverage.input1D[1] (`getAttr LipDist.distance`*-1);
connectAttr LipPlusMinusAverage.output1D LipDistMultiplyDivide.input1X;
connectAttr ctrlMouth_M.lipStretchedSqueeze LipDistMultiplyDivide.input2X;
connectAttr -f LipDistMultiplyDivide.outputX upperLipPressPlusMinusAverage.input1D[1];
connectAttr -f LipDistMultiplyDivide.outputX lowerLipPressPlusMinusAverage.input1D[1];
connectAttr -f LipDistMultiplyDivide.outputX upperLipRollPlusMinusAverage.input1D[1];
connectAttr -f LipDistMultiplyDivide.outputX lowerLipRollPlusMinusAverage.input1D[1];

	//LipZip CenterCurves
duplicate -n LipCenterBuildCurve_M upperLipCenterBuildCurve_M;
select upperLipCenterBuildCurve_M lowerLipCenterBuildCurve_M LipCenterBuildCurve_M;
blendShape -n LipCenterBuildCurveBS_M;
setAttr LipCenterBuildCurveBS_M.lowerLipCenterBuildCurve_M 0.5;
setAttr LipCenterBuildCurveBS_M.upperLipCenterBuildCurve_M 0.5;

$tempString=`wire -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w LipCenterBuildCurve_M upperLipZipCenterCurve_M lowerLipZipCenterCurve_M`;
rename $tempString[0] LipZipWire;
setAttr LipZipWire.dropoffDistance[0] ($faceFitScale*4);
createNode -n LipZipWireScaleMultiplyDivide multiplyDivide;
if (`objExists Main`)
	connectAttr Main.sx LipZipWireScaleMultiplyDivide.input1X;
else
	setAttr LipZipWireScaleMultiplyDivide.input1X 1;
connectAttr ($headJoint+".sx") LipZipWireScaleMultiplyDivide.input2X;
connectAttr LipZipWireScaleMultiplyDivide.outputX LipZipWire.scale[0];

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	//tweak curves
	$pos=`xform -q -ws -t ("Lip"+$side)`;
	scale -r -p $pos[0] $pos[1] $pos[2] -0.7 1 1 ("Lip"+$side+".cv[2:5]");
	scale -r -p $pos[0] $pos[1] $pos[2]  2 2 2 ("Lip"+$side+".cv[0:7]");
	scale -r -p $pos[0] $pos[1] $pos[2] 1 0.5 1 ("Lip"+$side+".cv[0]") ("Lip"+$side+".cv[2]") ("Lip"+$side+".cv[4]") ("Lip"+$side+".cv[6]");

	//Lip_R/_L scale
	connectAttr ("Lip"+$side+".s") ("lowerLipBCnr"+$side+".s");
	connectAttr ("Lip"+$side+".s") ("upperLipBCnr"+$side+".s");
	}


delete LipConstruction;

select -cl;
setToolTo $gSelect;
}

global proc asFaceLipFalloff ()
{
global string $gMove;
global string $gMainProgressBar;
int $test;
int $lipFalloffInsideMouth=`intField -q -v lipFalloffInsideMouthIntField`;
float $pos[],$posA[],$posB[];
float $lipCnrPos[],$lipAPos[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $tempString[],$lipFalloffInsideMouthArea[];

if (`objExists asFaceLipFalloffTest`)
	{
	$test=1;
	delete asFaceLipFalloffTest;
	}

setFocus MayaWindow;//ensure execution of intField -cc cmd, if focus is still at intField
int $vtxsFromLipToNose=3;
if (`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	$vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;


if (`objExists lipFalloffArea`) delete lipFalloffArea;
if (`objExists lipFalloffInsideMouthArea`) delete lipFalloffInsideMouthArea;
createNode -n lipFalloffArea objectSet;
sets -add FaceAreas lipFalloffArea;
if (!`objExists lipFalloffAreaMax`)
	{
	createNode -n lipFalloffAreaMax objectSet;
	sets -add FaceBuildingSets lipFalloffAreaMax;
	}

duplicate -n upperLipOuterCurve_L upperLipOuterCurve;
duplicate -n lowerLipOuterCurve_L lowerLipOuterCurve;
setAttr upperLipOuterCurve_L.sx -1;
setAttr lowerLipOuterCurve_L.sx -1;

eval ("select "+`asGetFaceFitSelection upperLipOuterCurve`);
string $upperOuterVtxs[]=`ls -sl -fl`;
eval ("select "+`asGetFaceFitSelection lowerLipOuterCurve`);
string $lowerOuterVtxs[]=`ls -sl -fl`;

eval ("select "+`asGetFaceFitSelection upperLipOuterCurve_L`);
string $upperOuterVtxsL[]=`ls -sl -fl`;
eval ("select "+`asGetFaceFitSelection lowerLipOuterCurve_L`);
string $lowerOuterVtxsL[]=`ls -sl -fl`;

//symmetricModelling -symmetry 1 -about "world" -axis "x";
select $upperOuterVtxs $lowerOuterVtxs $upperOuterVtxsL $lowerOuterVtxsL;
//symmetricModelling -symmetry 0;

for ($i=0;$i<$vtxsFromLipToNose-1;$i++)
	polySelectConstraint -pp 1 -t 0x0001;
if (`objExists lipArea`)
	select -d lipArea;
sets -add lipFalloffArea `ls -sl`;
sets -add lipFalloffAreaMax `ls -sl`;

eval ("select "+`asGetFaceFitSelection upperLipInnerCurve`);
$upperOuterVtxs=`ls -sl -fl`;
eval ("select -add "+`asGetFaceFitSelection lowerLipInnerCurve`);
$lowerOuterVtxs=`ls -sl -fl`;
for ($i=0;$i<$lipFalloffInsideMouth;$i++)
	polySelectConstraint -pp 1 -t 0x0001;
select -d lipArea;
$lipFalloffInsideMouthArea=`ls -sl`;

sets -n lipFalloffInsideMouthArea;
sets -add FaceAreas lipFalloffInsideMouthArea;

//Check if Smile-Crease and Smile-Line Overlap
if (`objExists SmileCreaseCurve`)
	{
	eval ("select "+`asGetFaceFitSelection SmileCreaseCurve`);
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	for ($i=0;$i<size($tempString);$i++)
		if (`sets -im lipFalloffArea $tempString[$i]`)
			{
			warning "LipFalloff overlaps with SmileCrease, it is recommended that you reduce the \"LipFalloff:Outside\" number, or make a \"wider\" SmileCrease.";
			break;
			}
	}

select lipFalloffArea;
select -add $lipFalloffInsideMouthArea;
refresh;

if ($test)
	return;

//flood to head first, as rhis function might have ran previously with a larger falloff
select lipFalloffAreaMax;
catchQuiet (`skinPercent -tv $headJoint 1 $skinCluster `);

$lipCnrPos=`xform -q -ws -t Lip_R`;
$lipAPos=`xform -q -ws -t upperLipA_R`;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 upperLipA_R lowerLipA_R Lip_R;

$tempString=`ls -sl -fl`;
progressBar -e -st "Lip Falloff" -bp -ii 0 -min 0 -max ((`size($tempString)`/2)+1) $gMainProgressBar;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	select $tempString[$i];
	progressBar -e -s 1 $gMainProgressBar;
	for ($y=0;$y<99;$y++)
		{
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		$tempString2=`ls -sl -fl`;
		for ($z=0;$z<size($tempString2);$z++)
			{
			if (`sets -im lipArea $tempString2[$z]`)
				{
				select $tempString2[$z];
//				refresh;
				$tempString3=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster`;
				$inf=$tempString3[0];
				$weight=1-((1.0/$vtxsFromLipToNose)*($y+1));

				catchQuiet (`skinPercent -tv $inf $weight $skinCluster $tempString[$i]`);
				$y=999;
				$z=999;
				}
			}
		}
	}
progressBar -e -ep $gMainProgressBar;

//just hammer inside
select $lipFalloffInsideMouthArea;
if (size(`ls -sl`))
	weightHammerVerts;

select upperLipA_R;
setToolTo $gMove;
}

global proc asFaceJaw ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`asFaceGetScale`;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $pos[],$pos2[],$posA[],$posB[];
string $tempString[],$lipCtrl[],$lipSide[],$lipUpLo[];
string $xyz[]={"x","y","z"};
string $trs[]={"t","r","s"};
string $upLoCtrl,$side;

//Existing Jaw ?
if (`objExists Jaw_M`)
	error "Jaw_M already exists, can not build new Jaw, remove old jaw first";

//Keep lipFalloffWeight weighting, for later combinage
$weighMesh="lipFalloffWeights";
polyCube -n lipFalloffWeights -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
connectAttr -f ($geometry+".outMesh") lipFalloffWeights.inMesh;
refresh;
disconnectAttr ($geometry+".outMesh") lipFalloffWeights.inMesh;
parent lipFalloffWeights FaceBuildInProgress;
select lipFalloffWeights `listConnections ($skinCluster+".matrix")`;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] lipFalloffWeightsSC;
select $geometry lipFalloffWeights;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

setAttr ControlsSetup.v 0;
setAttr lowerLipOffset_M.v 0;

//create joints
select -cl;
joint -n JawJoint_M;
parent JawJoint_M lowerFaceJoint_M;
//joint -n Chin_M;

$curve=`curve -d 1 -p -3 0 0 -p -1 0 -1 -p 0 0 -3 -p 1 0 -1 -p 3 0 0 -p 1 0 1 -p 0 0 3 -p -1 0 1 -p -3 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8`;
rename $curve Jaw_M;
move -r 0 0 5.3 Jaw_M.cv[2];
move -r 0 0 1.5 Jaw_M.cv[1] Jaw_M.cv[3];
rotate -r -p 0 0 0 -os 90 0 0 Jaw_M.cv[0:8];
sets -add FaceControlSet Jaw_M;
setAttr Jaw_MShape.overrideEnabled 1;
setAttr Jaw_MShape.overrideColor 17;
//setAttr -type float3 Jaw_M.s ($scale/6.0) ($scale/6.0) ($scale/6.0);
//makeIdentity -a 1 -t 0 -r 0 -s 1 Jaw_M;
createNode -n OffsetJaw_M transform;
createNode -n SDK1Jaw_M -p OffsetJaw_M transform;
parent Jaw_M SDK1Jaw_M;
setAttr -type float3 OffsetJaw_M.s ($faceFitScale/10.0) ($faceFitScale/10.0) ($faceFitScale/10.0);
$pos=`xform -q -ws -t JawPivot`;
xform -ws -t 0 $pos[1] $pos[2] OffsetJaw_M;

parentConstraint Jaw_M JawJoint_M;
scaleConstraint Jaw_M JawJoint_M;

$pos=`xform -q -ws -t Jaw`;
$pos2=`xform -q -ws -t Jaw_M`;
move -r 0 ($pos[1]-$pos2[1]) ($pos[2]-$pos2[2]) Jaw_M.cv[0:8];

string $upperLower,$upperLowerTeeth;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$upperLowerTeeth=$upperTeeth;}
	else {$upperLower="lower";$upperLowerTeeth=$lowerTeeth;}

	if ($upperLowerTeeth!="")
		{
		eval ("select "+$upperLowerTeeth);
		$tempString=`ls -sl -o`;
		if (size($tempString)>1)
			select $tempString[0];
		float $bb[]=`xform -q -ws -bb`;

		select -cl;
		joint -n ($upperLower+"TeethJoint_M");
//		parent ($upperLower+"TeethJoint_M") ($upperLower+"FaceJoint_M");
		parent ($upperLower+"TeethJoint_M") lowerFaceJoint_M;

//		createNode -n ($upperLower+"TeethOffset_M") -p ($upperLower+"Face_M") transform;
		createNode -n ($upperLower+"TeethOffset_M") -p lowerFace_M transform;

		xform -ws -t 0 (($bb[1]+$bb[4])/2.0) (($bb[2]+$bb[5])/2.0) ($upperLower+"TeethOffset_M");

		$tempString=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 4 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
		rename $tempString[0] ($upperLower+"Teeth_M");
		parent -r ($upperLower+"Teeth_M") ($upperLower+"TeethOffset_M");
		scale (($bb[3]-$bb[0])/$faceFitScale) 1 (($bb[5]-$bb[2])/$faceFitScale) ($upperLower+"Teeth_M.cv[0:7]");
		sets -add FaceControlSet ($upperLower+"Teeth_M");
		setAttr ($upperLower+"Teeth_MShape.overrideEnabled") 1;
		setAttr ($upperLower+"Teeth_MShape.overrideColor") 17;
		connectAttr ctrlBox.TeethCtrlVis ($upperLower+"Teeth_MShape.overrideVisibility");

		if ($upperLower=="lower")
			{
			createNode -n lowerTeethStatic_M -p Jaw_M transform;
			parent lowerTeethStatic_M lowerFace_M;
			duplicate -n lowerTeethBlend_M  lowerTeethStatic_M ;
			parentConstraint lowerTeethStatic_M  Jaw_M lowerTeethBlend_M;
			scaleConstraint lowerTeethStatic_M  Jaw_M lowerTeethBlend_M;
			parent lowerTeethOffset_M lowerTeethBlend_M;
			addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 lowerTeeth_M;
			asUnitConvertAndReverse lowerTeethBlend lowerTeeth_M.follow;
			connectAttr lowerTeethBlendReverse.outputX lowerTeethBlend_M_parentConstraint1.lowerTeethStatic_MW0;
			connectAttr lowerTeethBlendReverse.outputX lowerTeethBlend_M_scaleConstraint1.lowerTeethStatic_MW0;
			connectAttr lowerTeethBlendUnitConversion.output lowerTeethBlend_M_parentConstraint1.Jaw_MW1;
			connectAttr lowerTeethBlendUnitConversion.output lowerTeethBlend_M_scaleConstraint1.Jaw_MW1;
			}

		parentConstraint ($upperLower+"Teeth_M") ($upperLower+"TeethJoint_M");
		scaleConstraint ($upperLower+"Teeth_M") ($upperLower+"TeethJoint_M");
		}
	}

setAttr JawJoint_M.segmentScaleCompensate 0;
if (`objExists upperTeethJoint_M`)
	setAttr upperTeethJoint_M.segmentScaleCompensate 0;
if (`objExists lowerTeethJoint_M`)
setAttr lowerTeethJoint_M.segmentScaleCompensate 0;

asSkinTeeth;

//Skin jaw-curves
select Face_M JawJoint_M JawCurve;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] JawCurveSC;

skinCluster -e -lw false -wt 0 -ai JawJoint_M $skinCluster;

//if teeth part of Main mesh, temporarily weight teeth to jaw
if (`gmatch $lowerTeeth ($geometry+"*")` && `gmatch $lowerTeeth "*[.]*"`)
	{
	eval ("select "+$lowerTeeth);
	skinPercent -tv JawJoint_M 1 $skinCluster `ls -sl`;
	}

//Create the JawOpenRegion mesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
if (`objExists tempTargetFullMesh`)
	duplicate -n JawOpenRegion tempTargetFullMesh;
else
	duplicate -n JawOpenRegion tempTarget;
setAttr JawOpenRegion.v 1;
parent -w JawOpenRegion;
sets -e -forceElement initialShadingGroup JawOpenRegion;
select JawOpenRegion $headJoint JawJoint_M;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] JawOpenRegionSC;
skinPercent -tv $headJoint 1 JawOpenRegionSC JawOpenRegion.vtx[0:99999];

select `asobjSetCast lipArea {} JawOpenRegion`;
sets -n lipAreaJawOpenRegion;
sets -add FaceBuildingSets lipAreaJawOpenRegion;

$lipCtrl={"LipRegion","LipB","LipB","LipB","LipB","Lip","Lip"};
$lipSide={"_M","_R","_L","_R","_L","_M","_M"};
$lipUpLo={"","upper","upper","lower","lower","upper","lower"};
float $lipDv[]={5,3,3,6,6,0,10};
float $rangeMinV[]={0,3,3,3,3,6,6};
float $rangeMaxV[]={3,6,6,6,6,10,10};
for ($i=0;$i<size($lipCtrl);$i++)
	{
	$upLoCtrl=$lipUpLo[$i]+$lipCtrl[$i];
	$side=$lipSide[$i];

	if (!`attributeExists $upLoCtrl Jaw_M`)
		{
		addAttr -k 1 -ln $upLoCtrl -at double -min 0 -max 10 -dv $lipDv[$i] Jaw_M;
		asUnitConvertAndReverse $upLoCtrl ("Jaw_M."+$upLoCtrl);
		}

	//LipJawFollow
	createNode -n ($upLoCtrl+"JawFollowOffset"+$side) -p ($upLoCtrl+"Offset"+$side) transform;
	createNode -n ($upLoCtrl+"JawFollow"+$side) -p ($upLoCtrl+"JawFollowOffset"+$side) transform;
	createNode -n ($upLoCtrl+"JawFollowLocal"+$side) -p ($upLoCtrl+"Offset"+$side) transform;
	parent ($upLoCtrl+"SideReverse"+$side) ($upLoCtrl+"JawFollowLocal"+$side);
	parentConstraint -mo Jaw_M OffsetJaw_M ($upLoCtrl+"JawFollow"+$side);

	//seal
	createNode -n ($upLoCtrl+"Blend"+$side) blendColors;
	setAttr ($upLoCtrl+"Blend"+$side+".color1R") 0.5;
	setAttr ($upLoCtrl+"Blend"+$side+".color1G") 0.5;
	connectAttr ($upLoCtrl+"UnitConversion.output") ($upLoCtrl+"Blend"+$side+".color2.color2R");
	connectAttr ($upLoCtrl+"Reverse.outputX") ($upLoCtrl+"Blend"+$side+".color2.color2G");
//	connectAttr sealUnitConversion.output ($upLoCtrl+"Blend"+$side+".blender");

	createNode -n ($upLoCtrl+"SetRange"+$side) setRange;
	setAttr ($upLoCtrl+"SetRange"+$side+".minX") 0;
	setAttr ($upLoCtrl+"SetRange"+$side+".maxX") 1;
	setAttr ($upLoCtrl+"SetRange"+$side+".oldMinX") $rangeMinV[$i];
	setAttr ($upLoCtrl+"SetRange"+$side+".oldMaxX") $rangeMaxV[$i];
	if ($side=="_M")
		{
		rename ($upLoCtrl+"SetRange"+$side) ($upLoCtrl+"SetRange_R"+$side);
		duplicate -n ($upLoCtrl+"SetRange_L"+$side) ($upLoCtrl+"SetRange_R"+$side);
		connectAttr ctrlMouth_M.zip_R ($upLoCtrl+"SetRange_R"+$side+".value.valueX");
		connectAttr ctrlMouth_M.zip_L ($upLoCtrl+"SetRange_L"+$side+".value.valueX");
		createNode -n ($upLoCtrl+"BlendTwo"+$side) blendTwoAttr;
		setAttr ($upLoCtrl+"BlendTwo"+$side+".attributesBlender") 0.5;
		connectAttr ($upLoCtrl+"SetRange_R"+$side+".outValueX") ($upLoCtrl+"BlendTwo"+$side+".input[0]");
		connectAttr ($upLoCtrl+"SetRange_L"+$side+".outValueX") ($upLoCtrl+"BlendTwo"+$side+".input[1]");
		connectAttr ($upLoCtrl+"BlendTwo"+$side+".output") ($upLoCtrl+"Blend"+$side+".blender");
		}
	else
		{
		connectAttr ("ctrlMouth_M.zip"+$side) ($upLoCtrl+"SetRange"+$side+".value.valueX");
		connectAttr ($upLoCtrl+"SetRange"+$side+".outValue.outValueX") ($upLoCtrl+"Blend"+$side+".blender");
		}

	connectAttr ($upLoCtrl+"Blend"+$side+".output.outputR") ($upLoCtrl+"JawFollow"+$side+"_parentConstraint1.Jaw_MW0");
	connectAttr ($upLoCtrl+"Blend"+$side+".output.outputG") ($upLoCtrl+"JawFollow"+$side+"_parentConstraint1.OffsetJaw_MW1");

	if ($upLoCtrl=="LipRegion")
		parent ($upLoCtrl+"JawFollowOffset"+$side) FaceDeformationSystemFollowHead;
	else
		parent ($upLoCtrl+"JawFollowOffset"+$side) LipRegionJawFollow_M;

	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			connectAttr ($upLoCtrl+"JawFollow"+$side+"."+$trs[$y]+$xyz[$z]) ($upLoCtrl+"JawFollowLocal"+$side+"."+$trs[$y]+$xyz[$z]);
	}
//scaleConstraint lowerFace_M LipRegionJawFollowLocal_M;
scaleConstraint lowerFace_M LipRegionJawFollow_M;

asFaceDesignMouthOpen;
asFaceWeightLips;
asFaceUpdateJawCurvesWeights;

parent -w FaceFitJawCurves;
parent JawOpenRegion LipDeform mouthOpenSoftModHandle FaceBuildInProgress;

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;

currentTime 30;
select Jaw_M;
autoKeyframe -st 1;
}

global proc asFaceJawFinish ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $lipInf;
string $sel[]=`ls -sl`;
string $tempString[],$infs[],$infJoints[];
float $values[];
float $jawHeadWeight,$lipValue;

currentTime 0 ;

delete JawOpenRegionDeleteComponent LipDeformations mouthOpenSoftModHandle JawCurveSC;
parent FaceFitJawCurves FaceFitSkeleton;

setAttr ControlsSetup.v 1;
setAttr lowerLipOffset_M.v 1;
parent OffsetJaw_M lowerFace_M;
delete JawOpenRegion;

//change the jaw animation to SDK
currentTime 30;
delete `listConnections -s 1 -d 0 -type animCurve Jaw_M`;
delete `listConnections -s 1 -d 0 -type animCurve ctrlMouth_M`;
asFaceBsSdk ctrlMouth_M.ty 0 SDK1Jaw_M.ty 0;asFaceBsSdk ctrlMouth_M.ty -1 SDK1Jaw_M.ty `getAttr Jaw_M.ty`;
asFaceBsSdk ctrlMouth_M.ty 0 SDK1Jaw_M.tz 0;asFaceBsSdk ctrlMouth_M.ty -1 SDK1Jaw_M.tz `getAttr Jaw_M.tz`;
asFaceBsSdk ctrlMouth_M.ty 0 SDK1Jaw_M.rx 0;asFaceBsSdk ctrlMouth_M.ty -1 SDK1Jaw_M.rx `getAttr Jaw_M.rx`;
if (`getAttr Jaw_M.sx`!=1 || `getAttr Jaw_M.sy`!=1 || `getAttr Jaw_M.sz`!=1)
	{
	asFaceBsSdk ctrlMouth_M.ty 0 SDK1Jaw_M.sx 1;asFaceBsSdk ctrlMouth_M.ty -1 SDK1Jaw_M.sx `getAttr Jaw_M.sx`;
	asFaceBsSdk ctrlMouth_M.ty 0 SDK1Jaw_M.sy 1;asFaceBsSdk ctrlMouth_M.ty -1 SDK1Jaw_M.sy `getAttr Jaw_M.sy`;
	asFaceBsSdk ctrlMouth_M.ty 0 SDK1Jaw_M.sz 1;asFaceBsSdk ctrlMouth_M.ty -1 SDK1Jaw_M.sz `getAttr Jaw_M.sz`;
	}

setAttr -l 0 Jaw_M.tx;
setAttr -l 0 Jaw_M.ry;
setAttr -l 0 Jaw_M.rz;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 Jaw_M;
currentTime 0 ;

//Unlock influences
$infJoints=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($infJoints);$i++)
	setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;

//Mix-in lipFalloffWeights
//select lipFalloffArea;
select lipArea lipFalloffArea lipFalloffInsideMouthArea;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	$lipFalloffWeightsVtx=`substitute $geometry $tempString[$i] lipFalloffWeights`;
	$infs=`skinPercent -ignoreBelow 0.0000001 -q -t lipFalloffWeightsSC $lipFalloffWeightsVtx`;
	$values=`skinPercent -ignoreBelow 0.0000001 -q -v lipFalloffWeightsSC $lipFalloffWeightsVtx`;
	$lipInf="";
	for ($y=0;$y<size($infs);$y++)
		{
		if ($infs[$y]==$headJoint)
			continue;
		$lipInf=$infs[$y];
		$lipValue=$values[$y];
		catchQuiet (`skinPercent -tv $lipInf $lipValue $skinCluster $tempString[$i]`);
		}
//	if ($lipInf!="")
//		catchQuiet (`skinPercent -tv $lipInf $lipValue $skinCluster $tempString[$i]`);
	}

select $geometry;
copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//delete lipFalloffWeights;
catchQuiet (`select $sel`);
}

global proc asFaceNose ()
{
float $pos[],$posA[],$posB[];
float $falloffRadius,$noseUnderFalloffRadius;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;

asPingPong Nose Nose 1 "_M" 1 1 0;
asPingPong NoseUnder NoseUnder 1 "_M" 3 1 0;
asPingPong Nose NoseRegion 1 "_M" 4 1 0;
parent NoseJoint_M NoseUnderJoint_M NoseRegionJoint_M;
parent NoseRegionJoint_M middleFaceJoint_M;

parent NoseOffset_M NoseUnderOffset_M NoseRegion_M;
parent NoseRegionOffset_M middleFace_M;
skinCluster -e -dr 4 -lw false -wt 0 -ai NoseJoint_M -ai NoseUnderJoint_M -ai NoseRegionJoint_M $skinCluster;
//connectAttr ctrlBox.RegionCtrlVis NoseRegion_MShape.overrideVisibility;

$pos=`xform -q -ws -t Nose`;
scale -r -p $pos[0] $pos[1] $pos[2] 3 3 3 NoseRegion_M.cv[0:7];
$posA=$pos;
$posB=`xform -q -ws -t NoseCorner`;
$falloffRadius=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
$posA=`xform -q -ws -t NoseUnder`;
$posB=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
$noseUnderFalloffRadius=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
asSkinWeightBySoftMod NoseRegionJoint_M $geometry $skinCluster ($falloffRadius*2) 1;
asSkinWeightBySoftMod NoseUnderJoint_M $geometry $skinCluster $noseUnderFalloffRadius 1;
asSkinWeightBySoftMod NoseJoint_M $geometry $skinCluster $falloffRadius 1;

select Nose_M;
}

global proc asFaceSmileCrease ()
{
int $numVtx,$lipOuterSpans;
int $tempInts[];
float $dist,$maxDist;
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
float $NoseCornerPos[]=`xform -q -ws -t NoseCorner`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $weighMesh,$nearVtx1,$nearVtx2,$side,$ab,$upperLower,$lipCurve;
string $smileCreaseVtxs[],$lipFalloffInsideMouthArea[],$fullWeighVtxs[],$creaseJoints[],$infJoints[],$tempString[];

if (!`objExists FaceFitSmileCrease`)
	return;

eval ("select "+`asGetFaceFitSelection SmileCreaseCurve`);
ConvertSelectionToVertices;
$smileCreaseVtxs=`ls -sl -fl`;

if (`objExists closestSamplerFitSelection`) delete closestSamplerFitSelection;
createNode -n closestSamplerFitSelection closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSamplerFitSelection.inMesh;

//Crease-create
if (`objExists TempPos`) delete TempPos;
createNode -n TempPos transform;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	for ($i=0;$i<7;$i++)
		{
		if ($i==0) {$ab="";$side="_R";}
		if ($i==1) {$ab="B";$side="_R";}
		if ($i==2) {$ab="A";$side="_R";}
		if ($i==3) {$ab="";$side="_M";}
		if ($i==4) {$ab="A";$side="_L";}
		if ($i==5) {$ab="B";$side="_L";}
		if ($i==6) {$ab="";$side="_L";}
		if ($i==0 || $i==6)
			{
			$upperLower="";
			if ($upperLowerFactor==-1)
				continue;
			$lipCurve="upperLipOuterCurve";
			}
		else
			{
			if ($upperLowerFactor==1) $upperLower="upper";
			else $upperLower="lower";
			$lipCurve=$upperLower+"LipOuterCurve";
			}

		if ($side=="_M" && $upperLower=="upper") // do not need upperCrease_M ctrl, as we have NoseUnder_M ctrl
			continue;

		$lipOuterSpans=`getAttr ($lipCurve+".spans")`;

		if ($side=="_L")
			{
			$pos=`xform -q -ws -t ($upperLower+"Crease"+$ab+"_R")`;
			xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] TempPos;
			}
		else
			{
			if ($i==0 || $i==6)
				$pos=`xform -q -ws -t ($lipCurve+".cv["+$lipOuterSpans+"]")`;
			if ($i==1 || $i==5)
				$pos=`xform -q -ws -t ($lipCurve+".cv["+(($lipOuterSpans*2)/3)+"]")`;
			if ($i==2 || $i==4)
				$pos=`xform -q -ws -t ($lipCurve+".cv["+(($lipOuterSpans*1)/3)+"]")`;
			if ($i==3)
				$pos=`xform -q -ws -t ($lipCurve+".cv[0]")`;
			setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
			select ($geometry+".vtx["+`getAttr closestSamplerFitSelection.result.closestVertexIndex`+"]");

			for ($y=0;$y<25;$y++)
				{
				ConvertSelectionToEdges;
				ConvertSelectionToVertices;
				$tempString=`ls -sl -fl`;
				for ($z=0;$z<size($tempString);$z++)
					if (`stringArrayCount $tempString[$z] $smileCreaseVtxs`)
						{
						$pos=`xform -q -ws -t $tempString[$z]`;
						$y=99;
						break;
						}
				}
			if ($side=="_M")
				$pos[0]=0;

			//avoid A&B at the same place
			if ($ab=="B")
				{
				$posA=`xform -q -ws -t SmileCreaseCurve.cv[0]`;
				$posB=$pos;
				if (`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`<0.01)
					$pos=`xform -q -ws -t SmileCreaseCurve.cv[1]`;
				}

			xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
			}

		asPingPong TempPos ($upperLower+"Crease"+$ab) 1 $side 3 1 1;
		$creaseJoints[size($creaseJoints)]=$upperLower+"Crease"+$ab+"Joint"+$side;

		//For the crease ctrls that are not "Driven"
		if ($ab=="A" || $side=="_M")
			{
			if (`objExists ($upperLower+"Lip"+$ab+"JawFollowLocal"+$side)`)
				parent ($upperLower+"Crease"+$ab+"Offset"+$side) ($upperLower+"Lip"+$ab+"JawFollowLocal"+$side);
			else if (`objExists ($upperLower+"LipRegionJawFollowLocal_M")`)
				parent ($upperLower+"Crease"+$ab+"Offset"+$side) ($upperLower+"LipRegionJawFollowLocal_M");
			else
				parent ($upperLower+"Crease"+$ab+"Offset"+$side) ($upperLower+"LipJawFollowLocal_M");
			}
		}
	}

select $smileCreaseVtxs;
ConvertSelectionToContainedEdges;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	duplicateCurve -ch 0 -rn 0 -local 0 $tempString[$i];
	}
select `ls "|duplicatedCurve*"`;
attachCurve -n creaseCurve -ch 0 -rpo 0 -kmk 1 -m 1 -bb 0.5 -bki 0 -p 0.1;
delete `ls "|duplicatedCurve*"`;

//ensure .cv[0] is at top
$posA=`xform -q -ws -t creaseCurve.cv[0]`;
$posB=`xform -q -ws -t creaseCurve.cv[99]`;
if ($posB[1]>$posA[1])
	reverseCurve -ch 0 -rpo 1 creaseCurve;

offsetCurve -n creaseCurveOffset -ch 0 -rn false -cb 2 -st true -cl true -cr 0 -d ($scale*-0.001) -tol 0.01 -sd 5 -ugn false creaseCurve;
loft -n creaseLoft -ch 0 -u 1 -c 0 -ar 0 -d 1 -ss 1 -rn 0 -po 0 -rsn true creaseCurve creaseCurveOffset;
nurbsToPoly -n creaseMesh -mnd 1  -ch 1 -f 2 -pt 1 -pc 200 -chr 0.1 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.01 -es 0 -ntr 0 -mrt 0 -uss 1 creaseLoft;
parent creaseMesh FaceBuildInProgress;
delete creaseLoft creaseCurve creaseCurveOffset;
select creaseMesh $headJoint $creaseJoints;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] creaseMeshSC;

//crease-weighting
skinPercent -tv $headJoint 1 creaseMeshSC creaseMesh;
$tempInts=`polyEvaluate -v creaseMesh`;
$numVtx=$tempInts[0];
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	for ($i=0;$i<7;$i++)
		{
		if ($i==0) {$ab="";$side="_L";}
		if ($i==1) {$ab="B";$side="_L";}
		if ($i==2) {$ab="A";$side="_L";}
		if ($i==3) {$ab="";$side="_M";}
		if ($i==4) {$ab="A";$side="_R";}
		if ($i==5) {$ab="B";$side="_R";}
		if ($i==6) {$ab="";$side="_R";}
		if ($i==0 || $i==6)
			{
			$upperLower="";
			if ($upperLowerFactor==-1)
				continue;
			}
		else
			{
			if ($upperLowerFactor==1) $upperLower="upper";
			else $upperLower="lower";
			}

		if ($side=="_M" && $upperLower=="upper") // do not need upperCrease_M ctrl, as we have NoseUnder_M ctrl
			continue;

		$posB=`xform -q -ws -t ($upperLower+"Crease"+$ab+$side)`;
		for ($a=0;$a<2;$a++)
			{
			$maxDist=999;
			for ($y=0;$y<$numVtx;$y++)
				{
				$posA=`xform -q -ws -t ("creaseMesh.vtx["+$y+"]")`;
				$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
				if ($dist<$maxDist && ("creaseMesh.vtx["+$y+"]")!=$nearVtx1)
					{
					$maxDist=$dist;
					if ($a==0) $nearVtx1="creaseMesh.vtx["+$y+"]";
					if ($a==1) $nearVtx2="creaseMesh.vtx["+$y+"]";
					}
				}
			}
		skinPercent -tv ($upperLower+"Crease"+$ab+"Joint"+$side) 1 creaseMeshSC $nearVtx1 $nearVtx2;
		$fullWeighVtxs[size($fullWeighVtxs)]=$nearVtx1;
		$fullWeighVtxs[size($fullWeighVtxs)]=$nearVtx2;
		}
	}

//the top .vtx[0] & .vtx[3], might not be exactly On upperCreaseA_R location.
$tempString=`skinPercent -query -t creaseMeshSC creaseMesh.vtx[0]`;
if ($tempString[0]!="upperCreaseAJoint_R")
	skinPercent -tv $headJoint 1 creaseMeshSC creaseMesh.vtx[0] creaseMesh.vtx[3];

select creaseMesh.vtx[0:999];
select -d $fullWeighVtxs;
select -d creaseMesh.vtx[0] creaseMesh.vtx[3];
weightHammerVerts;
/*
select $fullWeighVtxs;
select -d creaseMesh.vtx[0] creaseMesh.vtx[3];
weightHammerVerts;
*/
select creaseMesh.vtx[0:999];
select -add $smileCreaseVtxs;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//take weights from headJoint in lipFalloffArea
$infJoints=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($infJoints);$i++)
	setAttr ($infJoints[$i]+".lockInfluenceWeights") 1;
setAttr ($headJoint+".lockInfluenceWeights") 0;
for ($i=0;$i<size($creaseJoints);$i++)
	setAttr ($creaseJoints[$i]+".lockInfluenceWeights") 0;
setAttr NoseUnderJoint_M.lockInfluenceWeights 0;
select lipFalloffArea;
select -d $smileCreaseVtxs;
if (size(`ls -sl`))
	skinPercent -tv $headJoint 0 $skinCluster;
for ($i=0;$i<size($infJoints);$i++)
	setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;

copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

delete TempPos closestSamplerFitSelection;

//Hammer `Outside $smileCreaseVtxs
select $smileCreaseVtxs;
for ($i=0;$i<2;$i++)
	{
	polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion;
	select -d lipFalloffArea;
	select -d $smileCreaseVtxs;
	}
sets -n creaseFalloffVtxs;
sets -add FaceBuildingSets creaseFalloffVtxs;
weightHammerVerts;

//Hammer lipFalloffArea;
select lipFalloffArea;
select -d $smileCreaseVtxs;
if (size(`ls -sl`))
	weightHammerVerts;

select $smileCreaseVtxs;
weightHammerVerts;

copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

select -cl;
}

global proc asFaceSmileFold ()
{
int $spans;
int $upperLipOuterSpans=`getAttr upperLipOuterCurve.spans`;
float $mag,$minMag,$falloffRadius,$maxDist;
float $pos[],$midPos[],$posA[],$posB[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $curve="SmileFoldCurve";
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$tempString3[],$smileFoldVtxs[];
string $foldLocs[]={"SmileFold","upperSmileFold"};

if (!`objExists FaceFitSmileFold`)
	return;

eval ("select "+`asGetFaceFitSelection SmileFoldCurve`);
ConvertSelectionToVertices;
$smileFoldVtxs=`ls -sl -fl`;

if (`objExists TempPos`) delete TempPos;
if (`objExists creaseMesh`) delete creaseMesh;
createNode -n TempPos transform;
createNode -n SmileFoldDeform -p FaceBuildInProgress transform;
if (`objExists closestSamplerFitSelection`) delete closestSamplerFitSelection;
createNode -n closestSamplerFitSelection closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSamplerFitSelection.inMesh;

for ($c=0;$c<size($foldLocs);$c++)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";

		if ($foldLocs[$c]=="SmileFold")
			$pos=`xform -q -ws -t ("upperLipOuterCurve.cv["+$upperLipOuterSpans+"]")`;
		if ($foldLocs[$c]=="upperSmileFold")
			$pos=`xform -q -ws -t lowerLid_R`;

		setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
		select ($geometry+".vtx["+`getAttr closestSamplerFitSelection.result.closestVertexIndex`+"]");
		for ($i=0;$i<25;$i++)
			{
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			$tempString=`ls -sl -fl`;
			for ($y=0;$y<size($tempString);$y++)
				if (`stringArrayCount $tempString[$y] $smileFoldVtxs`)
					{
					$pos=`xform -q -ws -t $tempString[$y]`;
					$i=99;
					break;
					}
			}

		xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] TempPos;
		asPingPong TempPos $foldLocs[$c] 1 $side 2 1 0;
	//	parent ($foldLocs[$c]+"Joint"+$side) lowerFaceJoint_M;
		skinCluster -e -dr 4 -lw false -wt 0 -ai ($foldLocs[$c]+"Joint"+$side) $skinCluster;
		scale -r -p ($pos[0]*$b) $pos[1] $pos[2] -0.8 1 1 ($foldLocs[$c]+$side+".cv[2:5]");
		if ($foldLocs[$c]=="SmileFold")
			{
			scale -r -p ($pos[0]*$b) $pos[1] $pos[2] 4 4 4 ($foldLocs[$c]+$side+".cv[0:7]");
//			parent ($foldLocs[$c]+"Offset"+$side) upperLipBJawFollowLocal_R;
			}
		else
			{
			scale -r -p ($pos[0]*$b) $pos[1] $pos[2] 2 2 2 ($foldLocs[$c]+$side+".cv[0:7]");
			rotate -r -p ($pos[0]*$b) $pos[1] $pos[2] -os 0 0 90 ($foldLocs[$c]+$side+".cv[0:7]");
			scale -r -p ($pos[0]*$b) $pos[1] $pos[2] 1 0.3 1 ($foldLocs[$c]+$side+".cv[0]") ($foldLocs[$c]+$side+".cv[2:4]") ($foldLocs[$c]+$side+".cv[6:7]");
//			parent ($foldLocs[$c]+"Offset"+$side) upperLipBJawFollowLocal_R;
			}
		scale -r -p ($pos[0]*$b) $pos[1] $pos[2] 0.5 1 1 ($foldLocs[$c]+$side+".cv[0]") ($foldLocs[$c]+$side+".cv[2:4]") ($foldLocs[$c]+$side+".cv[6:7]");
		}
	}
delete TempPos;

$pos=`xform -q -ws -t ("upperLipOuterCurve.cv["+$upperLipOuterSpans+"]")`;
$falloffRadius=$pos[0]/-4.0;
if (`attributeExists dropoffDistance FaceFitSmileFold`)
	$falloffRadius=`getAttr FaceFitSmileFold.dropoffDistance`;
duplicate -n SmileFoldMesh $geometry;
parent SmileFoldMesh FaceBuildInProgress;

$spans=`getAttr ($curve+".spans")`;
for ($i=2;$i<$spans+1;$i++)
	{
	duplicate -n tempCurve $curve;
	delete ("tempCurve.cv["+$i+":99]");
	rebuildCurve -n tempCurveRebuild -ch 0 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.0004 tempCurve;
/*
	$midPos=`xform -q -ws -t tempCurveRebuild.cv[3]`;
	$mag=`mag <<($midPos[0]-($smilePos[0]*-1)),($midPos[1]-$smilePos[1]),($midPos[2]-$smilePos[2])>>`;
	if ($mag<$minMag)
		{
		delete tempCurveRebuild;
		break;
		}
	$minMag=$mag;
*/
	if (`objExists tempCurveRebuildPrevious`) delete tempCurveRebuildPrevious;
	rename tempCurveRebuild tempCurveRebuildPrevious;
	delete tempCurve;
	}

rename tempCurveRebuildPrevious tempCurveRebuild;
parent tempCurveRebuild SmileFoldDeform;

for ($i=0;$i<7;$i++)
	{
	select ("tempCurveRebuild.cv["+$i+"]");
	$tempString=`newCluster " -envelope 1"`;
	rename $tempString[1] ("SmileFoldCurveClusterHandle"+$i);
	parent ("SmileFoldCurveClusterHandle"+$i) SmileFoldDeform; 
	}
pointConstraint -mo SmileFoldCurveClusterHandle1 SmileFoldCurveClusterHandle3 upperSmileFoldOffset_R;
pointConstraint -mo upperSmileFold_R SmileFoldCurveClusterHandle2;
//pointConstraint -mo SmileFoldCurveClusterHandle1 SmileFoldCurveClusterHandle3 SmileFoldCurveClusterHandle2;
pointConstraint -mo SmileFoldCurveClusterHandle3 SmileFoldCurveClusterHandle5 SmileFoldCurveClusterHandle4;
select SmileFoldMesh;
$tempString=`wire -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w tempCurveRebuild`;
rename $tempString[0] SkinWeightWire;
setAttr SkinWeightWire.dropoffDistance[0] $falloffRadius;

parentConstraint -mo SmileFold_R SmileFoldCurveClusterHandle3;
setAttr SmileFoldMesh.v 0;

select SmileFoldMesh $geometry;
blendShape -n SmileFoldDeformBS -frontOfChain -w 0 1;
addAttr -k 1 -ln dropoffDistance -at double -dv $falloffRadius SmileFold_R;
connectAttr SmileFold_R.dropoffDistance SkinWeightWire.dropoffDistance[0];

delete closestSamplerFitSelection;

//select $sel;
select SmileFold_R;
}

global proc asFaceBakeSmileFold ()
{
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $maxWeight=1;
float $weight;
float $posA[],$posB[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $name="SmileFold";
string $deformerMesh=$name+"Mesh";
string $deformerGrp=$name+"Deform";
string $joint,$ctrl,$deformer;
string $tempString[];
string $foldLocs[]={"SmileFold","upperSmileFold"};

delete upperSmileFoldOffset_R_pointConstraint1;

//asFaceBakeDeformerToSkinCluster SmileFoldJoint_R SmileFold_R SkinWeightWire SmileFoldLine;

select $deformerMesh;
for ($i=0;$i<7;$i++)
	{
	$pos=`xform -q -ws -t ("tempCurveRebuild.cv["+$i+"]")`;
	polySelectConstraint -m 3 -t 1 -d 1 -db 0 ($faceFitScale/3.0) -dp $pos[0] $pos[1] $pos[2];
	$tempString2=`ls -sl -fl`;
	$tempString=`stringArrayCatenate $tempString $tempString2`;
	}
polySelectConstraint -m 0;

for ($i=0;$i<size($tempString);$i++)
	{
	if (`objExists eyeLidArea`)
		if (`sets -im eyeLidArea $tempString[$i]`)
			continue;
	if (`objExists lipArea`)
		if (`sets -im lipArea $tempString[$i]`)
			continue;

	for ($c=0;$c<size($foldLocs);$c++)
		{
		$ctrl=$foldLocs[$c]+"_R";
		$joint=$foldLocs[$c]+"Joint_R";

		$posA=`xform -q -ws -t $tempString[$i]`;
		move -r 0 1 0 $ctrl;
		$posB=`xform -q -ws -t $tempString[$i]`;
		setAttr ($ctrl+".ty") 0;
		$weight=($posB[1]-$posA[1])*$maxWeight;
		if ($weight<0) $weight=0;
		if ($weight>1) $weight=1;
		$weight=$weight*0.8;//only `steal` 80%
		$vtx=`substitute $deformerMesh $tempString[$i] $geometry`;
	 	catchQuiet (`skinPercent -tv $joint $weight $skinCluster $vtx`);
		}
	}

if (`objExists $deformerGrp`)
	delete $deformerGrp;
if (`objExists ($name+"DeformBS")`)
	delete ($name+"DeformBS");
if (`attributeExists dropoffDistance SmileFold_R`)
	deleteAttr SmileFold_R.dropoffDistance;
}

global proc asFaceCheek ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $type,$cvNr;
float $falloffRadius;
float $scale=`asFaceGetScale`;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $posA[],$posB[];
string $side;
string $xyz[]={"x","y","z"};
//string $cheekLocs[]={"CheekRaiser","Cheek","NoseUnder","NoseMiddle","Nostril","NoseCorner"};
string $cheekLocs[]={"Cheek","NoseMiddle","Nostril","NoseCorner"};
if (`objExists NoseSide`)
	$cheekLocs[size($cheekLocs)]="NoseSide";
//add "CheekRaiser", if we dont have upperSmileFold_R ctrl
if (!`objExists FaceFitSmileFold`)
	$cheekLocs[size($cheekLocs)]="CheekRaiser";
string $infJoints[];

if (`objExists FaceFitSmileFold`)
	{
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 SmileFold_R upperSmileFold_R;
	refresh;
	asFaceBakeSmileFold;
	}

if (`objExists TempPos`) delete TempPos;
createNode -n TempPos transform;

//lockWeights
$infJoints=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($infJoints);$i++)
	{
	//	if ($infJoints[$i]!=$headJoint)
	if (`gmatch $infJoints[$i] "*Crease*"` || `gmatch $infJoints[$i] "*Fold*"` || `gmatch $infJoints[$i] "EyeBrow*"` || `gmatch $infJoints[$i] "*Lip*"` || `gmatch $infJoints[$i] "*Lid*"`)
		setAttr ($infJoints[$i]+".lockInfluenceWeights") 1;
	}

for ($c=0;$c<size($cheekLocs);$c++)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";
		if ($cheekLocs[$c]=="NoseMiddle")
			{
			if ($b==1) $side="_M";
			else continue;
			}

		if (!`objExists $cheekLocs[$c]`)
			continue;	

		if ($cheekLocs[$c]=="Cheek") $type=1;
		else if ($cheekLocs[$c]=="Nostril" || $cheekLocs[$c]=="NoseSide" || $cheekLocs[$c]=="NoseMiddle") $type=3;
		else $type=2;
		$pos=`xform -q -ws -t $cheekLocs[$c]`;
		xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] TempPos;
		asPingPong TempPos $cheekLocs[$c] 1 $side $type 1 0;
		if ($cheekLocs[$c]=="Nostril" || $cheekLocs[$c]=="NoseSide")
			{
			parent ($cheekLocs[$c]+"Joint"+$side) NoseRegionJoint_M;
			parent ($cheekLocs[$c]+"Offset"+$side) NoseRegion_M;
			}
		else if ($cheekLocs[$c]=="NoseMiddle")
			{
			parent ($cheekLocs[$c]+"Joint"+$side) upperFaceJoint_M;;
			parent ($cheekLocs[$c]+"Offset"+$side) upperFace_M;
			}
		else
			parent ($cheekLocs[$c]+"Joint"+$side) lowerFaceJoint_M;
		skinCluster -e -dr 4 -lw false -wt 0 -ai ($cheekLocs[$c]+"Joint"+$side) $skinCluster;
		$posA=`xform -q -ws -t $cheekLocs[$c]`;
		$posB=`xform -q -ws -t Lip_R`;

		if ($cheekLocs[$c]=="CheekRaiser") $posB=`xform -q -ws -t lowerEyeLidOuterCurve.cv[0]`;
		if ($cheekLocs[$c]=="NoseCorner") $posB=`xform -q -ws -t NoseUnder`;
//		if ($cheekLocs[$c]=="NoseCorner" && `objExists upperSmileFold_R`) $posB=`xform -q -ws -t upperSmileFold_R`;
		if ($cheekLocs[$c]=="NoseSide") $posB=`xform -q -ws -t lowerEyeLidOuterCurve.cv[0]`;
		if ($cheekLocs[$c]=="NoseMiddle") $posB=`xform -q -ws -t NoseCorner`;
		if ($cheekLocs[$c]=="Nostril") $posB=`xform -q -ws -t NoseCorner`;

		if ($side=="_L")
			continue;

		$falloffRadius=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		if ($cheekLocs[$c]=="Cheek") $falloffRadius=$falloffRadius*1.5;
		asSkinWeightBySoftMod ($cheekLocs[$c]+"Joint"+$side) $geometry $skinCluster $falloffRadius 1;
		}
	}

for ($c=0;$c<size($cheekLocs);$c++)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";
		if ($cheekLocs[$c]=="NoseMiddle")
			{
			if ($b==1) $side="_M";
			else continue;
			}
/*
		if ($cheekLocs[$c]=="Cheek")
			{
			createNode -n ($cheekLocs[$c]+"JawFollow"+$side) -p ($cheekLocs[$c]+"Offset"+$side) transform;
			parentConstraint -mo Jaw_M OffsetJaw_M ($cheekLocs[$c]+"JawFollow"+$side);
			parent ($cheekLocs[$c]+"SideReverse"+$side) ($cheekLocs[$c]+"JawFollow"+$side) ;
			}
*/
		if ($cheekLocs[$c]=="Cheek")
			{
			if (`objExists FaceFitSmileCrease`)
				asFaceAddDrive "Crease" $side "Lip" $side 1 {"tx","ty","tz"} {"mixTx","mixTy","mixTz"};
			if (`objExists FaceFitSmileFold`)
				{
				asFaceAddDrive "SmileFold" $side "Lip" $side 0.4 {"tx","ty","tz"} {"mixTx","mixTy","mixTz"};
				asFaceAddDrive "SmileFold" $side "Lip" $side -0.2 {"sx","sy","sz"} {"mixDist","mixDist","mixDist"};
				}
			asFaceAddDrive "Cheek" $side "Lip" $side 0.3 {"tx","ty","tz"} {"mixTx","mixTy","mixTz"};
			if (`objExists FaceFitSmileFold`)
				asFaceAddDrive "upperSmileFold" $side "Lip" $side 0.3 {"tx","ty","tz"} {"mixTx","mixTy","mixTz"};
			if (`objExists FaceFitSmileCrease`)
				{
				asFaceAddDrive "upperCreaseB" $side "Lip" $side 0.5 {"tx","ty","tz"} {"mixTx","mixTy","mixTz"};
				asFaceAddDrive "lowerCreaseB" $side "Lip" $side 0.5 {"tx","ty","tz"} {"mixTx","mixTy","mixTz"};
				}
			asFaceAddDrive "lowerLid" $side "Lip" $side 0.05 {"ty"} {"mixTy"};
			if (`objExists FaceFitEyeLidDroopy`)
				asFaceAddDrive "lowerLidDroopy" $side "Lip" $side 0.05 {"ty"} {"mixTy"};
			}
		if ($cheekLocs[$c]=="CheekRaiser")
			if (`objExists ("CheekRaiser"+$side)`)
				asFaceAddDrive CheekRaiser $side "Lip" $side 0.3 {"ty"} {"mixTy"};
		if ($cheekLocs[$c]=="NoseCorner")
			{
			asFaceAddDrive "NoseCorner" $side "Lip" $side 0.2 {"tx"} {"mixTx"};
			asFaceAddDrive "NoseCorner" $side "Lip" $side 0.2 {"ty"} {"mixTy"};
			}
		if ($cheekLocs[$c]=="NoseSide")
			{
			asFaceAddDrive "NoseSide" $side "NoseCorner" $side 0.75 {"ty"} {};
			select  ("NoseSide"+$side+".cv[0:7]");
			move -a -z ($posA[2]+($scale/100.0));
			asFaceAddDrive "Nostril" $side "NoseCorner" $side 0.2 {} {};
			}
		}
	}

//select $geometry;
//asSmoothFlood $geometry CheekJoint_R 10;
copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//Drive
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	if (`objExists upperSmileFold_R`)
		asFaceAddDrive upperSmileFold $side ctrlCheek $side 2.8 {"ty"} {};
	else if (`objExists CheekRaiser_R`)
		asFaceAddDrive CheekRaiser $side ctrlCheek $side 2.8 {"ty"} {};

	asFaceAddDrive Cheek $side ctrlCheek $side 2.8 {"tx"} {};
	$pos=`xform -q -ws -t NoseCorner`;
	asFaceAddDrive NoseCorner $side ctrlNose $side (($pos[0]/$faceFitScale)*-10) {"ty"} {};
	asFaceAddDrive NoseCorner $side ctrlNose $side (($pos[0]/$faceFitScale)*3) {"tx"} {};
	if (`objExists NoseSide`)
		asFaceAddDrive NoseSide $side ctrlNose $side (($pos[0]/$faceFitScale)*-10) {"ty"} {};
	if (`objExists Nostril`)
		asFaceAddDrive Nostril $side ctrlNose $side ((($pos[0]/$faceFitScale)*-10)*0.2) {"ty"} {};
	}

// Drive for Mouth
$posA=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs-1]`;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	asFaceAddDrive Lip $side ctrlMouth "_M" (($posA[0]/$faceFitScale)*-4.0) {"tx"} {};
	asFaceAddDrive Lip $side ctrlMouth "_M" (($posA[0]/$faceFitScale)*0.0) {"ty"} {"tx"};
	asFaceAddDrive Lip $side ctrlMouth "_M" (($posA[0]/$faceFitScale)*4.0) {"tz"} {"tx"};

	asFaceAddDrive Lip $side ctrlMouthCorner $side (($posA[0]/$faceFitScale)*-4.0) {"tx"} {};
	asFaceAddDrive Lip $side ctrlMouthCorner $side (($posA[0]/$faceFitScale)*4.0) {"tz"} {"tx"};
	asFaceAddDrive Lip $side ctrlMouthCorner $side (($posA[0]/$faceFitScale)*-4.0) {"ty"} {};
	}
//Make 1 set of attributes that controls both the _R and _L attributes
for ($z=0;$z<size($xyz);$z++)
	{
	addAttr -k 1 -ln ("Lip_t"+$xyz[$z]) -at double -dv `getAttr ("ctrlMouth_M.Lip_t"+$xyz[$z]+"_R")` ctrlMouth_M;
	setAttr -cb 1 ("ctrlMouth_M.Lip_t"+$xyz[$z]);
	connectAttr ("ctrlMouth_M.Lip_t"+$xyz[$z]) ("ctrlMouth_M.Lip_t"+$xyz[$z]+"_R");
	connectAttr ("ctrlMouth_M.Lip_t"+$xyz[$z]) ("ctrlMouth_M.Lip_t"+$xyz[$z]+"_L");
	setAttr -k 0 -cb 0 ("ctrlMouth_M.Lip_t"+$xyz[$z]+"_R");
	setAttr -k 0 -cb 0 ("ctrlMouth_M.Lip_t"+$xyz[$z]+"_L");
	}

//un-lockWeights
for ($i=0;$i<size($infJoints);$i++)
	setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;

delete TempPos;

if (`objExists TeethCollider`)
	{
	setAttr Lip_R.teethSlide 10;
	setAttr Lip_L.teethSlide 10;
	}
select Lip_R;
}

global proc asFaceTongue ()
{
global string $gSelect;
setToolTo $gSelect;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
if ($tongue=="" || !`objExists TongueCurve`)
	return;
float $pos[];
float $scale=`asFaceGetScale`;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
string $tongueSkinCluster="";
string $tempString[];
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

//Display only tongue geo
if (!`gmatch $tongue "*[.]*"`)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		{
		if (!`getAttr -l ($allFaceGeo[$i]+".v")`)
			setAttr ($allFaceGeo[$i]+".v") 0;
		}
	setAttr ($tongue+".v") 1;

	setAttr ctrlBox.ACtrlVis 0;
	setAttr ctrlBox.BCtrlVis 0;
	setAttr ctrlBox.CCtrlVis 0;
	setAttr ctrlBox.TeethCtrlVis 0;
	}

for ($i=0;$i<5;$i++)
	{
	select -cl;
	joint -n ("Tongue"+$i+"Joint_M");
	$pos=`xform -q -ws -t ("TongueCurve.cv["+$i+"]")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("Tongue"+$i+"Joint_M");
	}
for ($i=1;$i<5;$i++)
	delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 ("Tongue"+$i+"Joint_M") ("Tongue"+($i-1)+"Joint_M")`;
parent Tongue0Joint_M lowerFaceJoint_M;
for ($i=1;$i<5;$i++)
	parent ("Tongue"+$i+"Joint_M") ("Tongue"+($i-1)+"Joint_M");
for ($i=0;$i<5;$i++)
	makeIdentity -a 1 -t 0 -r 1 -s 0 ("Tongue"+$i+"Joint_M");
//setAttr -type float3 Tongue4_M.jo 0 0 0;
//setAttr Tongue0Joint_M.overrideEnabled 0;
//setAttr Tongue0Joint_M.segmentScaleCompensate 0;

//Polycube skin method
polyCube -n tempWeightCube -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 4 -ax 0 1 0 -cuv 4 -ch 1;
xform -s $scale $scale $scale tempWeightCube;
eval ("select "+$tongue);
float $bb[]=`xform -q -ws -bb`;

select -r tempWeightCube.vtx[10:13] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[0]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

select -r tempWeightCube.vtx[8:9] tempWeightCube.vtx[14:15] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[1]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

select -r tempWeightCube.vtx[6:7] tempWeightCube.vtx[16:17] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[2]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

select -r tempWeightCube.vtx[4:5] tempWeightCube.vtx[18:19] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[3]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

select -r tempWeightCube.vtx[0:3] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[4]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

duplicate -n tempWeightCube2 tempWeightCube;
select -r tempWeightCube2 Tongue3Joint_M Tongue2Joint_M Tongue1Joint_M Tongue0Joint_M;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] tongueBoxSC;
//	skinCluster -n tongueBoxSC -dr 4 -lw false -wt 1 -mi 1;
select -r tempWeightCube2.vtx[10:13] ;
skinPercent -tv Tongue0Joint_M 1 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[8:9] tempWeightCube2.vtx[14:15] ;
skinPercent -tv Tongue0Joint_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv Tongue1Joint_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[6:7] tempWeightCube2.vtx[16:17] ;
skinPercent -tv Tongue1Joint_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv Tongue2Joint_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[4:5] tempWeightCube2.vtx[18:19] ;
skinPercent -tv Tongue2Joint_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv Tongue3Joint_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[0:3] ;
skinPercent -tv Tongue3Joint_M 1 tongueBoxSC `ls -sl`;

string $historyNodes[];
tokenize $tongue $tempString;
if(size($tempString))
	$historyNodes=`listHistory $tempString[0]`;
else
	$historyNodes=`listHistory $tongue`;
for ($i=0;$i<size($historyNodes);$i++)
	if (`objectType $historyNodes[$i]`=="skinCluster")
		if (!`gmatch $historyNodes[$i] "prefix_*"` && $historyNodes[$i]!="squashIKSC")
			{
			$tongueSkinCluster=$historyNodes[$i];
			break;
			}
if ($tongueSkinCluster=="")
	{
	select -r $tongue Tongue3Joint_M Tongue2Joint_M Tongue1Joint_M Tongue0Joint_M;
	$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
	rename $tempString[0] tongueSC;
//		skinCluster -n tongueSC -dr 4 -lw false -wt 1 -mi 1;
	$tongueSkinCluster="tongueSC";
	}
else
	skinCluster -e -wt 0 -ai Tongue3Joint_M -ai Tongue2Joint_M -ai Tongue1Joint_M -ai Tongue0Joint_M $tongueSkinCluster;

eval ("select tempWeightCube2 "+$tongue);
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
skinCluster -e -removeUnusedInfluence 1 $tongueSkinCluster;
delete tempWeightCube tempWeightCube2;

for ($i=0;$i<4;$i++)
	{
	$tempString=`circle -c 0 0 0 -nr 1 0 0 -sw 360 -r 4 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
	rename $tempString[0] ("Tongue"+$i+"_M");
	sets -add FaceControlSet ("Tongue"+$i+"_M");
	setAttr ("Tongue"+$i+"_MShape.overrideEnabled") 1;
	setAttr ("Tongue"+$i+"_MShape.overrideColor") 17;
	connectAttr ctrlBox.TongueCtrlVis ("Tongue"+$i+"_MShape.overrideVisibility");
	createNode -n ("OffsetTongue"+$i+"_M") -p lowerFace_M transform;
	parent -r ("Tongue"+$i+"_M") ("OffsetTongue"+$i+"_M");
	$pos=`xform -q -ws -t ("Tongue"+$i+"_M")`;
	scale -r -p $pos[0] $pos[1] $pos[2] 0 (($bb[4]-$bb[1])/$faceFitScale) (($bb[3]-$bb[0])/$faceFitScale) ("Tongue"+$i+"_M.cv[0:7]");
	if ($i>0)
		parent ("OffsetTongue"+$i+"_M") ("Tongue"+($i-1)+"_M");
	asAlign ("OffsetTongue"+$i+"_M") ("Tongue"+$i+"Joint_M") 1 1 0 0;
	parentConstraint ("Tongue"+$i+"_M") ("Tongue"+$i+"Joint_M");
//	scaleConstraint ("Tongue"+$i+"_M") ("Tongue"+$i+"Joint_M");
	connectAttr ("Tongue"+$i+"_M.s") ("Tongue"+$i+"Joint_M.s");
	}

//follow jaw
createNode -n Tongue0Static_M -p Jaw_M transform;
parent Tongue0Static_M  lowerFace_M;
duplicate -n Tongue0Blend_M  Tongue0Static_M ;
parentConstraint Tongue0Static_M  Jaw_M Tongue0Blend_M;
scaleConstraint Tongue0Static_M  Jaw_M Tongue0Blend_M;
parent OffsetTongue0_M Tongue0Blend_M;
addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 Tongue0_M;
asUnitConvertAndReverse Tongue0Blend Tongue0_M.follow;
connectAttr Tongue0BlendReverse.outputX Tongue0Blend_M_parentConstraint1.Tongue0Static_MW0;
connectAttr Tongue0BlendReverse.outputX Tongue0Blend_M_scaleConstraint1.Tongue0Static_MW0;
connectAttr Tongue0BlendUnitConversion.output Tongue0Blend_M_parentConstraint1.Jaw_MW1;
connectAttr Tongue0BlendUnitConversion.output Tongue0Blend_M_scaleConstraint1.Jaw_MW1;

select -cl;
}

global proc asFaceRegions ()
{
string $tempString[];
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

//Display all again, after finishing tongue
if (!`gmatch $tongue "*[.]*"`)
	for ($i=0;$i<size($allFaceGeo);$i++)
		if (!`getAttr -l ($allFaceGeo[$i]+".v")`)
			setAttr ($allFaceGeo[$i]+".v") 1;


setAttr ctrlBox.RegionCtrlVis 1;
setAttr ctrlBox.TongueCtrlVis 0;
select -cl;
}

global proc asFaceEyeAim ()
{
setAttr ctrlBox.RegionCtrlVis 0;
setAttr ctrlBox.AimCtrlVis 1;
}

global proc asFaceUpperLowerFace ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $posA[];

//lockWeights all but headJoint (and faceUpperLower)
$tempString=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!=$headJoint && $tempString[$i]!="upperFaceJoint_M" && $tempString[$i]!="lowerFaceJoint_M")
		setAttr ($tempString[$i]+".lockInfluenceWeights") 1;

//first floof to head as previous might have larger falloff
catchQuiet (`skinPercent -tv $headJoint 1 $skinCluster $geometry`);

$posA=`xform -q -ws -t middleFace_M`;
select $geometry;
polySelectConstraint -m 3 -t 1 -d 3 -db $posA[1] 9999 -da 0 1 0 -dp 0 0 0;
catchQuiet (`skinPercent -tv upperFaceJoint_M 1 $skinCluster`);
polySelectConstraint -m 3 -t 1 -d 3 -db 0 $posA[1] -da 0 1 0 -dp 0 0 0;
catchQuiet (`skinPercent -tv lowerFaceJoint_M 1 $skinCluster`);
polySelectConstraint -m 0;

select $geometry;
asSmoothFlood upperFaceJoint_M lowerFaceJoint_M `intField -q -v asFaceNumUpperLowerFacemooths`;

setAttr "ctrlBox.RegionCtrlVis" 1;
select -r upperFaceJoint_M;
}

global proc asFaceFinish ()
{
//eyeBlink for all chars, cross X weights, free-form ctrl-box driving ?, Jaw-open to be `driven` as other ctrl-box attrs, squint ?

float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $pos[],$posA[],$posB[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $mirrorVtx;
string $infJoints[]=`listConnections ($skinCluster+".matrix")`;
string $tempString[],$sets[];

setAttr ctrlBox.ACtrlVis 1;
setAttr ctrlBox.BCtrlVis 1;
setAttr ctrlBox.CCtrlVis 1;
setAttr ctrlBox.TeethCtrlVis 1;
setAttr ctrlBox.TongueCtrlVis 1;
setAttr ctrlBox.RegionCtrlVis 1;

//faceArea sets to be symmetrical
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSampler.inMesh;
$sets=`sets -q FaceAreas`;
for ($i=0;$i<size($sets);$i++)
	{
	select $sets[$i];
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$pos=`xform -q -ws -t $tempString[$y]`;
		if ($pos[0]>=0)
			continue;
		setAttr -type float3 closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
		$mirrorVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
		if (!`sets -im $sets[$i] $mirrorVtx`)
			sets -add $sets[$i] $mirrorVtx;
		}
	}
delete closestSampler;

//Un-lockWeights
$tempString=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".lockInfluenceWeights") 0;

if (`objExists tempLocFlip`) delete tempLocFlip;
if (`objExists FaceBuildInProgress`) delete FaceBuildInProgress;

//Unlock influences
for ($i=0;$i<size($infJoints);$i++)
	setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;

//Also update buildPose
select `sets -q FaceControlSet`;
string $controlSetMembers[]=`ls -sl`;
string $setAttrCmd;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listAttr -k -shortNames $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controlSetMembers[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
setAttr -type "string" faceBuildPose.udAttr $setAttrCmd;

//version
if (!`attributeExists version FaceGroup`)
	addAttr -ln version -at double FaceGroup;
setAttr -l 0 FaceGroup.version;
setAttr -l 1 FaceGroup.version `asGetScriptVersion`;

//update AllSet
select -ne `ls -o`;
select -ne -d `ls -type objectSet`;
select -ne -d `ls -type partition`;
select -d allBeforeFaceBuild;
//not include any `intermediate` meshes, as these most likely belong to the model
select -d `ls -type mesh -intermediateObjects`;
sets -add FaceAllSet `ls -sl`;

sets -rm FaceBuildingSets allBeforeFaceBuild;
delete `sets -q FaceBuildingSets`;

asGoToBuildPose faceSetup;//as we might have "keept buildpose" from previous build.

cycleCheck -e on;

evalDeferred ("sets -clear allBeforeFaceBuild;delete allBeforeFaceBuild;");

select -cl;
print ("// Advanced Face created\n");
}

global proc asFaceAddDrive (string $driven, string $drivenSide, string $driver, string $driverSide, float $dv, string $drivenAttrs[], string $driverAttrs[])
{
string $exp,$existingExp,$mirrorMult;
string $xyz[]={"x","y","z"};
string $tr[]={"t","r","s"};
string $tempString[];

//string $attrName=$driven+$drivenSide;
string $attrName=$driven;
if (size($drivenAttrs)==1)
	$attrName+="_"+$drivenAttrs[0];
if (size($drivenAttrs)==3)
	{
	if ($drivenAttrs[0]=="tx" && $drivenAttrs[1]=="ty" && $drivenAttrs[2]=="tz") $attrName+="_t";
	if ($drivenAttrs[0]=="rx" && $drivenAttrs[1]=="ry" && $drivenAttrs[2]=="rz") $attrName+="_r";
	if ($drivenAttrs[0]=="sx" && $drivenAttrs[1]=="sy" && $drivenAttrs[2]=="sz") $attrName+="_s";
	}
if ($driverSide=="_M" && $drivenSide!="_M")
	$attrName+=$drivenSide;
if (`attributeExists $attrName ($driver+$driverSide)`)
	error ($driver+$driverSide+" is already a driver of: "+$driven+$drivenSide);
if (!`attributeExists influence ($driver+$driverSide)`)
	{
	addAttr -k 1 -ln influence -at double ($driver+$driverSide);
	setAttr -l 1 ($driver+$driverSide+".influence");
	}
//addAttr -k 1 -ln $attrName -at double -dv $dv -smx 2 -hsx 1 -smn 0 -hnv 1 ($driver+$driverSide);
addAttr -k 1 -ln $attrName -at double -dv $dv ($driver+$driverSide);
setAttr -cb 1 ($driver+$driverSide+"."+$attrName);

if (`objExists ($driven+"DriveExp"+$drivenSide)`)
	$existingExp=`getAttr ($driven+"DriveExp"+$drivenSide+".expression")`;

if ($existingExp=="")
	{
	$exp="//AdvancedSkeleton autogenerated expression\n";
	$exp+="float $tx=0;float $ty=0;float $tz=0;float $rx=0;float $ry=0;float $rz=0;float $sx=1;float $sy=1;float $sz=1;\n";
	}
else
	{
	//remove "to:" section
	tokenize $existingExp "\n" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`gmatch $tempString[$i] "//from:*"`)
			$exp+="\n";
		if (`gmatch $tempString[$i] "//to:*"`)
			break;
		$exp+=$tempString[$i]+"\n";
		}
	delete ($driven+"DriveExp"+$drivenSide);
	}

if (!size($drivenAttrs))
	for ($y=0;$y<size($tr);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			$drivenAttrs[size($drivenAttrs)]=$tr[$y]+$xyz[$z];
			}

if (size($driverAttrs)==0)
	$driverAttrs=$drivenAttrs;

$exp+="\n//from:"+$driver+$driverSide+"\n";

for ($i=0;$i<size($drivenAttrs);$i++)
	{
	$mirrorMult="";
	if ($driverSide=="_R" && $drivenSide!="_R")
		if ($drivenAttrs[$i]=="tx" || $drivenAttrs[$i]=="rz")
			$mirrorMult="*-1";

		$exp+="$"+$drivenAttrs[$i]+"+="+$driver+$driverSide+"."+$driverAttrs[$i]+"*"+$driver+$driverSide+$mirrorMult+"."+$attrName+";\n";
	}

$exp+="\n";
$exp+="//to:\n";
for ($y=0;$y<size($tr);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		$exp+=$driven+"Drive"+$drivenSide+"."+$tr[$y]+$xyz[$z]+"=$"+$tr[$y]+$xyz[$z]+";\n";
		}
expression -n ($driven+"DriveExp"+$drivenSide) -s $exp -o ($driven+"Drive"+$drivenSide) -ae 1 -uc all ;
}

global proc string asGetFaceFitSelection (string $object)
{
int $tempInts[];
int $form,$spans,$degrees,$numCv,$vtxNr,$numVtx;
float $radius,$maxScale;
float $scale=`asFaceGetScale`;
float $pos[],$pos2[],$s[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $selection,$objectType;
string $sel[]=`ls -sl`;
string $tempString[],$curves[],$groupChildren[];
$tempString=`listRelatives -s $object`;
if ($tempString[0]!="")
	$objectType=`objectType $tempString[0]`;

if (`objExists closestSamplerFitSelection2`) delete closestSamplerFitSelection2;
createNode -n closestSamplerFitSelection2 closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSamplerFitSelection2.inMesh;

if ($objectType=="locator")
	{
	$pos=`xform -q -ws -t $object`;
	duplicate -n tempGeo $geometry;
	$tempString=`sculpt -mode stretch -insideMode even -maxDisplacement 0.1 -dropoffType linear -dropoffDistance 0 -groupWithLocator 0 -objectCentered 1 tempGeo`;
	rename $tempString[0] tempSculpt;
	rename $tempString[1] tempSculptor;
	rename $tempString[2] tempStretchOrigin;
	parent tempSculptor tempStretchOrigin $object;
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 tempSculptor tempStretchOrigin;
	$pos2=`xform -q -ws -t ($object+"SphereShape.cv[0][0]")`;
	$radius=$pos[1]-$pos2[1];
	xform -os -s $radius $radius $radius tempSculptor tempStretchOrigin;
	$s=`getAttr ($object+".s")`;
	$maxScale=$s[0];
	if ($s[1]>$maxScale) $maxScale=$s[1];
	if ($s[2]>$maxScale) $maxScale=$s[2];
	$pos2=`xform -q -ws -t tempSculptor`;
	xform -ws -t $pos2[0] $pos2[1] 1000 tempSculptor;
	select tempGeo;
	polySelectConstraint -m 3 -t 1 -d 1 -db 0 $maxScale -dp $pos[0] ($pos[1]-100) $pos[2];
	polySelectConstraint -m 3 -t 1 -d 3 -db 0 ($scale*2) -dp 0 0 1000 -da 0 0 1;
	$tempString=`ls -sl -fl`;
	polySelectConstraint -m 0;
	$tempString=`asobjSetCast "" $tempString $geometry`;
	$selection+=`stringArrayToString $tempString " "`;
	delete tempGeo;
	if ($selection=="")
		error ("Unable to find vertices inside the FitSphere: \""+$object+"\", maybe it needs to be scaled up.");
	}
else if ($objectType=="mesh")
	{
	$tempInts=`polyEvaluate -v $object`;
	$numVtx=$tempInts[0];
	for ($i=0;$i<$numVtx;$i++)
		{
		$pos=`xform -q -ws -t ($object+".vtx["+$i+"]")`;
		setAttr -type float3 closestSamplerFitSelection2.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr=`getAttr closestSamplerFitSelection2.result.closestVertexIndex`;
		$selection+=($geometry+".vtx["+$vtxNr+"] ");
		}
	}
else if ($tempString[0]=="")
	{
	$groupChildren=`listRelatives -c $object`;
	for ($i=0;$i<size($groupChildren);$i++)
		{
		$tempString=`listRelatives -s $groupChildren[$i]`;
		if (`gmatch $groupChildren[$i] "*Profile*"`)
			continue;
		if ($tempString[0]!="")
			$curves[size($curves)]=$groupChildren[$i];
		}
	}
else
	$curves[0]=$object;

for ($i=0;$i<size($curves);$i++)
	{
	$spans=`getAttr ($curves[$i]+".spans")`;
	$degrees=`getAttr ($curves[$i]+".degree")`;
	$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv;$y++)
		{
		$pos=`xform -q -ws -t ($curves[$i]+".cv["+$y+"]")`;
		setAttr -type float3 closestSamplerFitSelection2.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr=`getAttr closestSamplerFitSelection2.result.closestVertexIndex`;
		$selection+=($geometry+".vtx["+$vtxNr+"] ");
		}
	}

delete closestSamplerFitSelection2;
select $sel;
return $selection;
}

global proc string[] asobjSetCast (string $set, string $components[], string $destObj)
{
string $sel[]=`ls -sl`;

if ($set!="")
	select $set;
else
	select $components;

string $tempString[]=`ls -sl -fl`;
string $tempString2[];
tokenize $tempString[0] "[.]" $tempString2;
string $sourceObj=$tempString2[0];
select -cl;
for ($i=0;$i<size($tempString);$i++)
	{
	select -add `substitute $sourceObj $tempString[$i] $destObj`;
	}

string $return[]=`ls -sl -fl`;
select $sel;
return $return;
}

global proc asFaceReSelect (string $section, string $part)
{
string $faceFitNode="FaceFit"+$section+$part;
if (`objExists $faceFitNode`)
	if (`attributeExists selection $faceFitNode`)
		eval ("select "+`getAttr ($faceFitNode+".selection")`);
print ("// ReSelecting: "+$section+" : "+$part+"\n");
}

global proc asFaceWeightLips ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];
string $sel[]=`ls -sl`;

if (`objExists JawOpenRegionDeleteComponent`)
	setAttr JawOpenRegionDeleteComponent.nodeState 1;
float $currentTime=`currentTime -q`;
currentTime 0;

skinPercent -tv $headJoint 1 JawOpenRegionSC JawOpenRegion.vtx[0:99999];

duplicate -n lipWeighter $geometry;
$tempString=`listRelatives -s -f lipWeighter`;
for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
sets -rm lipArea lipWeighter.vtx[0:99999];
sets -add mouthOpenSoftModSet lipWeighter;
sets -add mouthOpenSoftModSet JawCurveMid.cv[1:4];
setAttr mouthOpenSoftModHandle.ty 0;
if (!`objExists lipAreaJawOpenRegion`)
	{
	createNode -n lipAreaJawOpenRegion objectSet;
	sets -add FaceBuildingSets lipAreaJawOpenRegion;
	}
select lipArea;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	string $vtxOnLipWeighter=`substitute $geometry $tempString[$i] lipWeighter`;
	$posA=`xform -q -ws -t $vtxOnLipWeighter`;
	setAttr mouthOpenSoftModHandle.ty 1;
	$posB=`xform -q -ws -t $vtxOnLipWeighter`;
	setAttr mouthOpenSoftModHandle.ty 0;
	float $weight=$posB[1]-$posA[1];
	$tempString[0]=`substitute $geometry $tempString[$i] JawOpenRegion`;
	sets -add lipAreaJawOpenRegion $tempString[0];
	skinPercent -tv JawJoint_M $weight JawOpenRegionSC $tempString[0];
	}
delete lipWeighter;

if (`objExists JawOpenRegionDeleteComponent`)
	setAttr JawOpenRegionDeleteComponent.nodeState 0;
currentTime $currentTime;
select $sel;
}

global proc asFaceUpdateJawCurvesWeights ()
{
global string $gMainPane;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $posA[],$posB[];
float $bbCurveTop[],$bbCurveBottom[];
float $maxDist;
string $tempString[],$ySel[],$zSelInv[],$infJoints[];
int $numJawSmooths=`intField -q -v asFaceNumJawSmooths`;
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $vtxsFromLipToNose=3;
if (`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	$vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;
float $currentTime=`currentTime -q`;
currentTime 0;

progressBar -e -st ("Update Jaw Weights") -bp -ii 0 -min 0 -max 1 $gMainProgressBar;

if (`objExists JawOpenRegionDeleteComponent`)
	setAttr JawOpenRegionDeleteComponent.nodeState 1;

if (`objExists jawArea`) delete jawArea;

asSelectCurveVtx JawCurve;
$tempString=`ls -sl -fl`;select -cl;
for ($i=0;$i<size($tempString);$i++) select -add `substitute $geometry $tempString[$i] JawOpenRegion`;
string $jawCurveVtxs[]=`ls -sl -fl`;
asSelectCurveVtx JawCurveMid;
$tempString=`ls -sl -fl`;select -cl;
for ($i=0;$i<size($tempString);$i++) select -add `substitute $geometry $tempString[$i] JawOpenRegion`;
string $jawCurveMidVtxs[]=`ls -sl -fl`;

skinPercent -tv JawJoint_M 1 JawOpenRegionSC $jawCurveVtxs;
skinPercent -tv JawJoint_M 0.5 JawOpenRegionSC $jawCurveMidVtxs;

//taper off skinWeights towards the jawPivot, based on distance
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t Jaw`;
$maxDist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
for ($i=0;$i<size($jawCurveVtxs);$i++)
	{
	$posB=`xform -q -ws -t $jawCurveVtxs[$i]`;
	float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist<($maxDist/2.0))
		skinPercent -tv JawJoint_M (($dist/$maxDist)*2) JawOpenRegionSC $jawCurveVtxs[$i];
	}

//taper off skinWeights towards the jawPivot, based on distance (50vtx)
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs]`;
$maxDist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
for ($i=0;$i<size($jawCurveMidVtxs);$i++)
	{
	$posB=`xform -q -ws -t $jawCurveMidVtxs[$i]`;
	float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist<($maxDist/2.0))
		skinPercent -tv JawJoint_M ($dist/$maxDist) JawOpenRegionSC $jawCurveMidVtxs[$i];
	}

//Select vtxs with curve boundaries, first from BB polySeConstr for speed
duplicate -n JawCurveTopSampler JawCurveTop;
duplicate -n JawCurveBottomSampler JawCurveBottom;
select JawCurveTopSampler.cv[0:6] JawCurveBottomSampler.cv[0:5];
move -x 0;
//Jaw can be lower than throat on some characters
$posA=`xform -q -ws -t Jaw`;
$posB=`xform -q -ws -t Throat`;
if ($posA[1]<$posB[1])
	xform -ws -t 0 $posA[1] $posA[2] JawCurveBottomSampler.cv[5]; 
spaceLocator -n samplerLocator;
spaceLocator -n samplerLocatorTop;
spaceLocator -n samplerLocatorBottom;
parent samplerLocatorTop samplerLocatorBottom samplerLocator;
select JawCurveTopSampler samplerLocatorTop;geometryConstraint -weight 1;
select samplerLocator samplerLocatorTop;pointConstraint;
select JawCurveBottomSampler samplerLocatorBottom;geometryConstraint -weight 1;
select samplerLocator samplerLocatorBottom;pointConstraint;

$bbCurveTop=`xform -q -ws -bb JawCurveTopSampler`;
$bbCurveBottom=`xform -q -ws -bb JawCurveBottomSampler`;
select JawOpenRegion;
polySelectConstraint -m 3 -t 1 -d 3 -db $bbCurveBottom[1] $bbCurveTop[4] -da 0 1 0 -dp 0 0 0;
$ySel=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 100 -da 0 0 1 -dp 0 0 ($bbCurveBottom[2]-100);
$zSelInv=`ls -sl`;
polySelectConstraint -m 0;
select $ySel;
select -d $zSelInv;
asInvertSelection;
string $outsideOuterBoundsVtxs[]=`ls -sl`;

$bbCurveTop=`xform -q -ws -bb JawCurveTopSampler`;
$bbCurveBottom=`xform -q -ws -bb JawCurveBottomSampler`;
select JawOpenRegion;
polySelectConstraint -m 3 -t 1 -d 3 -db $bbCurveBottom[1] $bbCurveTop[1] -da 0 1 0 -dp 0 0 0;
$ySel=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 100 -da 0 0 1 -dp 0 0 ($bbCurveBottom[5]-100);
$zSelInv=`ls -sl`;
polySelectConstraint -m 0;
select $ySel;
select -d $zSelInv;
string $insideInnerBoundsVtxs[]=`ls -sl`;

$bbCurveTop=`xform -q -ws -bb JawCurveTopSampler`;
$bbCurveBottom=`xform -q -ws -bb JawCurveBottomSampler`;
select JawOpenRegion;
polySelectConstraint -m 3 -t 1 -d 3 -db $bbCurveTop[4] $bbCurveTop[1] -da 0 1 0 -dp 0 0 0;
string $yOnBoundSel[]=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($bbCurveBottom[5]-$bbCurveBottom[2])/2.0) -da 0 0 1 -dp 0 0 (($bbCurveBottom[5]+$bbCurveBottom[2])/2.0);
string $zOnBoundSelInv[]=`ls -sl`;
polySelectConstraint -m 0;
select $yOnBoundSel $zOnBoundSelInv;
select -d $outsideOuterBoundsVtxs;
string $onBoundsVtxs[]=`ls -sl -fl`;

select -cl;
for ($i=0;$i<size($onBoundsVtxs);$i++)
	{
	$pos=`xform -q -ws -t $onBoundsVtxs[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] samplerLocator;
	refresh;
	if (`getAttr samplerLocatorTop.ty`>0)
		select -add $onBoundsVtxs[$i];
	}

select -add $insideInnerBoundsVtxs;
select -d lipAreaJawOpenRegion;
sets -n jawArea;
sets -add FaceBuildingSets jawArea;
select -d $jawCurveVtxs $jawCurveMidVtxs;
if (size(`ls -sl`))
	weightHammerVerts;
copySkinWeights -ss JawOpenRegionSC -ds JawOpenRegionSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

select jawArea;
//asSmoothFlood $headJoint JawJoint_M $numJawSmooths;
select JawOpenRegion JawCurve;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//fix the weighting just above upperLip
select lipAreaJawOpenRegion;
string $completedVtxs[]=`ls -sl -fl`;
//eval ("select "+`getAttr FaceFitLipOuter.upperSelection`);
eval ("select "+`asGetFaceFitSelection upperLipOuterCurve`);
$tempString=`ls -sl -fl`;
float $bb[]=`xform -q -bb`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	select -add `substitute $geometry $tempString[$i] JawOpenRegion`;
string $lipOutherVtxs[]=`ls -sl -fl`;
for ($i=0;$i<size($lipOutherVtxs);$i++)
	{
	$posA=`xform -q -ws -t $lipOutherVtxs[$i]`;
//	if ($posA[0]>0)
//		continue;
	select $lipOutherVtxs[$i];
	float $prevWeights[];
	float $onLipWeights[]=`skinPercent -ignoreBelow 0.001 -q -v JawOpenRegionSC`;
	select $lipOutherVtxs[$i];
	for ($y=0;$y<$vtxsFromLipToNose;$y++)
		{
		asWsPickWalk 0 1 0;
//		refresh;
		$tempString=`ls -sl -fl`;
		if (`sets -im lipAreaJawOpenRegion $tempString[0]`)
			continue;
		float $newWeight=$onLipWeights[1]-(($onLipWeights[1]/$vtxsFromLipToNose)*$y);
		skinPercent -tv JawJoint_M $newWeight JawOpenRegionSC;
		}
	}

copySkinWeights -ss JawOpenRegionSC -ds JawOpenRegionSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

select jawArea;
asSmoothFlood $headJoint JawJoint_M $numJawSmooths;

copySkinWeights -ss JawOpenRegionSC -ds JawOpenRegionSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

if (`objExists JawOpenRegionDeleteComponent`)
	setAttr JawOpenRegionDeleteComponent.nodeState 0;

delete samplerLocator JawCurveTopSampler JawCurveBottomSampler;

//lockWeights all but headJoint & jawJoint, to so reduced jaw-weights `fall to` head-weights
$infJoints=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($infJoints);$i++)
	if ($infJoints[$i]==$headJoint || $infJoints[$i]=="JawJoint_M")
		setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;
	else
		setAttr ($infJoints[$i]+".lockInfluenceWeights") 1;

//remove all jaw weights, as the jawAre might have been reduced by adjustment of JawCurves
skinPercent -tv JawJoint_M 0 $skinCluster $geometry;

//unlock
for ($i=0;$i<size($infJoints);$i++)
	setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;

//transfer to $geometry mesh
if (`objExists JawOpenRegionDeleteComponent`)
	setAttr JawOpenRegionDeleteComponent.nodeState 1;
select jawArea;
select -add `asobjSetCast jawArea {} $geometry`;

copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

progressBar -e -ep $gMainProgressBar;
currentTime $currentTime;
select $sel;
}

global proc asWsPickWalk (int $x, int $y, int $z)
{
string $sel[]=`ls -sl`;
if (size($sel)==0)
	error "No selection provided to asWsPickWalk";
float $posA[]=`xform -q -ws -t $sel[0]`;
ConvertSelectionToEdges;
ConvertSelectionToVertices;
string $expandSel[]=`ls -sl -fl`;
float $dist,$maxWeight;
//float $minDist=9999;
for ($i=0;$i<size($expandSel);$i++)
	{
	if ($expandSel[$i]==$sel[0])
		continue;
	float $posB[]=`xform -q -ws -t $expandSel[$i]`;
	if ($x==1 && $posB[0]<$posA[0]) continue;
	if ($y==1 && $posB[1]<$posA[1]) continue;
	if ($z==1 && $posB[2]<$posA[2]) continue;
	if ($x==-1 && $posB[0]>$posA[0]) continue;
	if ($y==-1 && $posB[1]>$posA[1]) continue;
	if ($z==-1 && $posB[2]>$posA[2]) continue;

	$xDist=abs($posB[0]-$posA[0]);
	$yDist=abs($posB[1]-$posA[1]);
	$zDist=abs($posB[2]-$posA[2]);
	$xyzDist=$xDist+$yDist+$zDist;
	if (abs($x)) $weight=$xDist/$xyzDist;
	if (abs($y)) $weight=$yDist/$xyzDist;
	if (abs($z)) $weight=$zDist/$xyzDist;

	if ($weight>$maxWeight)
		{
		$maxWeight=$weight;
		select $expandSel[$i];
		}
	}
string $tempString[]=`ls -sl -fl`;
if (size($tempString)>1)
	select $tempString[0];
}

global proc asCurveOffsetMesh (string $curve, string $geometry ,float $offset)
{
$form=`getAttr ($curve+".form")`;
$spans=`getAttr ($curve+".spans")`;
$degrees=`getAttr ($curve+".degree")`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 20 -d 3 -tol 0.01 $curve;
spaceLocator -n constraintLoc;
spaceLocator -n constraintLoc2;
parent constraintLoc2 constraintLoc;
setAttr constraintLoc2.tx $offset;
select $geometry constraintLoc;
geometryConstraint -weight 1;
select $geometry constraintLoc;
normalConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0;
for ($i=0;$i<23;$i++)
    {
    $posA=`xform -q -ws -t ($curve+".cv["+$i+"]")`;
    xform -ws -t $posA[0] $posA[1] $posA[2] constraintLoc;
    $posB=`xform -q -ws -t constraintLoc2`;
    xform -ws -t $posB[0] $posB[1] $posB[2] ($curve+".cv["+$i+"]");
    }
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spans -d 3 -tol 0.01 $curve;
delete constraintLoc;
}

global proc asFaceWrapDeformToFace ()
{
float $pos[];
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $shape;
string $tempString[];
//remove possible existing defomers first
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	if (size($tempString)<2)
		continue;
	$tempString=`listRelatives -ni -s $sel[$i]`;
	delete `listRelatives -s -ni $sel[$i]`;
	$tempString=`listRelatives -s $sel[$i]`;
	$shape=$tempString[0];
	setAttr ($shape+".intermediateObject") 0;
	$tempString=`listConnections -p 1 ($shape+".worldMesh[0]")`;
	if (size($tempString))
		disconnectAttr ($shape+".worldMesh[0]") $tempString[0];
	print ("// Deleting history for \""+$sel[$i]+"\", to avoid double deformations;\n");
	}
for ($i=0;$i<size($sel);$i++)
	{
	select -r $sel[$i];
	select -add $geometry;
	$tempString=`doWrapArgList "6" { "1","0","1", "2", "0", "1", "1", "0" }`;
	rename $tempString[0] eyeBrowWrap;
	}
print ("// WrapDeformer created\n");
}

global proc asFaceWireDeformToFace ()
{
string $sel[]=`ls -sl`;
int $spans,$cv;
float $bb[],$scale[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster,$side;
string $curveCmd="curve -d 1";
string $tempString[],$eyeBrows[];

string $eyeBrowLocs[]={"EyeBrowInner","EyeBrowMid1","EyeBrowMid2","EyeBrowMid3","EyeBrowOuter"};
for ($y=0;$y<size($eyeBrowLocs);$y++)
	{
	if (!`objExists $eyeBrowLocs[$y]`)
		continue;
	$pos=`xform -q -ws -t $eyeBrowLocs[$y]`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	}
if (!`objExists EyeBrowMainCurve`)
	{
	$tempString[0]=`evalEcho ($curveCmd)`;
	rename $tempString[0] EyeBrowMainCurve;
	}

if (!`objExists EyeBrowWire`)
	{
	createNode -n EyeBrowWire -p FaceDeformationSystem transform;
	createNode -n EyeBrowWireScaleOffset -p EyeBrowWire transform;
	createNode -n EyeBrowWireScale_R -p EyeBrowWireScaleOffset transform;
	createNode -n EyeBrowWireScale_L -p EyeBrowWireScaleOffset transform;
	$scale=`getAttr upperFaceOffset_M.s`;
	setAttr -type float3 EyeBrowWireScaleOffset.s $scale[0] $scale[0] $scale[0];
	scaleConstraint EyeBrowRegion_R EyeBrowWireScale_R;
	scaleConstraint EyeBrowRegion_L EyeBrowWireScale_L;
	parent EyeBrowMainCurve EyeBrowWire;
	}

$eyeBrows[size($eyeBrows)]="EyeBrowInner";
$spans=1;
if (`objExists EyeBrowMid1`) {$spans++;$eyeBrows[size($eyeBrows)]="EyeBrowMid1";}
if (`objExists EyeBrowMid2`) {$spans++;$eyeBrows[size($eyeBrows)]="EyeBrowMid2";}
if (`objExists EyeBrowMid3`) {$spans++;$eyeBrows[size($eyeBrows)]="EyeBrowMid3";}
$eyeBrows[size($eyeBrows)]="EyeBrowOuter";

for ($i=0;$i<size($sel);$i++)
	{
	$side="_R";
	$bb=`xform -q -ws -bb $sel[$i]`;
	if ((($bb[0]+$bb[3])/2.0)>0)
		$side="_L";

	select $sel[$i];
	DeleteHistory;

	if (`objExists ("EyeBrowWireCurve"+$side)`) delete ("EyeBrowWireCurve"+$side);
	duplicate -n ("EyeBrowWireCurve"+$side) EyeBrowMainCurve;
	if ($side=="_L")
		{
		setAttr EyeBrowWireCurve_L.sx -1;
		makeIdentity -a 1 -t 0 -r 0 -s 1 EyeBrowWireCurve_L;
		}

/*
	select -r ("EyeBrowWireCurve"+$side) $geometry;
	$tempString=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
	rename $tempString[0] ("EyeBrowCurveWrap"+$side);
	if (`objExists asFaceBS`)
		connectAttr -f asFaceBS.outputGeometry[0] ("EyeBrowCurveWrap"+$side+".driverPoints[0]");
*/

	

	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spans -d 3 -tol 0.000393701 ("EyeBrowWireCurve"+$side);

	$tempString=`wire -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w ("EyeBrowWireCurve"+$side) $sel[$i]`;
	$tempString[0]=`rename $tempString[0] ("EyeBrowWire"+$side)`;
	string $wireDeformer=$tempString[0];
//	connectAttr ("EyeBrowWireScale"+$side+".sx") ($wireDeformer+".scale[0]");

	//set dropoffDistance to the width of the geometry (5x to allow for scaling)
	$bb=`xform -q -ws -bb $sel[$i]`;
	setAttr ("EyeBrowWire"+$side+".dropoffDistance[0]") (($bb[3]-$bb[0])*5);


	$skinCluster="";
	string $historyNodes[]=`listHistory -pdo 1 -il 2 $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$skinCluster=$historyNodes[$y];
			skinCluster -e -ai upperFaceJoint_M -lw false -wt 0 $skinCluster;
			}

	if (!`objExists $skinCluster`)
		{
		select upperFaceJoint_M $sel[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}
	skinPercent -tv upperFaceJoint_M 1 $skinCluster $sel[$i];

//	reorderDeformers $skinCluster $wireDeformer $sel[$i];

	for ($y=0;$y<size($eyeBrows);$y++)
		{
		$cv=$y;
		if ($y>0) $cv=$y+1;
		if ($y==size($eyeBrows)-1) $cv=$y+2;
		select -r ("EyeBrowWireCurve"+$side+".cv["+$cv+"]");
		$tempString=`newCluster " -envelope 1"`;
		rename $tempString[0] ($eyeBrows[$y]+"WireCluster"+$side);
		rename $tempString[1] ($eyeBrows[$y]+"WireClusterHandle"+$side);
		$tempString=`listConnections ($eyeBrows[$y]+"WireCluster"+$side+".message")`;
		rename $tempString[0] ($eyeBrows[$y]+"WireClusterSet"+$side);
		parent ($eyeBrows[$y]+"WireClusterHandle"+$side) EyeBrowWire;
		}
	sets -add ($eyeBrows[0]+"WireClusterSet"+$side) ("EyeBrowWireCurve"+$side+".cv[1]");
	sets -add ($eyeBrows[size($eyeBrows)-1]+"WireClusterSet"+$side) ("EyeBrowWireCurve"+$side+".cv["+`size($eyeBrows)`+"]");

	for ($y=0;$y<size($eyeBrows);$y++)
		{
		createNode -n ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side) plusMinusAverage;
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".operation") 2;
		connectAttr ($eyeBrows[$y]+"Joint"+$side+".t") ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[0]");
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[1].input3Dx") `getAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[0].input3Dx")`;
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[1].input3Dy") `getAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[0].input3Dy")`;
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[1].input3Dz") `getAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[0].input3Dz")`;
		connectAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".output3D") ($eyeBrows[$y]+"WireClusterHandle"+$side+".t");

		createNode -n ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side) plusMinusAverage;
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".operation") 2;
		connectAttr ($eyeBrows[$y]+"Joint"+$side+".r") ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[0]");
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[1].input3Dx") `getAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[0].input3Dx")`;
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[1].input3Dy") `getAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[0].input3Dy")`;
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[1].input3Dz") `getAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[0].input3Dz")`;
		connectAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".output3D") ($eyeBrows[$y]+"WireClusterHandle"+$side+".r");
		}

/*
	//copySkinWeights from face (to get EyeBrow joint weights)
	for ($y=0;$y<size($eyeBrowLocs);$y++)
		{
		if (!`objExists $eyeBrowLocs[$y]`)
			continue;
		skinCluster -e -ai ($eyeBrowLocs[$y]+"Joint"+$side) -lw false -wt 0 $skinCluster;
		}
	select $geometry $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	//not sure why `copySkinWeights` needs to run twice here
*/
	}
print "// Wire deformer added.\n";
select $sel;
}

global proc asFaceCopyWeightsToFace () 
{
int $haveSkinCluster;
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $tempString[],$historyNodes[];
string $eyeBrowSC;

string $infJoints[]=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($sel);$i++)
	{
	$historyNodes=`listHistory $sel[$i]`;
	$haveSkinCluster=0;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$eyeBrowSC=$historyNodes[$y];
			}	
	if ($haveSkinCluster)
		{
		select $infJoints;
		select -d `listConnections ($eyeBrowSC+".matrix")`;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			skinCluster -e -ai $tempString[$y] -lw false -wt 0 $eyeBrowSC;
		}
	else
		{
		select -add $infJoints;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$eyeBrowSC=`rename $tempString[0] EyeBrowSC`;
		}
	select $geometry $sel[$i];
	copySkinWeights  -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	refresh;dgdirty -a;//first time does not seem to always work
	copySkinWeights  -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	select $sel[$i];
	removeUnusedInfluences;
	}

select $sel;
print "// Weights copied.\n";
}

global proc asFaceEyeBallBuild ()
{
int $innerVtxsIsA,$IrisLoopNextToPupilLoop;
int $addIrisAttr=`checkBox -q -v asFaceIrisCheckBox`;
float $bb[],$bbA[],$bbB[],$pos[],$pupilCenterPos[],$irisCenterPos[],$temp[];
float $eyeRadius,$pupilRadius,$vtxRadius,$irisRadius,$wouldBeRadius,$factor,$maxX,$maxY;
string $xyz[]={"x","y","z"};
//string $xyz[]={"y","z"};
string $vtxs[],$pupilVtxs[],$pupilVtxs[],$tempString[],$tempString2[],$sideAVtxs[],$sideBVtxs[];
string $innerVtxs[],$outerVtxs[],$backHalfVtxs[],$irisToBackHalfVtxs[];
string $pupilText,$irisText,$skinCluster,$maxXVtx,$maxYVtx,$pupilIris,$pupilIrisLowerCase,$eyeGeo,$setAttrCmdExtra,$eyeCtrl,$buildPose;


for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	
	$eyeCtrl="ctrlEye"+$side;
	if (!`objExists $eyeCtrl`)
		$eyeCtrl="FKEye"+$side;

	if (`attributeExists pupil $eyeCtrl`)
		error "Pupil attribute already added";

	$pupilText=`textField -q -tx ("asFacePupil"+$side+"TextField")`;
	$irisText=`textField -q -tx ("asFaceIris"+$side+"TextField")`;
	if ($pupilText=="") {warning ("Pupil"+$side+" EdgeLoop not defined");continue;}
	if ($irisText=="") {warning ("Iris"+$side+" EdgeLoop not defined");continue;}

	eval ("select "+$pupilText);
	ConvertSelectionToVertices;
	$pupilVtxs=`ls -sl -fl`;
	$bb=`xform -q -bb`;
	$pupilCenterPos={(($bb[3]+$bb[0])/2.0),(($bb[4]+$bb[1])/2.0),(($bb[5]+$bb[2])/2.0)};
	$pupilRadius=($bb[4]-$bb[1])/2.0;

	eval ("select "+$irisText);
	ConvertSelectionToVertices;
	$irisVtxs=`ls -sl -fl`;
	$bb=`xform -q -bb`;
	$irisCenterPos={(($bb[3]+$bb[0])/2.0),(($bb[4]+$bb[1])/2.0),(($bb[5]+$bb[2])/2.0)};
	$irisRadius=($bb[4]-$bb[1])/2.0;

	//find $eyeGeo & $eyeRadius
	tokenize $pupilVtxs[0] "[.]" $tempString;
	$eyeGeo=$tempString[0];
	$bb=`xform -q -ws -bb $eyeGeo`;
	$eyeRadius=($bb[4]-$bb[1])/2.0;

	//find $backHalfVtxs
	select $eyeGeo;
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	createNode -n tempTransform -p ("Eye"+$side) transform;
	for ($i=0;$i<size($tempString);$i++)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		xform -ws -t $pos[0] $pos[1] $pos[2] tempTransform;
		if (`getAttr tempTransform.tx`<0)
			$backHalfVtxs[size($backHalfVtxs)]=$tempString[$i];
		}
	delete tempTransform;

	$tempString=`listHistory $pupilVtxs[0]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`nodeType $tempString[$y]`=="skinCluster")
			if ($tempString[$y]!="squashIKSC")
				$skinCluster=$tempString[$y];

	for ($a=1;$a>-2;$a=$a-2)
		{
		if ($a==1)
			{$pupilIris="Pupil";$pupilIrisLowerCase="pupil";$pos=$pupilCenterPos;$vtxs=$pupilVtxs;}
		else
			{$pupilIris="Iris";$pupilIrisLowerCase="iris";$pos=$irisCenterPos;$vtxs=$irisVtxs;}
		
		//Create Joint
		select ("Eye"+$side);
		joint -n ($pupilIris+$side);
		setAttr ($pupilIris+$side+".segmentScaleCompensate") 0;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($pupilIris+$side);

		//Orient to Loop-Plane
		$maxX=$maxY=-9999;
		for ($i=0;$i<size($vtxs);$i++)
			{
			$pos=`xform -q -ws -t $vtxs[$i]`;
			if ($pos[0]>$maxX) {$maxX=$pos[0];$maxXVtx=$vtxs[$i];}
			if ($pos[1]>$maxY) {$maxY=$pos[1];$maxYVtx=$vtxs[$i];}
			}
		createNode -n tempTransform2 -p ("Eye"+$side) transform;
		$pos=`xform -q -ws -t $maxXVtx`;
		xform -ws -t $pos[0] $pos[1] $pos[2] tempTransform2;
		createNode -n tempTransform3 -p ("Eye"+$side) transform;
		$pos=`xform -q -ws -t $maxYVtx`;
		xform -ws -t $pos[0] $pos[1] $pos[2] tempTransform3;
		delete `aimConstraint -aimVector 	0 0 1 -upVector 0 -1 0 -worldUpType object -worldUpObject tempTransform3 tempTransform2 ($pupilIris+$side)`;
		delete tempTransform2 tempTransform3;

		//AddAttr
		if ($a==1) //Add Iris attr first, so Pupil attr appear last
			{
			addAttr -k $addIrisAttr -ln iris -at double -smn -10 -hsn 1 -smx 10 -hsx 1 -dv 0 $eyeCtrl;
			addAttr -k 1 -ln pupil -at double -smn -10 -hsn 1 -smx 10 -hsx 1 -dv 0 $eyeCtrl;
			}
		addAttr -k 0 -ln ($pupilIrisLowerCase+"Scale") -at double -dv 1 $eyeCtrl;
		for ($z=0;$z<size($xyz);$z++)
			connectAttr ($eyeCtrl+"."+$pupilIrisLowerCase+"Scale") ($pupilIris+$side+".s"+$xyz[$z]);

		skinCluster -e -ai ($pupilIris+$side) -lw false -wt 0 $skinCluster;
		skinPercent -tv ($pupilIris+$side) 1 $skinCluster $vtxs;
		}

	select  $pupilVtxs[0];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $pupilVtxs;
	$tempString=`ls -sl -fl`;

	//Grow A
	select $tempString[0];
	for ($i=0;$i<99;$i++)
		{
		if (`stringArrayCount $tempString[0] $irisVtxs`) // IrisLoops is next to PupilLoop
			{$IrisLoopNextToPupilLoop=1;select $irisVtxs;break;}
		GrowPolygonSelectionRegion;
		select -d $pupilVtxs $irisVtxs;
		if (size(`ls -sl -fl`)==size($tempString2))//same count as previously
			break;
		$tempString2=`ls -sl -fl`;
		}
	$sideAVtxs=`ls -sl -fl`;

	//Grow B
	select $tempString[1];
	for ($i=0;$i<99;$i++)
		{
		if (`stringArrayCount $tempString[1] $irisVtxs`) // IrisLoops is next to PupilLoop
			{$IrisLoopNextToPupilLoop=1;select $irisVtxs;break;}
		GrowPolygonSelectionRegion;
		select -d $pupilVtxs $irisVtxs;
		if (size(`ls -sl -fl`)==size($tempString2))//same count as previously
			break;
		$tempString2=`ls -sl -fl`;
		}
	$sideBVtxs=`ls -sl -fl`;

	//Determine A/B is Inner/Outer
	$bbA=`xform -q -bb $sideAVtxs`;
	$bbB=`xform -q -bb $sideBVtxs`;
	$xyzA=($bbA[3]-$bbA[0]) + ($bbA[4]-$bbA[1]) + ($bbA[5]-$bbA[2]);
	$xyzB=($bbB[3]-$bbB[0]) + ($bbB[4]-$bbB[1]) + ($bbB[5]-$bbB[2]);
	if ($xyzA<$xyzB)
		{
		$innerVtxs=$sideAVtxs;
		$outerVtxs=$sideBVtxs;
		}
	else
		{
		$innerVtxs=$sideBVtxs;
		$outerVtxs=$sideAVtxs;
		}

	//Weighting Pupil-to-Iris-area (flatten eye, for correct radius-fraction calculations)
	skinPercent -tv ("Pupil"+$side) 1 $skinCluster $innerVtxs;
	skinPercent -tv ("Iris"+$side) 1 $skinCluster $outerVtxs;
	select $innerVtxs $outerVtxs;
	$tempString=`lattice -divisions 2 2 2 -objectCentered true  -ldv 2 2 2`;
	rename $tempString[0] EyeFlattenFFD;
	rename $tempString[1] EyeFlattenLattice;
	rename $tempString[2] EyeFlattenBase;
	setAttr EyeFlattenFFD.outsideLattice 1;
	parent EyeFlattenLattice EyeFlattenBase	 ("Iris"+$side);
	setAttr -type float3 EyeFlattenLattice.r 0 0 0;
	setAttr -type float3 EyeFlattenBase.r 0 0 0;
	setAttr EyeFlattenLattice.sx 0;
	xform -ws -t $pupilCenterPos[0] $pupilCenterPos[1] $pupilCenterPos[2] EyeFlattenLattice;
	for ($i=0;$i<size($outerVtxs);$i++)
		{
		if ($IrisLoopNextToPupilLoop)
			break;
		$pos=`xform -q -ws -t $outerVtxs[$i]`;
		$vtxRadius=`mag <<($pos[0]-$pupilCenterPos[0]),($pos[1]-$pupilCenterPos[1]),($pos[2]-$pupilCenterPos[2])>>`;
		$factor=1-(smoothstep(0,$irisRadius,$vtxRadius));
		$factor=$vtxRadius/$irisRadius;
		$factor=linstep ($pupilRadius,$irisRadius,$vtxRadius);
		$factor=(($irisRadius/$pupilRadius)*$vtxRadius);
		$wouldBeRadius=($irisRadius/$pupilRadius)*$vtxRadius;
		$factor=linstep ($vtxRadius,$wouldBeRadius,$irisRadius);
		skinPercent -tv ("Pupil"+$side) $factor $skinCluster $outerVtxs[$i];
		}
	delete EyeFlattenLattice;

	//Weighting Iris-to-backHalf-area (flatten eye, for correct radius-fraction calculations)
	tokenize $pupilVtxs[0] "[.]" $tempString;
	select $tempString[0];
	ConvertSelectionToVertices;
	select -d $innerVtxs $outerVtxs $pupilVtxs $irisVtxs $backHalfVtxs;
	$irisToBackHalfVtxs=`ls -sl -fl`;
	skinPercent -tv ("Eye"+$side) 1 $skinCluster $irisToBackHalfVtxs;
	select $irisToBackHalfVtxs;
	$tempString=`lattice -divisions 2 2 2 -objectCentered true  -ldv 2 2 2`;
	rename $tempString[0] EyeFlattenFFD;
	rename $tempString[1] EyeFlattenLattice;
	rename $tempString[2] EyeFlattenBase;
	setAttr EyeFlattenFFD.outsideLattice 1;
	parent EyeFlattenLattice EyeFlattenBase	 ("Iris"+$side);
	setAttr -type float3 EyeFlattenLattice.r 0 0 0;
	setAttr -type float3 EyeFlattenBase.r 0 0 0;
	setAttr EyeFlattenLattice.sx 0;
	xform -ws -t $irisCenterPos[0] $irisCenterPos[1] $irisCenterPos[2] EyeFlattenLattice;
	for ($i=0;$i<size($irisToBackHalfVtxs);$i++)
		{
//		if ($IrisLoopNextToPupilLoop)
//			break;
		$pos=`xform -q -ws -t $irisToBackHalfVtxs[$i]`;
		$vtxRadius=`mag <<($pos[0]-$irisCenterPos[0]),($pos[1]-$irisCenterPos[1]),($pos[2]-$irisCenterPos[2])>>`;
		$factor=1-(smoothstep(0,$eyeRadius,$vtxRadius));
		$factor=$vtxRadius/$eyeRadius;
		$factor=linstep ($irisRadius,$eyeRadius,$vtxRadius);
		$factor=(($eyeRadius/$irisRadius)*$vtxRadius);
		$wouldBeRadius=($eyeRadius/$irisRadius)*$vtxRadius;
		$factor=linstep ($vtxRadius,$wouldBeRadius,$eyeRadius);
		skinPercent -tv ("Iris"+$side) $factor $skinCluster $irisToBackHalfVtxs[$i];
		}
	delete EyeFlattenLattice;

	setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v 1 -cd ($eyeCtrl+".pupil") ($eyeCtrl+".pupilScale");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v 1 -cd ($eyeCtrl+".iris") ($eyeCtrl+".irisScale");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 10 -v ($irisRadius/$pupilRadius) -cd ($eyeCtrl+".pupil") ($eyeCtrl+".pupilScale");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 10 -v ($eyeRadius/$irisRadius) -cd ($eyeCtrl+".iris") ($eyeCtrl+".irisScale");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv -10 -v 0 -cd ($eyeCtrl+".pupil") ($eyeCtrl+".pupilScale");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv -10 -v ($pupilRadius/$irisRadius) -cd ($eyeCtrl+".iris") ($eyeCtrl+".irisScale");

	for ($a=1;$a>-2;$a=$a-2)
		{
		if ($a==1)
			{$pupilIris="Pupil";$pupilIrisLowerCase="pupil";$vtxs=$pupilVtxs;}
		else
			{$pupilIris="Iris";$pupilIrisLowerCase="iris";$vtxs=$irisVtxs;}

		if ($a==-1 && !$addIrisAttr)
			continue;

		//pushback as grows with Lattice
		if ($a==1)  select $irisVtxs;
		if ($a==-1) select $eyeGeo;
		$tempString=`lattice -divisions 2 2 2 -objectCentered true  -ldv 2 2 2`;
		rename $tempString[0] ($pupilIris+"Ffd"+$side);
		rename $tempString[1] ($pupilIris+"FfdLattice"+$side);
		rename $tempString[2] ($pupilIris+"FfdBase"+$side);
		$tempString=`listConnections ($pupilIris+"Ffd"+$side+".message")`;
		rename $tempString[0] ($pupilIris+"FfdSet"+$side);
		setAttr -l 1 ($pupilIris+"FfdLattice"+$side+".v") 0;
		setAttr -l 1 ($pupilIris+"FfdBase"+$side+".v") 0;
		if (`objExists squashFfd`)
			reorderDeformers squashFfd ($pupilIris+"Ffd"+$side) $eyeGeo;
		if ($a==1)  sets -add ($pupilIris+"FfdSet"+$side) $vtxs $innerVtxs $outerVtxs;
		if ($a==-1) sets -remove ($pupilIris+"FfdSet"+$side) $backHalfVtxs;
		setAttr ($pupilIris+"Ffd"+$side+".outsideLattice") 1;
		parent ($pupilIris+"FfdLattice"+$side) ($pupilIris+"FfdBase"+$side) ("Eye"+$side);
		asAlign ($pupilIris+"FfdLattice"+$side) ("Iris"+$side) 0 1 0 0;
		asAlign ($pupilIris+"FfdBase"+$side) ("Iris"+$side) 0 1 0 0;
		rotate -r -os 0 90 0 ($pupilIris+"FfdLattice"+$side);
		rotate -r -os 0 90 0 ($pupilIris+"FfdBase"+$side);
		if ($a==-1)
			{
			setAttr ($pupilIris+"FfdLattice"+$side+".tx") 0;
			setAttr ($pupilIris+"FfdBase"+$side+".tx") 0;
			}
		setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v `getAttr ($pupilIris+"FfdLattice"+$side+".sz")` -cd ($eyeCtrl+"."+$pupilIrisLowerCase) ($pupilIris+"FfdLattice"+$side+".sz");
		keyTangent -index 0 -inTangentType flat -outTangentType flat ($pupilIris+"FfdLattice"+$side+"_scaleZ");
		setDrivenKeyframe -itt "linear" -ott "linear" -dv 10 -v 0 -cd ($eyeCtrl+"."+$pupilIrisLowerCase) ($pupilIris+"FfdLattice"+$side+".sz");
		setDrivenKeyframe -itt "linear" -ott "linear" -dv -10 -v (`getAttr ($pupilIris+"FfdLattice"+$side+".sz")`*1) -cd ($eyeCtrl+"."+$pupilIrisLowerCase) ($pupilIris+"FfdLattice"+$side+".sz");

		$buildPose="faceBuildPose";
		if (!`objExists $buildPose`)
			$buildPose="buildPose";
		$setAttrCmdExtra="setAttr "+$eyeCtrl+"."+$pupilIrisLowerCase+" 0;";
		setAttr -type "string" ($buildPose+".udAttr") (`getAttr ($buildPose+".udAttr")`+$setAttrCmdExtra);
		}
	}
if (`objExists ctrlEye_R`)
	select ctrlEye_R ctrlEye_L;
else
	select FKEye_R FKEye_L;
print "// EyeBall build complete.\n";
}

global proc asFaceEditEyeBallSDK ()
{
string $sdkObjs[]={"Pupil_R","Pupil_L","IrisFfdLattice_R","IrisFfdLattice_L"};
select -cl;
for ($i=0;$i<size($sdkObjs);$i++)
	if (`objExists $sdkObjs[$i]`)
		select -add $sdkObjs[$i];
GraphEditor;
}

global proc asFaceAttachEyeLashes ()
{
string $sel[]=`ls -sl`;
if (size($sel)==0)
	error "Nothing selected";
int $modifier=`getModifiers`;
int $numLid,$haveSkinCluster;
float $weight;
float $upperCurveChkSumBefore_R,$lowerCurveChkSumBefore_R,$upperCurveChkSumAfter_R,$lowerCurveChkSumAfter_R;
float $upperCurveChkSumBefore_L,$lowerCurveChkSumBefore_L,$upperCurveChkSumAfter_L,$lowerCurveChkSumAfter_L;
float $pos[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster,$side,$upperLower;
string $tempString[],$historyNodes[],$eyeLashTargets[];
//string $targets[]=`listAttr -m asFaceBS.weight`;

//MayaCrash when looping and duplicating
if (size($sel)>1)
	error "// Select only 1 EyeLash object at the time.\n";

//delete existing
for ($i=0;$i<size($sel);$i++)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";

		if (`objExists ($sel[$i]+"Cluster"+$side)`) delete ($sel[$i]+"Cluster"+$side);
		if (`objExists ($sel[$i]+"ClusterOffset"+$side)`) delete ($sel[$i]+"ClusterOffset"+$side);
		}
	if (`objExists ($sel[$i]+"BS")`) delete ($sel[$i]+"BS");
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		for ($y=1;$y<99;$y++)
			{
			if (`objExists ($upperLower+"LidMain"+$y+$side)`)
				$numLid=$y;
			else
				break;
			}

		polyPlane -n ($upperLower+"EyeLidCage"+$side) -w 1 -h 1 -sx ($numLid-1) -sy 1 -ax 0 1 0 -cuv 2 -ch 1;
		for ($y=1;$y<$numLid+1;$y++)
			{
			$pos=`xform -q -ws -t ($upperLower+"LidMain"+$y+$side)`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]");
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			$pos=`xform -q -ws -t FitEyeBall`;
			scale -r -p ($pos[0]*$b) $pos[1] $pos[2] 4 4 4 ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			}
		select ($upperLower+"EyeLidCage"+$side);
		for ($y=1;$y<$numLid+1;$y++)
			select -add ($upperLower+"LidMain"+$y+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($upperLower+"EyeLidCageSC"+$side);
		select $geometry ($upperLower+"EyeLidCage"+$side);
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		
		for ($y=1;$y<$numLid+1;$y++)
			{
			select ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]");
			artAttrSkinWeightCopy;
			select ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			artAttrSkinWeightPaste;
			}
		}
	}

select upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;
for ($i=0;$i<size($sel);$i++)
	{
	$historyNodes=`listHistory $sel[$i]`;
	$haveSkinCluster=0;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$skinCluster=$historyNodes[$y];
			}
	select $sel[$i];
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
			{
			if ($upperLowerFactor==1) $upperLower="upper";
			else $upperLower="lower";

			for ($y=1;$y<99;$y++)
				{
				if (`objExists ($upperLower+"LidMain"+$y+$side)`)
					$numLid=$y;
				else
					break;
				}

			if ($haveSkinCluster)
				for ($y=1;$y<$numLid+1;$y++)
					catchQuiet (`skinCluster -e -ai ($upperLower+"LidMain"+$y+$side) -lw false -wt 0 $skinCluster`);
			if (!$haveSkinCluster)
				{
				for ($y=1;$y<$numLid+1;$y++)
					select -add ($upperLower+"LidMain"+$y+$side);
				}
			}
		}
	if (!$haveSkinCluster)
		{
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=`rename $tempString[0] ($sel[$i]+"EyeLashSC")`;
		}

	select upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;
	select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	select $sel[$i];
	removeUnusedInfluences;
	}

delete upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;

select $sel;
}

global proc float asCurveChkSum (string $curve)
{
int $form,$spans,$degrees,$numCv;
float $chkSum;
$form=`getAttr ($curve+".form")`;
$spans=`getAttr ($curve+".spans")`;
$degrees=`getAttr ($curve+".degree")`;
if ($form==2) $numCv=$spans;
else $numCv=$spans+$degrees;
for ($i=0;$i<$numCv;$i++)
	{
	$pos=`xform -q -ws -t ($curve+".cv["+$i+"]")`;
	$chkSum=$chkSum+$pos[0]+$pos[1]+$pos[2];
	}

return $chkSum;
}

global proc asFaceDeleteFromCheckBox (string $region)
{
string $dialog=`confirmDialog -t "Confirm"
	-m ("Delete "+$region)
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	{
	checkBox -e -v 1 ("asFaceFit"+$region);
	return;
	}
if (`objExists ("FaceFit"+$region)`)
	delete ("FaceFit"+$region);
checkBox -e -ed 0 ("asFaceFit"+$region);
}

global proc asSmoothFlood (string $infA, string $infB, int $numSmoo)
{
global string $gSelect;
string $selO[]=`ls -sl -o`;
if ($selO[0]=="")
	return;

string $tempString[]=`listHistory $selO[0]`;
string $skinCluster;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="skinCluster")
		$skinCluster=$tempString[$y];

//string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $infJoints[]=`listConnections ($skinCluster+".matrix")`;

if ($infB!="")
	for ($i=0;$i<size($infJoints);$i++)
		{
		setAttr ($infJoints[$i]+".lockInfluenceWeights") 1;
		if ($infJoints[$i]==$infA || $infJoints[$i]==$infB)
			setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;
		}

ArtPaintSkinWeightsTool; 
artAttrSkinPaintCtx -e -sao smooth -influence $infA artAttrSkinContext;
artSkinInflListChanging $infA 1;
artSkinInflListChanged artAttrSkinPaintCtx;
for ($i=0;$i<$numSmoo;$i++)
	artFloodSurfaces;

for ($i=0;$i<size($infJoints);$i++)
	setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;
setToolTo $gSelect;
}

global proc asSkinTeeth ()
{
global string $gMainProgressBar;
global string $gSelect;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $upperTeethJoint="upperTeethJoint_M";
string $lowerTeethJoint="lowerTeethJoint_M";
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $tempString[];

//make sure teeth geo is in vtxs
if ($upperTeeth!="") 
	{
	eval ("select "+$upperTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	$upperTeeth=`stringArrayToString $tempString " "`;
	}
if ($lowerTeeth!="") 
	{
	eval ("select "+$lowerTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	$lowerTeeth=`stringArrayToString $tempString " "`;
	}

//teeth
string $upperLower,$teeth,$teethJoint,$teethObject;
string $teethObjects[];
string $teethSC=$skinCluster;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$teeth=$upperTeeth;$teethJoint=$upperTeethJoint;}
	else {$upperLower="lower";$teeth=$lowerTeeth;$teethJoint=$lowerTeethJoint;}
		
	if ($teeth=="")
		continue;

  eval ("select "+$teeth);
  $teethObjects=`ls -sl -o`;

	for ($i=0;$i<size($teethObjects);$i++)
		{
		$teethObject=$teethObjects[$i];
		int $haveSkinCluster=0;
	
		string $historyNodes[]=`listHistory -pdo 1 -il 2 $teethObject`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$teethSC=$historyNodes[$y];
				}
		if (!$haveSkinCluster)
			{
			select $teethJoint;
			select -add $teethObjects[$i];
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			rename $tempString[0] ($upperLower+"TeethSC");
			}
		else
			{
			$tempString=`listConnections ($teethSC+".matrix")`;
			if (!`stringArrayCount $teethJoint $tempString`)
				skinCluster -e -ai $teethJoint -lw false -wt 0 $teethSC;
			eval ("select "+$teeth);
			skinPercent -tv $teethJoint 1 $teethSC `ls -sl`;
			}
		}
	}
//Temp skin tongue as well, for easier jaw-weighting
if ($tongue!="")
	{
	eval ("select "+$tongue);
	$tempString=`ls -sl -o`;
	string $tongueObject=$tempString[0];
	int $haveSkinCluster=0;
	string $historyNodes[]=`listHistory -pdo 1 -il 2 $tongueObject`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$skinCluster=$historyNodes[$y];
				}
	if (!$haveSkinCluster)
		{
		select JawJoint_M;
		select -add $tongueObject;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] TongueSC;
		}
	else
		{
		$tempString=`listConnections ($skinCluster+".matrix")`;
		if (!`stringArrayCount JawJoint_M $tempString`)
			skinCluster -e -ai JawJoint_M -lw false -wt 0 $skinCluster;
		eval ("select "+$tongue);
		skinPercent -tv JawJoint_M 1 $skinCluster `ls -sl`;
		}
	}

setToolTo $gSelect;
}

global proc asSelectCurveVtx (string $curve)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[]=`listRelatives -s $curve`;
string $curveShape=$tempString[0];

string $tmpObjs[]={"tempLocator","tempPointOnCurveInfo","samplerMesh","closestSampler"};
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
spaceLocator -n tempLocator;
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
connectAttr -f ($curveShape+".worldSpace[0]") tempPointOnCurveInfo.inputCurve;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
setAttr tempPointOnCurveInfo.parameter 0.5;
connectAttr tempPointOnCurveInfo.position tempLocator.t;
setAttr tempLocator.v 0;

asCreateSamplerMesh $geometry; 
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
connectAttr tempLocator.worldPosition closestSampler.inPosition;
setAttr "tempPointOnCurveInfo.parameter" 1;
select -cl;
int $previousVtx;
for ($i=0;$i<99;$i++)
	{
	setAttr tempPointOnCurveInfo.parameter (0.01*$i);
	int $vtx=`getAttr closestSampler.result.closestVertexIndex`;
	if($vtx!=$previousVtx)
		{
		select -add ($geometry+".vtx["+$vtx+"]");
		string $currentSel[]=`ls -sl`;
//		refresh;
		select $currentSel;
		}
	$previousVtx=$vtx;
	}
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
}

global proc asFacePaintControllerWeights ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
int $error;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 Controller first";

if (`gmatch $sel[0] "*Lip[0-9]_*"`)
	error "The Lip controller does not directly control any joints or clusters";

if (!(`sets -im FaceControlSet` || `sets -im ControlSet`))
	error "Not a controller, as it is not a member of a controlset";

$tempString=`listConnections ($sel[0]+".s")`;
if (`gmatch $tempString[0] "*Cluster*"`)
	{
	asFacePaintClusterWeights;
	showRegion Clusters;
	select ClustersRegion;
	print "// Detected this controller to control a \"Cluster\", starting Cluster Painting Tool";
	}
else
	{
	tokenize $sel[0] "_" $tempString;
	if (!($tempString[1]=="R" || $tempString[1]=="L" || $tempString[1]=="M"))
		$error=1;
	string $joint=$tempString[0]+"Joint_"+$tempString[1];
	if (!`objExists $joint`)
		$error=1;
	if (!$error)
		{
		select $geometry;
		ArtPaintSkinWeightsTool;
		string $currentCtx = `currentCtx`;
		artSkinSelectInfluence artAttrSkinPaintCtx $joint;
		showRegion Normal;
		select $geometry;
		print "// Detected this controller to control a \"Joint\", starting Skin Weight Tool";
		}
	}
if ($error)
		error "Unable to detect which joint or cluster this is controlling";
}

global proc asFacePaintClusterWeights ()
{
global string $artSelectObject;
string $dialog=`confirmDialog -t "Confirm"
	-m ("This cluster have been \"Pruned\" for improved performance\n"
		+"Which means weights can not be painted outside Pruned area.")
	-b "UnPrune" -b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog=="Cancel")
	return;
	
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $sel[]=`ls -sl`;
string $tempString[];
tokenize $sel[0] "_" $tempString;
$fitJoint=$tempString[0];
$side="_"+$tempString[1];

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
setAttr ClustersRegion.v 1;

if ($dialog=="UnPrune")
	if (`objExists ($fitJoint+"Cluster"+$side+"Set") `)
		{
		string $currentMembers[]=`sets -q ($fitJoint+"Cluster"+$side+"Set")`;
		select ClustersRegion.vtx[0:999999];
		select -d $currentMembers;
		sets -add ($fitJoint+"Cluster"+$side+"Set") `ls -sl`;
		percent -v 0 ($fitJoint+"Cluster"+$side) `ls -sl`;
		select -cl;
		}

artAttrToolScript 4 "cluster";
$artSelectObject="";
eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
select ClustersRegion;
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
}

global proc asFaceCreatePlacementLocator (int $mirror, string $controlName)
{
string $side="_R";
if ($mirror)
	$side="_L";
else
	{
	if (`promptDialog -t "New Control" -m "Enter Name:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
		return;
	$controlName=`promptDialog -query -text`;
	}
if (`objExists ($controlName+$side)`)
	error ("Controller \""+$controlName+$side+"\" Already exists");

int $form,$spans,$degrees,$numCv;
$form=`getAttr upperEyeLidOuterCurve.form`;
$spans=`getAttr upperEyeLidOuterCurve.spans`;
$degrees=`getAttr upperEyeLidOuterCurve.degree`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;

spaceLocator -n ($controlName+"_placement");
float $posA[]=`xform -q -ws -t ("upperEyeLidOuterCurve.cv["+($numCv-1)+"]")`;
float $posB[]=`xform -q -ws -t ("upperEyeLidOuterCurve.cv[0]")`;
float $posC[];
$posC[0]=($posA[0]+$posB[0])/2.0;
$posC[1]=($posA[1]+$posB[1])/2.0;
$posC[2]=($posA[2]+$posB[2])/2.0 + ($posB[0]-$posA[0]);
xform -ws -t $posC[0] $posC[1] $posC[2] ($controlName+"_placement");
float $scale=($posB[0]-$posA[0])/2.0;
xform -os -r -s $scale $scale $scale ($controlName+"_placement");
addAttr -k 1 -ln placementLocator -at bool -dv true ($controlName+"_placement");
if ($mirror)
	{
	$posC=`xform -q -ws -t ($controlName+"_R")`;
	xform -ws -t ($posC[0]*-1) $posC[1] $posC[2] ($controlName+"_placement");
	$scale=`getAttr ($controlName+"_R.falloffRadius")`*2;
	xform -os -r -s $scale $scale $scale ($controlName+"_placement");
	}
select ($controlName+"_placement");
}

global proc asFaceConvertSoftModToControl (int $convertingBack)
{
global string $gSelect;
string $sel[]=`ls -sl`;
asFaceEnsureAdvancedBase;
float $pos[3],$posSoftMod[3],$posControl[3],$currentT[3],$currentR[3],$currentS[3];
string $tempString[],$historyList[];
string $side;
int $multiply;
int $autoKeyState=`autoKeyframe -q -state`;
string $fitJoint,$restoreCmd,$setAttrCmdExtra,$softModSet;
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*Handle*"`)
		$sel[0]=$sel[$i];

if ($convertingBack==1)
	{
	if (!`gmatch $sel[0] "convertedSoftModHandle_*"`)
		error "convertedSoftModHandle not selected";
	tokenize $sel[0] "_" $tempString;
	$fitJoint=$tempString[1];
	$side="_"+$tempString[2];
	$tempString=`listConnections ("convertedSoftMod_"+$fitJoint+$side+".message")`;
	$softModSet=$tempString[0];
	}
else
	{
	string $allBefore[]=`ls`;
	if (!`gmatch $sel[0] "softMod*"`)
		error "Selection is not a new SoftMod, name does not match \"softMod*\"";
	if ($convertingBack==0)
		{
		if (`promptDialog -t "New Control" -m "Enter Name:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
			return;
		$fitJoint=`promptDialog -query -text`;
		}
	if (`objExists $fitJoint` || $fitJoint=="")
		error "not a unique name";
	setToolTo $gSelect;

	//find $side, when tx=0
	float $locPos[3]=`getAttr ($sel[0]+".t")`;
	setAttr -type float3 ($sel[0]+".t") 0 0 0;
	float $pos[3]=`xform -q -ws -piv $sel[0]`;
	setAttr -type float3 ($sel[0]+".t") $locPos[0] $locPos[1] $locPos[2];
	$side="_M";
	if (!`checkBox -q -v asFaceIsMiddleControlCheckBox`)
		$side="_R";
	if ($pos[0]>0.001)
		error "SoftMod must be on Right side, or middle, currenly on Left side";

	$sel[0]=`rename $sel[0] ("convertedSoftModHandle_"+$fitJoint+$side)`;
	$tempString=`listConnections ("convertedSoftModHandle_"+$fitJoint+$side+".worldMatrix[0]")`;
	rename $tempString[0] ("convertedSoftMod_"+$fitJoint+$side);
	$tempString=`listConnections ("convertedSoftMod_"+$fitJoint+$side+".message")`;
	$softModSet=$tempString[0];
	string $deformObjs[]=`sets -q -no $softModSet`;
	$deformObjs=`stringArrayRemoveDuplicates $deformObjs`;

	$currentT=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".t")`;
	$currentR=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".r")`;
	$currentS=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".s")`;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".t") 0 0 0;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".r") 0 0 0;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".s") 1 1 1;
	$posSoftMod=`xform -q -ws -piv ("convertedSoftModHandle_"+$fitJoint+$side)`;
	curve -n tempCurve -d 1 -p $posSoftMod[0] $posSoftMod[1] $posSoftMod[2] -p $posSoftMod[0] $posSoftMod[1] $posSoftMod[2] -k 0 -k 1;
	deformer -type wrap tempCurve;
	select -r tempCurve;
	select -add ClustersRegion;
	AddWrapInfluence;

	$posControl=`xform -q -ws -t tempCurve.cv[0]`;
	createNode -n tempTransform transform;
	xform -ws -t $posControl[0] $posControl[1] $posControl[2] tempTransform;
	select tempTransform;
	int $color=6;
	if (size($deformObjs)>1)
		$color=9;
	asCreateFaceFitJoint $fitJoint `getAttr ("convertedSoftMod_"+$fitJoint+$side+".falloffRadius")` $color;
	setAttr ($fitJoint+".falloffMode") `getAttr ("convertedSoftMod_"+$fitJoint+$side+".falloffMode")`;
	softCluster $fitJoint $fitJoint 1 $side;
	
	if ($side=="_R")
		{
		//Mirror pose before doing left to ensure identical attachment
		string $restoreCmd=`asFaceMirror`;
		softCluster $fitJoint $fitJoint -1 "_L";
		$setAttrCmdExtra="xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_R;xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_L;";
	
		eval ($restoreCmd);
		if ($autoKeyState)
			autoKeyframe -state 1;
		}
	else
		$setAttrCmdExtra="xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_M;";


	delete tempCurve tempTransform;
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".t") $currentT[0] $currentT[1] $currentT[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".r") $currentR[0] $currentR[1] $currentR[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".s") $currentS[0] $currentS[1] $currentS[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	//add to faceBuildPose
	setAttr -type "string" faceBuildPose.udAttr (`getAttr faceBuildPose.udAttr`+$setAttrCmdExtra);

	//FaceAllset
	string $allAfter[]=`ls`;
	string $allNew[];
	for ($i=0;$i<size($allAfter);$i++)
		if (!`stringArrayCount $allAfter[$i] $allBefore`)
			if (`objectType $allAfter[$i]`!="objectSet")
				$allNew[size($allNew)]=$allAfter[$i];
	sets -add FaceAllSet $allNew;
	sets -remove FaceAllSet `listRelatives -ad FaceFitSkeleton`;
	}

float $t[3]=`xform -q -ws -piv $sel[0]`;
float $r[3]=`xform -q -ws -ro $sel[0]`;
float $s[3]=`xform -q -r -s $sel[0]`;
setAttr -type float3 ($sel[0]+".t") 0 0 0;
setAttr -type float3 ($sel[0]+".r") 0 0 0;
setAttr -type float3 ($sel[0]+".s") 1 1 1;

$pos=`xform -q -ws -t $fitJoint`;
string $softMod=`substitute "convertedSoftModHandle" $sel[0] "convertedSoftMod"`;
string $cluster=$fitJoint+"Cluster"+$side;
float $falloffRadius=`getAttr ($softMod+".falloffRadius")`;

float $falloffMode=`getAttr ($softMod+".falloffMode")`;
setAttr ($fitJoint+".falloffRadius") $falloffRadius;
setAttr ($fitJoint+".falloffMode") $falloffMode;

select $softModSet;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
$vtxs=`ls -sl -fl`;
polySelectConstraint -m 0;

if ($convertingBack)
	{
	percent -v 0 $cluster ClustersRegion;
	asFaceSoftModToCluster $softMod $cluster $vtxs;
	}
delete $softMod;
if ($convertingBack)
	{
	select ($fitJoint+$side);
	asFaceMirrorClusterWeight;
	}
xform -ws -t $t[0] $t[1] $t[2] -ro $r[0] $r[1] $r[2] -s $s[0] $s[1] $s[2] ($fitJoint+$side);
select ($fitJoint+$side);
}

global proc asFaceConvertControlToSoftMod ()
{
string $sel[]=`ls -sl`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $allFaceGeo[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a face control";
$tempString=`listConnections ($sel[0]+".s")`;
if (!`gmatch $tempString[0] "*Cluster*"`)
	error "Selected object is not a \"cluster\" control";
tokenize $sel[0] "_" $tempString;
string $fitJoint=$tempString[0];
string $side="_"+$tempString[1];
if ($side=="_L")
	error "must be Right side";

string $dialog=`confirmDialog -t "Confirm"
	-m ("This cluster have been \"Pruned\" for improved performance\n"
		+"Which means weights can not be painted outside Pruned area.")
	-b "UnPrune" -b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog=="Cancel")
	return;

float $falloffRadius=`getAttr ($fitJoint+".falloffRadius")`;
float $falloffMode=`getAttr ($fitJoint+".falloffMode")`;

if ($dialog=="UnPrune")
	if (`objExists ($fitJoint+"Cluster"+$side+"Set") `)
		{
		string $currentMembers[]=`sets -q ($fitJoint+"Cluster"+$side+"Set")`;
		select ClustersRegion.vtx[0:999999];
		select -d $currentMembers;
		sets -add ($fitJoint+"Cluster"+$side+"Set") `ls -sl`;
		percent -v 0 ($fitJoint+"Cluster"+$side) `ls -sl`;
		select -cl;
		}

float $t[3]=`xform -q -ws -t $sel[0]`;
float $r[3]=`xform -q -ws -ro $sel[0]`;
float $s[3]=`xform -q -r -s $sel[0]`;
setAttr -type float3 ($sel[0]+".t") 0 0 0;
setAttr -type float3 ($sel[0]+".r") 0 0 0;
setAttr -type float3 ($sel[0]+".s") 1 1 1;
float $pos[3]=`xform -q -ws -t $sel[0]`;
select -r ClustersRegion;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] ("convertedSoftMod_"+$sel[0])`;
string $softModHandle=`rename $tempString[1] ("convertedSoftModHandle_"+$sel[0])`;
$tempString=`listConnections ($softMod+".message")`;
string $softModSet=$tempString[0];
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]) $pos[1] $pos[2];
xform -piv ($pos[0]) $pos[1] $pos[2] $softModHandle;
xform -ws -t ($t[0]-$pos[0]) ($t[1]-$pos[1]) ($t[2]-$pos[2]) -ro $r[0] $r[1] $r[2] -s $s[0] $s[1] $s[2] $softModHandle;

if (`getAttr ($fitJoint+".overrideColor")`==9)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		if ($allFaceGeo[$i]!="ClustersRegion")
			sets -add $softModSet $allFaceGeo[$i];
	}
select $softModHandle;
}

global proc asFaceRetopoBase ()
{
if (!`objExists FaceFitSkeleton`)
	error "FaceFitSkeleton not found, The Face>Fit section must be completed first";
float $pos[];
string $tempString[];
string $headJoint=`getAttr FaceFitSkeleton.HeadJoint`;
string $geometry=`getAttr FaceFitSkeleton.Geometry`;

if (`objExists faceCage`) delete faceCage;
string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;
parent -w faceCage;
setAttr faceCage.v 1;
if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;

int $vtxs[]={0,1,2,3,4,5,6,7,8,9,
	10,11,12,13,
	14,16,17,18,20,21,
	22,23,
	24,25};
string $dests[]={"JawCurve.cv[3] ","Jaw","JawCorner","Throat","upperLipOuterCurve.cv[99]","lowerLipOuterCurve.cv[0]","JawPivot","Cheek","NoseCorner","NoseUnder",
	"CheekRaiser","upperLipOuterCurve.cv[0]","Nose",("lowerEyeLidOuterCurve.cv["+(`getAttr lowerEyeLidOuterCurve.spans`/2)+"]"),
	"lowerEyeLidOuterCurve.cv[0]","lowerEyeLidOuterCurve.cv[99]","EyeBrowMain3","EyeBrowMain0","EyeBrowMain6","EyeBrowOuterCurve.cv[99]",
	("upperEyeLidOuterCurve.cv["+(`getAttr upperEyeLidOuterCurve.spans`/2)+"]"),("EyeBrowOuterCurve.cv["+(`getAttr EyeBrowOuterCurve.spans`/2)+"]"),
	"EyeBrowOuterCurve.cv[0]","JawCurveTop.cv[3]"};
for ($i=0;$i<size($vtxs);$i++)
	{
	$pos=`xform -q -ws -t $dests[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] faceCage.vtx[$vtxs[$i]];
	}

$pos=`xform -q -ws -t faceCage.vtx[18]`; xform -ws -t 0 $pos[1] $pos[2] faceCage.vtx[19];

$posA=`xform -q -ws -t faceCage.vtx[12]`;
$posB=`xform -q -ws -t faceCage.vtx[19]`;
xform -ws -t 0 (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) faceCage.vtx[15];

//cluster BeackHead
select -r faceCage.vtx[28:42] ;
$tempString=`newCluster " -envelope 1"`;
rename $tempString[0] backHeadCluster;
rename $tempString[1] backHeadClusterHandle;
$posA=`xform -q -ws -piv backHeadClusterHandle`;
$posB=`xform -q -ws -piv faceCage.vtx[33]`;
xform -piv 0 $posA[1] $posB[2];
setAttr -type float3 backHeadClusterHandleShape.origin 0 $posA[1] $posB[2];
$posA=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
$posB=`xform -q -ws -t JawCorner`;
$posC=`xform -q -ws -piv backHeadClusterHandle`;
move -r 0 ((($posA[1]+$posB[1])/2.0)-$posC[1]) 0 backHeadClusterHandle;
$posA=`xform -q -ws -t $headJoint`;
move -r 0 0 ($posA[2]-$posC[2]) backHeadClusterHandle;

//scale to match
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t faceCage.vtx[30]`;
$scaleX=$posA[0]/$posB[0];
$posA=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
$posB=`xform -q -ws -t JawCorner`;
$FaceFitHeight=$posA[1]-$posB[1];
$posA=`xform -q -ws -t faceCage.vtx[33]`;
$posB=`xform -q -ws -t faceCage.vtx[29]`;
$BackHeadHeight=$posA[1]-$posB[1];
$scaleY=$FaceFitHeight/$BackHeadHeight;
scale -r $scaleX $scaleY ($scaleX/1.5) backHeadClusterHandle;
//select faceCage;
//DeleteHistory;

//snap to surface
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSampler.inMesh;
$posA=`xform -q -ws -t faceCage.vtx[14]`;
$posB=`xform -q -ws -t faceCage.vtx[12]`;
setAttr -type float3 closestSampler.inPosition 0 $posA[1] $posB[2];
$pos=`getAttr closestSampler.result.position`;
xform -ws -t 0 $pos[1] $pos[2] faceCage.vtx[15];

$posA=`xform -q -ws -t faceCage.vtx[15]`;
$posB=`xform -q -ws -t faceCage.vtx[12]`;
setAttr -type float3 closestSampler.inPosition 0 (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0);
$pos=`getAttr closestSampler.result.position`;
xform -ws -t 0 $pos[1] $pos[2] faceCage.vtx[26];

$pos=`xform -q -ws -t faceCage.vtx[10]`;
setAttr -type float3 closestSampler.inPosition ($pos[0]/2.0) $pos[1] $pos[2];
$pos=`getAttr closestSampler.result.position`;
xform -ws -t $pos[0] $pos[1] $pos[2] faceCage.vtx[27];

delete closestSampler;
print "// Face SkinCage created.\n";
}

global proc asFaceRetopoSections ()
{
float $pos[];
string $tempString[];
string $geometry=`getAttr FaceFitSkeleton.Geometry`;

if (`objExists topologyConstruction`) delete topologyConstruction;
if (!`objExists asRed`) asFitModeEnsureShaders;
createNode -n topologyConstruction transform;
asLockAttr topologyConstruction 1 1 1 1;

for ($a=0;$a<2;$a++)
	{
	if ($a==0) $lidLip="EyeLid";
	if ($a==1) $lidLip="Lip";

	addAttr -k 1 -dv 3 -ln ($lidLip+"Degree") -at "enum" -en "Linear=1:Cubic=3" topologyConstruction;
	addAttr -k 1 -dv 8 -ln ($lidLip+"UNumber") -at long topologyConstruction;
	addAttr -k 1 -dv 2 -ln ($lidLip+"VNumber") -at long topologyConstruction;

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";
		for ($b=0;$b<3;$b++)
			{
			if ($b==0) $outerMain="Outer";
			if ($b==1) $outerMain="Main";
			if ($b==2) $outerMain="Inner";

			rebuildCurve -n ($upperLower+$lidLip+$outerMain+"Curve2") -ch 0 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.000393701 ($upperLower+$lidLip+$outerMain+"Curve");
			setAttr ($upperLower+$lidLip+$outerMain+"Curve2.v") 0;
			parent ($upperLower+$lidLip+$outerMain+"Curve2") topologyConstruction;
			}
		select ($upperLower+$lidLip+"OuterCurve2") ($upperLower+$lidLip+"MainCurve2") ($upperLower+$lidLip+"InnerCurve2");
		$tempString=`loft -n ($upperLower+$lidLip+"Surface") -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 0 -rsn true`;
		setAttr ($upperLower+$lidLip+"Surface.v") 0;
		rename $tempString[1] ($upperLower+$lidLip+"Loft");
		connectAttr ("topologyConstruction."+$lidLip+"Degree") ($upperLower+$lidLip+"Loft.degree");

		$tempString=`nurbsToPoly -n ($upperLower+$lidLip) -mnd 1  -ch 1 -f 2 -pt 1 -pc 200 -chr 0.1 -ft 0.01 -mel 0.001 -d 0.1 -ut 2 -un 8 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 ($upperLower+$lidLip+"Surface")`;
		rename $tempString[1] ($upperLower+$lidLip+"NurbsTessellate");
		parent ($upperLower+$lidLip+"Surface") ($upperLower+$lidLip) topologyConstruction;

		connectAttr ("topologyConstruction."+$lidLip+"UNumber") ($upperLower+$lidLip+"NurbsTessellate.uNumber");
		connectAttr ("topologyConstruction."+$lidLip+"VNumber") ($upperLower+$lidLip+"NurbsTessellate.vNumber");
		sets -e -forceElement asRedSG ($upperLower+$lidLip);

		rename ($upperLower+$lidLip) ($upperLower+$lidLip+"_R");
		instance -n ($upperLower+$lidLip+"_L") ($upperLower+$lidLip+"_R");
		setAttr ($upperLower+$lidLip+"_L.scaleX") -1;
		}
	}

polyPlane -n NosePatch -w 1 -h 1 -sx 1 -sy 2 -ax 0 1 0 -cuv 2 -ch 0;
parent NosePatch topologyConstruction;
sets -e -forceElement asGreen2SG NosePatch;

$pos=`xform -q -ws -t NoseCorner`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[0:5];
$pos=`xform -q -ws -t NoseUnder`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[1];
$pos=`xform -q -ws -t Nose`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[3];

spaceLocator -n tempGeoSnapLoc;
geometryConstraint $geometry tempGeoSnapLoc;
$pos=`xform -q -ws -t Nose`; xform -ws -t $pos[0] $pos[1] $pos[2] tempGeoSnapLoc;
$posA=`xform -q -ws -t Nose`;
$posB=`xform -q -ws -t upperEyeLidOuterCurve.cv[0]`;
for ($i=0;$i<10;$i++)
	setAttr tempGeoSnapLoc.ty (($posA[1]+$posB[1])/2.0);
$pos=`xform -q -ws -t tempGeoSnapLoc`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[5];

$posA=`xform -q -ws -t Nose`;
$posB=`xform -q -ws -t NoseCorner`;
for ($i=0;$i<10;$i++)
	setAttr tempGeoSnapLoc.tx ($posB[0]/3.0);
$pos=`xform -q -ws -t tempGeoSnapLoc`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[4];
for ($i=0;$i<10;$i++)
	{
	setAttr tempGeoSnapLoc.ty (($pos[1]+$posB[1])/2.0);
	setAttr tempGeoSnapLoc.tx $posB[0];
	}
$pos=`xform -q -ws -t tempGeoSnapLoc`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[2];

rename NosePatch NosePatch_R;
instance -n NosePatch_L NosePatch_R;
setAttr NosePatch_R.scaleX -1;

delete tempGeoSnapLoc;
select topologyConstruction;
}

global proc asFaceDeleteSkinCage ()
{
delete faceCage;
}

global proc asEyeBallsChooseInput (string $textField)
{
string $sel[]=`ls -sl`;
string $txt=$sel[0];
if (size($sel)>1)
	for ($i=1;$i<size($sel);$i++)
		$txt+=" "+$sel[$i];
textField -e -tx $txt $textField;
asFaceUpdateInfo 0;
}

global proc asChooseInput (string $textField)
{
int $confirmed;
float $tempFloat[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $txt,$dialog,$m;
string $sel[]=`ls -sl`;
string $restoreSel[]=$sel;
string $tempString[],$tempString2[];

if (!`objExists FaceFitSkeleton`)
	error "FaceFitSkeleton not found, you must click \"Create Face FitSkeleton Node\" first.";

float $pos1[]=`xform -q -ws -t FaceFitSkeletonShape.cv[0]`;
float $pos2[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;

if (!`gmatch $textField "*Joint*"`)
	{
	//Include children
	select -cl;
	string $children[];
	for ($i=0;$i<size($sel);$i++)
		if (!`gmatch $sel[$i] "*[.]*"`)
			select -add `listRelatives -ad -f -type transform $sel[$i]`;
	string $addedSel[]=`ls -sl`;
	$sel=`stringArrayCatenate $sel $addedSel`;
	$sel=`stringArrayRemoveDuplicates $sel`;

	//Not include non-mesh || non-nurbs (unless choose joint)
	string $shapes[];
	for ($i=0;$i<size($sel);$i++)
		if (!`gmatch $sel[$i] "*[.]*"`)
			{
			$nodeType="";
			$shapes=`listRelatives -s -ni -f $sel[$i]`;
			if (size($shapes))
				$nodeType=`nodeType $shapes[0]`;
			if ($nodeType!="nurbsSurface" && $nodeType!="mesh")
				$sel=`stringArrayRemove {$sel[$i]} $sel`;
			}
	}
select $restoreSel;

$txt=$sel[0];

if (size($sel)>1)
	for ($i=1;$i<size($sel);$i++)
		$txt+=" "+$sel[$i];

//FaceGeometry validate part1
if ($textField=="asFaceGeometryTextField" && $sel[0]!="")
	if (!`asModelCheck "Continue anyway"`)
		return;

//Everything must have skinCluster
string $skinCluster;
for ($i=0;$i<size($sel);$i++)
	{
	if ($textField=="asFaceHeadJointTextField")
		continue;
	$tempString=`listHistory $sel[$i]`;
	$skinCluster="";
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			$skinCluster=$tempString[$y];
	if ($skinCluster=="")
		{
		if ($dialog!="Create New SkinCluster")
			$dialog=`confirmDialog -t "Confirm"
			-m "No SkinCluster found on this geometry"
			-b "Create New SkinCluster" -db "Create New SkinCluster"
			-b "Cancel" -ds "Cancel"`;
		if ($dialog!="Create New SkinCluster")
			return;
		select -cl;
		if (!`objExists $headJoint`)
			{
			joint -n $headJoint;
			xform -ws -t 0 ($pos1[1]+(($pos2[1]-$pos1[1])/3.0)) 0 $headJoint;
			}
		textField -e -tx $headJoint asFaceHeadJointTextField;
		select $sel[$i] $headJoint;
		$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		select $sel[$i];
		}
	if ($textField=="asFaceGeometryTextField")
		textField -e -tx $skinCluster asFaceSkinClusterTextField;
	}

//FaceGeometry validate part2
if ($textField=="asFaceGeometryTextField" && $sel[0]!="")
	{
	//Auto weight head ? (check by see if any other then Head-joint are inf on the top 2/3 of verts in `FaceFitSkeleton-region`
	select $sel;
//	polySelectConstraint -m 3 -t 1 -d 3 -db 0 (((($pos2[1]-$pos1[1])/1.0)*2)/3.0) -dp 0 $pos2[1] 0 -da 0 1 0;
	polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($pos2[1]-$pos1[1])/1.0) -dp 0 $pos2[1] 0 -da 0 1 0;
	$tempString=`skinPercent -query -t $skinCluster`;
	$tempString2=`ls -sl`;
	polySelectConstraint -m 0;
	select $tempString2;
	refresh;
	if (size($tempString)>1 || $tempString[0]!=$headJoint)
		$dialog=`confirmDialog -t "Confirm"
				-m "Selected vertices are not fully weighted to the headjoint."
				-b "Weight face to headjoint" -db "Weight face to headjoint"
				-b "No, keep current weighting" -ds "Cancel"`;
				if ($dialog=="Weight face to headjoint")
					{
					print "// Weighting face to headjoint.\n";
					polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($pos2[1]-$pos1[1])/1.0) -dp 0 $pos2[1] 0 -da 0 1 0;
					skinPercent -tv $headJoint 1 $skinCluster;
					polySelectConstraint -m 0;
					select $sel;
					asSmoothFlood $headJoint "" 3;
					}
	select $sel;
	}

//AllFaceGeo validate
if ($textField=="asFaceAllFaceGeoTextField" && $sel[0]!="")
	for ($i=0;$i<size($sel);$i++)
		{
		$tempString=`listRelatives -ni -s $sel[$i]`;
		if (!size($tempString))
			continue;
		if (!(`objectType $tempString[0]`=="mesh" || `objectType $tempString[0]`=="nurbsSurface"))
			continue;
		$tempString=`listHistory $sel[$i]`;
		$skinCluster="";
		for ($y=0;$y<size($tempString);$y++)
			if (`objectType $tempString[$y]`=="skinCluster")
				$skinCluster=$tempString[$y];
		if ($skinCluster=="")
			{
			if (!$confirmed)
				{
				$dialog=`confirmDialog -t "Confirm"
				-m "No SkinCluster found on some of the geometry"
				-b "Create New SkinClusters" -db "Create New SkinClusters"
				-b "Cancel" -ds "Cancel"`;
				if ($dialog!="Create New SkinClusters")
					return;
				}
			$confirmed=1;
			select -cl;
			if (!`objExists $headJoint`)
				joint -n $headJoint;
			select $sel[$i] $headJoint;
			$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
			}
		}

if (!`objExists FaceFitSkeleton`)
	error "First Create Face FitSkeleton Node";

asFaceEnsureFitBase;

textField -e -tx $txt $textField;
//optionVar -sv $textField $txt;
asFaceUpdateInfo 0;
}

global proc asFaceAddIn (string $targets[], string $transform, int $mo)
{
string $trAddIn=$transform+"AddIn";
createNode -n $trAddIn transform;
string $tempString[]=`listRelatives -p $transform`;
parent $trAddIn $tempString[0];
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $trAddIn;
string $cmd="parentConstraint";
if($mo)
	$cmd+=" -mo";
for ($i=0;$i<size($targets);$i++)
	$cmd+=" "+$targets[$i];
$cmd+=" "+$trAddIn;
eval $cmd;

string $trs[]={"t","r"};
for ($i=0;$i<size($trs);$i++)
	{
	createNode -n ($trAddIn+$trs[$i]+"plusMinusAverage") plusMinusAverage;
	if ($trs[$i]=="s")
		setAttr ($trAddIn+$trs[$i]+"plusMinusAverage.operation") 3;
	connectAttr ($trAddIn+"."+$trs[$i]+"x") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dx");
	connectAttr ($trAddIn+"."+$trs[$i]+"y") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dy");
	connectAttr ($trAddIn+"."+$trs[$i]+"z") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dz");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"x")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dx");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"y")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dy");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"z")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dz");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dx") ($transform+"."+$trs[$i]+"x");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dy") ($transform+"."+$trs[$i]+"y");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dz") ($transform+"."+$trs[$i]+"z");
	}
}

global proc float asFaceGetScale ()
{
float $scale=1.5;
if (`objExists FaceFitSkeletonHeightShape`)
    {
    float $pos1[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[5]`;
    float $pos2[]=`xform -q -ws -t FaceFitSkeletonShape.cv[5]`;
    $scale=$pos1[1]-$pos2[1];
   	}
return $scale;
}

global proc asCreateFaceFitJoint (string $region, float $size, int $color)
{
string $sel[]=`ls -sl -fl`;
float $pos[3]=`xform -q -ws -t $sel[0]`;
float $centerErrorMargin=0.001;
if ($region=="mouthUpper" || $region=="mouthLower" || $region=="eyeBrow0"
	|| `gmatch $region "*Middle"` || $region=="noseTip" || $region=="noseLower")
	if ($pos[0]>$centerErrorMargin || $pos[0]<(-1*$centerErrorMargin))
		error ($region+" needs to be in the center, currently:"+$pos[0]+"\n");
int $jointNumber;
string $jointName;
for ($i=1;$i<99;$i++)
	{
	$jointNumber=$i;
	$jointName=$region+$jointNumber;
	if (!`objExists $jointName`)
		break;
	}
asFaceEnsureFitBase;
for ($i=0;$i<size($sel);$i++)
	{
	$jointName=$region;
	if (size($sel)>1)
		$jointName=$region+$jointNumber;
	$jointNumber++;
	$jointName=`asFaceCreateFitJoint $jointName $size $color`;
	$pos=`xform -q -ws -t $sel[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $jointName;
	}

if (`checkBox -q -ex ("asFaceFit"+$region)`)
	checkBox -e -v 1 -ed 1 ("asFaceFit"+$region);
hilite -r `ls -o $sel`; 
select $sel;
repeatLast -addCommand ("asCreateFaceFitJoint "+$region+" "+$size+" "+$color);

if (`gmatch $region "eyeBrow[0-9]"`)
	asAutoEyeBrowFalloff $region;
}

global proc asAutoEyeBrowFalloff (string $region)
{
float $posA[3],$posB[3];
float $mag;
int $nr=`substring $region 8 8`;
string $previousRegion="eyeBrow"+($nr-1);
if (!`objExists $previousRegion`)
	return;
$posA=`xform -q -ws -t $region`;
$posB=`xform -q -ws -t $previousRegion`;
$mag=mag(<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>);
setAttr ($region+".falloffRadius") $mag;
float $previousRad=`getAttr ($previousRegion+".falloffRadius")`;
if ($mag>$previousRad || $previousRegion=="eyeBrow0")
	setAttr ($previousRegion+".falloffRadius") $mag;
}

global proc string asFaceCreateFitJoint (string $name, float $radius, int $color)
{
if (`objExists $name`)
	error ($name+" Already Exists");

if (!`objExists FaceFitFromSoftMods`)
	createNode -n FaceFitFromSoftMods -p FaceFitSkeleton transform;

select FaceFitFromSoftMods;
joint -n $name;
setAttr ($name+".overrideEnabled") 1;
setAttr ($name+".overrideColor") $color;
addAttr -k 1 -min 0 -dv $radius -ln "falloffRadius" -at double $name;
addAttr -k 1 -ln "falloffMode"  -at "enum" -en "volume:surface:" $name;
addAttr -k 1 -ln "interpolation"  -at "enum" -en "none:linear:smooth:spline:" $name;
if (`gmatch $name "lowerEye*"` || `gmatch $name "upperEye*"` || `gmatch $name "lowerLip*"` || `gmatch $name "upperLip*"`)
	;
else
	{
	setAttr ($name+".falloffMode") 1;
	setAttr ($name+".interpolation") 2;
	}
if (`gmatch $name "*Sculpt*"`)
	setAttr ($name+".falloffMode") 0;
return $name;
}

global proc asFaceUpdateInfo (int $read)
{
int $vtxsFromLipToNose=3;
int $vtxsFromLipCornerToNoseCorner=6;
int $stepBuild=0;
int $disableSteps[];
string $attrs[]={"Geometry","AllFaceGeo","Eye_R","Eye_L","UpperTeeth","LowerTeeth","Tongue",
	"EyeBrow_L","EyeBrow_R","EyeLash_L","EyeLash_R","HeadJoint","SkinCluster","Pupil_R","Pupil_L","Iris_R","Iris_L"};
string $avaiableBuiltTypes[];
string $text,$obj,$fitType,$savedFitType;

for ($i=0;$i<size($attrs);$i++)
	{
	string $texField="asFace"+$attrs[$i]+"TextField";
	if(!`textField -q -ex $texField`)
		continue;
	if ($read)
		{
		$text="";

		if ($attrs[$i]=="HeadJoint") $text="Head_M";
		if (`attributeExists $attrs[$i] FaceFitSkeleton`)
			$text=`getAttr ("FaceFitSkeleton."+$attrs[$i])`;
		textField -e -tx $text $texField;
		}
	else
		{
		if (!`attributeExists $attrs[$i] FaceFitSkeleton`)
			addAttr -ln $attrs[$i] -dt "string" FaceFitSkeleton;
		setAttr -type "string" ("FaceFitSkeleton."+$attrs[$i]) `textField -q -tx $texField`;
		}
	}

//Update CheckBoxes
string $checkBoxes[]=`lsUI -type checkBox`;
for ($i=0;$i<size($checkBoxes);$i++)
	{
	int $value=0;
	if (`gmatch $checkBoxes[$i] "asFaceFit*"`)
		{
		$obj=`substitute "asFaceFit" $checkBoxes[$i] "FaceFit"`;
		if (`objExists $obj`)
			$value=1;
		checkBox -e -ed $value -v $value $checkBoxes[$i];
		}
	}

//BuildStep
for ($i=1;$i<99;$i++)
	if (`rowLayout -q -ex ("asStepBuildRowLayout"+$i)`)
		rowLayout -e -en 1 ("asStepBuildRowLayout"+$i);
	else
		break;
if (`attributeExists buildStep FaceFitSkeleton`)
	{
	$stepBuild=`getAttr FaceFitSkeleton.buildStep`;
	for ($i=1;$i<99;$i++)
		if ($i<$stepBuild+1)
			if (`rowLayout -q -ex ("asStepBuildRowLayout"+$i)`)
				rowLayout -e -en 0 ("asStepBuildRowLayout"+$i);
			else
				break;
	}

//vtxsFromLipToNose
if (`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	$vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;
if (`intField -q -ex vtxsFromLipToNoseIntField`)
	intField -e -v $vtxsFromLipToNose vtxsFromLipToNoseIntField;

//vtxsFromCornerLipToNoseCorner
if (`attributeExists vtxsFromLipCornerToNoseCorner FaceFitSkeleton`)
	$vtxsFromLipCornerToNoseCorner=`getAttr FaceFitSkeleton.vtxsFromLipCornerToNoseCorner`;
if (`intField -q -ex vtxsFromLipCornerToNoseCornerIntField`)
	intField -e -v $vtxsFromLipCornerToNoseCorner vtxsFromLipCornerToNoseCornerIntField;

//BuildType
if (`optionMenu -q -ex asFaceBuildTypeOptionMenu`)
	{
	$fitType="Full";
	if (`attributeExists buildType FaceFitSkeleton`)
		{
		$avaiableBuiltTypes=`optionMenu -q -ils asFaceBuildTypeOptionMenu`;
		$savedFitType=`getAttr FaceFitSkeleton.buildType`;
		if (`stringArrayCount $savedFitType $avaiableBuiltTypes`)
			$fitType=$savedFitType;
		}
	optionMenu -e -v $fitType asFaceBuildTypeOptionMenu;
	}
}

global proc asParentPingPong (string $pingPong, string $side, string $ctrlParent)
{
parent ($pingPong+"Offset"+$side) $ctrlParent;
setAttr -type float3 ($pingPong+"Offset"+$side+".s") 1 1 1;
setAttr -type float3 ($pingPong+"Offset"+$side+".r") 0 0 0;
setAttr -type float3 ($pingPong+"SideReverse"+$side+".s") 1 1 1;
}

global proc asPingPong (string $trnPos, string $name, int $b, string $side, int $type, int $createJoint, int $bindSkin)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $curves[];
float $maxZ;
float $bb[],$pos[];
float $scale=`asFaceGetScale`/3.0;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;

$pos=`xform -q -ws -t $trnPos`;

//nurbsSphere controller
asCreateFaceController $name $side $type;
xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($name+"Offset"+$side);

//Joint + Offset
if ($createJoint)
	{
	select -cl;
	joint -n ($name+"Joint"+$side);
	parent ($name+"Joint"+$side) Face_M;
	setAttr ($name+"Joint"+$side+".segmentScaleCompensate") 0;
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($name+"Joint"+$side);
	parentConstraint ($name+$side) ($name+"Joint"+$side);
	createNode -n ($name+$side+"ScaleMultiplyDivide") multiplyDivide;
	connectAttr ($name+$side+".s") ($name+$side+"ScaleMultiplyDivide.input1");
	connectAttr ($name+"Drive"+$side+".s") ($name+$side+"ScaleMultiplyDivide.input2");
	connectAttr ($name+$side+"ScaleMultiplyDivide.output") ($name+"Joint"+$side+".s");
//	connectAttr ($name+$side+".s") ($name+"Joint"+$side+".s");
//	scaleConstraint ($name+$side) ($name+"Joint"+$side);
	}
if ($bindSkin)
	{
	string $bindToSkinCluster=$skinCluster;
	skinCluster -e -ai ($name+"Joint"+$side) -lw false -wt 0 $skinCluster;
	}

//move curve cv`s to be `infront` of mesh
asFacePlaceCtrlByProjection ($name+$side);

select -cl;
refresh;
}

global proc asCreateFaceController (string $name, string $side, int $type)
{
int $color;
float $scale=`asFaceGetScale`/5.0;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $radius=0.2;
string $letter;

if (`gmatch $name "*Droopy*"`)
	$type=3;
if ($type==1) $radius=0.3;
if ($type==3) $radius=0.1;

if ($type==1) {$letter="A";$color=14;}
if ($type==2) {$letter="B";$color=13;}
if ($type==3) {$letter="C";$color=6;}
if ($type==4) {$letter="Region";$color=17;}
if ($type==5) {$letter="Custom";$color=28;}

string $tempString[]=`circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $radius -d 3 -ut 0 -s 8 -ch 0`;
rename $tempString[0] ($name+$side);
sets -add "FaceControlSet" ($name+$side);
setAttr ($name+$side+"Shape.overrideEnabled") 1;
setAttr ($name+$side+"Shape.overrideColor") $color;
createNode -n ($name+"Offset"+$side) transform;
createNode -n ($name+"SideReverse"+$side) -p ($name+"Offset"+$side) transform;
createNode -n ($name+"Drive"+$side) -p ($name+"SideReverse"+$side) transform;
parent ($name+$side) ($name+"Drive"+$side);
if ($side=="_R")
	setAttr ($name+"SideReverse"+$side+".sx") -1;

parent ($name+"Offset"+$side) ($letter+"controls");
setAttr -type float3 ($name+"Offset"+$side+".s") ($faceFitScale/10.0) ($faceFitScale/10.0) ($faceFitScale/10.0);
connectAttr ("ctrlBox."+$letter+"CtrlVis") ($name+$side+"Shape.overrideVisibility");
//connectAttr ("ctrlBox."+$letter+"CtrlColor") ($name+$side+"Shape.overrideColor");
}

global proc asFacePlaceCtrlByProjection (string $ctrl)
{
float $maxZ=-999;
float $bb[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[],$curves[];

$tempString=`polyProjectCurve -ch true -direction 0 0 1 -pointsOnEdges 0 $ctrl $geometry`;
$curves=`listRelatives -c -type transform $tempString[0]`;
for ($i=0;$i<size($curves);$i++)
	{
	$bb=`xform -q -ws -bb $curves[$i]`;
	if ($bb[5]>$maxZ)
		$maxZ=$bb[5];
	}
delete $tempString[0];
$pos=`xform -q -ws -t ($ctrl+".cv[0]")`;
move -r 0 0 ($maxZ-$pos[2]) ($ctrl+".cv[0:99]");
}

global proc softCluster (string $trnPos, string $name, int $b, string $side)
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $falloffRadius=`getAttr ($name+".falloffRadius")`;
float $falloffMode=`getAttr ($name+".falloffMode")`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $allFaceGeo[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

if (!`objExists ClustersRegion`)
	{
	if (`objExists tempTargetFullMesh`)
		duplicate -n ClustersRegion tempTargetFullMesh;
	else
		duplicate -n ClustersRegion tempTarget;
	parent ClustersRegion RegionDeformations;
	sets -e -forceElement initialShadingGroup ClustersRegion;
	blendShape -e -tc 0 -t `textField -q -tx asFaceGeometryTextField` `getAttr -s asFaceBS.w` ClustersRegion 1 asFaceBS;
	setAttr asFaceBS.ClustersRegion 1;
	}

select $allFaceGeo;
float $scale=`asFaceGetScale`/3.0;
float $pos[3]=`xform -q -ws -t $trnPos`;
float $tempFloat[];
int $numVtxs[];
int $infNr;
float $value;
float $skinPercents[];
string $skinClusterInfs[];
string $oppositeSide;
select -r ClustersRegion;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;

string $softMod=`rename $tempString[0] ($name+"SoftMod"+$side)`;
string $softModHandle=`rename $tempString[1] ($name+"SoftModHandle"+$side)`;
$tempString=`listConnections ($name+"SoftMod"+$side+".message")`;
string $softModSet=`rename $tempString[0] ($name+"SoftModSet"+$side)`;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]*$b) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]*$b) $pos[1] $pos[2];
xform -piv ($pos[0]*$b) $pos[1] $pos[2] $softModHandle;
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;

asPingPong $name $name $b $side 8 0 0;
//setAttr ($name+$side+"Shape.overrideColor") `getAttr ($name+".overrideColor")`;
parent ($name+"Attach"+$side) Acontrols;

setAttr -type float3 ($softModHandle+".t") 1 0 0;
//softMod -e -pr fails in batch, when affecting multiple meshes
//no longer pruning , as this gets tricky when user want to paint outside prune area
//if (`getAttr ($name+".overrideColor")`!=9)
//	softMod -e -pr $softMod;
//changed:trying to bring back -pruning
	dgdirty -a;
if (`getAttr ($name+".overrideColor")`!=9) // Prune softMode does not work well with multiAffectedObjects
	{
	if (`asMayaVersionAsFloat`==2016) //2016 seem to need falloffMode==0, for pruning to work
		{
		setAttr ($softMod+".falloffMode") 0;
		softMod -e -pr $softMod;
		setAttr ($softMod+".falloffMode") $falloffMode;
		}
	else
		softMod -e -pr $softMod;
	}
$tempString=`listConnections ($softMod+".message")`;
select `sets -q $tempString[0]`;
string $vtxs[]=`ls -sl -fl`;
setAttr -type float3 ($softModHandle+".t") 0 0 0;

$tempString=`cluster -n ($name+"Cluster"+$side) -envelope 1`;
string $cluster=$tempString[0];
string $clusterHandle=$tempString[1];
$tempString=`listRelatives -s $clusterHandle`;
string $clusterHandleShape=$tempString[0];
$tempString=`listConnections ($cluster+".input[0].inputGeometry")`;
string $clusterGroupParts=$tempString[0];
$tempString=`listConnections ($cluster+".input[0].groupId")`;
string $clusterGroupId=$tempString[0];
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$tempString[0];
parent $clusterHandle ClusterSetup;
setAttr -type float3 ($clusterHandle+"Shape.origin") ($pos[0]*$b) $pos[1] $pos[2];
xform -piv ($pos[0]*$b) $pos[1] $pos[2] $clusterHandle;

asFaceSoftModToCluster $softMod $cluster $vtxs;
delete $softMod;

setAttr -l 1 ($clusterHandle+".v") 0;
connectAttr ($name+$side+".t") ($clusterHandle+".t");
connectAttr ($name+$side+".r") ($clusterHandle+".r");
connectAttr ($name+$side+".s") ($clusterHandle+".s");

//catch (`reorderDeformers $skinCluster $cluster $geometry`);
//catch (`reorderDeformers asFaceBS $cluster $geometry`);

if (`getAttr ($name+".overrideColor")`==9)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		if ($allFaceGeo[$i]!="ClustersRegion")
			{
			int $haveSkinCluster=0;
			$historyNodes=`listHistory -pdo 1 $allFaceGeo[$i]`;
			for ($y=0;$y<size($historyNodes);$y++)
				if (`nodeType $historyNodes[$y]`=="skinCluster")
					{
					$haveSkinCluster=1;
					$skinCluster=$historyNodes[$y];
					}
			if ($haveSkinCluster)
				catch (`reorderDeformers $skinCluster $cluster $allFaceGeo[$i]`);
			}
	}
}

global proc asFaceSoftModToCluster (string $softMod, string $cluster, string $vtxs[])
{
string $tempString[]=`listConnections ($softMod+".matrix")`;
string $softModHandle=$tempString[0];
setAttr ($softModHandle+".ty") 1;
$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
$softMod=$tempString[0];
string $componentType="vtx";

string $deformMeshs[]=`ls -o $vtxs`;
$deformMeshs=`stringArrayRemoveDuplicates $deformMeshs`;
string $deformXforms[];
for ($i=0;$i<size($deformMeshs);$i++)
	{
	$tempString=`listRelatives -p $deformMeshs[$i]`;
	$deformXforms[$i]=$tempString[0];
	}
setAttr ($softMod+".envelope") 0;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshA"+$i) $deformMeshs[$i];
setAttr ($softMod+".envelope") 1;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshB"+$i) $deformMeshs[$i];
float $sofModDefaultPos[3]=`xform -q -os -piv $softModHandle`;
float $posA[3];
float $posB[3];
for ($i=0;$i<size($deformMeshs);$i++)
    {
		$componentType="vtx";
		if (`objectType $deformMeshs[$i]`=="lattice")
			$componentType="pt";
    string $historyNodes[]=`listHistory $deformMeshs[$i]`;
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	if (`getAttr -se ($historyNodes[$y]+".nodeState")`)
	    	setAttr ($historyNodes[$y]+".nodeState") 1;
    percent -v 0 $cluster ($deformMeshs[$i]+"."+$componentType+"[0:999999]");
    for ($y=0;$y<size($vtxs);$y++)
        {
        if (!`gmatch $vtxs[$y] ($deformXforms[$i]+"[.]"+$componentType+"*")`)
            continue;
        tokenize $vtxs[$y] "." $tempString;
        $posA=`xform -q -ws -t ("tempMeshA"+$i+"."+$tempString[1])`;
        $posB=`xform -q -ws -t ("tempMeshB"+$i+"."+$tempString[1])`;
        percent -v ($posB[1]-$posA[1]) $cluster $vtxs[$y];
        }
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	if (`getAttr -se ($historyNodes[$y]+".nodeState")`)
	    	setAttr ($historyNodes[$y]+".nodeState") 0;
     }
for ($i=0;$i<size($deformMeshs);$i++)
	delete ("tempMeshA"+$i) ("tempMeshB"+$i);
clear $vtxs;
}

global proc string asFaceMirror ()
{
string $restoreCmd,$oppositeControl;
int $autoKeyState=`autoKeyframe -q -state`;
if ($autoKeyState)
	autoKeyframe -state 0;
string $mirrorAttrs[]={"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
string $controls[]=`sets -q FaceControlSet`;
for ($i=0;$i<size($controls);$i++)
	{
	if (!`gmatch $controls[$i] "*_L"`)
		continue;
	for ($attr in $mirrorAttrs)
		{
		if (`getAttr -l ($controls[$i]+"."+$attr)`)
			continue;
		$oppositeControl=`substitute "_L" $controls[$i] "_R"`;
		$multiply=1;
		if ($attr=="tx" || $attr=="ry" || $attr=="rz")
			$multiply=-1;
	
		$restoreCmd+="setAttr "+$controls[$i]+"."+$attr+" "+`getAttr ($controls[$i]+"."+$attr)`+";";
		setAttr ($controls[$i]+"."+$attr) (`getAttr ($oppositeControl+"."+$attr)`*$multiply);
		}
	}
if ($autoKeyState)
	$restoreCmd+="autoKeyframe -state 1;";
return $restoreCmd;
}

global proc asFaceMirrorControllerWeights ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $error;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 Controller first";

if (!(`sets -im FaceControlSet` || `sets -im ControlSet`))
	error "Not a controller, as it is not a member of a controlset";
$tempString=`listConnections ($sel[0]+".s")`;
float $pos[]=`getAttr ($sel[0]+".t")`;
float $rot[]=`getAttr ($sel[0]+".r")`;
float $sca[]=`getAttr ($sel[0]+".s")`;
	asGoToBuildPose faceSetup;
if (`gmatch $tempString[0] "*Cluster*"`)
	{
	print "// Detected this controller to control a \"Cluster\", performing Mirror Cluster Weights\n";
	asFaceMirrorClusterWeight;
	}
else
	{
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	print "Detected this controller to control a \"Joint\", performing Mirror Skin Weights";
	}
setAttr -type float3 ($sel[0]+".t") $pos[0] $pos[1] $pos[2];
setAttr -type float3 ($sel[0]+".r") $rot[0] $rot[1] $rot[2];
setAttr -type float3 ($sel[0]+".s") $sca[0] $sca[1] $sca[2];
select $sel;
}

global proc asFaceMirrorClusterWeight ()
{
string $sel[]=`ls -sl`;
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a faceControl";
string $control=$sel[0];

string $restorePoseCmd;
int $multiply;
int $numVtxs[]=`polyEvaluate -v ClustersRegion`;
float $maxDist,$mag;
float $posA[3],$posB[3],$tempFloat[];
string $tempString[],$rightVtxs[];
string $cluster=`substitute "_R" $control "Cluster_R"`;
string $oppositeControl=`substitute "_R" $control "_L"`;
string $oppositeCluster=`substitute "_R" $cluster "_L"`;
if (!`gmatch $control "*_R"` || !`objExists $oppositeCluster`)
	return;
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$cluster+"Set";
string $oppositeClusterSet=`substitute "_R" $clusterSet "_L"`;
if (!`objExists $oppositeClusterSet`)
	return;

//Start off by pruning
setAttr -type float3 ($control+".t") 1 0 0;
cluster -e -pr $cluster;
setAttr -type float3 ($control+".t") 0 0 0;

//Mirror pose before doing left to ensure identical attachment
string $restoreCmd=`asFaceMirror`;

percent -v 0 $oppositeCluster ("ClustersRegion.vtx[0:"+$numVtxs[0]+"]");
select `sets -q ($cluster+"Set")`;
$rightVtxs=`ls -sl -fl`;
$posA=`xform -q -ws -t $control`;
$maxDist=0;
for ($i=0;$i<size($rightVtxs);$i++)
	{
	$posB=`xform -q -ws -t $rightVtxs[$i]`;
	$mag=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
	if ($mag>$maxDist)
		$maxDist=$mag;
	}
$maxDist=$maxDist+($maxDist/20.0);

select ClustersRegion;
sets -add ($oppositeCluster+"Set") ClustersRegion;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $maxDist -dp ($posA[0]*-1) $posA[1] $posA[2];
string $vtxs[]=`ls -sl -fl`;
polySelectConstraint -m 0;
//sets -add ($oppositeCluster+"Set") $vtxs;
string $closestSampler=`createNode -n closestSampler closestPointOnMesh`;
$tempString=`listRelatives -ni -s ClustersRegion`;
connectAttr -f ($tempString[0]+".outMesh") ($closestSampler+".inMesh");
connectAttr -f ("ClustersRegion.worldMatrix[0]") ($closestSampler+".inputMatrix");
int $closestOppositeVtxNr;
global string $gMainProgressBar;
progressBar -e -st ("Mirroring Cluster for: "+$control) -bp -ii 1 -min 0 -max `size($vtxs)` $gMainProgressBar;
for ($i=0;$i<size($vtxs);$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		break;
	progressBar -e -s 1 $gMainProgressBar;
	$posB=`xform -q -ws -t $vtxs[$i]`;
	setAttr -type float3 ($closestSampler+".inPosition") ($posB[0]*-1) $posB[1] $posB[2];
	$closestOppositeVtxNr=`getAttr ($closestSampler+".result.closestVertexIndex")`;
	$tempFloat=`percent -q -v $cluster ("ClustersRegion.vtx["+$closestOppositeVtxNr+"]")`;

	if (!`sets -im $clusterSet ("ClustersRegion.vtx["+$closestOppositeVtxNr+"]")`)
		$tempFloat[0]=0;

	percent -v $tempFloat[0] $oppositeCluster $vtxs[$i];
	}
progressBar -e -ep $gMainProgressBar;
setAttr -type float3 ($oppositeControl+".t") 1 1 1;
cluster -e -pr $oppositeCluster;
setAttr -type float3 ($oppositeControl+".t") 0 0 0;
delete $closestSampler;

eval ($restoreCmd);
}

global proc asHelpImage (string $region)
{
string $asScriptLocation=`asGetScriptLocation`;
if (`window -q -ex faceHelpImage`)
	deleteUI faceHelpImage;
window faceHelpImage;
scrollLayout -w 666 -h 10;

if (`gmatch $region "*asBSWizardStep*"`)
	$region="asBSWizard/"+$region;

formLayout asHelpFormLayout;
image -i ($asScriptLocation+"/AdvancedSkeleton5Files/div/images/help/"+$region+".jpg") asHelpImage;

formLayout -e
	-af asHelpImage "right" 0
	-af asHelpImage "left" 0
	-af asHelpImage "top" 0
	-af asHelpImage "bottom" 0
	asHelpFormLayout;

//Video Link
string $helpUrl;
string $buttonLabel="Open Video Link";
if ($region=="asDeformSkinCageSliders")
	$helpUrl="https://youtu.be/uMaKwxKXygw";
if ($region=="asFitLabels")
	$helpUrl="https://youtu.be/fyR2szfj3z0";
if ($region=="asFitAttributes")
	$helpUrl="https://youtu.be/WgJsDv1ZdVs";
if ($region=="asDeformSkinCageDWidth")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=153";
if ($region=="asDeformSubWrapCage" || $region=="asDeformSubWrapWrap")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=280";
if ($region=="asDeformSkinLoopsCreate" || $region=="asDeformSkinLoopsSelectAll"
	|| $region=="asDeformSkinLoopsBind" || $region=="asDeformSkinLoopsCutUp")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=151";
if ($region=="asMotionCaptureReadBvh" || $region=="asMotionCaptureConnect")
	{
	$helpUrl="https://sites.google.com/a/cgspeed.com/cgspeed/motion-capture/cmu-bvh-conversion";
	$buttonLabel="Open Link";
	}
if ($region=="asGameSkeletonCreate" || $region=="asGameSkeletonTransfer")
	{
	$helpUrl="https://youtu.be/fPX9gy2RrbA";
	$buttonLabel="Open Link";
	}
if ($region=="asCorrectiveShapesCreate")
	$helpUrl="https://youtu.be/YOIyFB2nK90";
if ($region=="asCorrectiveShapesBake")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=327";
if ($region=="faceFitSkeletonNode")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=357";
if ($region=="asEditBlendShapesCreate")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=663";
if ($region=="asTweakControllersCreate")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=743";
if ($region=="asSelectorDesigner")
	$helpUrl="https://youtu.be/0dpLmKZbEJc";
if ($region=="asPoserDesigner")
	{
	$helpUrl="http://www.studiolibrary.com/";
	$buttonLabel="Open Link";
	}
if ($region=="asWalkDesigner")
	$helpUrl="https://youtu.be/jMTfxKArl1Q";

if ($helpUrl!="")
	{
	string $button=`button -w 200 -h 50 -l $buttonLabel -c ("showHelp -a \""+$helpUrl+"\"")`;
	formLayout -e
		-af $button "top" 715
		-af $button "left" 220
		asHelpFormLayout;
	if ($region=="asFitLabels" || $region=="asFitAttributes") formLayout -e -af $button "top" 40  asHelpFormLayout;
	}
showWindow;
window -e -h 808 faceHelpImage;
}

global proc asFaceSquintByLattice ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
float $dist;
float $scale=`asFaceGetScale`;
float $pos[],$pos2[];
string $tempString[],$allFaceGeo[];
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

//Restore "Display only tongue geo"
if (!`gmatch $tongue "*[.]*"`)
	for ($i=0;$i<size($allFaceGeo);$i++)
		{
		if (!`getAttr -l ($allFaceGeo[$i]+".v")`)
			setAttr ($allFaceGeo[$i]+".v") 1;
		}

$side="_R";

duplicate -rr -n ("eye_squint"+$side) tempTarget;
setAttr ("eye_squint"+$side+".v") 1;

$tempString=`listRelatives -s -f ("eye_squint"+$side)`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
parent -w eye_squint_R;
setAttr ($geometry+".v") 0;

select ("eye_squint"+$side);
$tempString=`lattice  -divisions 3 4 4 -objectCentered true  -ldv 2 2 2`;
string $ffd=$tempString[0];
string $lattice=$tempString[1];
string $latticeBase=$tempString[2];

$pos=`xform -q -ws -t FitEyeBall`;
xform -ws -t $pos[0] $pos[1] $pos[2] $lattice;
xform -ws -t $pos[0] $pos[1] $pos[2] $latticeBase;
delete `scaleConstraint FitEyeBall $lattice`;
delete `scaleConstraint FitEyeBall $latticeBase`;
scale -r 2 2 2 $lattice;
scale -r 2 2 2 $latticeBase;
setAttr ($lattice+".sx") ($pos[0]*4);
setAttr ($latticeBase+".sx") ($pos[0]*4);
select ($lattice+".pt[1:2][1:2][2]");
scale -r -p $pos[0] $pos[1] $pos[2] 1 0.2 1 ;
$pos=`xform -q -ws -t ($lattice+".pt[0][2][3]")`;
$pos2=`xform -q -ws -t ($lattice+".pt[0][1][3]")`;
$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
move -r 0 0 ($dist*0.2); 
select ("eye_squint"+$side);

select -cl;
}

global proc asFaceBsSdk (string $ctrl, float $driveValue, string $bs, float $drivenValue)
{
setDrivenKeyframe -itt spline -ott spline -currentDriver $ctrl $bs;
setAttr $ctrl $driveValue;
setAttr $bs $drivenValue;
setDrivenKeyframe -itt spline -ott spline -currentDriver $ctrl $bs;
setAttr $ctrl 0;
if ($driveValue>0)
	keyTangent -in 0 -itt linear -ott linear $bs;

//pre post infinity
string $nodes[]=`listConnections -s 1 -d 0 -scn 1 $bs`;
for ($i=0;$i<size($nodes);$i++)
	{
	$tempString=`nodeType -inherited $nodes[$i]`;
	if ($tempString[0]=="animCurve")
		{
		setAttr ($nodes[$i]+".preInfinity") 4;
		setAttr ($nodes[$i]+".postInfinity") 4;
		}
	}
}

global proc float[] asGetMidHeadPos ()
{
float $midHeadPos[];
//first look for joints, as the fig might be from before faceFitScaleCurve came about
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $headPos[]=`xform -q -ws -t $headJoint`;
string $tempString[]=`listRelatives -c $headJoint`;
if(size($tempString))
	{
	$temp=`xform -q -ws -t $tempString[0]`;
	$midHeadPos[0]=(($headPos[0]+$temp[0])/2.0);
	$midHeadPos[1]=(($headPos[1]+$temp[1])/2.0);
	$midHeadPos[2]=(($headPos[2]+$temp[2])/2.0);
	}
if (`objExists FaceFitSkeletonHeightShape`)
	{
	float $pos1[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[5]`;
	float $pos2[]=`xform -q -ws -t FaceFitSkeletonShape.cv[5]`;
	$midHeadPos={$headPos[0],($pos1[1]+$pos2[1])/2.0,$headPos[2]};
	}

return $midHeadPos;
}

global proc asFaceCreateCtrlBox (string $name, float $x, float $y, int $half)
{
$tempString=`duplicate -rc ctrlBoxTemplate`;
rename $tempString[0] ("ctrlBox"+$name);
rename $tempString[1] ("ctrl"+$name);
setAttr -type float3 ("ctrlBox"+$name+".t") $x $y 0;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransYLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransYLimitEnable")`);

if ($half)
	{
	float $pos0[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[0]")`;
	float $pos2[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[2]")`;
	float $pos3[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[3]")`;
	if ($half==1)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[2]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos3[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[3]");
		transformLimits -tx -1 1 -ty 0 1 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	if ($half==2)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[1]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[0]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[4]");
		transformLimits -tx -1 1 -ty -1 0 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	}
}

global proc asRemoveInfluence (string $joint, string $skinCluster)
{
string $infJoints[]=`listConnections -s 1 -d 0 ($skinCluster+".matrix")`;
if (`stringArrayCount $joint $infJoints`)
	{
	skinCluster -e -ri $joint $skinCluster;
	//If no other influences, then remove skinCluster.
	if (size($infJoints)==1)
		delete $skinCluster;
	}
}

global proc asBuildFitEyeBall ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $righEyeGeoText=`textField -q -tx asFaceEye_RTextField`;
string $dialog="OK";
string $tempString[],$tempString2[],$eyeGeos[];
if ($righEyeGeoText=="")
	error "No Eye Geometry choosen";
if (`objExists FitEyeBall`)
	error "FitEyeBall already exists";
int $hadBodyEye=0;
float $pos[],$rot[];
if (`objExists FKEye_R`)
	{
	if (!`objExists headTopology`)
		$dialog=`confirmDialog -t "Confirm"
			-m "This will replace the Eyes from the Body-setup"
			-b "OK" -db "OK"
			-b "Cancel" -ds "Cancel"`;
	if ($dialog!="OK")
		return;
	$hadBodyEye=1;
	string $skinClusters[]=`ls -type skinCluster`;
	for ($i=0;$i<size($skinClusters);$i++)
		{
		//First add Head as inf (if Eye is only inf), since having none inf`s breaks the skinCluster
		$tempString=`listConnections ($skinClusters[$i]+".matrix")`;
		if (size($tempString)==1 && `gmatch $tempString[0] "Eye_*"`) {
			skinCluster -e -ai $headJoint -lw false -wt 1 $skinClusters[$i];
			print ("skinCluster -e -ai "+$headJoint+" -lw false -wt 1 "+$skinClusters[$i]+";\n");
			}
		if (`objExists Eye_R`) asRemoveInfluence Eye_R $skinClusters[$i];
		if (`objExists Eye_L`) asRemoveInfluence Eye_L $skinClusters[$i];
		}
	$pos=`xform -q -ws -t Eye_R`;
	$rot=`xform -q -ws -ro Eye_R`;
	if (`objExists FKOffsetEye_R`) delete FKOffsetEye_R;
	if (`objExists FKOffsetEye_L`) delete FKOffsetEye_L;
	if (`objExists FKAimEye_R`) delete FKAimEye_R;
	if (`objExists FKAimEye_L`) delete FKAimEye_L;
	if (`objExists Eye_R`)delete Eye_R;
	if (`objExists Eye_L`) delete Eye_L;
	if (`objExists AimEye`) delete AimEye;
	if (`objExists Eye`) delete Eye;
	asRemoveUnusedfromBuildPose bodySetup;
	}
float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
asFitModeEnsureShaders;
spaceLocator -n FitEyeBall;
setAttr FitEyeBall.rotateOrder 2;
setAttr -type float3 FitEyeBallShape.localScale 1.5 1.5 1.5;
createNode -n FaceFitEyeBall -p FaceFitSkeleton transform;
setAttr -type float3 FaceFitEyeBall.r 180 -90 0;
parent FitEyeBall FaceFitEyeBall;
setAttr -type float3 FitEyeBall.r 0 0 0;
polySphere -n FitEyeSphere -r 0.5 -sx 8 -sy 8 -ax 0 1 0 -cuv 2 -ch 0;
setAttr FitEyeSphere.overrideEnabled 1;
setAttr FitEyeSphere.overrideDisplayType 2;
parent FitEyeSphere FitEyeBall;
sets -e -forceElement asWhiteSG FitEyeSphere;
sets -e -forceElement asBlackSG FitEyeSphere.f[56:63];
setAttr -type float3 FitEyeSphere.r 0 0 -90;
setAttr -type float3 FitEyeBall.s (0.025*$height) (0.025*$height) (0.025*$height);

if ($hadBodyEye)
	{
	xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] FitEyeBall;
	}
else
	{
	$pos=`xform -q -ws -t $headJoint`;
	xform -ws -t $pos[0] $pos[1] $pos[2] FitEyeBall;
	setAttr -type float3 FitEyeBall.t ($pos[1]/-50.0) ($pos[1]/15.0) ($pos[1]/15.0);
//	setAttr FitEyeBall.ry -90;
	}

//guestimate placement (and scale) based upon 1st selected geo
tokenize $righEyeGeoText $tempString;
for ($i=0;$i<size($tempString);$i++)
	if (!`gmatch $tempString[$i] "*[.]*"`)
		$eyeGeos[size($eyeGeos)]=$tempString[$i];
if (size($eyeGeos))
	{
	$tempString=`duplicate -n tempEye $eyeGeos[0]`;
	$tempString2=`listRelatives -p $tempString[0]`;
	if ($tempString2[0]!="")
		$tempString=`parent -w $tempString[0]`;
	select $tempString[0];
	CenterPivot;
	float $pos[]=`xform -q -ws -piv $tempString[0]`;
	float $bb[]=`xform -q -ws -bb $tempString[0]`;
	delete $tempString[0];
	if ($pos[1]>0)
		{
		parent -w FitEyeBall;
		if (!$hadBodyEye)
			xform -ws -t $pos[0] $pos[1] $pos[2] FitEyeBall;
		xform -os -s ($bb[4]-$bb[1]) ($bb[4]-$bb[1]) ($bb[4]-$bb[1]) FitEyeBall;
		parent FitEyeBall FaceFitEyeBall;
		}
	}


select FitEyeBall;
print ("// FitEyeBall created, place this to match the eye-ball of your character\n");
checkBox -e -ed 1 -v 1 asFaceFitEyeBall;
}

global proc asFaceEnsureFitBase ()
{
if (!`objExists FaceFitSkeleton`)
	asCreateFaceFitSkeleton;
}

global proc asFaceEnsureShaders ()
{
string $colors[]={"asFaceBlue","asFaceBrown","asFaceGreen","asFaceCyan","asFaceRed"};
float $rs[]={0.0,0.541,0.000,0.0,0.4};
float $gs[]={0.0,0.282,0.275,0.5,0};
float $bs[]={1.0,0.200,0.098,0.5,0};
for ($i=0;$i<size($colors);$i++)
	{
	if (`objExists $colors[$i]` && `objExists ($colors[$i]+"SG")`)
		continue;
	if (`objExists $colors[$i]`) delete $colors[$i];
	if (`objExists ($colors[$i]+"SG")`) delete ($colors[$i]+"SG");
	shadingNode -n $colors[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($colors[$i]+"SG");
	connectAttr -f ($colors[$i]+".outColor") ($colors[$i]+"SG.surfaceShader");
	setAttr -type float3 ($colors[$i]+".color") $rs[$i] $gs[$i] $bs[$i];
	setAttr -type float3 ($colors[$i]+".ambientColor") $rs[$i] $gs[$i] $bs[$i];
	setAttr -type float3 ($colors[$i]+".incandescence") $rs[$i] $gs[$i] $bs[$i];
	}
}

global proc asFaceEnsureAdvancedBase ()
{
asFaceEnsureShaders;
string $sel[]=`ls -sl`;
if (!`objExists FaceGroup`)
	error "FaceGroup does not exists, must build a Fit-system first";
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
if (!`objExists $headJoint`)
	error ("HeadJoint: \""+$headJoint+"\" Does not exists");
if (`objExists FaceMotionSystem`)
	setAttr FaceMotionSystem.v 1;
if (`objExists FaceMotionSystem`)
	return;

//top level nodes
createNode -n FaceMotionSystem -p FaceGroup transform;
createNode -n FaceMotionFollowHead -p FaceMotionSystem transform;
createNode -n ControlsSetup -p FaceMotionFollowHead transform;
createNode -n FaceDeformationSystem -p FaceMotionSystem transform;
setAttr -l 1 FaceDeformationSystem.v 0;
createNode -n FaceDeformationSystemFollowHead -p FaceMotionFollowHead transform;
setAttr -l 1 FaceDeformationSystemFollowHead.v 0;
createNode -n Acontrols -p ControlsSetup transform;
createNode -n Bcontrols -p ControlsSetup transform;
createNode -n Ccontrols -p ControlsSetup transform;
createNode -n Aimcontrols -p ControlsSetup transform;
createNode -n Regioncontrols -p ControlsSetup transform;
createNode -n Customcontrols -p ControlsSetup transform;

createNode -n FaceBuildInProgress transform;
setAttr FaceBuildInProgress.v 0;

createNode -n MainAndHeadScaleMultiplyDivide multiplyDivide;
connectAttr ($headJoint+".scale") MainAndHeadScaleMultiplyDivide.input1;
if (`objExists Main`)
	connectAttr Main.scale MainAndHeadScaleMultiplyDivide.input2;

pointConstraint $headJoint FaceMotionFollowHead;
orientConstraint -mo $headJoint FaceMotionFollowHead;
//scaleConstraint $headJoint FaceMotionFollowHead;
connectAttr MainAndHeadScaleMultiplyDivide.output FaceMotionFollowHead.s;

//faceBuildPose
if (!`objExists faceBuildPose`)
	{
	createNode -n faceBuildPose dagPose;
	addAttr -ln udAttr -dt "string"  faceBuildPose;
	}

//Sets
select -cl;
sets -name FaceAllSet;
sets -name FaceControlSet;
sets -em -n FaceAreas;
if (`objExists "Sets"`)
	{
	sets -add "Sets" FaceAllSet;
	sets -add "Sets" FaceControlSet;
	sets -add "Sets" FaceAreas;
	}
sets -em -n FaceBuildingSets;
sets -add FaceAllSet FaceBuildingSets;
sets -add FaceBuildingSets allBeforeFaceBuild;


select $sel;
}

global proc asFaceDeltaMush ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];

if (!`exists deltaMush`)
	error "DeltaMush not avaiable in this version of Maya";
if (`objExists asFaceDeltaMush`)
	error "asFaceDeltaMush already exists";

select $geometry;
$tempString=`deltaMush -smoothingIterations 10 -smoothingStep 0.5 -pinBorderVertices 1 -envelope 1`;
rename $tempString[0] asFaceDeltaMush;
$tempString=`listConnections asFaceDeltaMush.message`;
rename $tempString[0] asFaceDeltaMushSet;

asConnectDeltaMushScale;
select $geometry;
print "// DeltaMush applied\n";
}

global proc asAdvancedSquash ()
{
global string $gSelect;
setToolTo $gSelect;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`asFaceGetScale`/3.0;
float $value,$min,$max;
float $pos[3],$pos2[3];
string $name;
string $tempString[],$allFaceGeo[],$historyNodes[],$infs[];
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
string $allBefore[]=`ls`;
string $faceControlSetMembers[]=`sets -q FaceControlSet`;

//squashHead
float $squashTopPos[3]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
float $squashBasePos[3]=`xform -q -ws -t FaceFitSkeletonShape.cv[0]`;
float $BaseToTopY=$squashTopPos[1]-$squashBasePos[1];

createNode -n SquashSetup -p FaceMotionSystem transform;
$tempString[0]=`curve -d 1 -p 1 1 1 -p 1 -1 1 -p -1 -1 1 -p -1 1 1 -p 1 1 1 -p 1 1 -1 -p 1 -1 -1 -p 1 -1 1 -p 1 -1 -1 -p -1 -1 -1 -p -1 1 -1 -p 1 1 -1 -p -1 1 -1 -p -1 1 1 -p -1 -1 1 -p -1 -1 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15`;
rename $tempString[0] squashTop_M;
setAttr squashTop_MShape.overrideEnabled 1;
setAttr squashTop_MShape.overrideColor 13;
createNode -n squashTopOffset transform;
parent squashTop_M squashTopOffset;
xform -ws -t 0 $squashTopPos[1] 0 squashTopOffset;
xform -ws -s ($scale/0.75) ($scale/5.0) ($scale/5.0) squashTop_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashTop_M;
sets -add "FaceControlSet" squashTop_M;
duplicate -n SquashControls squashTopOffset;
rename SquashControls|squashTop_M squashBase_M;
xform -ws -t 0 $squashBasePos[1] 0 SquashControls;
duplicate -n squashMiddleOffset squashTopOffset;
rename squashMiddleOffset|squashTop_M squashMiddle_M;
xform -ws -t 0 (($squashBasePos[1]+$squashTopPos[1])/2) 0 squashMiddleOffset;
scale -r 1.5 1 1 squashMiddle_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashMiddle_M;
parent squashTopOffset squashMiddleOffset squashBase_M;

addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 squashTop_M;
createNode -n squashTopVolumeUC unitConversion;
setAttr squashTopVolumeUC.conversionFactor 0.1;
connectAttr squashTop_M.volume squashTopVolumeUC.input;

setAttr -l 1 -k 0 squashTop_M.rx;setAttr -l 1 -k 0 squashTop_M.ry;setAttr -l 1 -k 0 squashTop_M.rz;
setAttr -l 1 -k 0 squashTop_M.sx;setAttr -l 1 -k 0 squashTop_M.sy;setAttr -l 1 -k 0 squashTop_M.sz;
setAttr -l 1 -k 0 squashTop_M.v;
setAttr -l 1 -k 0 squashMiddle_M.rx;setAttr -l 1 -k 0 squashMiddle_M.ry;setAttr -l 1 -k 0 squashMiddle_M.rz;
setAttr -l 1 -k 0 squashMiddle_M.sx;setAttr -l 1 -k 0 squashMiddle_M.sy;setAttr -l 1 -k 0 squashMiddle_M.sz;
setAttr -l 1 -k 0 squashMiddle_M.v;
setAttr -l 1 -k 0 squashBase_M.sx;setAttr -l 1 -k 0 squashBase_M.sy;setAttr -l 1 -k 0 squashBase_M.sz;
setAttr -l 1 -k 0 squashBase_M.v;

select $allFaceGeo;
//Do not include wrapped on`s or wired on`s  (e.g eyebrows)
for ($i=0;$i<size($allFaceGeo);$i++)
	{
	$historyNodes=`listHistory -f 0 -pruneDagObjects 1 -lv 4 $allFaceGeo[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`objectType $historyNodes[$y]`=="wrap" || `objectType $historyNodes[$y]`=="wire")
			select -d $allFaceGeo[$i];
	}

$tempString=`lattice  -divisions 2 11 2 -objectCentered true  -ldv 2 2 2`;
rename $tempString[0] squashFfd;
rename $tempString[1] squashFfdLattice;
rename $tempString[2] squashFfdBase;
$tempString=`listConnections squashFfd.message`;
rename $tempString[0] squashFfdSet;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdLattice;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdBase;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdLattice;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdBase;
scale -r 1.25 1.25 1.25 squashFfdLattice;
scale -r 1.25 1.25 1.25 squashFfdBase;
setAttr "squashFfd.outsideLattice" 1;
parent squashFfdBase squashBase_M;
createNode -n squashXup transform;
setAttr -type float3 squashXup.r 90 0 90;
select squashXup;
$pos=`xform -q -ws -t squashFfdLattice.pt[0][1][1]`;
joint -n squashIKX0 -p 0 $pos[1] 0;
select squashXup;
for ($i=1;$i<10;$i++)
    {
    $pos=`xform -q -ws -t squashFfdLattice.pt[0][$i][1]`;
    joint -n ("squashIKX"+$i) -p 0 $pos[1] 0;
    }
setAttr squashIKX1.segmentScaleCompensate 0;
$tempString=`ikHandle -n squashIKHandle -ccv 1 -ns 2 -sol ikSplineSolver -sj squashIKX1 -ee squashIKX9`;
rename $tempString[1] squashIKEffector;
rename $tempString[2] squashIKECurve;
for ($i=0;$i<5;$i++)
    {
    select -r squashIKECurve.cv[$i];
    $tempString=`newCluster " -envelope 1"`;
    rename $tempString[0] ("squashIKCluster"+$i);
    rename $tempString[1] ("squashIKClusterHandle"+$i);
    }  
select -cl;
for ($i=0;$i<10;$i++)
    select -add ("squashIKX"+$i);
select -add squashFfdLattice;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] squashIKSC;

skinPercent -tv squashIKX0 1 squashIKSC squashFfdLattice.pt[0:1][0:1][0:1];
skinPercent -tv squashIKX2 1 squashIKSC squashFfdLattice.pt[0:1][2][0] squashFfdLattice.pt[0:1][2][1];
skinPercent -tv squashIKX3 1 squashIKSC squashFfdLattice.pt[0:1][3][0] squashFfdLattice.pt[0:1][3][1];
skinPercent -tv squashIKX4 1 squashIKSC squashFfdLattice.pt[0:1][4][0] squashFfdLattice.pt[0:1][4][1];
skinPercent -tv squashIKX5 1 squashIKSC squashFfdLattice.pt[0:1][5][0] squashFfdLattice.pt[0:1][5][1];
skinPercent -tv squashIKX6 1 squashIKSC squashFfdLattice.pt[0:1][6][0] squashFfdLattice.pt[0:1][6][1];
skinPercent -tv squashIKX7 1 squashIKSC squashFfdLattice.pt[0:1][7][0] squashFfdLattice.pt[0:1][7][1];
skinPercent -tv squashIKX8 1 squashIKSC squashFfdLattice.pt[0:1][8][0] squashFfdLattice.pt[0:1][8][1];
skinPercent -tv squashIKX9 1 squashIKSC squashFfdLattice.pt[0:1][9:10][0:1];

delete `pointConstraint squashIKClusterHandle4 squashIKClusterHandle3`;
parent squashIKClusterHandle3 squashIKClusterHandle4;
move -r 0 ($scale*-0.1) 0 ;

parent squashIKClusterHandle4 squashTop_M;
parent squashIKClusterHandle2 squashMiddle_M;
parent squashIKClusterHandle0 squashIKClusterHandle1 squashIKX0 squashBase_M;

createNode -n squashIKCurveInfo curveInfo;
connectAttr squashIKECurveShape.worldSpace[0] squashIKCurveInfo.inputCurve;


createNode -n squashIKCurveInfoNormalize multiplyDivide;
setAttr squashIKCurveInfoNormalize.operation 2;
connectAttr squashIKCurveInfo.arcLength squashIKCurveInfoNormalize.input1X;
setAttr squashIKCurveInfoNormalize.input2X `getAttr squashIKCurveInfoNormalize.input1X`;
createNode -n squashIKScale multiplyDivide;

//scale-compansate Main ctrl
createNode -n squashIKCurveInfoMainScale multiplyDivide;
setAttr squashIKCurveInfoMainScale.operation 2;
connectAttr squashIKCurveInfoNormalize.outputX squashIKCurveInfoMainScale.input1X;
if (`objExists Main`) // maight be `bodyLess` faceSetup
	connectAttr Main.sy squashIKCurveInfoMainScale.input2X;

connectAttr squashIKCurveInfoMainScale.outputX squashIKScale.input1X;
createNode -n squashIKStretch multiplyDivide;
connectAttr squashIKScale.outputX squashIKStretch.input2X;
setAttr squashIKStretch.input1X `getAttr squashIKX2.tx`;

//connectAttr squashIKScale.outputX squashIKStretch.input1X;
connectAttr ($headJoint+".sx") squashIKScale.input2X;
setAttr "squashIKScale.operation" 2;
for ($i=1;$i<10;$i++)
    connectAttr squashIKStretch.outputX ("squashIKX"+$i+".tx");
createNode -n squashVolume1Over multiplyDivide;
connectAttr squashIKScale.outputX squashVolume1Over.input2X;
setAttr "squashVolume1Over.input1X" 1;
setAttr "squashVolume1Over.operation" 2;
createNode -n squashVolumePow multiplyDivide;
connectAttr squashVolume1Over.outputX squashVolumePow.input1X;
setAttr "squashVolumePow.operation" 3;
setAttr "squashVolumePow.input2X" 0.5;
createNode -n squashBlendTwo blendTwoAttr;
setAttr squashBlendTwo.input[0] 1;
connectAttr squashVolumePow.outputX squashBlendTwo.input[1];
connectAttr squashTopVolumeUC.output squashBlendTwo.attributesBlender;
for ($i=2;$i<9;$i++)
    {
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sy");
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sz");
    }
    
parent squashFfdLattice squashIKECurve squashIKHandle SquashSetup;
//parent squashIKX1 $headJoint;
parent squashIKX1 FaceMotionFollowHead;
parent SquashControls FaceMotionSystem;
parentConstraint -mo $headJoint SquashControls;
//scaleConstraint $headJoint SquashControls;
connectAttr MainAndHeadScaleMultiplyDivide.output SquashControls.s;
delete squashXup;

setAttr -l 1 squashIKX1.v 0;
setAttr -l 1 squashFfdBase.v 0;
setAttr -l 1 squashIKHandle.v 0;
setAttr -l 1 squashIKX0.v 0;
for ($i=0;$i<5;$i++)
    setAttr -l 1 ("squashIKClusterHandle"+$i+".v") 0;

addAttr -k 0 -ln curveVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.curveVis;
connectAttr squashTop_M.curveVis squashIKECurve.v;
addAttr -k 0 -ln LatticeVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.LatticeVis;
connectAttr squashTop_M.LatticeVis squashFfdLattice.v;

//include on-face nurbsCurveControllers
select -cl;
for ($i=0;$i<size($faceControlSetMembers);$i++)
	{
	$tempString=`ls -l $faceControlSetMembers[$i]`;
	if (`gmatch $tempString[0] "*|ctrlBox|*"` || `gmatch $faceControlSetMembers[$i] "AimEye_*"`)
		continue;
	$tempString=`listRelatives -s $faceControlSetMembers[$i]`;
	if ($tempString[0]!="")
		sets -add squashFfdSet $tempString[0];
	}


//update buildPose
string $controls[]={"squashTop_M","squashMiddle_M","squashBase_M"};
string $setAttrCmd;
for ($i=0;$i<size($controls);$i++)
	{
	$tempString=`listAttr -k -shortNames $controls[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controls[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controls[$i]+"."+$tempString[$y]+" "+`getAttr ($controls[$i]+"."+$tempString[$y])`+";";
	}
string $existingCmd=`getAttr faceBuildPose.udAttr`;
setAttr -type "string" faceBuildPose.udAttr ($existingCmd+$setAttrCmd);

connectAttr ctrlBox.SquashCtrlVis squashTop_MShape.overrideVisibility;
connectAttr ctrlBox.SquashCtrlVis squashMiddle_MShape.overrideVisibility;
connectAttr ctrlBox.SquashCtrlVis squashBase_MShape.overrideVisibility;

//FaceAllset
string $allAfter[]=`ls`;
string $allNew[];
for ($i=0;$i<size($allAfter);$i++)
	if (!`stringArrayCount $allAfter[$i] $allBefore`)
		if (`objectType $allAfter[$i]`!="objectSet")
			$allNew[size($allNew)]=$allAfter[$i];
sets -add FaceAllSet $allNew;
sets -remove FaceAllSet `listRelatives -ad FaceFitSkeleton`;

select squashTop_M;
}

global proc asOptimizeSquash ()
{
global string $gMainProgressBar;
string $tempString[],$tempString2[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $tempInt[]=`polyEvaluate -v $geometry`;
int $numVtx=$tempInt[0];

string $allHeadJoints[]=`listRelatives -ad -type joint $headJoint`;
$tempString=`listRelatives -ad -type joint FaceDeformationSystem`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections ($tempString[$i]+".worldMatrix")`;
	if ($tempString2[0]==$skinCluster)
		$allHeadJoints=`stringArrayCatenate $allHeadJoints $tempString`;
	}
if (`objExists EyeRegion_R`) $allHeadJoints[size($allHeadJoints)]="EyeRegion_R";
if (`objExists EyeRegion_L`) $allHeadJoints[size($allHeadJoints)]="EyeRegion_L";
$allHeadJoints[size($allHeadJoints)]=$headJoint;
select -cl;
progressBar -e -st "Optimizing" -bp -ii 1 -min 0 -max $numVtx $gMainProgressBar;
for ($i=0;$i<$numVtx;$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;return;}

	string $vtx=$geometry+".vtx["+$i+"]";
	$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $vtx`;
	int $headVtx=0;
	for ($y=0;$y<size($infs);$y++)
		{
		if (`stringArrayCount $infs[$y] $allHeadJoints`)
			{
			$headVtx=1;
			break;
			}
		}
	if (!$headVtx)
		select -add $vtx;
	}
sets -rm squashFfdSet `ls -sl`;
asInvertSelection;
progressBar -e -ep $gMainProgressBar;
print ("// Optimize complete, now only these selected vtx`s are affected by Squash\n");
}

global proc asFaceConvertSoftModToCustomControl ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $softModHandle;
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*oftMod*Handle"`)
		$softModHandle=$sel[$i];
if ($softModHandle=="")
	error "SoftMod must be selected";

if (`promptDialog -t "Name" -m "Enter Name of new control:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
	return;
string $name=`promptDialog -query -text`;
string $side="_R";
string $mirrorSide="_L";
if (`objExists ($name+$side)`)
	error ("\""+$name+$side+"\" Already exists, choose another name");
setToolTo $gSelect;
int $mirror=`checkBox -q -v asCustomControlMirrorCheckBox`;
int $middle=`checkBox -q -v asCustomControlMiddleCheckBox`;
float $maxWeight=`floatField -q -v asCustomControlMaxWeightFloatField`;
float $mag,$vtxMag,$falloffRadius,$falloffMode,$weight;
float $currentPos[],$originPos[];
string $softMod,$mesh,$skinCluster,$buildPoseCmd,$newCtrlBuildPoseCmd;
string $tempString[],$historyNodes[];

$currentPos=`xform -q -ws -piv $softModHandle`;
$currentTrans=`getAttr ($softModHandle+".t")`;
setAttr -type float3 ($softModHandle+".t") 0 0 0;
$originPos=`xform -q -ws -piv $softModHandle`;
$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
$softMod=$tempString[0];
$falloffRadius=`getAttr ($softMod+".falloffRadius")`;
$falloffMode=`getAttr ($softMod+".falloffMode")`;
$tempString=`listConnections -type mesh ($softMod+".outputGeometry")`;
$mesh=$tempString[0];
$historyNodes=`listHistory -pdo 1 -il 2 $mesh`;
for ($y=0;$y<size($historyNodes);$y++)
	if (`nodeType $historyNodes[$y]`=="skinCluster")
		$skinCluster=$historyNodes[$y];

if ($originPos[0]>0)
	{
	$side="_L";
	$mirrorSide="_R";
	}
if ($middle)
	{
	$originPos[0]=0;
	setAttr ($softModHandle+".originX") 0;
	setAttr ($softMod+".falloffCenterX") 0;
	$side="_M";
	}

if (`objExists TempPos`) delete TempPos;
createNode -n TempPos transform;

xform -ws -t $originPos[0] $originPos[1] $originPos[2] TempPos;

asPingPong TempPos $name 1 $side 5 1 1;
asSkinWeightBySoftMod ($name+"Joint"+$side) $mesh $skinCluster $falloffRadius $maxWeight;
$newCtrlBuildPoseCmd="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$name+$side+";";

if ($mirror)
	{
	xform -ws -t ($originPos[0]*-1) $originPos[1] $originPos[2] TempPos;
	asPingPong TempPos $name 1 $mirrorSide 5 1 1;
	$newCtrlBuildPoseCmd+="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$name+$mirrorSide+";";
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}
delete TempPos;
delete $softModHandle;

//update buildPose
$buildPoseCmd=`getAttr faceBuildPose.udAttr`;
setAttr -type "string" faceBuildPose.udAttr ($buildPoseCmd+$newCtrlBuildPoseCmd);

select ($name+$side);
}


//-- ASFace Procedures Ends Here --//

global proc string asGetLatestLocalScriptLocation ()
{
string $scriptLocation=`asGetScriptLocation`;
string $latestLocalScriptLocation=$scriptLocation;
string $tempString[];
if (`gmatch $scriptLocation "*oldVersions*"`)
	{
	tokenize $scriptLocation "/" $tempString;
	$latestLocalScriptLocation="";
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="AdvancedSkeleton5Files")
			break;
		else
			{
			if ($i>0 || `gmatch $scriptLocation "/*"`)
				$latestLocalScriptLocation+="/";
			$latestLocalScriptLocation+=$tempString[$i];
			}
		}
	}
return $latestLocalScriptLocation;
}

global proc string asGetLatestLocalVersionAsString ()
{
string $latestLocalVersion=`asGetScriptVersionAsString`;
string $scriptLocation=`asGetScriptLocation`;
string $tempString[];
string $latestLocalASFile;
if (`gmatch $scriptLocation "*oldVersions*"`)
	{
	$latestLocalASFile=`asGetLatestLocalScriptLocation`+"/AdvancedSkeleton5.mel";
	$latestLocalVersion=`asGetScriptVersionFromFile $latestLocalASFile`;
	}
return $latestLocalVersion;
}

global proc asDownloadDemoUpdates ()
{
int $fileId,$replacedLine;
string $scriptLocation=`asGetScriptLocation`;
string $curl=$scriptLocation+"/AdvancedSkeleton5Files/bin/curl.e";
string $zip=$scriptLocation+"/AdvancedSkeleton5Files/bin/7za.e";
if (`about -mac` || `about -linux`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);
string $tempString[],$oldFilesList[],$exampleFolders[];
string $cmd,$name,$unzipFolder,$downloadedFile,$zipFileUrl,$file,$exampleFile,$nextLine,$demoVersionsText,$onlineVersion;
string $exampleFilesFolder=$scriptLocation+"/AdvancedSkeleton5Files/exampleFiles";
string $downloadsFolder=$exampleFilesFolder+"/downloads";
string $demoVersionsTextFile=$downloadsFolder+"/DemoVersions.txt";
if (!`file -q -ex $downloadsFolder`)
	sysFile -md $downloadsFolder;

for ($i=0;$i<99;$i++)
	{
	if (!`checkBox -q -ex ("asDemoUpdateCheckBox"+$i)`)
		break;
	if (!`checkBox -q -v ("asDemoUpdateCheckBox"+$i)`)
		continue;
	$name=`text -q -l ("asDemoUpdateFileText"+$i)`;
	$onlineVersion=`text -q -l ("asDemoUpdateFileOnlineVersion"+$i)`;
	$downloadedFile=$downloadsFolder+"/"+$name+".7z";
	$unzipFolder=$downloadsFolder+"/"+$name;
	$zipFileUrl="http://www.advancedskeleton.com/download/AdvancedSkeletonExamples/"+$name+".7z";
	if (!`file -q -ex $unzipFolder`)
		sysFile -md $unzipFolder;

	//download
	if (`about -mac` || `about -linux`)
		{
		$cmd="\"curl -o "+$downloadedFile+" "+$zipFileUrl+"\"";
		evalEcho ("system("+$cmd+")");
		}
	else
		{
		$cmd="start\/wait \"Downloading\"  \""+$curl+"\" -k -o \""+$downloadedFile+"\" "+$zipFileUrl;
		system ($cmd);
		}

	//confirm download
	if (`file -q -ex $downloadedFile`)
		print ("// Downloaded sucessfully:"+$downloadedFile+";\n");
	else
		error ("// Download failed, could not find:"+$downloadedFile+";\n");

	//unzip (with -y for overwrite)
	if (`about -mac` || `about -linux`)
	  $cmd="unzip "+$downloadedFile+" -d "+$unzipFolder;
	else
		$cmd="start\/wait \"Unzipping\"  \""+$zip+"\" x -y \""+$downloadedFile+"\" -o\""+$unzipFolder+"\"";
	print ("// Starting Unzip:"+$cmd+";\n");
	system($cmd);
	
	//confirm unzip
	if (`file -q -ex ($unzipFolder+"/"+$name+".mb")`)
		print ("// Unzipped sucessfully:"+$unzipFolder+"/"+$name+".mb;\n");
	else
		error ("// Unzipp failed, could not find:"+$unzipFolder+"/"+$name+".mb;\n");

	//remove old file
	if (`file -q -ex ($exampleFilesFolder+"/"+$name)`)
		{
		$oldFilesList=`getFileList -fld ($exampleFilesFolder+"/"+$name+"/")`;
		for ($file in $oldFilesList)
			sysFile -del ($exampleFilesFolder+"/"+$name+"/"+$file);
		sysFile -red ($exampleFilesFolder+"/"+$name);
		}

//	//Move (by rename) downloadedFolder to exampleFolder
//	sysFile -ren ($exampleFilesFolder+"/"+$name) $unzipFolder;

	//Delete $downloadedFile
	sysFile -del $downloadedFile;

	//Update DemoVersions.txt
	$demoVersionsText="";
	$replacedLine=0;
	$fileId=`fopen $demoVersionsTextFile "r"`;
	$nextLine=`fgetline $fileId`;
	while ( size( $nextLine ) > 0 )
		{
		$nextLine=`strip $nextLine`;
		tokenize $nextLine $tempString;
		if ($tempString[0]==$name)
			{
			$demoVersionsText=$demoVersionsText+`substitute $tempString[1] $nextLine $onlineVersion`+"\r\n";
			$replacedLine=1;
			}
		else if ($nextLine!="")
			$demoVersionsText=$demoVersionsText+$nextLine+"\r\n";
		$nextLine=`fgetline $fileId`;
		}
	fclose $fileId;
	if (!$replacedLine)
		$demoVersionsText=$demoVersionsText+$name+" "+$onlineVersion+"\r\n";
	$fileId=`fopen $demoVersionsTextFile "w"`;
	fprint $fileId $demoVersionsText;
	fclose $fileId;

	//populate Demo optionMenu
	$tempString=`optionMenu -q -ill asDemoOptionMenu`;
	for ($y=0;$y<size($tempString);$y++)
		deleteUI $tempString[$y];
	setParent -menu asDemoOptionMenu;
	$exampleFolders=`getFileList -fld ($exampleFilesFolder+"/downloads/")`;
	for ($y=0;$y<size($exampleFolders);$y++)
		{
		string $exampleFile=$exampleFilesFolder+"/downloads/"+$exampleFolders[$y]+"/"+$exampleFolders[$y]+".mb";
		if (`file -q -ex $exampleFile`)
			menuItem -l $exampleFolders[$y];
		}

	//disable RowLayout
	rowLayout -e -en 0 ("asDemoUpdateRowLayout"+$i);
	text -e -bgc 0 1 0 ("asDemoUpdateFileOnlineVersion"+$i);
	text -e -l $onlineVersion ("asDemoUpdateFileLocalVersion"+$i);
	checkBox -e -v 0 ("asDemoUpdateCheckBox"+$i);
	}
print "// Download of selected files complete.\n";
}

global proc asCheckForDemoUpdates ()
{
int $x,$y,$needUpdate,$fileId;
string $scriptLocation=`asGetScriptLocation`;
string $onlineVersionsText,$localVersionsText,$localVersionInfo;
string $onlineVersionsFile="http://www.advancedskeleton.com/download/AdvancedSkeletonExamples/DemoVersions.txt";
string $localVersionsFile=$scriptLocation+"/AdvancedSkeleton5Files/exampleFiles/downloads/DemoVersions.txt";
string $curl=$scriptLocation+"/AdvancedSkeleton5Files/bin/curl.e";
if (`about -mac` || `about -linux`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);
string $tempString[],$localFiles[],$localVersions[],$onlineFiles[],$onlineVersions[];
print ("// Checking online for demo updates at www.advancedskeleton.com\n");
waitCursor -st 1;

$onlineVersionsText=`system ("\""+$curl+"\" -k -s "+$onlineVersionsFile)`;

if (!`gmatch $onlineVersionsText "*chubby*"`)
	print ("Failed to access \""+$onlineVersionsFile+"\"");

if (!`file -q -ex $localVersionsFile`)
	{
	$fileId=`fopen $localVersionsFile "w"`;
	fclose $fileId;
	}
$localVersionsText="";
$fileId=`fopen $localVersionsFile "r"`;
string $nextLine = `fgetline $fileId`;
while ( size( $nextLine ) > 0 )
	{
	$localVersionsText=$localVersionsText+$nextLine;
	$nextLine=`fgetline $fileId`;
	}
fclose $fileId;

$x=0;
tokenize $localVersionsText $tempString;
for ($i=0;$i<size($tempString);$i=$i+2)
	{
	$localFiles[$x]=$tempString[$i];
	$localVersions[$x]=$tempString[$i+1];
	$x++;
	}

$x=0;
tokenize $onlineVersionsText $tempString;
for ($i=0;$i<size($tempString);$i=$i+2)
	{
	$onlineFiles[$x]=$tempString[$i];
	$onlineVersions[$x]=$tempString[$i+1];
	$x++;
	}

if (`window -q -ex asDemoUpdates`)
	deleteUI asDemoUpdates;
window -t Updates asDemoUpdates;
columnLayout;
rowLayout -nc 4 -cw4 80 50 60 40;
	text -l " File:";
	text -l " Online:";
	text -l " Local:";
	text -l " Update:";
	setParent..;
separator -h 5 -st none;
for ($i=0;$i<size($onlineFiles);$i++)
	{
	$needUpdate=0;
	$localVersionInfo="n/a";
	for ($y=0;$y<size($localFiles);$y++)
		if ($localFiles[$y]==$onlineFiles[$i])
			$localVersionInfo=$localVersions[$y];
	if ($localVersionInfo!=$onlineVersions[$i])
		$needUpdate=1;

	rowLayout -en $needUpdate -nc 4 -cw4 80 50 50 50 ("asDemoUpdateRowLayout"+$i);
	text -l $onlineFiles[$i] ("asDemoUpdateFileText"+$i);
	if ($needUpdate)
		text -bgc 1 0 0 -l $onlineVersions[$i] ("asDemoUpdateFileOnlineVersion"+$i);
	else
		text -l $onlineVersions[$i] ("asDemoUpdateFileOnlineVersion"+$i);
	text -l $localVersionInfo ("asDemoUpdateFileLocalVersion"+$i);
	checkBox -v $needUpdate -l "" ("asDemoUpdateCheckBox"+$i);
	setParent..;
	}
separator -h 15 -st none;
button -l "  Download selected files  " -c asDownloadDemoUpdates;
showWindow;
waitCursor -st 0;
}

global proc asCheckForUpdates ()
{
string $curl=`asGetScriptLocation`+"/AdvancedSkeleton5Files/bin/curl.e";
if (`about -mac` || `about -linux`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);
text -e -en 0 -l "x.xxx" asUpdateFoundVersion;
checkBox -e -v 0 asBetaCheckBox;
button -e -en 0 asUpdateVersionButton;
waitCursor -st 1;
int $modifier=`getModifiers`;
float $versions[];
string $versionsText;

if ($modifier==13)
	{
	print ("// Checking online for new BETA version at www.advancedskeleton.com\n");
	checkBox -e -v 1 asBetaCheckBox;
	$versionsText=`system ("\""+$curl+"\" -k -s http://www.advancedskeleton.com/download/AdvancedSkeleton5Beta/latestBetaVersion.txt")`;
	}
else
	{
	print ("// Checking online for new version at www.advancedskeleton.com\n");
	checkBox -e -v 0 asBetaCheckBox;
	$versionsText=`system ("\""+$curl+"\" -k -s http://www.advancedskeleton.com/download/AdvancedSkeleton5/latestVersion.txt")`;
	}
if (!`gmatch $versionsText "[0-9]*"`)
	{
	print ("// returned:\""+$versionsText+"\"\n");
	error "Unable to connect to update server \"http://www.advancedskeleton.com\", you might not be connected to internet, or blocked by firewall";
	}
string $latestVersionAsString=$versionsText;
float $latestVersion=$versionsText;

string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
float $latestInstalledVersion=`asGetScriptVersionFromFile ($sLoc+"/AdvancedSkeleton5.mel")`;
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton5.mel")`;

if ($latestVersion>$latestInstalledVersion)
	{
	text -e -en 1 -l $latestVersionAsString asUpdateFoundVersion;
	button -e -en 1 asUpdateVersionButton;
	print ("// New version found, click Update, to update to the new version\n");
	}
else
	print ("// Latest version("+$latestVersionAsString+"), is not greater than your latest installed version("+$latestInstalledVersionAsString+")\n");
waitCursor -st 0;
}

global proc string asGetLatestInstalledVersionScriptLocation ()
{
string $sLoc=`asGetScriptLocation`;
string $ts[];
int $numTok=`tokenize $sLoc "/" $ts`;
if ($ts[size($ts)-2]=="oldVersions")
	$sLoc=`substitute ("/"+$ts[$numTok-3]+"/"+$ts[$numTok-2]+"/"+$ts[$numTok-1]) $sLoc ""`;
return $sLoc;
}

global proc asUpdateVersion ()
{
//First check if download is from Autodesk store,
//since the C:\ProgramData\Autodesk\ApplicationPlugins folder probably does not have overwrite priveleges
//Testing by attempting to rename eula.txt file
int $fileId;
int $isReadOnly=0;
string $dialog;
string $fDet,$cmd,$changePriviligeFolder;
string $asScriptLocation=`asGetScriptLocation`;
string $eulaFile=$asScriptLocation+"/eula.txt";
string $eula2File=$asScriptLocation+"/eula2.txt";
string $tmpDir=`internalVar -utd`;
string $batFile=$tmpDir+"AdvancedSkeleton_changeFolderPriviliges.bat";
if (`file -q -ex $eulaFile` && `about -win`)
	{
	sysFile -rename $eula2File $eulaFile;
	if (!`file -q -ex $eulaFile`)
		sysFile -rename $eulaFile $eula2File;
	else
		{
		$isReadOnly=1;
		sysFile -del $eula2File;
		}
	}
if ($isReadOnly)
	{
	$changePriviligeFolder=$asScriptLocation;
	if (`gmatch $asScriptLocation "C:/ProgramData/Autodesk/ApplicationPlugins/AdvancedSkeleton5*"`)
		$changePriviligeFolder="C:/ProgramData/Autodesk/ApplicationPlugins/AdvancedSkeleton5";
	$dialog=`confirmDialog -t "Confirm"
	-m ("Detected Read-Only AdvancedSkeleton files,\nClick OK to attemp to modify the priviliges for this folder:\n"+$changePriviligeFolder)
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
	if ($dialog!="OK")
		error ("Unable to Update, as the files are Read-Only.\nThis is common if you downloaded AdvancedSkeleton from the Autodesk store.\n"
			+"You can try to manually add Write-priviliges to this folder:\n"+$changePriviligeFolder);
	$fDet="icacls "+$changePriviligeFolder+" /grant Everyone:(OI)(CI)F";
	$fileId=`fopen $batFile "w"`;
	fprint $fileId ($fDet);
	fclose $fileId;
	$cmd="powershell -Command \"Start-Process '"+$batFile+"' -Verb runAs\"";
	system ($cmd);
	}

waitCursor -st 1;
string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton5.mel")`;
string $curl=$sLoc+"/AdvancedSkeleton5Files/bin/curl.e";
string $zip=$sLoc+"/AdvancedSkeleton5Files/bin/7za.e";
string $newVersionAsString=`text -q -l asUpdateFoundVersion`;
string $newVersionFolder=$sLoc+"/AdvancedSkeleton5Files/newVersions/AdvancedSkeleton_v"+$newVersionAsString;
if (!`file -q -ex $newVersionFolder`)
	sysFile -md $newVersionFolder;
//download
string $newVersionZipFile=$newVersionFolder+"/AdvancedSkeleton5.zip";
string $zipFileUrl="http://www.advancedskeleton.com/download/AdvancedSkeleton5/AdvancedSkeleton_v"+$newVersionAsString+"/AdvancedSkeleton5.zip";
if (`checkBox -q -v asBetaCheckBox`)
	$zipFileUrl="http://www.advancedskeleton.com/download/AdvancedSkeleton5Beta/AdvancedSkeleton_v"+$newVersionAsString+"/AdvancedSkeleton5.zip";
if (`about -mac` || `about -linux`)
	{
	$cmd="\"curl -o "+$newVersionZipFile+" "+$zipFileUrl+"\"";
	evalEcho ("system("+$cmd+")");
	}
else
	{
	$cmd="start\/wait \"Downloading\"  \""+$curl+"\" -k -o \""+$newVersionZipFile+"\" "+$zipFileUrl;
	print ("// Starting Download:"+$cmd+";\n");
	system ($cmd);
	}
//confirm download
if (`file -q -ex $newVersionZipFile`)
	print ("// Downloaded sucessfully:"+$newVersionZipFile+";\n");
else
	error ("// Download failed, could not find:"+$newVersionZipFile+";\n");
//unzip
if (`about -mac` || `about -linux`)
  $cmd="unzip "+$newVersionZipFile+" -d "+$newVersionFolder;
else
	$cmd="start\/wait \"Unzipping\"  \""+$zip+"\" x \""+$newVersionZipFile+"\" -o\""+$newVersionFolder+"\"";
print ("// Starting Unzip:"+$cmd+";\n");
system($cmd);

//confirm unzip
if (`file -q -ex ($newVersionFolder+"/AdvancedSkeleton5.mel")`)
	print ("// Unzipped sucessfully:"+$newVersionFolder+"/AdvancedSkeleton5.mel;\n");
else
	error ("// Unzipp failed, could not find:"+$newVersionFolder+"/AdvancedSkeleton5.mel;\n");
//remove zip file
if (`file -q -ex ($newVersionFolder+"/AdvancedSkeleton5.zip")`)
	sysFile -del ($newVersionFolder+"/AdvancedSkeleton5.zip");
//backup $latestInstalledVersion version
string $oldVersionsFolder=$sLoc+"/AdvancedSkeleton5Files/oldVersions/AdvancedSkeleton_v"+$latestInstalledVersionAsString;
print ("// Backing up old version: asCopyFilesInFolder \""+$oldVersionsFolder+"\" \""+$sLoc+"\";\n");
sysFile -md ($oldVersionsFolder+"/AdvancedSkeleton5Files");
asCopyFilesInFolder ($oldVersionsFolder+"/AdvancedSkeleton5Files") ($sLoc+"/AdvancedSkeleton5Files");
sysFile -cp ($oldVersionsFolder+"/AdvancedSkeleton5.mel") ($sLoc+"/AdvancedSkeleton5.mel");
//replace with new version
print ("// Replacing current version with the downloaded version: asCopyFilesInFolder \""+$sLoc+"\" \""+$newVersionFolder+";\n");
asCopyFilesInFolder $sLoc $newVersionFolder;
waitCursor -st 0;
print ("// Updated from "+$latestInstalledVersionAsString+" to "+$newVersionAsString+"\n");
//Re-start
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;
optionVar -iv asHaveRanThisVersion 0;
evalDeferred -lp ("source \""+$sLoc+"/AdvancedSkeleton5.mel\";AdvancedSkeleton5;");
}

global proc asVersionHistory ()
{
global string $gMainProgressBar;

string $versionHistoryFileUrl="http://www.advancedskeleton.com/download/AdvancedSkeleton5/versionHistory.txt";
if (`getModifiers`==13)
	$versionHistoryFileUrl="http://www.advancedskeleton.com/download/AdvancedSkeleton5Beta/betaVersionHistory.txt";
string $curl=`asGetScriptLocation`+"/AdvancedSkeleton5Files/bin/curl.e";
if (`about -mac` || `about -linux`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);

evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
print ("// Downloading version information from:"+$versionHistoryFileUrl+"\n");
progressBar -e -st "Downloading version information" -bp -ii 1 -min 0 -max 1 $gMainProgressBar;
string $versionHistoryText=`system ("\""+$curl+"\" -k -s "+$versionHistoryFileUrl)`;

if (`window -q -ex asVersionHistory`)
	deleteUI asVersionHistory;
window asVersionHistory;
formLayout asVersionHistoryFormLayout;
scrollField -text $versionHistoryText asVersionHistoryScrollField;
formLayout -e 
	-af asVersionHistoryScrollField "left" 0
	-af asVersionHistoryScrollField "right" 0
	-af asVersionHistoryScrollField "top" 0
	-af asVersionHistoryScrollField "bottom" 0
	asVersionHistoryFormLayout;
showWindow;
}

global proc asCopyFilesInFolder (string $destFolder, string $sourceFolder)
{
global string $gMainProgressBar;
if (`gmatch $destFolder"*/exampleFiles/*"`)
	return;//dont include downloaded exampleFiles
if (!`file -q -ex $destFolder`)
    sysFile -md $destFolder;
string $fileList[]=`getFileList -fld ($sourceFolder+"/")`;
if (`size($fileList)`==0)
	return;
progressBar -e -st "Copy files" -bp -ii 1 -min 0 -max (size($fileList)) $gMainProgressBar;
for ($i=0;$i<size($fileList);$i++)
    {
		progressBar -e -s 1 $gMainProgressBar;
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
    if ($fileList[$i]=="incrementalSave" || $fileList[$i]=="downloads" || $fileList[$i]=="distributes" || `gmatch $fileList[$i] "[.]*"`
  		|| $fileList[$i]=="newVersions" || $fileList[$i]=="oldVersions" || $fileList[$i]=="asReleaser.mel" || `gmatch $fileList[$i] "*[.]psd"`)
        continue;
    if (`filetest -d ($sourceFolder+"/"+$fileList[$i])`)
			asCopyFilesInFolder ($destFolder+"/"+$fileList[$i]) ($sourceFolder+"/"+$fileList[$i]);
    else
			if (!`sysFile -cp ($destFolder+"/"+$fileList[$i]) ($sourceFolder+"/"+$fileList[$i])` && `about -win`)
				{
				error ("Failed to copy file ("+$destFolder+"/"+$fileList[$i]+")\n"
					+"Possibly privileges issue. This is common if you downloaded AdvancedSkeleton from the Autodesk store\n"
					+"Follow the steps in the URL below, then redo the updates\n"
					+"http://www.advancedskeleton.com/download/AdvancedSkeleton4/changePrivilegesHelp.jpg\n");
				progressBar -e -ep $gMainProgressBar;
				return;
				}
    }
progressBar -e -ep $gMainProgressBar;
}

global proc asDockWindow (int $dock)
{
int $asDock=`optionVar -q asDock`;
optionVar -iv asDock $dock;
removeAsWorkspaceControl;
if (`dockControl -q -ex AdvancedSkeletonDockControl`)
	deleteUI -control AdvancedSkeletonDockControl;
AdvancedSkeleton5;
}

global proc asDockWindowChangeFloatingState ()
{
optionVar -iv asDock (!`dockControl -q -ex AdvancedSkeletonDockControl`);
}

global proc asCreateWorkspaceControl ()
{
//First we ensure runTimeCommand
string $asScriptLocation=`asGetScriptLocation`;
if (`runTimeCommand -ex AdvancedSkeletonWorkspaceController`) //update, since $asScriptLocation can change.
	runTimeCommand -e -annotation "Run AdvancedSkeleton as WorkSpace controller" -category "User"
		-command ("if (!`exists AdvancedSkeleton5`)source \""+$asScriptLocation+"/AdvancedSkeleton5.mel\";AdvancedSkeleton5;")
		AdvancedSkeletonWorkspaceController;
else
	runTimeCommand -annotation "Run AdvancedSkeleton as WorkSpace controller" -category "User"
		-command ("if (!`exists AdvancedSkeleton5`)source \""+$asScriptLocation+"/AdvancedSkeleton5.mel\";AdvancedSkeleton5;")
		AdvancedSkeletonWorkspaceController;

if (`workspaceControl -ex asWorkspaceControl`)
	{
	print ("Already a Workspace Controller, click \"UnDock\" to detach.\n");
	return;//since removing it, then re-building it, appears to cause crashes.
	}

if (`exists dockControl`)
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		deleteUI -control AdvancedSkeletonDockControl;
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;

workspaceControl -initialWidth 288 -minimumWidth 288 -retain 0 -dockToControl ToolBox left -label AdvancedSkeleton -uiScript AdvancedSkeletonWorkspaceController asWorkspaceControl;

}

global proc removeAsWorkspaceControl ()
{
if (!`exists workspaceControl`)
	return;//Maya version < 2017
if (`workspaceControl -ex asWorkspaceControl`)
	workspaceControl -e -close asWorkspaceControl;
if (`workspaceControlState -exists asWorkspaceControl`)
	workspaceControlState -remove asWorkspaceControl;
}

global proc asFitSkeletonImport ()
{
string $dialog;
string $tempString[],$tempString2[];
if (`objExists FitSkeleton`)
	{
	$dialog=`confirmDialog -t "Confirm"
		-m "FitSkeleton already exists"
		-b "Replace"
		-b "Merge"
		-b "Cancel"
		-db "Replace" -ds "Cancel"`;
	if ($dialog!="Replace" && $dialog!="Merge")
		return;
	}
int $merge=0;
if ($dialog=="Merge") $merge=1;

float $existingScale[];
if (`objExists FitSkeleton`)
	$existingScale=`getAttr FitSkeleton.s`;
string $removeExistingObjs[]={"FitSkeleton","FitSkeletonVisualizers","cylinders","boxes","locators","directions",
	"asRedSG","asRed2SG","asGreenSG","asGreen2SG","asBlueSG","asBlue2SG","asBlackSG","asWhiteSG","asBonesSG",
	"asRed","asRed2","asGreen","asGreen2","asBlue","asBlue2","asBlack","asWhite","asBones"};
if (!$merge)
	for ($i=0;$i<size($removeExistingObjs);$i++)
		if (`objExists $removeExistingObjs[$i]`)
			delete $removeExistingObjs[$i];
string $fitSkeletonsDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/fitSkeletons/";
string $FitSkeletonFile=$fitSkeletonsDir+`optionMenu -q -v asFitFiles`;
if (`file -q -ex $FitSkeletonFile`)
	{
	if ($merge)
		{
		if (`namespace -ex "Merge"`)
			namespace -rm "Merge";
		file -import -ra true -ns "Merge" -options "v=0" $FitSkeletonFile;
		asFitSkeletonMerge;
		}
	else
		file -import -rpr "AdvancedSkeleton" -options "v=0" $FitSkeletonFile;
	}
if ($existingScale[0]!=0)
	setAttr -type float3 FitSkeleton.s $existingScale[0] $existingScale[1] $existingScale[2];
if (`objExists Group|Main` && !`objExists Group|Main|FitSkeleton` && `objExists FitSkeleton`)
	parent FitSkeleton Group|Main;
asEnsureFitSkeletonAttributes;
//asFitSkeletonConnectControl; //asEnsureFitSkeletonAttributes now includes asFitSkeletonConnectControl
asUpdateButtonEnables;
}

global proc asFitSkeletonMerge ()
{
int $lockCenterJoints=`getAttr FitSkeleton.lockCenterJoints`;
string $tempString[],$tempString2[],$tempString3[];
string $counterPart,$counterPartParent;
setAttr FitSkeleton.lockCenterJoints 0;

string $dialog=`confirmDialog -t "Confirm"
		-m "Joints with same names ?"
		-b "Keep existing"
		-b "Keep imported"
		-b "Keep both by renaming imported"
		-db "Keep existing"`;
int $keepExisting=0;
int $keepImported=0;
int $keepBoth=0;
if ($dialog=="Keep existing") $keepExisting=1;
if ($dialog=="Keep imported") $keepImported=1;
if ($dialog=="Keep both by renaming imported") $keepBoth=1;

//$keepExisting
if ($keepExisting || $keepImported)
	{
	if ($keepExisting) $tempString=`listRelatives -ad -type joint Merge:FitSkeleton`;
	if ($keepImported) $tempString=`listRelatives -ad -type joint FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (!`objExists $tempString[$i]`)
			continue;
		if ($keepExisting) $counterPart=`substitute "Merge:" $tempString[$i] ""`;
		if ($keepImported) $counterPart="Merge:"+$tempString[$i];
		if (`objExists $counterPart`)
			{
			delete $tempString[$i];
			continue;
			}
		$tempString2=`listRelatives -p $tempString[$i]`;
		if ($tempString2[0]=="")
			continue;
		if ($keepExisting) $counterPartParent=`substitute "Merge:" $tempString2[0] ""`;
		if ($keepImported) $counterPartParent="Merge:"+$tempString2[0];
		if (`objExists $counterPartParent`)
			parent $tempString[$i] $counterPartParent;
		}
	}

$tempString=`listRelatives -c -type joint Merge:FitSkeleton`;
if (size($tempString))
	parent $tempString FitSkeleton;

if (`objExists Merge:FitSkeleton`)
	{
	//Unlock
	$tempString=`listRelatives -ad -type joint FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		setAttr -l 0 ($tempString[$i]+".tx");setAttr -l 0 ($tempString[$i]+".ty");setAttr -l 0 ($tempString[$i]+".tz");
		setAttr -l 0 ($tempString[$i]+".rx");setAttr -l 0 ($tempString[$i]+".ry");setAttr -l 0 ($tempString[$i]+".rz");
		}

	//Keep imported DrivingSystems
	if (!`attributeExists drivingSystem FitSkeleton`)
		addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;
	$tempString=`listAttr -ud -m Merge:FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		if (`gmatch $tempString[$i] "drivingSystem*"`)
			{
			$tempString2=`listConnections -s 1 -d 0 -p 1 ("Merge:FitSkeleton."+$tempString[$i])`;
			if ($tempString2[0]!="")
				{
				connectAttr -na $tempString2[0] FitSkeleton.drivingSystem;
				disconnectAttr -na $tempString2[0] -na Merge:FitSkeleton.drivingSystem;
				}
			$tempString2=`listConnections -s 0 -d 1 -p 1 ("Merge:FitSkeleton."+$tempString[$i])`;
			if ($tempString2[0]!="")
				{
				tokenize $tempString[$i] "[" $tempString3;
				if (!`attributeExists $tempString3[0] FitSkeleton`)
					addAttr -k 0 -ln $tempString3[0] -at bool -dv true -multi FitSkeleton;
				connectAttr -f ("FitSkeleton."+$tempString[$i]) $tempString2[0];
				}
			}
	delete Merge:FitSkeleton;
	}

//rename Merge:*
while (size(`ls "Merge:*"`))
	{
	$tempString=`ls "Merge:*"`;
	tokenize $tempString[0] ":" $tempString2;
	string $newName=$tempString2[1];
	if (`objExists $tempString2[1]`)
	for ($i=1;$i<99;$i++)
		{
		$newName=$tempString2[1]+$i;
		if (!`objExists $newName`)
			break;
		}
	rename $tempString[0] $newName;
	}

if ($lockCenterJoints)
	setAttr FitSkeleton.lockCenterJoints 1;
namespace -rm "Merge";
}

global proc asFitSkeletonLimbsImport ()
{
string $dialog;
string $tempString[],$tempString2[],$tempString3[];
string $fitSkeletonsDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/fitSkeletonsLimbs/";
string $FitSkeletonFile=$fitSkeletonsDir+`optionMenu -q -v asLimbFiles`;
float $existingScale[3]={1,1,1};
if (`objExists FitSkeleton`)
	$existingScale=`getAttr FitSkeleton.s`;
if (`file -q -ex $FitSkeletonFile`)
	file -import -rpr "AdvancedSkeleton" -options "v=0" $FitSkeletonFile;
if (`objExists Main|FitSkeleton` && `objExists |FitSkeleton`)
	rename |FitSkeleton AdvancedSkeleton_FitSkeleton;
if (`objExists AdvancedSkeleton_FitSkeleton` && `objExists FitSkeleton`)
	{
	setAttr -type float3 AdvancedSkeleton_FitSkeleton.s $existingScale[0] $existingScale[1] $existingScale[2];
	$tempString=`listRelatives -f -c -type transform AdvancedSkeleton_FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		tokenize $tempString[$i] "|" $tempString2;
		string $shortName=$tempString2[size($tempString2)-1];
		$tempString2=`ls -l $shortName`;
			{
			if (size($tempString2)>1)
				$dialog=`confirmDialog -t "Confirm"
				-m ($shortName+" already exist")
				-b "Replace" -db "Replace"
				-b "Merge" -ds "Merge"`;
			if ($dialog=="Replace")
				{
				for ($y=0;$y<size($tempString2);$y++)
					if ($tempString2[$y]!=$tempString[$i])
						{
						$tempString3=`listRelatives -p $tempString2[$y]`;
						delete $tempString2[$y];
						if ($tempString3[0]!="")
							parent $tempString[$i] $tempString3[0];
						else
							parent $tempString[$i] FitSkeleton;
						}
				}
			else if (`objExists Root`)
				parent $tempString[$i] Root;
			else
				parent $tempString[$i] FitSkeleton;
			}
		}
	//Transfer SDK`s to FitSkeleton;
	if (`attributeExists drivingSystem AdvancedSkeleton_FitSkeleton`)
		{
		$tempString=`listConnections AdvancedSkeleton_FitSkeleton.drivingSystem`;
		if (!`attributeExists drivingSystem FitSkeleton`)
			addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;
		for ($i=0;$i<size($tempString);$i++)
			connectAttr -na ($tempString[$i]+".drivingSystemOut") FitSkeleton.drivingSystem;
		string $uAs[]=`listAttr -ud AdvancedSkeleton_FitSkeleton`;
		for ($i=0;$i<size($uAs);$i++)
			{
			if (!`gmatch $uAs[$i] "drivingSystem_*"`)
				continue;
			if (!`attributeExists $uAs[$i] FitSkeleton`)
				addAttr -k 0 -ln $uAs[$i] -at bool -dv true -multi FitSkeleton;
			$tempString=`listConnections -p 1 ("AdvancedSkeleton_FitSkeleton."+$uAs[$i])`;
			for ($y=0;$y<size($tempString);$y++)
				connectAttr -f ("FitSkeleton."+$uAs[$i]+"["+$y+"]") $tempString[$y];
			}
		}
	delete AdvancedSkeleton_FitSkeleton;
	}
asEnsureFitSkeletonAttributes;
//asFitSkeletonConnectControl;
asUpdateButtonEnables;
}

global proc asFitSkeletonExport ()
{
string $selJoints[]=`ls -sl -type joint `;
string $selJointsLongName[]=`ls -l -sl -type joint `;
int $fitSkeletonVisLocked=`getAttr -l FitSkeleton.v`;
string $tempString[],$tempString2[],$drivingSystems[],$previousFitSkeletonChildren[],$previousSelJointParents[];
string $asScriptLocation=`asGetScriptLocation`;
string $fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletons/";

//Limb only, first check, to determine destinationDir
int $limbOnly=0;
for ($i=0;$i<size($selJoints);$i++)
	{
	tokenize $selJointsLongName[$i] "|" $tempString2;
	if ($tempString2[0]=="FitSkeleton" && size($tempString2)>2)
		$limbOnly=1;
	}
if ($limbOnly)
	$fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletonsLimbs/";
string $result[] = `fileDialog2 -fileFilter "*.ma" -dialogStyle 2 -dir $fitSkeletonsDir`;
string $file=$result[0];
if ($file=="")
	return;

$tempString=`listRelatives -p FitSkeleton`;
string $currentParent=$tempString[0];
if ($fitSkeletonVisLocked)
	setAttr -l 0 FitSkeleton.v;
setAttr FitSkeleton.v 1;
if (`objExists $currentParent`)
	parent -w FitSkeleton;
$tempString=`listConnections -s 0 -d 1 -type animCurve`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -s 1 -d 0 -type transform $tempString[$i]`;
	if ($tempString2[0]!="" && $tempString2[0]!="FitSkeleton")
		if (!`stringArrayCount $tempString2[0] $drivingSystems`)
			$drivingSystems[size($drivingSystems)]=$tempString2[0];
	}

//Limb only ?
for ($i=0;$i<size($selJoints);$i++)
	{
	tokenize $selJointsLongName[$i] "|" $tempString2;
	if ($tempString2[0]=="FitSkeleton" && size($tempString2)>2)
		{
		if (!`objExists previousFitSkeletonChildren`)
			{
			createNode -n previousFitSkeletonChildren transform;
			$previousFitSkeletonChildren=`listRelatives -c -type joint FitSkeleton`;
			parent $previousFitSkeletonChildren previousFitSkeletonChildren;
			}
		$tempString=`listRelatives -p $selJoints[$i]`;
		$previousSelJointParents[$i]=$tempString[0];
		parent $selJoints[$i] FitSkeleton;
		}
	}

select FitSkeleton;
if (size($drivingSystems))
	delete $drivingSystems;
file -force -options "v=0;" -typ "mayaAscii" -es $file;
if (size($drivingSystems))
	undo;

if (`objExists $currentParent`)
	parent FitSkeleton $currentParent;
if ($fitSkeletonVisLocked)
	setAttr -l 1 FitSkeleton.v;

//Limb only ? (restore)
for ($i=0;$i<size($selJoints);$i++)
	if ($previousSelJointParents[$i]!="")
		parent $selJoints[$i] $previousSelJointParents[$i];
if (`objExists previousFitSkeletonChildren`)
	{
	parent `listRelatives -c previousFitSkeletonChildren` FitSkeleton;
	delete previousFitSkeletonChildren;
	}

print ("// FitSkeleton exported to: \""+$file+"\"\n");
}

global proc asOpenDemoFile ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $exampleFoldersDir=$asScriptLocation+"/AdvancedSkeleton5Files/exampleFiles/downloads/";
string $exampleFolder=`optionMenu -q -v asDemoOptionMenu`;
string $exampleFile=$exampleFoldersDir+$exampleFolder+"/"+$exampleFolder+".mb";
string $tempString[];
float $preMayaVersion;

//backwards compatability files
string $exampleFiles[]=`getFileList -fld ($exampleFoldersDir+$exampleFolder+"/")`;
for ($i=0;$i<size($exampleFiles);$i++)
	if (`gmatch $exampleFiles[$i] "*_MayaPre*"`)
		{
		$tempString[0]=`substitute ($exampleFolder+"_MayaPre") $exampleFiles[$i] ""`;
		$tempString[0]=`basenameEx $tempString[0]`;
		$preMayaVersion=$tempString[0];
		if (`asMayaVersionAsFloat`<$preMayaVersion)
			{
			$exampleFile=$exampleFoldersDir+$exampleFolder+"/"+$exampleFiles[$i];
			print ("// using backwards compatability file, as the original file requires Maya:\""+$preMayaVersion+"\" or higher\n");
			//requires wbDeltaMushDeformer
			if ($exampleFolder=="cody")
				asLoadWbDeltaMushPlugin;
			}
		}

print ("// Opening:\""+$exampleFile+"\"\n");
if (`file -q -ex $exampleFile`)
	{
	if (`saveChanges ""`)
		file -f -o $exampleFile;
	}
else
	warning ("Not Found:"+$exampleFile);
}

global proc asFitChangeLimbType ()
{
string $limbType=`optionMenu -q -v asLimbType`;
if ($limbType=="Spine" || $limbType=="Neck" || $limbType=="Tail")
	checkBox -e -v 1 asLimbMiddle;
else
	checkBox -e -v 0 asLimbMiddle;
}

global proc asFL ()
{
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
	if (`gmatch $framLayouts[$i] "as*FrameLayout"`)
		optionVar -iv $framLayouts[$i] `frameLayout -q -cl $framLayouts[$i]`;

}

global proc asReferenceModelBrowser ()
{
global string $selectedNamespaceRadioButton;
string $sNRB=$selectedNamespaceRadioButton;
string $referenceOptionsRenamePrefix=`optionVar -q referenceOptionsRenamePrefix`;
int $referenceUseNamespacesDuringFileIO=`optionVar -q referenceUseNamespacesDuringFileIO`;
int $referenceOptionsUseRenamePrefix=`optionVar -q referenceOptionsUseRenamePrefix`;
string $ReferenceMergeOptionValue=`optionVar -q ReferenceMergeOptionValue`;

optionVar -sv referenceOptionsRenamePrefix "model";
optionVar -iv referenceUseNamespacesDuringFileIO 1;
optionVar -iv referenceOptionsUseRenamePrefix 1;
optionVar -sv ReferenceMergeOptionValue "radioNamespaceOnString";
if ($selectedNamespaceRadioButton!="")
	$selectedNamespaceRadioButton="radioNamespaceOnString";
string $topNodesBefore[]=`ls -as`;

if (`asIsMayaLT`)
	error ("Maya LT does not have Reference, Import the model instead");
CreateReferenceOptions;

//Something in here Ran again, makes it work
global string $selectedNamespaceRadioButton;
$sNRB=$selectedNamespaceRadioButton;
$referenceOptionsRenamePrefix=`optionVar -q referenceOptionsRenamePrefix`;
$referenceUseNamespacesDuringFileIO=`optionVar -q referenceUseNamespacesDuringFileIO`;
$referenceOptionsUseRenamePrefix=`optionVar -q referenceOptionsUseRenamePrefix`;
$ReferenceMergeOptionValue=`optionVar -q ReferenceMergeOptionValue`;

optionVar -sv referenceOptionsRenamePrefix "model";
optionVar -iv referenceUseNamespacesDuringFileIO 1;
optionVar -iv referenceOptionsUseRenamePrefix 1;
optionVar -sv ReferenceMergeOptionValue "radioNamespaceOnString";
if ($selectedNamespaceRadioButton!="")
	$selectedNamespaceRadioButton="radioNamespaceOnString";
CreateReference;

optionVar -sv referenceOptionsRenamePrefix $referenceOptionsRenamePrefix;
optionVar -iv referenceUseNamespacesDuringFileIO $referenceUseNamespacesDuringFileIO;
optionVar -iv referenceOptionsUseRenamePrefix $referenceOptionsUseRenamePrefix;
optionVar -sv ReferenceMergeOptionValue $ReferenceMergeOptionValue;
if ($sNRB!="")
	$selectedNamespaceRadioButton=$sNRB;
string $topNodesAfter[]=`ls -as`;
select -cl;
for ($i=0;$i<size($topNodesAfter);$i++)
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		select -add $topNodesAfter[$i];

//Hi layer
if (`objExists Hi`)
	{
	if(`objectType Hi`=="displayLayer")
		editDisplayLayerMembers -noRecurse Hi `ls -selection`;
	}
else
	{
	createDisplayLayer -name Hi -number 1 -nr;
	setAttr Hi.displayType 1;
	}
select -cl;
}

global proc asFitTglRLA ()
{
if (!`objExists Visualizers`)
	return;
string $tempString[];
string $visualizers[]=`listRelatives -ad -type transform Visualizers`;
int $onOff,$setOnOff;
for ($i=0;$i<size($visualizers);$i++)
	{
	$tempString=`listRelatives -s $visualizers[$i]`;
	if ($tempString[0]!="" || !`gmatch $visualizers[$i] "*Aim"`)
		continue;
	if (!$setOnOff)
		{
		$onOff=!`getAttr ($visualizers[$i]+".displayLocalAxis")`;
		$setOnOff=1;
		}
	setAttr ($visualizers[$i]+".displayLocalAxis") $onOff;
	}
}

global proc asJointsVisibility (int $onOff)
{
if (!`objExists Main`)
	return;
string $joints[]=`listRelatives -type joint -ad Main`;
int $drawStyle=0;
if (!$onOff)
	$drawStyle=2;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".drawStyle") $drawStyle;
//DrawStyle=none, is still selectable ( in some versions of Maya), so set to "Reference"
//correction: setting to "Reference", causes selection of FK controls to select Shape only.
//turns out DrawStyle=none is not selectable, after save & reopen file.
//if (`objExists jointLayer`)
//	setAttr jointLayer.displayType (2*!$onOff);
}

global proc asDisplayRigRLA (int $onOff)
{
string $joints[]=`listRelatives -ad -type joint DeformationSystem`;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".displayLocalAxis") $onOff;
}

global proc asCreateFitSkeleton ()
{
if (`objExists FitSkeleton`)
	delete FitSkeleton;
string $tempString[]=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1.5 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FitSkeleton;
setAttr FitSkeletonShape.overrideEnabled 1;
setAttr FitSkeletonShape.overrideColor 29;
scale -r -p 0 0 0 2 2 2 FitSkeleton.cv[0:7];
duplicate -n FitSkeletonHeight FitSkeleton;
parent FitSkeletonHeight FitSkeleton;
parent -add -s FitSkeletonHeightShape FitSkeleton;
delete FitSkeletonHeight;
move -r 0 17 0 FitSkeletonHeightShape.cv[0:7];
setAttr -k 0 -l 1 FitSkeleton.tx;setAttr -k 0 -l 1 FitSkeleton.ty;setAttr -k 0 -l 1 FitSkeleton.tz;
setAttr -k 0 -l 1 FitSkeleton.rx;setAttr -k 0 -l 1 FitSkeleton.ry;setAttr -k 0 -l 1 FitSkeleton.rz;
asEnsureFitSkeletonAttributes;
//asFitSkeletonConnectControl;
select FitSkeleton;
}

global proc asEnsureFitSkeletonAttributes ()
{
if (!`objExists FitSkeleton`)
	return;
float $gap=0.75;
if (`optionVar -ex asFitSkeletonGap`)
	$gap=`optionVar -q asFitSkeletonGap`;

if (!`attributeExists visGeo FitSkeleton`)
	addAttr -k 1 -ln visGeo -at bool -dv 0 FitSkeleton;
if (!`attributeExists visGeoType FitSkeleton`)
	addAttr -k 1 -ln visGeoType -at "enum" -en "cylinders:boxes:spheres:bones" FitSkeleton;
if (!`attributeExists visCylinders FitSkeleton`)
	addAttr -k 0 -ln visCylinders -at bool FitSkeleton;
if (!`attributeExists visBoxes FitSkeleton`)
	addAttr -k 0 -ln visBoxes -at bool FitSkeleton;
if (!`attributeExists visSpheres FitSkeleton`)
	addAttr -k 0 -ln visSpheres -at bool FitSkeleton;
if (!`attributeExists visBones FitSkeleton`)
	addAttr -k 0 -ln visBones -at bool FitSkeleton;
if (!`attributeExists lockCenterJoints FitSkeleton`)
	addAttr -k 1 -ln lockCenterJoints -dv 1 -at bool FitSkeleton;
if (!`attributeExists visGap FitSkeleton`)
	addAttr -k 1 -ln visGap -at double -dv $gap -min 0 -max 1 FitSkeleton;

if (!`attributeExists visPoleVector FitSkeleton`)
	addAttr -k 1 -ln visPoleVector -at bool -dv 0 FitSkeleton;
if (!`attributeExists visJointOrient FitSkeleton`)
	addAttr -k 1 -ln visJointOrient -at bool -dv 0 FitSkeleton;
if (!`attributeExists visJointAxis FitSkeleton`)
	addAttr -k 1 -ln visJointAxis -at bool -dv 0 FitSkeleton;

if (!`attributeExists preRebuildScript FitSkeleton`)
	addAttr -ln preRebuildScript -dt "string" FitSkeleton;
if (!`attributeExists postRebuildScript FitSkeleton`)
	addAttr -ln postRebuildScript -dt "string" FitSkeleton;

asFitSkeletonConnectControl;
}

global proc asEnsureFitBaseStruct ()
{
if (!`objExists FitSkeletonVisualizers`)
	createNode -n FitSkeletonVisualizers transform;
if (!`objExists Aims`)
	createNode -n Aims -p FitSkeletonVisualizers transform;
if (!`objExists Systems`)
	createNode -n Systems -p FitSkeletonVisualizers transform;
}

global proc asFitSkeletonConnectControl ()
{
if (!`objExists FitSkeleton`)
	return;

if(`attributeExists visGeo FitSkeleton`)
	connectControl asVisGeo FitSkeleton.visGeo;
if(`attributeExists visGeoType FitSkeleton`)
	connectControl asVisGeoType FitSkeleton.visGeoType;
if(`attributeExists visGap FitSkeleton`)
	connectControl asVisGap FitSkeleton.visGap;
if(`attributeExists lockCenterJoints FitSkeleton`)
	connectControl asLockCenterJoints FitSkeleton.lockCenterJoints;

if(`attributeExists lockCenterJoints FitSkeleton`)
	asFitModeLockCenterJoints;

if(`attributeExists visPoleVector FitSkeleton`)
	connectControl asVisPoleVector FitSkeleton.visPoleVector;
if(`attributeExists visJointOrient FitSkeleton`)
	connectControl asVisJointOrient FitSkeleton.visJointOrient;
if(`attributeExists visJointAxis FitSkeleton`)
	connectControl asVisJointAxis FitSkeleton.visJointAxis;
}

global proc asStraightEndLoc (string $loc, float $lenght)
{
//maintain the `direction` with the end loc
string $parent;
float $pos[]=`getAttr ($loc+".t")`;
$tempString=`listConnections -s 0 -d 1 ($loc+".message")`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		{
		if (`attributeExists "child" $tempString[$i]`)
			if (`isConnected ($loc+".message") ($tempString[$i]+".child")`)
				$parent=$tempString[$i];
		if (`attributeExists "otherChildren" $tempString[$i]`)
			for ($y=0;$y<`getAttr -s ($tempString[$i]+".otherChildren")`;$y++)
				if (`isConnected ($loc+".message") ($tempString[$i]+".otherChildren["+$y+"]")`)
					$parent=$tempString[$i];
		}

if ($parent!="")
	{
	float $pos2[]=`getAttr ($parent+".t")`;
	float $parentLenght=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	if ($lenght==0)
		$lenght=$parentLenght;
	float $lenghtMuliplier=1;
	if ($lenght!=0)
		$lenghtMuliplier=$parentLenght*1/$lenght;
	if (`objExists ($loc+"End")`)
		{
		if (!`getAttr -l ($loc+"End.tx")`)
			setAttr ($loc+"End.tx") ($pos[0]+($pos[0]-$pos2[0])/$lenghtMuliplier);
		if (!`getAttr -l ($loc+"End.ty")`)
			setAttr ($loc+"End.ty") ($pos[1]+($pos[1]-$pos2[1])/$lenghtMuliplier);
		if (!`getAttr -l ($loc+"End.tz")`)
			setAttr ($loc+"End.tz") ($pos[2]+($pos[2]-$pos2[2])/$lenghtMuliplier);
		}
	}
}

global proc asUpdateButtonEnables ()
{
int $hasBodySetup=`objExists "Group"`;
int $hasFaceSetup=`objExists FaceMotionSystem`;
int $hasVisualizers=`objExists FitSkeletonVisualizers`;
int $hasGeometryVisualizers=`objExists FitSkeletonVisualizers` && `objExists Aims`;
int $showDelteAdvFaceButton=0;
if ($hasFaceSetup && `getAttr FaceFitSkeleton.v`)
	$showDelteAdvFaceButton=1;

//Body
checkBox -e -v $hasGeometryVisualizers asVisGeo;
optionMenu -e -en $hasVisualizers asVisGeoType;
floatSliderGrp -e -en $hasVisualizers asVisGap;

checkBox -e -m $hasBodySetup asRebuildConnections;
button -e -m $hasBodySetup asToggleFitSkeletonButton;
string $buildLabel="Build AdvancedSkeleton";
if ($hasBodySetup)
	$buildLabel="ReBuild AdvancedSkeleton";
button -e -l $buildLabel asBuildAdvancedSkeletonButton;

//Face
button -e -m $hasFaceSetup asToggleFitFaceButton;
button -e -m $showDelteAdvFaceButton asDelteAdvFaceButton;
checkBox -e -m $showDelteAdvFaceButton asFaceKeepBuildPose;
button -e -en (!$hasFaceSetup) asBuildAdvancedFaceButton;

text -e -m $hasFaceSetup asBodyText;
text -e -m $hasFaceSetup asFaceText;
button -e -m $hasFaceSetup asGoToBuildPoseFaceButton;
}

global proc asSceneOpened ()
{
global int $asFitModeScriptJobNr4;
$asFitModeScriptJob4Nr=`scriptJob -runOnce 1 -e SceneOpened asSceneOpened`;
asOffFitMode;

asEnsureFitSkeletonAttributes;
asUpdateButtonEnables;
asFaceUpdateInfo 1;
}

global proc asOffFitMode ()
{
global int $asFitModeScriptJobNr1;
global int $asFitModeScriptJobNr2[];
global int $asFitModeScriptJobNr3;
if (`headsUpDisplay -q -ex HUDFitMode`)
	headsUpDisplay -rem HUDFitMode;

if (`scriptJob -ex $asFitModeScriptJobNr1` && $asFitModeScriptJobNr1!=0)
	{
	scriptJob -kill $asFitModeScriptJobNr1;
	$asFitModeScriptJobNr1=0;
	}
if (`scriptJob -ex $asFitModeScriptJobNr3` && $asFitModeScriptJobNr3!=0)
	{
	scriptJob -kill $asFitModeScriptJobNr3;
	$asFitModeScriptJobNr3=0;
	}
for ($i=0;$i<size($asFitModeScriptJobNr2);$i++)
	if ($asFitModeScriptJobNr2[$i])
		if (`scriptJob -ex $asFitModeScriptJobNr2[$i]`)
			{
			scriptJob -kill $asFitModeScriptJobNr2[$i];
			$asFitModeScriptJobNr2[$i]=0;
			}
}


global proc asToggleFitFace ()
{
int $fitFaceVis=`getAttr FaceFitSkeleton.visibility`;
setAttr -l 0 FaceFitSkeleton.v;
setAttr -l 1 FaceFitSkeleton.v (!$fitFaceVis);
catchQuiet (`setAttr FaceMotionSystem.v $fitFaceVis`);
asUpdateButtonEnables;
}


global proc asCopyAttrProperties (string $sourceObjAttr, string $destObjAttr)
{
float $temp[];
string $tempString[];
tokenize $sourceObjAttr "[.]" $tempString;
string $sourceObj=$tempString[0];
string $sourceAttr=$tempString[1];
tokenize $destObjAttr "[.]" $tempString;
string $destObj=$tempString[0];
string $destAttr=$tempString[1];
if (`attributeQuery -node $sourceObj -minExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -min $sourceAttr`;
	addAttr -e -min $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -maxExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -max $sourceAttr`;
	addAttr -e -max $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -softMinExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -softMin $sourceAttr`;
	addAttr -e -softMinValue $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -softMaxExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -softMax $sourceAttr`;
	addAttr -e -softMaxValue $temp[0] $destObjAttr;
	}
}

global proc asUpdateDrivingSystemsToFitSkeleton ()
{
string $sel[]=`ls -sl`;
//Remove ewxisting FitSkeltonDrivingSystems first
string $systems[]=`listRelatives -c Systems`;
for ($i=0;$i<size($systems);$i++)
	if (`gmatch $systems[$i] "DS_*"`)
		delete $systems[$i];
string $drivingSystems[]=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	$ds="DS_"+$drivingSystems[$i];
	createNode -n $ds -p "Systems" transform;
	string $uAs[]=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($uAs);$y++)
		{
		$dsd=$ds+"_"+$uAs[$y];
		createNode -n $dsd -p $ds transform;
		asLockAttr $dsd 1 1 1 1;
		addAttr -k 1 -ln $uAs[$y] -at double $ds;
		asCopyAttrProperties ($drivingSystems[$i]+"."+$uAs[$y]) ($ds+"."+$uAs[$y]);
		$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$uAs[$y])`;
		for ($z=0;$z<size($tempString);$z++)
			{
			duplicate -n ("Fit_"+$tempString[$z]) $tempString[$z];
			if (`sets -im AllSet ("Fit_"+$tempString[$z])`)
				sets -rm AllSet ("Fit_"+$tempString[$z]);
			addAttr -k 1 -ln ("standinAttr"+$z) -at double $dsd;
			connectAttr ("Fit_"+$tempString[$z]+".output") ($dsd+".standinAttr"+$z);
			}
		}
	}
select $sel;
}

global proc asFitModeEnsureShaders ()
{
string $colors[]={"asRed","asRed2","asGreen","asGreen2","asBlue","asBlue2","asWhite","asBlack","asBones"};
float $rs[]={1.0 , 1.0 , 0.0 , 1.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.78};
float $gs[]={0.0 , 0.0 , 1.0 , 1.0 , 0.0 , 1.0 , 1.0 , 0.0 , 0.76};
float $bs[]={0.0 , 1.0 , 0.0 , 0.0 , 1.0 , 1.0 , 1.0 , 0.0 , 0.72};
for ($i=0;$i<size($colors);$i++)
	{
	if (`objExists $colors[$i]` && `objExists ($colors[$i]+"SG")`)
		continue;
	if (`objExists $colors[$i]`) delete $colors[$i];
	if (`objExists ($colors[$i]+"SG")`) delete ($colors[$i]+"SG");
	shadingNode -n $colors[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($colors[$i]+"SG");
	connectAttr -f ($colors[$i]+".outColor") ($colors[$i]+"SG.surfaceShader");
	setAttr -type float3 ($colors[$i]+".color") $rs[$i] $gs[$i] $bs[$i];
	}
}

global proc asCreateSamplerMesh (string $sourceObj)
{
//make a copy of the geometry, so we can freeze transforms and get correct sampler-results
string $tempString[];
duplicate -n samplerMesh $sourceObj;
$tempString=`listRelatives -f -ni -s samplerMesh`;
rename $tempString[0] samplerMeshShape;
asLockAttr samplerMesh 0 0 0 0;
$tempString=`listRelatives -p samplerMesh`;
if ($tempString[0]!="")
	parent -w samplerMesh;
$tempString=`listRelatives -s -f samplerMesh`;
for ($w=0;$w<size($tempString);$w++)
	if (`getAttr ($tempString[$w]+".intermediateObject")`)
		delete $tempString[$w];
makeIdentity -a 1 -t 1 -r 1 -s 1 samplerMesh;
}

global proc asSelectDeformJoints ()
{
string $sel[]=`ls -sl`;
if (`objExists "DeformSet"`)
	select `sets -q "DeformSet"`;
//Deselect end-joints
string $tempString[];
string $deformJoints[]=`ls -sl`;
for ($i=0;$i<size($deformJoints);$i++)
	{
	if (`gmatch $deformJoints[$i] "*Slider[0-9]"`)
		continue;
	$tempString=`listRelatives -c -type joint $deformJoints[$i]`;
	if ($tempString[0]=="")
		select -d $deformJoints[$i];
	}
for ($i=0;$i<size($deformJoints);$i++)
	if ($deformJoints[$i]=="Eye_R" || $deformJoints[$i]=="Eye_L" || $deformJoints[$i]=="Jaw_M")
		select -d $deformJoints[$i];
select -add $sel;
}

global proc asSetSmoothBindOptions ()
{
optionVar
-iv "multipleBindPosesOpt" 1
-iv "bindMethod" 1
-iv "bindTo" 2
-iv "skinMethod" 1
-iv "removeUnusedInfluences" 0
-iv "colorizeSkeleton" 0
-fv "maxInfl" 3
-iv "normalizeWeights" 2
-iv "obeyMaxInfl" 0;
SmoothBindSkinOptions;
}

global proc asOpenSelector ()
{
evalEcho ("source \""+`asGetScriptLocation`+"/AdvancedSkeleton5Files/Selector/biped.mel\"");
}

global proc asCreateTempNodes ()
{
createNode -n TempNodes transform;
string $tempNodes[]={"FKScapula_R","FKScapula_L","FKAnkle_L","FKAnkle_R","FKChest_M","FKElbow_L","FKElbow_R","FKHead_M","FKHip_L","FKHip_R","FKIndexFinger1_L","FKIndexFinger1_R","FKIndexFinger2_L","FKIndexFinger2_R","FKIndexFinger3_L","FKIndexFinger3_R","FKKnee_L","FKKnee_R","FKMiddleFinger1_L","FKMiddleFinger1_R","FKMiddleFinger2_L","FKMiddleFinger2_R","FKMiddleFinger3_L","FKMiddleFinger3_R","FKNeck_M","FKPinkyFinger1_L","FKPinkyFinger1_R","FKPinkyFinger2_L","FKPinkyFinger2_R","FKPinkyFinger3_L","FKPinkyFinger3_R","FKRingFinger1_L","FKRingFinger1_R","FKRingFinger2_L","FKRingFinger2_R","FKRingFinger3_L","FKRingFinger3_R","FKRoot_M","FKShoulder_L","FKShoulder_R","FKSpine1_M","FKThumbFinger1_L","FKThumbFinger1_R","FKThumbFinger2_L","FKThumbFinger2_R","FKThumbFinger3_L","FKThumbFinger3_R","FKToes_L","FKToes_R","FKWrist_L","FKWrist_R"};
for ($i=0;$i<size($tempNodes);$i++)
	createNode -n $tempNodes[$i] -p TempNodes transform;
select `listRelatives -ad TempNodes`;
}

global proc asFitSkeletonFromEdgeLoops ()
{
global string $gMove;
setToolTo $gMove;
float $pos[];
string $loc;
string $skinLoopSets[]=`sets -q SkinLoops`;
for ($i=0;$i<size($skinLoopSets);$i++)
	{
	$loc=`substitute "SkinLoops_" $skinLoopSets[$i] ""`;
	$loc=`substitute "_R" $loc ""`;
	$loc=`substitute "_M" $loc ""`;
	if (!`objExists $loc`)
		continue;
	select $skinLoopSets[$i];
	$pos=`manipMoveContext -q -position "Move"`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $loc;
	}
select -cl;
}

global proc asCreateSkinLoop (int $mirroring)
{
string $sel[]=`ls -sl`;
if (!size($sel))
	error "nothing selected";
string $fkControl=$sel[size($sel)-1];
string $deformJoint;
if (`objExists DeformSet` && `sets -im DeformSet $fkControl`)
	$deformJoint=$fkControl;
else
	{
	$deformJoint=`substitute "FK" $fkControl ""`;
	if (!`gmatch $fkControl "FK*"`)
		error "No FK control selected";
	}
float $pos[];
float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
//float $mirrorTolerance=0.001*$scale;

int $neighboursInLoop;
string $mirrorFkControl;
string $tempString[],$tempString2[],$tempString3[],$mirrorVtxs[];

//validate complete loop
select -d $fkControl;
ConvertSelectionToVertices;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	select $tempString[$i];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $tempString[$i];
	$tempString2=`ls -sl -fl`;
	$neighboursInLoop=0;
	for ($y=0;$y<size($tempString2);$y++)
		if (`stringArrayCount $tempString2[$y] $tempString`)
			$neighboursInLoop++;
	if ($neighboursInLoop!=2)
		{
		select $tempString[$i];
		if ($mirroring)
			error ("Not a complete loop, on mirrored side");
		else
			error ("Not a complete loop");
		}
	}

if (`objExists ("SkinLoops_"+$deformJoint)`)
	delete ("SkinLoops_"+$deformJoint);

if (!`objExists SkinLoops`)
	sets -em -name SkinLoops;
select $sel;
select -d $fkControl;
sets -name ("SkinLoops_"+$deformJoint);
sets -add  SkinLoops ("SkinLoops_"+$deformJoint);

if (`checkBox -q -v asCreateSkinLoopCheckBox` && !`gmatch $deformJoint "*_M"` && !$mirroring)
	{
	select ("SkinLoops_"+$deformJoint);
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	$tempString2=`ls -sl -o`;
	$tempString3=`listRelatives -p $tempString2[0]`;
	if (`objExists closestSampler`) delete closestSampler;
	if (`objExists samplerMesh`) delete samplerMesh;
	asCreateSamplerMesh $tempString3[0];
	createNode -n closestSampler closestPointOnMesh;
	connectAttr -f samplerMesh.outMesh closestSampler.inMesh;
	
	for ($i=0;$i<size($tempString);$i++)
		{
		select $tempString[$i];
		$pos=`xform -q -ws -t $tempString[$i]`;
		setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
		int $closestVtxIndex=`getAttr closestSampler.closestVertexIndex`;
		$mirrorVtxs[size($mirrorVtxs)]=$tempString2[0]+".vtx["+$closestVtxIndex+"]";
		}
	select $mirrorVtxs;
	ConvertSelectionToContainedEdges;
	if (`gmatch $deformJoint "*_R"`) $mirrorFkControl=`substitute "_R" $fkControl "_L"`;
	if (`gmatch $deformJoint "*_L"`) $mirrorFkControl=`substitute "_L" $fkControl "_R"`;
	select -add $mirrorFkControl;
	asCreateSkinLoop 1;
	}
if (`objExists closestSampler`) delete closestSampler;
if (`objExists samplerMesh`) delete samplerMesh;
print ("// SkinLoops_"+$deformJoint+" Created\n");
select $sel;
}

global proc asSelectAllSkinLoops ()
{
select SkinLoops;
select -add `ls -sl -o`;
}

global proc asDeleteCutUp ()
{
delete `listConnections CutUp.drawInfo`;
delete CutUp;
}

global proc asBindSkinLoops (int $createCutUp)
{
source removeUnusedInfluences;
global string $gMove;
string $sel[]=`ls -sl`;
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*[.]*"`)
		error ("Selection is not a object:"+$sel[$i]);
int $tempInt[],$twistJoints[];
int $haveSkinCluster,$numVtxs,$foundDownSideVtx,$loopAffectsCut;
float $circumference,$radius,$ratio;
float $pos[],$posA[],$posB[],$values[];
string $tempString[],$tempString2[],$deformJoints[],$parentJoints[],$childJoints[],$historyNodes[],$skinClusterJoints[],$infs[];
string $allJointChildren[],$edgeLoopVtxs[],$allEdgeLoopVtxs[],$allNonPartEdgeLoopVtxs[],$neighbourVtxs[];
string $skinCluster,$weightTo,$cutName,$twistJoint;
string $skinLoopSets[]=`sets -q SkinLoops`;
$skinLoopSets=`sort $skinLoopSets`;

createNode -n CutUpWIP transform;
sets -em -n SkinLoopWeighted;
if ($createCutUp && !`objExists CutUp`)
	{
	createDisplayLayer -e -name CutUp;
	setAttr CutUp.color 29;
	setAttr CutUp.displayType 2;
	}

string $skinLoopObjects[];
select SkinLoops;
$tempString=`ls -sl -o`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	if (!`stringArrayCount $tempString2[0] $skinLoopObjects`)
		$skinLoopObjects[size($skinLoopObjects)]=$tempString2[0];
	}

for ($i=0;$i<size($sel);$i++)
	{
	if (!`stringArrayCount $sel[$i] $skinLoopObjects`)
		{
		print ("// SkinLoops not defined for \""+$sel[$i]+"\", skipping this\n");
		continue;
		}
	if ($createCutUp)
		{//temp geo, to maintain weights on original
		duplicate -n ($sel[$i]+"CutUp") $sel[$i];
		$tempString=`listRelatives -s ($sel[$i]+"CutUp")`;
		for ($w=0;$w<size($tempString);$w++)
			if (`getAttr ($tempString[$w]+".intermediateObject")`)
				delete $tempString[$w];
		$sel[$i]=$sel[$i]+"CutUp";
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			$tempString=`duplicate $skinLoopSets[$y]`;
			rename $tempString[0] ($skinLoopSets[$y]+"CutUp");

			select $skinLoopSets[$y];
			$tempString=`ls -sl -fl`;
			for ($t=0;$t<size($tempString);$t++)
				if (`gmatch $tempString[$t] ($sel[$i]+"[.]*")`)
					{
					sets -add ($skinLoopSets[$y]+"CutUp") $tempString[$t];
					sets -rm $skinLoopSets[$y] $tempString[$t];
					}
			}

		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			rename $skinLoopSets[$y] ($skinLoopSets[$y]+"Temp");
			rename ($skinLoopSets[$y]+"CutUp") $skinLoopSets[$y];
			}
		}
	$haveSkinCluster=0;
	$tempInt=`polyEvaluate -v $sel[$i]`;
	$numVtxs=$tempInt[0];
	if (!$createCutUp)
		$historyNodes=`listHistory $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$skinCluster=$historyNodes[$y];
			}
	if ($haveSkinCluster)
		skinPercent -tv Root_M 1 $skinCluster $sel[$i];
	else
		{
		select Root_M $sel[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	for ($y=0;$y<size($skinLoopSets);$y++)
		{
		//Check that skinLoops comes from this object
		$tempString=`sets -q $skinLoopSets[$y]`;
		if (!size($tempString))
			continue;
		tokenize $tempString[0] "[.]" $tempString;
		if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
		if ($tempString[0]!=$sel[$i])
			continue;

		$skinClusterJoints=`listConnections ($skinCluster+".matrix")`;
		$deformJoints[$y]=`substitute "SkinLoops_" $skinLoopSets[$y] ""`;
		$parentJoints[$y]=$childJoints[$y]="";
		$twistJoints[$y]=0;

		$tempString=`listRelatives -p -type joint $deformJoints[$y]`;
		if ($tempString[0]!="")
			$parentJoints[$y]=$tempString[0];
		$tempString=`listRelatives -c -type joint $deformJoints[$y]`;
		if ($tempString[0]!="")
			$childJoints[$y]=$tempString[0];
		if (!`stringArrayCount $deformJoints[$y] $skinClusterJoints`)
			{
			skinCluster -e -lw false -wt 0 -ai $deformJoints[$y] $skinCluster;
			$skinClusterJoints[size($skinClusterJoints)]=$deformJoints[$y];
			}
		if ($parentJoints[$y]!="")
			if (!`stringArrayCount $parentJoints[$y] $skinClusterJoints`)
				{
				skinCluster -e -lw false -wt 0 -ai $parentJoints[$y] $skinCluster;
				$skinClusterJoints[size($skinClusterJoints)]=$parentJoints[$y];
				}
		select $skinLoopSets[$y];
		ConvertSelectionToVertices;
		refresh;
		skinPercent -tv $deformJoints[$y] 1 $skinCluster `ls -sl`;
		sets -add SkinLoopWeighted `ls -sl`;
		}
	select -cl;
	for ($y=0;$y<size($skinLoopSets);$y++)
		select -add $skinLoopSets[$y];
	ConvertSelectionToVertices;
	string $loopVtxs[]=`ls -sl`;
	select ($sel[$i]+".vtx[0:"+$numVtxs+"]");
	select -d $loopVtxs;
	$nonLoopVtx=`ls -sl -fl`;
	refresh;
	weightHammerVerts;

	//another round of hammer, just near loops, to improve chance of finding $DownSideVtx
	select $loopVtxs;
	GrowPolygonSelectionRegion;
	select -d $loopVtxs;
	weightHammerVerts;

	select SkinLoops;
	ConvertSelectionToVertices;
	$allEdgeLoopVtxs=`ls -sl`;

	select -cl;
	for ($y=0;$y<size($skinLoopSets);$y++)
		if (!`gmatch $skinLoopSets[$y] "*Part[0-9]_*"`)
			select -add $skinLoopSets[$y];
	ConvertSelectionToVertices;
	$allNonPartEdgeLoopVtxs=`ls -sl`;

	for ($y=0;$y<size($skinLoopSets);$y++)
		{
		//Check that skinLoops comes from this object
		$tempString=`sets -q $skinLoopSets[$y]`;
		if (!size($tempString))
			continue;
		tokenize $tempString[0] "[.]" $tempString;
		if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
		if ($tempString[0]!=$sel[$i])
			continue;

		select $skinLoopSets[$y];
		ConvertSelectionToVertices;
		$edgeLoopVtxs=`ls -sl -fl`;
		select $edgeLoopVtxs[0];
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		select -d $allEdgeLoopVtxs;
		$neighbourVtxs=`ls -sl -fl`;

		$allJointChildren=`listRelatives -ad -type joint $deformJoints[$y]`;
		for ($z=0;$z<size($neighbourVtxs);$z++)
			{
			if (`sets -im SkinLoopWeighted $neighbourVtxs[$z]`)
				continue;
			$foundDownSideVtx=0;
			select $neighbourVtxs[$z];
			$infs=`skinPercent -ignoreBelow 0.0000001 -q -t $skinCluster $neighbourVtxs[$z]`;
			for ($q=0;$q<size($infs);$q++)
				{//size($infs)==1 means EndPiece
				if (`stringArrayCount $infs[$q] $allJointChildren` || size($infs)==1)
					{
					$cutName=$deformJoints[$y]+"_"+$infs[$q]+"_Cut";
					$foundDownSideVtx=1;
					break;
					}
				}
			if (`objExists ($cutName+"WIP")` || `objExists ($infs[$q]+"_"+$deformJoints[$y]+"_CutWIP")`)
				continue;
			if ($foundDownSideVtx)
				{
				$numSel=0;
				$previousNumSel=-1;
				for ($q=0;$q<100;$q++)
					{
					ConvertSelectionToEdges;
					ConvertSelectionToVertices;
//					select -d $allNonPartEdgeLoopVtxs;
					select -d $allEdgeLoopVtxs;
					$numSel=size(`ls -sl -fl`);
					if ($numSel==$previousNumSel)
						break;
					$previousNumSel=$numSel;
					if ($skinLoopSets[$y]!="SkinLoops_Root_M")
						$z=99;//dont need to check the other $neighbourVtxs
					}
				refresh;

				$tempString=`ls -sl -fl`;
				createNode -n ($cutName+"WIP") -p CutUpWIP transform;
				select $tempString;
				if (!$createCutUp)
					{
					if (!$twistJoints[$y])
						skinPercent -tv $deformJoints[$y] 1 $skinCluster `ls -sl`;
					if ($twistJoints[$y]==2)// Only works with TwistJoints==2 For Now.
						{
						tokenize $deformJoints[$y] "_" $tempString2;
						for ($w=1;$w<$twistJoints[$y]+1;$w++)
							{
							$twistJoint=$tempString2[0]+"Part"+$w+"_"+$tempString2[1];
							if (!`stringArrayCount $twistJoint $skinClusterJoints`)
								{
								skinCluster -e -lw false -wt 0 -ai $twistJoint $skinCluster;
								$skinClusterJoints[size($skinClusterJoints)]=$twistJoint;
								}
							}
						for ($w=0;$w<size($tempString);$w++)
							{
							$infs=`skinPercent -ignoreBelow 0.0000001 -q -t $skinCluster $tempString[$w]`;
							$values=`skinPercent -ignoreBelow 0.0000001 -q -v $skinCluster $tempString[$w]`;
							$tempString2=`listRelatives -ad -type joint $infs[0]`;
							if (`stringArrayCount $infs[1] $tempString2`)
								$ratio=$values[0];
							else
								$ratio=$values[1];
							tokenize $deformJoints[$y] "_" $tempString2;
							skinPercent -tv ($tempString2[0]+"Part1_"+$tempString2[1]) $ratio 
													-tv ($tempString2[0]+"Part2_"+$tempString2[1]) (1-$ratio)
													$skinCluster $tempString[$w];
							}
						}
					select $tempString;
					sets -add SkinLoopWeighted `ls -sl`;
					}
				if ($createCutUp)
					{
					ConvertSelectionToFaces;
					$tempString=`ls -sl`;
					if (`objExists $cutName`)
						delete $cutName;
					duplicate -n $cutName $sel[$i];
					asLockAttr $cutName 0 0 0 0;
					$tempString2=`listRelatives -s $cutName`;
					for ($w=0;$w<size($tempString2);$w++)
						if (`getAttr ($tempString2[$w]+".intermediateObject")`)
							delete $tempString2[$w];					
					parent $cutName $deformJoints[$y];
					editDisplayLayerMembers -noRecurse CutUp $cutName;
					select -cl;
					for ($q=0;$q<size($tempString);$q++)
						select -add `substitute $sel[$i] $tempString[$q] $cutName`;
					asInvertSelection;
					delete;
					select $cutName;
					CenterPivot;
					//cap
					for ($r=0;$r<size($skinLoopSets);$r++)
						{
						select $skinLoopSets[$r];
						$tempString=`ls -sl -o`;
						$loopAffectsCut=0;
						for ($t=0;$t<size($tempString);$t++)
							{
							$tempString2=`listRelatives -p $tempString[$t]`;
							if ($tempString2[0]==$cutName)
								{
								$loopAffectsCut=1;
								break;
								}
							}
						if (!$loopAffectsCut)
							continue;
						select -d ($sel[$i]+".e[0:99999]");
						//get radius of loop
						$circumference=0;
						$tempString=`ls -sl -fl`;
						for ($t=0;$t<size($tempString);$t++)
							{
							select $tempString[$t];
							ConvertSelectionToVertices;
							$tempString2=`ls -sl -fl`;
							$posA=`xform -q -ws -t $tempString2[0]`;
							$posB=`xform -q -ws -t $tempString2[1]`;
							$circumference+=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
							}
						$radius=($circumference/3.14)/2.0;
						select $skinLoopSets[$r];
						select -d ($sel[$i]+".e[0:99999]");
						$tempString=`polyExtrudeEdge -constructionHistory 1 -keepFacesTogether 1 -pvx 1.927402496 -pvy 3.865962148 -pvz 0.184265554 -divisions 1 -twist 0 -taper 1 -offset 0 -thickness 0 -smoothingAngle 30`;
						$extrudedSel=`ls -sl`;
						setToolTo $gMove;
						$pos=`manipMoveContext -q -position "Move"`;
						scale -r -p $pos[0] $pos[1] $pos[2] 0.25 0.25 0.25;
						$posB=`xform -q -ws -piv $cutName`;
						spaceLocator -n tempLoc1;
						xform -ws -t $posB[0] $posB[1] $posB[1] tempLoc1;
						spaceLocator -n tempLoc2;
						xform -ws -t $pos[0] $pos[1] $pos[1] tempLoc2;	
						aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 tempLoc2 tempLoc1;
						parent $cutName tempLoc1;
						select $extrudedSel;
						move -r -ls -wd ($radius*0.5) 0 0;

						parent $cutName $deformJoints[$y];
						delete tempLoc1 tempLoc2;
						select $cutName;
						DeleteHistory;
						sets -rm $skinLoopSets[$r] ($cutName+".e[0:99999]");
						}
					}
				}
			}
		}

	if (!$createCutUp)
		{
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			//Check that skinLoops comes from this object
			$tempString=`sets -q $skinLoopSets[$y]`;
			if (!size($tempString))
				continue;
			tokenize $tempString[0] "[.]" $tempString;
			if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
			if ($tempString[0]!=$sel[$i])
				continue;
			if (`gmatch $deformJoints[$y] "*Part[0-9]_*"`)//skip 50 weight of partial joint
				continue;

			select $skinLoopSets[$y];
			ConvertSelectionToVertices;
			$tempString2=`ls -sl`;
			$tempString=`listRelatives -p -type joint $deformJoints[$y]`;
			if (size($tempString))
				skinPercent -tv $deformJoints[$y] 0.5 -tv $tempString[0] 0.5 $skinCluster `ls -sl`;
			GrowPolygonSelectionRegion;
//			select -d $tempString2;
			select -d $loopVtxs;
			if (size(`ls -sl`))
				weightHammerVerts;
			}
		}
	if ($createCutUp)
		{
		delete $sel[$i];
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			if (`objExists $skinLoopSets[$y]`)
				delete $skinLoopSets[$y];
			rename ($skinLoopSets[$y]+"Temp") $skinLoopSets[$y];
			}
		}

	if (!$createCutUp)
		{
		select $sel[$i];
		removeUnusedInfluences;
		}
	}


delete CutUpWIP SkinLoopWeighted;
select -cl;
catchQuiet (`select $sel`);
if ($createCutUp)
	print "// SkinLoop CutUp completed.\n";
else
	print "// SkinLoop Bind completed.\n";
}

global proc asCopySkinLoopWeights ()
{
string $sel[]=`ls -sl`;

if (!`objExists SkinLoops`)
	error "SkinLoops not created";

int $isComponents=0;
source removeUnusedInfluences;
int $hasSkinCluster,$skinningMethod;
string $skinCluster,$sourceSC;
string $selObjs[],$shapes[],$history[],$joints[],$tempString[];

select SkinLoops;
select `ls -sl -o`;
$tempString=`ls -sl`;
string $source=$tempString[0];
$tempString=`ls -sl -showType $source`;
if ($tempString[1]=="mesh")
	{
	$tempString=`listRelatives -p $source`;
	$source=$tempString[0];
	}
$history=`listHistory -pdo 1 $source`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$sourceSC=$history[$y];

if (`gmatch $sel[0] "*[.]*"`) 
    $isComponents=1;
if ($isComponents)
    {
    $tempString=`ls -sl -o`;
    $selObjs=`listRelatives -p $tempString[0]`;
    }
else
    $selObjs=$sel;

$history=`listHistory -pdo 1 $source`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$skinningMethod=`getAttr ($history[$y]+".skinningMethod")`;

for ($i=0;$i<size($selObjs);$i++)
	{
	$shapes=`listRelatives -s -ni $selObjs[$i]`;
	if (size($shapes)<1)
		continue;
	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $selObjs[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}

	if ($hasSkinCluster) // possible joints added to skinCage
		{
		$joints=`listConnections ($sourceSC+".matrix")`;
		string $joints2[]=`listConnections ($skinCluster+".matrix")`;
		for ($y=0;$y<size($joints);$y++)
			if (!`stringArrayCount $joints[$y] $joints2`)
				skinCluster -e -lw false -wt 0 -ai $joints[$y] $skinCluster;
		}
	if (!$hasSkinCluster)
		{
		$joints=`listConnections ($sourceSC+".matrix")`;
		select $joints;
		select -add $selObjs[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	//copy skin
	select -r  $source;
	if ($isComponents)
	    select -add $sel;
	else
		select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	setAttr ($skinCluster+".skinningMethod") $skinningMethod;
	removeUnusedForSkin $skinCluster 0;
	}
select $sel;
}

global proc string asStripSystemLetter (string $system)
{
string $systemNoLetter=$system;
int $numLetters=size($system);
if (`gmatch $system "*[A-Z]"`)
	$systemNoLetter=`substring $system 1 ($numLetters-1)`;
return $systemNoLetter;
}

global proc int asConfirmIfNotInBuildPose ()
{
if (!`objExists DeformSet`)
	return 1;
int $proceed=1;
int $maxTextLines=35;
int $numNonDef;
string $m;
string $deformJointsList[]=`sets -q DeformSet`;
string $checkAttr[]={"rx","ry","rz","sx","sy","sz"};
float $checkValues[]={0,0,0,1,1,1};
for ($i=0;$i<size($deformJointsList);$i++)
	for ($y=0;$y<size($checkAttr);$y++)
		{
		$value=`getAttr ($deformJointsList[$i]+"."+$checkAttr[$y])`;
		if ($value>($checkValues[$y]+0.01) || $value<($checkValues[$y]-0.01))
			{
			$m+=$deformJointsList[$i]+"."+$checkAttr[$y]+" = "+$value+"\n";
			$numNonDef++;
			}
		if ($numNonDef>$maxTextLines)
			{
			$m+="...And more..\n\n";
			$y=999;
			$i=999;
			}
		}
if ($m!="")
	{
	$m+="It is reccomended that you Go to Build Pose";
	string $dialog=`confirmDialog -t "Not in Build Pose"
		-m $m
		-b "Go to Build Pose, and Proceed"
		-b "Just Proceed"
		-b "Cancel"
		-ds "Cancel" -db "Cancel"`;
	if ($dialog=="Go to Build Pose, and Proceed")
		{
		asGoToBuildPose bodySetup;
		refresh;
		}
	if ($dialog=="Go to Build Pose, and Proceed")
		$proceed=1;
	else if ($dialog=="Just Proceed")
		$proceed=2;
	else
		$proceed=0;
	}
return $proceed;
}

global proc asLockAttr (string $object, int $trans, int $rot, int $scale, int $vis)
{
setAttr -l $trans -k (!$trans) ($object+".translateX");
setAttr -l $trans -k (!$trans) ($object+".translateY");
setAttr -l $trans -k (!$trans) ($object+".translateZ");
setAttr -l $rot -k (!$rot) ($object+".rotateX");
setAttr -l $rot -k (!$rot) ($object+".rotateY");
setAttr -l $rot -k (!$rot) ($object+".rotateZ");
setAttr -l $scale -k (!$scale) ($object+".scaleX");
setAttr -l $scale -k (!$scale) ($object+".scaleY");
setAttr -l $scale -k (!$scale) ($object+".scaleZ");
setAttr -l $vis -k (!$vis) ($object+".visibility");
}

global proc int asGetCurveNumCvs (string $curve)
{
int $form,$spans,$degrees,$numCv;
$form=`getAttr ($curve+".form")`;
$spans=`getAttr ($curve+".spans")`;
$degrees=`getAttr ($curve+".degree")`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;
return $numCv;
}

global proc float asgetCharHeight ()
{
float $height;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
return $height;
}

global proc asCreateSkeleton ()
{
//asCreateFromFitGeometry Bone;
createNode -n SkeletonGeometry -p Geometry transform;
createDisplayLayer -e -name PolySkeleton;
//setAttr PolySkeleton.color 21;

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;

int $numChar,$hasBone,$b;
int $vs[];
float $dist,$dist2,$dist3;
float $pos[],$pos2[],$pos3[],$scale[];
string $tempString[],$joints[],$children[];
string $deformJointsList[]=`sets -q "DeformSet"`;
string $copyBones[]={"Pelvis","Cranium","SpineVertebras","Mandible","Femur","Tibia","Fibula",
	"Calcaneus","Talus","Metatarsals","Phalanxs","Ribs","Humerus","Scapula","Clavicle","Ulna","Radius","CarpalA","CarpalB","Eye"};
string $joint,$side,$childJoint,$parentJoint,$sourceBone;
for ($i=0;$i<size($copyBones);$i++)
	for ($a=0;$a<3;$a++)
		{
		if ($a==0) $side="_M";
		if ($a==1) $side="_L";
		if ($a==2) $side="_R";
		$b=1;
		if ($side=="_L") $b=-1;
//		$joint=$copyBones[$i]+$side;
		if ($copyBones[$i]=="Pelvis") $joint="Root"+$side;
		if ($copyBones[$i]=="SpineVertebras") $joint="Root"+$side;
		if ($copyBones[$i]=="Cranium") $joint="Head"+$side;
		if ($copyBones[$i]=="Mandible") $joint="Jaw"+$side;
		if ($copyBones[$i]=="Femur") $joint="Hip"+$side;
		if ($copyBones[$i]=="Tibia") $joint="Knee"+$side;
		if ($copyBones[$i]=="Fibula") $joint="Knee"+$side;
		if ($copyBones[$i]=="Calcaneus") $joint="Ankle"+$side;
		if ($copyBones[$i]=="Talus") $joint="Ankle"+$side;
		if ($copyBones[$i]=="Metatarsals") $joint="Toes"+$side;
		if ($copyBones[$i]=="Phalanxs") $joint="Toes"+$side;
		if ($copyBones[$i]=="Ribs") $joint="Chest"+$side;
		if ($copyBones[$i]=="Humerus") $joint="Shoulder"+$side;
		if ($copyBones[$i]=="Scapula") $joint="Shoulder"+$side;
		if ($copyBones[$i]=="Clavicle") $joint="Scapula"+$side;
		if ($copyBones[$i]=="Ulna") $joint="Elbow"+$side;
		if ($copyBones[$i]=="Radius") $joint="Elbow"+$side;
		if ($copyBones[$i]=="CarpalA") $joint="Wrist"+$side;
		if ($copyBones[$i]=="CarpalB") $joint="Wrist"+$side;
		if ($copyBones[$i]=="Eye") $joint="Eye"+$side;
		if (!`objExists $joint` || !`objExists ($copyBones[$i]+"Bone")`)
			continue;
		duplicate -n ($copyBones[$i]+"Bone"+$side) ($copyBones[$i]+"Bone");
		parent ($copyBones[$i]+"Bone"+$side) SkeletonGeometry;
		delete `parentConstraint $joint ($copyBones[$i]+"Bone"+$side) `;
		setAttr ($copyBones[$i]+"Bone"+$side+".v") 1;
//		sets -e -forceElement asBonesSG ($copyBones[$i]+"Bone"+$side);
		editDisplayLayerMembers -noRecurse PolySkeleton ($copyBones[$i]+"Bone"+$side);
		$childJoint=`asRlaChild $joint`;
		if ($copyBones[$i]=="SpineVertebras")
			{
			if (`objExists Head_M`) $childJoint="CraniumBone"+$side+"|CraniumBoneNeck";
			else if (`objExists Neck_M`) $childJoint="Neck_M";
			else if (`objExists Neck0_M`) $childJoint="Neck0_M";
			else if (`objExists Chest_M`) $childJoint="Chest_M";
			}
		if (($copyBones[$i]=="Cranium" || $copyBones[$i]=="Mandible")  && `objExists HeadEnd_M`) $childJoint="HeadEnd_M";
		if ($copyBones[$i]=="Femur"  && `objExists ("Knee"+$side)`) $childJoint="Knee"+$side;
		if (($copyBones[$i]=="Tibia" || $copyBones[$i]=="Fibula")  && `objExists ("Ankle"+$side)`) $childJoint="Ankle"+$side;
		if ($copyBones[$i]=="Humerus"  && `objExists ("Elbow"+$side)`) $childJoint="Elbow"+$side;
		if (($copyBones[$i]=="Ulna" || $copyBones[$i]=="Radius")  && `objExists ("Wrist"+$side)`) $childJoint="Wrist"+$side;
		if (($copyBones[$i]=="CarpalA"  || $copyBones[$i]=="CarpalB") && `objExists ("MiddleFinger1"+$side)`) $childJoint="MiddleFinger1"+$side;
		if ($childJoint!="")
			{
			$pos=`xform -q -ws -t $joint`;
			$pos2=`xform -q -ws -t $childJoint`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			$scale[0]=$dist;
			if (`attributeExists "fatY" $joint`)
				{
				$scale[1]=`getAttr ($joint+".fat")`*`getAttr ($joint+".fatY")`;
				$scale[2]=`getAttr ($joint+".fat")`*`getAttr ($joint+".fatZ")`;
				}
			else
				$scale[1]=$scale[2]=$scale[0];
			xform -os -a -s $scale[0] $scale[1] $scale[2] ($copyBones[$i]+"Bone"+$side);
			}
		if ($side=="_L")
			{
			$pos=`xform -q -ws -t $joint`;
			scale -r -p $pos[0] $pos[1] $pos[2] -1 -1 -1 ($copyBones[$i]+"Bone"+$side);
			}
/*
		//some bones not to un-twist
		if (`gmatch $joint "*Shoulder*"` || `gmatch $joint "*Hip*"`)
			if (`objExists ("TwistBalancer"+$joint)`)
				connectAttr -f ("TwistBalancer"+$joint+".rotateX") ($copyBones[$i]+"BoneParentConstraint"+$side+"_parentConstraint1.target[0].targetOffsetRotateX");
*/

		//Spine / neck
		if ($copyBones[$i]=="SpineVertebras")
			{
			if (`objExists Root_M` && `objExists $childJoint`)
				delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject Root_M $childJoint SpineVertebrasBone_M`;
			$scale[0]=`getAttr SpineVertebrasBone_M.sx`;
			setAttr -type float3 SpineVertebrasBone_M.s $scale[0] $scale[0] $scale[0];
			//Coccyx
			select ("SpineVertebrasBone"+$side+"Shape");
			$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
			rename $tempString[0] FixSoftMod;
			rename $tempString[1] FixSoftModHandle;
			$pos=`xform -q -ws -t ("SpineVertebrasBone"+$side+"|SpineVertebrasCoccyx")`;
			$pos2=`xform -q -ws -t ("Root"+$side)`;
			$pos3=`xform -q -ws -t PelvisBone_M|PelvisBoneFemur`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			setAttr -type float3 FixSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
			setAttr FixSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
			xform -piv $pos2[0] $pos2[1] $pos2[2] FixSoftModHandle;
			setAttr FixSoftMod.falloffRadius $dist;
			setAttr FixSoftMod.falloffMode 0;
			$scale[0]=`mag<<$pos2[0]-$pos3[0],$pos2[1]-$pos3[1],$pos2[2]-$pos3[2]>>`/$dist;
			setAttr -type float3 FixSoftModHandle.s $scale[0] $scale[0] $scale[0];
			select ("SpineVertebrasBone"+$side+"Shape");
			DeleteHistory;
			//Run-through Chest joint
			if (`objExists Root_M` && `objExists Chest_M`)
				{
				select ("SpineVertebrasBone"+$side+"Shape");
				$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
				rename $tempString[0] FixSoftMod;
				rename $tempString[1] FixSoftModHandle;
				$pos=`xform -q -ws -t Root_M`;
				$pos2=`xform -q -ws -t Chest_M`;
				$pos3=`xform -q -ws -t Head_M`;
				$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
				$dist2=`mag<<$pos3[0]-$pos[0],$pos3[1]-$pos[1],$pos3[2]-$pos[2]>>`;
				$dist3=`mag<<$pos3[0]-$pos[0],$pos3[1]-$pos[1],$pos3[2]-$pos[2]>>`;
				if (`objExists tempLoc`) delete tempLoc;
				spaceLocator -n tempLoc;
				createNode -n tempMotionPath motionPath;
				setAttr tempMotionPath.fractionMode 1;
				connectAttr SpineVertebrasBone_M|SpineVertebrasCurve.worldSpace tempMotionPath.geometryPath;
				connectAttr tempMotionPath.allCoordinates tempLoc.t;
				setAttr tempMotionPath.uValue ($dist/$dist2);
				$pos=`xform -q -ws -t tempLoc`;
				delete tempLoc tempMotionPath;
				setAttr -type float3 FixSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
				setAttr FixSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
				xform -piv $pos[0] $pos[1] $pos[2] FixSoftModHandle;
				setAttr FixSoftMod.falloffRadius ($dist3/2.0);
				setAttr FixSoftMod.falloffMode 0;
				delete `pointConstraint Chest_M FixSoftModHandle`;
				select ("SpineVertebrasBone"+$side+"Shape");
				DeleteHistory;
				}
			}

		//Scapula
		if ($copyBones[$i]=="Scapula" && `objExists ("HumerusBone"+$side)` && `objExists RibsBone_M`)
			{
			$dist=`getAttr ("HumerusBone"+$side+".sx")`;
			setAttr -type float3 ("ScapulaBone"+$side+".s") $dist $dist $dist;

			duplicate -n ("ScapulaBone"+$side+"_Copy") ("ScapulaBone"+$side);
			parent -w ("ScapulaBone"+$side+"_Copy");
			catchQuiet (`makeIdentity -a 1 -t 1 -r 1 -s 1 ("ScapulaBone"+$side+"_Copy")`);
			select ("ScapulaBone"+$side+"_CopyShape");
			$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
			rename $tempString[0] FixSoftMod;
			rename $tempString[1] FixSoftModHandle;
			$pos=`xform -q -ws -t ("ScapulaBone"+$side+"|ScapulaBoneLoc1")`;
			$pos2=`xform -q -ws -t ("ScapulaBone"+$side+"|ScapulaBoneLoc2")`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			setAttr -type float3 FixSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
			setAttr FixSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
			xform -piv $pos[0] $pos[1] $pos[2] FixSoftModHandle;
			setAttr FixSoftMod.falloffRadius $dist;
			setAttr FixSoftMod.falloffMode 0;
			setAttr FixSoftMod.falloffInY 0;
			$pos3=`xform -q -ws -t ("RibsBone_M|RibsBoneLoc1")`;
			move -r 0 0 (($pos3[2]-$pos[2])*1.2) FixSoftModHandle;
			select ("ScapulaBone"+$side+"_CopyShape") ("ScapulaBone"+$side+"Shape");
			blendShape -n TempBS -w 0 1;
			setAttr TempBS.origin 0;
			select ("ScapulaBone"+$side);
			DeleteHistory;
			delete ("ScapulaBone"+$side+"_Copy");
			}
		//Clavicle
		if ($copyBones[$i]=="Clavicle" && `objExists ("ScapulaBone"+$side)` && `objExists RibsBone_M`)
			{
			$pos=`xform -q -ws -t ("RibsBone_M|RibsBoneClavicle")`;
			xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ("ClavicleBone"+$side);
			$pos2=`xform -q -ws -t ("ScapulaBone"+$side+"|ScapulaBoneClavicle")`;
			$pos2[0]=$pos2[0]*$b;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			$scale[0]=$dist*$b;
			xform -os -a -s $scale[0] $scale[0] $scale[0] ($copyBones[$i]+"Bone"+$side);
			delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector ($b) 0 0 -upVector 0 $b 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject Chest_M ("ScapulaBone"+$side+"|ScapulaBoneClavicle") ($copyBones[$i]+"Bone"+$side)`;
			}

		//PelvisBone
		if ($copyBones[$i]=="Pelvis")
			{
			xform -ws -ro 0 0 0 PelvisBone_M;
			$tempString=`listRelatives -type joint -c Root_M`;
			for ($y=0;$y<size($tempString);$y++)
				if (`gmatch $tempString[$y] "*_R"`)
					{
					$pos=`xform -q -ws -t $tempString[$y]`;
					xform -ws -t 0 $pos[1] $pos[2] PelvisBone_M;
					$pos2=`xform -q -ws -t PelvisBone_M|PelvisBoneFemur`;
					xform -r -s ($pos[0]/$pos2[0]) ($pos[0]/$pos2[0]) ($pos[0]/$pos2[0]) PelvisBone_M;
					$scale[0]=`getAttr PelvisBone_M.sx`;
					setAttr -type float3 PelvisBone_M.s $scale[0] $scale[0] $scale[0];
					}
			}

		//Cranium
		if ($copyBones[$i]=="Cranium" && `objExists Eye_R`)
			{
			$pos=`xform -q -ws -t Eye_R`;
			$pos2=`xform -q -ws -t ("CraniumBone"+$side+"|CraniumBoneEye")`;
			scale -r ($pos[0]/$pos2[0]) ($pos[0]/$pos2[0]) ($pos[0]/$pos2[0]) CraniumBone_M;
			$scale[0]=`getAttr CraniumBone_M.sz`;
			setAttr -type float3 CraniumBone_M.s $scale[0] $scale[0] $scale[0];
			$pos2=`xform -q -ws -t ("CraniumBone"+$side+"|CraniumBoneEye")`;
			move -r 0 ($pos[1]-$pos2[1]) 0 CraniumBone_M;
			}

		//Mandible
		if ($copyBones[$i]=="Mandible" && `objExists CraniumBone_M`)
			{
			asAlign MandibleBone_M CraniumBone_M 1 1 0 0;
			$scale=`getAttr CraniumBone_M.s`;
			setAttr -type float3 MandibleBone_M.s $scale[0] $scale[0] $scale[0];
			}

		//Ankle
		if ($copyBones[$i]=="Calcaneus" && `objExists Toes` && `objExists Ankle` && `objExists Heel`)
			{
			$pos=`xform -q -ws -t ("Ankle"+$side)`;
			$pos2=`xform -q -ws -t ("CalcaneusBone"+$side+"|CalcaneusBoneLoc1")`;
			$dist=($pos[1]/($pos[1]-$pos2[1]))*0.95;
			scale -r $dist 1 $dist ("CalcaneusBone"+$side);
			$pos2=`xform -q -ws -t ("CalcaneusBone"+$side+"|CalcaneusBoneLoc2")`;
			$pos3=`xform -q -ws -t Heel`;
			$dist=(($pos[2]-$pos3[2])/($pos[2]-$pos2[2]))*0.9;
			scale -r 1 $dist 1 ("CalcaneusBone"+$side);
			setAttr ("CalcaneusBone"+$side+".sz") `getAttr ("CalcaneusBone"+$side+".sy")`;
			}
		if ($copyBones[$i]=="Talus")
			{
			$scale[0]=`getAttr ("CalcaneusBone"+$side+".sy")`;
			setAttr -type float3 ("TalusBone"+$side+".s") $scale[0] $scale[0] $scale[0];
			}

	//Metatarsals
	if (($copyBones[$i]=="Metatarsals" || $copyBones[$i]=="Phalanxs") && `objExists Toes` && `objExists Ankle`)
		{
		$scale[0]=`getAttr ("TalusBone"+$side+".sx")`;
//		$scale[0]=(`getAttr ("Ankle"+$side+".fat")`*`getAttr ("Ankle"+$side+".fatZ")`)/1.5*$b;
		setAttr ($copyBones[$i]+"Bone"+$side+".sy") $scale[0];
		setAttr ($copyBones[$i]+"Bone"+$side+".sz") $scale[0];
		}
	if ($copyBones[$i]=="Metatarsals" && `objExists Toes` && `objExists Ankle`)
		{
		select ("MetatarsalsBone"+$side+"Shape");
		$tempString=`lattice  -divisions 2 2 2 -objectCentered true  -ldv 2 2 2`;
//		setAttr ($tempString[0]+".outsideLattice") 1;
		parent $tempString[1] $tempString[2] ("MetatarsalsBone"+$side+"|MetatarsalsBoneLattice");
		xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $tempString[1] $tempString[2];
		$pos=`xform -q -ws -t ("MetatarsalsBone"+$side+"|MetatarsalsBoneToes")`;
		$pos2=`xform -q -ws -t ("TalusBone"+$side+"|TalusBoneToes")`;

		select -r ($tempString[1]+".pt[0][0:1][0]") ($tempString[1]+".pt[0][0:1][1]");
		move -r ($pos2[0]-$pos[0]) ($pos2[1]-$pos[1]) ($pos2[2]-$pos[2]);
		select ("MetatarsalsBone"+$side);
		DeleteHistory;
		}


		//Bind: Bind-to Bones - selection
		select ($copyBones[$i]+"Bone"+$side) $joint;
		$childJoint=`asRlaChild $joint`;
		while (`gmatch $childJoint "*Part[0-9]*"`)
			{
			select -add $childJoint;
			$tempString=`listRelatives -c -type joint $childJoint`;
			$childJoint=$tempString[0];
			}

		//Bind: Bind-to Bones - tweaks
		if ($copyBones[$i]=="SpineVertebras" && `objExists Chest_M`)
			{
			select Chest_M;
			if (`objExists Head_M`)
				select `listRelatives -p Head_M`;
			for ($y=0;$y<99;$y++)
				{
				$tempString=`listRelatives -p`;
				select -add $tempString;
				if (`stringArrayCount "Root_M" $tempString`)
				 break;
				}
			}
		if ($copyBones[$i]=="Metatarsals" || $copyBones[$i]=="Scapula") {select -r `listRelatives -p $joint`;select -d $joint;}

		//Bind
		select -add ($copyBones[$i]+"Bone"+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($copyBones[$i]+"BoneSC"+$side);

		//Bind: tweak - Carpal (wrist)
		if ($copyBones[$i]=="CarpalA")
			{
			skinCluster -e  -dr 4 -ai `listRelatives -p ("Wrist"+$side)` ("CarpalABoneSC"+$side);
			select -r ("CarpalABone"+$side);
			skinPercent -tv ("Wrist"+$side) 0.5 ("CarpalABoneSC"+$side);
			}
		//Bind: tweak - Jaw_M (with FaceSetup)
		if ($copyBones[$i]=="Mandible")
			{
			$tempString=`listRelatives -p $joint`;
			if ($tempString[0]=="Face_M")
				{
				select ($copyBones[$i]+"Bone"+$side);
				$tempString=`cluster -n ($copyBones[$i]+"BoneCluster"+$side) -envelope 1`;
				parent ($copyBones[$i]+"BoneCluster"+$side+"Handle") ($copyBones[$i]+"Bone"+$side);
				setAttr ($copyBones[$i]+"BoneCluster"+$side+"Handle.v") 0;
				parentConstraint -mo Head_M ($copyBones[$i]+"BoneCluster"+$side+"Handle");
				scaleConstraint Head_M ($copyBones[$i]+"BoneCluster"+$side+"Handle");
				}
			}
		}

//Fingers (Phalanges & Metacarpal)
$sourceBone="PhalangesBone";
for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (!`gmatch $deformJointsList[$i] "*Finger*"`)
		continue;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if ($childJoint=="")
		continue;

	$numChar=size($deformJointsList[$i]);
	string $newBone=`substring $deformJointsList[$i] 1 ($numChar-2)`+"Bone";
	$side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	duplicate -n ($newBone+$side) $sourceBone;
	parent ($newBone+$side) SkeletonGeometry;
	delete `parentConstraint $deformJointsList[$i] ($newBone+$side) `;
	setAttr ($newBone+$side+".v") 1;
	editDisplayLayerMembers -noRecurse PolySkeleton ($newBone+$side);
	$pos=`xform -q -ws -t $deformJointsList[$i]`;
	$pos2=`xform -q -ws -t $childJoint`;
	$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	$scale[0]=$dist;
	$scale[1]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatY")`;
	$scale[2]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatZ")`;
	xform -os -a -s $scale[0] $scale[1] $scale[2] ($newBone+$side);
	if (`gmatch $deformJointsList[$i] "*_L"`)
		{
		$pos=`xform -q -ws -t $deformJointsList[$i]`;
		scale -r -p $pos[0] $pos[1] $pos[2] -1 -1 -1 ($newBone+$side+".vtx[0:9999]");
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($newBone+$side);
		}
	select $deformJointsList[$i] ($newBone+$side);
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] ($newBone+"BoneSC"+$side);
	}

//MetaCarpals
$sourceBone="MetacarpalBone";
for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (!`gmatch $deformJointsList[$i] "*Finger1*"`)
		continue;
	if (`gmatch $deformJointsList[$i] "*ThumbFinger1*"`)
		continue;
	$tempString=`listRelatives -p $deformJointsList[$i]`;
	$parentJoint=$tempString[0];

	$numChar=size($deformJointsList[$i]);
	string $jointName=`substring $deformJointsList[$i] 1 ($numChar-2)`;
	string $newBone=$jointName+"MetacarpalBone";
	$side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	string $loc="CarpalBBone"+$side+"|CarpalBone"+$jointName;
	duplicate -n ($newBone+$side) $sourceBone;
	parent ($newBone+$side) SkeletonGeometry;
	delete `parentConstraint $parentJoint ($newBone+$side) `;
	setAttr ($newBone+$side+".v") 1;
	editDisplayLayerMembers -noRecurse PolySkeleton ($newBone+$side);
	delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $parentJoint $deformJointsList[$i] ($newBone+$side)`;

	$pos=`xform -q -ws -t $deformJointsList[$i]`;
	$pos2=`xform -q -ws -t $parentJoint`;
	$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	if (`objExists $loc`)
		{// allow space for CarpalBone
		$pos3=`xform -q -ws -t $loc`;
		$dist=`mag<<$pos3[0]-$pos[0],$pos3[1]-$pos[1],$pos3[2]-$pos[2]>>`;
		}
	$scale[0]=$dist;
	$scale[1]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatY")`;
	$scale[2]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatZ")`;
	xform -os -a -s $scale[0] $scale[1] $scale[2] ($newBone+$side);
	if (`objExists $loc`)
		{
		move -r -os -wd `mag<<$pos2[0]-$pos3[0],$pos2[1]-$pos3[1],$pos2[2]-$pos3[2]>>` 0 0 ($newBone+$side+".vtx[0:9999]");
		}
	select $parentJoint ($newBone+$side);
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] ($newBone+"BoneSC"+$side);
	}

//Generic
$sourceBone="GenericBone";
for ($i=0;$i<size($deformJointsList);$i++)
	{
	$hasBone=0;
	$tempString=`listConnections -s 0 -d 1 ($deformJointsList[$i]+".worldMatrix")`;
	for ($y=0;$y<size($tempString);$y++)
		if (`gmatch $tempString[$y] "*BoneSC_*"`)
			$hasBone=1;
	if ($hasBone)
		continue;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if ($childJoint=="")
		continue;

	$numChar=size($deformJointsList[$i]);
	string $newBone=`substring $deformJointsList[$i] 1 ($numChar-2)`+"Bone";
	$side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	duplicate -n ($newBone+$side) $sourceBone;
	parent ($newBone+$side) SkeletonGeometry;
	delete `parentConstraint $deformJointsList[$i] ($newBone+$side) `;
	setAttr ($newBone+$side+".v") 1;
	editDisplayLayerMembers -noRecurse PolySkeleton ($newBone+$side);
	$pos=`xform -q -ws -t $deformJointsList[$i]`;
	$pos2=`xform -q -ws -t $childJoint`;
	$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	$scale[0]=$dist;
	$scale[1]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatY")`;
	$scale[2]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatZ")`;
	xform -os -a -s $scale[0] $scale[1] $scale[2] ($newBone+$side);
	if (`gmatch $deformJointsList[$i] "*_L"`)
		{
		$pos=`xform -q -ws -t $deformJointsList[$i]`;
		scale -r -p $pos[0] $pos[1] $pos[2] -1 -1 -1 ($newBone+$side+".vtx[0:9999]");
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($newBone+$side);
		}
	select $deformJointsList[$i] ($newBone+$side);
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] ($newBone+"BoneSC"+$side);
	}

$tempString=`listRelatives -f -ad -type locator -type nurbsCurve SkeletonGeometry`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		delete `listRelatives -f -p $tempString[$i]`;

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;

//asMirrorGeometry Skeleton 0;

print ("// Skeleton created\n");
select -cl;
}

global proc asDeleteSkeleton ()
{
string $deleteObjs[]={"SkeletonGeometry","PolySkeleton","Skeleton_Geometry","Mannequin_Geometry","SkinCage_Geometry","Skeleton","tempAimAt"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreateFromFitGeometry (string $geo)
{
//$geo=Box, Cyl, Bone
if (!`asConfirmIfNotInBuildPose`)
	return;
string $geoLongName="Boxes";
if ($geo=="Cyl")
	$geoLongName="Cylinders";
if ($geo=="Bone")
	$geoLongName="Skeleton";
string $sourceGeo=$geo;
if (`getModifiers`==4)
	$sourceGeo="Cyl";
if (`objExists ($geoLongName+"Geometry")`)
	error ("\""+$geoLongName+"Geometry\" Alread exists");
if (`objExists ("Poly"+$geoLongName)`)
	error ("\"Poly"+$geoLongName+"\" Alread exists");
createNode -n ($geoLongName+"Geometry") -p Geometry transform;
createDisplayLayer -e -name ("Poly"+$geoLongName);
setAttr ("Poly"+$geoLongName+".color") 14;
if ($geo=="Bone")
	setAttr ("Poly"+$geoLongName+".color") 21;

float $scale=`asGetScale`;
float $sideTreshold=0.0001*$scale;
float $visGap=`getAttr FitSkeleton.visGap`;
float $pos[],$rot[];
if (`objExists asMirror`)
	delete asMirror;
//checkBox -e -v 1 asVisGeo;
int $visGeo=`getAttr FitSkeleton.visGeo`;
setAttr FitSkeleton.visGeo 1;
asFitGeometry;
setAttr FitSkeleton.visGeo $visGeo;

setAttr FitSkeleton.visGap 1;
	dgdirty -a;
refresh;
setAttr FitSkeletonVisualizers.v 0;
refresh;

string $joint;
string $aimsAD[]=`listRelatives -ad -type transform Aims`;
for ($i=$y=0;$i<size($aimsAD);$i++)
	if (`gmatch $aimsAD[$i] ("*"+$sourceGeo+"*")`)
		{
		$joint=`substitute $sourceGeo $aimsAD[$i] ""`;
		string $side="_M";
		$pos=`xform -q -ws -t $aimsAD[$i]`;

		if ($pos[0]<$sideTreshold*-1)
			$side="_R";
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==-1 && $side=="_M") continue;
			if ($b==-1 && $side=="_R") $side="_L";

			if (!`objExists ($joint+$side)`)//could be `noMirror`
				continue;

			duplicate -n ($aimsAD[$i]+$side) $aimsAD[$i];
			editDisplayLayerMembers -noRecurse ("Poly"+$geoLongName) ($aimsAD[$i]+$side);
			setAttr ($aimsAD[$i]+$side+".v") 1;
			createNode -n asMirror transform;
			parent ($aimsAD[$i]+$side) asMirror;
			if ($side=="_L")
				{
				setAttr asMirror.sx -1;
				polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($aimsAD[$i]+$side);
//				setAttr ($aimsAD[$i]+$side+".sz") (`getAttr ($aimsAD[$i]+$side+".sz")`*-1);
				}
			parent -w ($aimsAD[$i]+$side);
			delete asMirror;
			createNode -n ($aimsAD[$i]+"ParentConstraint"+$side) -p ($geoLongName+"Geometry") transform;
			asAlign ($aimsAD[$i]+"ParentConstraint"+$side) ($aimsAD[$i]+$side) 1 1 0 0;
			parent ($aimsAD[$i]+$side) ($aimsAD[$i]+"ParentConstraint"+$side);

			if (`objExists ($joint+"Part1_M")` && $geo=="Bone" && `objExists ($joint+"Bone_M")`) //Bind Spine and Neck Geo
				{
				select ($joint+"_M");
				for ($z=1;$z<99;$z++)
					if (`objExists ($joint+"Part"+$z+"_M")`) select -add ($joint+"Part"+$z+"_M");
					else break;
				select -add ($joint+"Bone_M");
				newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
				}
			else
				{
				parentConstraint -mo ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
				scaleConstraint  -mo ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
				}
			setAttr ($aimsAD[$i]+$side+"Shape.overrideEnabled") 0;
			asLockAttr ($aimsAD[$i]+$side) 1 1 0 0;
//			if ($geo=="Box")
//				asMirrorGeometry Boxes 0; // slower, but looks better
//			refresh;
			}
		}
setAttr FitSkeleton.visGap $visGap;
delete FitSkeletonVisualizers;
}

global proc asCreateMuscular ()
{
int $form,$spans,$degrees,$numCv,$numChar,$skinningMethod;
string $tempString[],$tempString2[],$muscles[],$curves[],$mirrorCurves[],$transforms[],$newTransforms[];
string $skinCluster,$attach,$newTransform,$mirrorMuscle,$nurbs,$mirrorNurbs,$loft,$mirrorLoft,$sc;
string $cmd;
float $values[],$pos[];

if (!`objExists SkeletonGeometry`)
	error "Create Skeleton Geometry first";
asFitModeEnsureShaders;
if (`objExists MuscularGeometry`)
	delete MuscularGeometry;

string $asMuscularFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asMuscular.ma";
file -i $asMuscularFile;
parent MuscularGeometry Geometry;
$muscles=`listRelatives -c Muscular_Muscles`;


//Attach curves to bones by wrap
for ($i=0;$i<size($muscles);$i++)
	{
	$curves=`listRelatives -c $muscles[$i]`;
	for ($y=0;$y<size($curves);$y++)
		{
		$attach=`getAttr ($curves[$y]+".attach")`;
		select $curves[$y] ("Muscular_"+$attach);
		$tempString=`doWrapArgList "7" { "1","0","1", "2", "0", "1", "1", "0" }`;
		//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
		rename $tempString[0] ($curves[$y]+"TempWrap");	
		}
	}

//match bones by worldspace BS
$tempString=`listRelatives -c Muscular_SkeletonGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -ni -s $tempString[$i]`;
	if (`objectType $tempString2[0]`!="mesh")
		continue;
	$muscularBone=$tempString[$i];
	$bone=`substitute "Muscular_" $muscularBone ""`;
	if (!`objExists $bone`)
		continue;
	select $bone $muscularBone;
	select `listRelatives -ni -s`;
	blendShape -n ($muscularBone+"BS") -w 0 1;
	setAttr ($muscularBone+"BS.origin") 0;
	}

//Special case, Muscular_ExternalOblique_R
for ($i=1;$i<5;$i++)
	{
	select -r ("Muscular_ExternalObliqueALT1_curve"+$i+"_R") ("Muscular_ExternalOblique_curve"+$i+"_R");
	blendShape -n ("Muscular_ExternalOblique_curve"+$i+"_RTempBS") -w 0 1;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[7]") 0;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[6]") 0.2;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[8]") 0.2;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[5]") 0.4;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[9]") 0.4;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[4]") 0.6;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[10]") 0.6;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[3]") 0.8;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[11]") 0.8;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[2]") 1;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[0]") 1;
	}

//Delete-Wrap-History, but retain `shape`
for ($i=0;$i<size($muscles);$i++)
	{
	$curves=`listRelatives -c $muscles[$i]`;
	for ($y=0;$y<size($curves);$y++)
		{
		$numCv=`asGetCurveNumCvs $curves[$y]`;
		$cmd="";
		for ($cv=0;$cv<$numCv;$cv++)
			{
			$pos=`xform -q -ws -t ($curves[$y]+".cv["+$cv+"]")`;
			$cmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$curves[$y]+".cv["+$cv+"];";
			}
		delete ($curves[$y]+"TempWrap");
		if (`gmatch $curves[$y] ("*ALT*")`)
			continue;
		if (`gmatch $curves[$y] ("Muscular_ExternalOblique_curve[0-9]_R")` && `objExists ($curves[$y]+"TempBS")`)
			delete ($curves[$y]+"TempBS");
		eval ($cmd);
		}
	}
delete Muscular_SkeletonGeometry;
for ($i=0;$i<size($muscles);$i++)
	if (`gmatch $muscles[$i] "*ALT*"`)
		{
		delete $muscles[$i];
		$muscles=`stringArrayRemove {$muscles[$i]} $muscles`;
		}

for ($i=0;$i<size($muscles);$i++)
	{
	$curves=`listRelatives -c $muscles[$i]`;
	for ($y=0;$y<size($curves);$y++)
		{
		$tempString=`listRelatives -s $curves[$y]`;
		$curveShape=$tempString[0];
		$tempString=`listConnections ($curveShape+".create")`;
		$skinCluster=$tempString[0];
		if ($skinCluster=="")
			continue;
		$skinningMethod=`getAttr ($skinCluster+".skinningMethod")`;
		$numCv=`asGetCurveNumCvs $curves[$y]`;
		$transforms=`skinPercent -ib 0 -q -t $skinCluster ($curves[$y]+".cv[0:99]")`;
		clear $newTransforms;
		$cmd="";
		for ($z=0;$z<size($transforms);$z++)
			{
			$newTransform=`substitute "Muscular_" $transforms[$z] ""`;
			if (!`objExists $newTransform`)//pickWalk -d up, until we find a match
				{
				select $transforms[$z];
				while (!`objExists $newTransform`)
					{
					pickWalk -d up;
					$tempString=`ls -sl`;
					$newTransform=`substitute "Muscular_" $tempString[0] ""`;
					}
				}
			$newTransforms[size($newTransforms)]=$newTransform;
			for ($cv=0;$cv<$numCv;$cv++)
				{
				$values=`skinPercent -ib 0 -q -v $skinCluster ($curves[$y]+".cv["+$cv+"]")`;
				$cmd+="skinPercent -tv "+$newTransform+" "+$values[$z]+" "+$curves[$y]+"SC "+$curves[$y]+".cv["+$cv+"];\n";
				}
			}
		delete $skinCluster;
		select $curves[$y];
		select -add $newTransforms;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($curves[$y]+"SC");
		setAttr ($curves[$y]+"SC.skinningMethod") $skinningMethod;
		eval $cmd;
		}

	//Mirror
	$numChar=size($muscles[$i]);
	$mirrorMuscle=`substring $muscles[$i] 1 ($numChar-2)`+"_L";
	$nurbs=`substring $muscles[$i] 1 ($numChar-2)`+"_loft_R";
	$mirrorNurbs=`substring $muscles[$i] 1 ($numChar-2)`+"_loft_L";
	if (!`objExists $nurbs`)
		continue;

	duplicate -n $mirrorMuscle $muscles[$i];
	setAttr ($mirrorMuscle+".sx") -1;
	$curves=`listRelatives -c $mirrorMuscle`;
	$tempString=`listRelatives -f -c $mirrorMuscle`;
	for ($y=0;$y<size($curves);$y++)
		{
		$numChar=size($curves[$y]);
		$mirrorCurves[$y]=`substring $curves[$y] 1 ($numChar-2)`+"_L";
		rename $tempString[$y] $mirrorCurves[$y];
		asLockAttr $mirrorCurves[$y] 0 0 0 0;
		}
	makeIdentity -a 1 -t 1 -r 1 -s 1 $mirrorMuscle;
	for ($y=0;$y<size($curves);$y++)
		{
		$tempString=`listConnections ($curves[$y]+".create")`;
		$sc=$tempString[0];
		$tempString=`listConnections -s 1 -d 0 ($sc+".matrix")`;
		select -cl;
		for ($z=0;$z<size($tempString);$z++)
			{
			$numChar=size($tempString[$z]);
			if (`gmatch $tempString[$z] "*_R"`)
				select -add (`substring $tempString[$z] 1 ($numChar-2)`+"_L");
			else
				select -add $tempString[$z];
			}
		select -add $mirrorCurves[$y];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($mirrorCurves[$y]+"SC");
		select $curves[$y] $mirrorCurves[$y];
		copySkinWeights -ss $sc -ds ($mirrorCurves[$y]+"SC") -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		}

	duplicate -n $mirrorNurbs $nurbs;
	$tempString=`listConnections ($nurbs+".create")`;
	$loft=$tempString[0];
	$tempString=`duplicate $loft`;
	$mirrorLoft=$tempString[0];
	connectAttr ($mirrorLoft+".outputSurface") ($mirrorNurbs+".create");
	$tempString=`listConnections ($loft+".inputCurve")`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$numChar=size($tempString[$y]);
		connectAttr (`substring $curves[$y] 1 ($numChar-2)`+"_L.worldSpace[0]") ($mirrorLoft+".inputCurve["+$y+"]");
		}
	}
delete Muscular_Root_M;
select -cl;
print ("// Muscles created\n");
}

global proc asDeleteMuscular ()
{
string $deleteObjs[]={"MuscularGeometry","Muscular_SkeletonGeometry","Muscular_Root_M"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreatePolyBoxes ()
{
asCreateFromFitGeometry Box;
float $fitSkeletonScale=`getAttr FitSkeleton.sx`;
float $mag;
float $scale[3],$posA[3],$posB[3];
string $toes,$heel,$childLabel;
string $tempString[];
string $deformJointsList[]=`sets -q "DeformSet"`;
for ($i=0;$i<size($deformJointsList);$i++)
	{
	int $numChar=size($deformJointsList[$i]);
	string $joint=`substring $deformJointsList[$i] 1 ($numChar-2)`;
	string $side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	$tempString=`listRelatives -c -type joint $deformJointsList[$i]`;
	if ($tempString[0]=="")
		continue;
	if (`objExists ($joint+"Box"+$side)`)
		continue;
	if (`gmatch $deformJointsList[$i] "*Eye*"`)
		continue;
	createNode -n ($joint+"BoxParentConstraint"+$side) -p BoxesGeometry transform;
	duplicate -n ($joint+"Box"+$side) RootBox_M;
	parent ($joint+"Box"+$side) ($joint+"BoxParentConstraint"+$side);
	setAttr -type float3 ($joint+"Box"+$side+".s") 1 1 1;
	xform -ws -t 0 0.875 -0.875 ($joint+"Box"+$side+".vtx[0]");
	xform -ws -t 0 0.875 0.875 ($joint+"Box"+$side+".vtx[1]");
	xform -ws -t 1 0.875 -0.875 ($joint+"Box"+$side+".vtx[2]");
	xform -ws -t 1 0.875 0.875 ($joint+"Box"+$side+".vtx[3]");
	xform -ws -t 1 -0.875 -0.875 ($joint+"Box"+$side+".vtx[4]");
	xform -ws -t 1 -0.875 0.875($joint+"Box"+$side+".vtx[5]");
	xform -ws -t 0 -0.875 -0.875 ($joint+"Box"+$side+".vtx[6]");
	xform -ws -t 0 -0.875 0.875 ($joint+"Box"+$side+".vtx[7]");
	parentConstraint ($joint+$side) ($joint+"BoxParentConstraint"+$side);
	scaleConstraint ($joint+$side) ($joint+"BoxParentConstraint"+$side);
	$scale={0.1,1,1};
	$scale[1]=`getAttr ($joint+$side+".fat")`*`getAttr ($joint+$side+".fatY")`*$fitSkeletonScale;
	$scale[2]=`getAttr ($joint+$side+".fat")`*`getAttr ($joint+$side+".fatZ")`*$fitSkeletonScale;
	$tempString=`listRelatives -c -type joint $deformJointsList[$i]`;
	$mag=0;
	for ($y=0;$y<size($tempString);$y++)
		{
		$posA=`xform -q -ws -t $deformJointsList[$i]`;
		$posB=`xform -q -ws -t $tempString[$y]`;
		$mag=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		if ($mag>$scale[0]) {
		$scale[0]=$mag;}
		}
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		{
		$tempString=`listRelatives -c -type joint $joint`;
		for ($y=0;$y<size($tempString);$y++)
			{
			$childLabel=`asLabel $tempString[$y]`;
			if (`gmatch $childLabel "*Ball*"`)
				$toes=$tempString[$y];
			if (`gmatch $childLabel "*Heel*"`)
				$heel=$tempString[$y];
			}
		}
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		{
		$posA=`xform -q -ws -t $deformJointsList[$i]`;
		$scale[0]=$posA[1];
		}
	setAttr -type float3 ($joint+"Box"+$side+".s") $scale[0] $scale[1] $scale[2];
	if (`gmatch $deformJointsList[$i] "*Ankle*"` && `objExists $toes` && `objExists ($toes+"Box"+$side)` && `objExists $heel`)
		{
		polySubdivideFacet -dv 1 -m 0 -ch 0 ($joint+"Box"+$side);
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[0]")`;
		xform -ws -t $posA[0] $posA[1] $posA[2] ($joint+"Box"+$side+".vtx[12]");
		$posB=`xform -q -ws -t ($toes+"Box"+$side+".vtx[1]")`;
		xform -ws -t $posB[0] $posB[1] $posB[2] ($joint+"Box"+$side+".vtx[10]");
		xform -ws -t (($posA[0]+$posB[0])/2.0) (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) ($joint+"Box"+$side+".vtx[8]");

		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[6]")`;
		xform -ws -t $posA[0] 0 $posA[2] ($joint+"Box"+$side+".vtx[2]");
		$posB=`xform -q -ws -t ($toes+"Box"+$side+".vtx[7]")`;
		xform -ws -t $posB[0] 0 $posB[2] ($joint+"Box"+$side+".vtx[3]");
		xform -ws -t (($posA[0]+$posB[0])/2.0) 0 (($posA[2]+$posB[2])/2.0) ($joint+"Box"+$side+".vtx[11]");

		$posA=`xform -q -ws -t $heel`;
		$posB=`xform -q -ws -t ($joint+"Box"+$side+".vtx[15]")`;
		$mag=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		move -r -os -wd 0 ($mag*-1) 0 ($joint+"Box"+$side+".vtx[4:5]") ($joint+"Box"+$side+".vtx[15]");

		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[7]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[7]");
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[6]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[6]");
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[5]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[5]");
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[4]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[4]");
		}
	}

asMirrorGeometry Boxes 0;
print "// PolyBoxes created\n";
select -cl;
}

global proc asDeletePolyBoxes ()
{
if (`objExists "BoxesGeometry"`)
	delete "BoxesGeometry";
if (`objExists "PolyBoxes"`)
	delete "PolyBoxes";
}

global proc asCreateBoolean ()
{
global string $gMainProgressBar;
int $vs[];
string $tempString[],$tempString2[],$boxes[];
string $dupObj,$dupBox,$joint,$puppet,$restoreVisCmd;

if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	refresh;
	}
string $dialog=`confirmDialog -t "Boolean"
	-m "Attempt to Boolean selected geometry with PolyBoxes?"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`objExists "BoxesGeometry"`)
	error "No BoxesGeometry in scene !";
$tempString=`listRelatives -ad -type transform BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -s -ni $tempString[$i]`;
	if ($tempString2[0]!="")
		$boxes[size($boxes)]=$tempString[$i];
	}


string $objs[]=`ls -sl`;
if (size($objs)<1)
	error "No Objects Selected !";

if (!`objExists Bool`)
	{
	createDisplayLayer -e -name Bool;
	setAttr Bool.color 21;
	setAttr Bool.displayType 2;
	}
dgdirty -a;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Creating Booleans" -bp -ii 1 -min 0 -max (size($objs)) $gMainProgressBar;
for ($i=0;$i<size($objs);$i++)
	{
	$restoreVisCmd+="setAttr "+$objs[$i]+".v "+`getAttr ($objs[$i]+".v")`+";";
	setAttr ($objs[$i]+".v") 0;
	}
if (`objExists PolyBoxes`)
	{
	$restoreVisCmd+="setAttr PolyBoxes.v "+`getAttr PolyBoxes.v`+";";
	setAttr PolyBoxes.v 0;
	}
for ($i=0;$i<size($objs);$i++)
	{
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
		$joint=`substitute "Box" $boxes[$y] ""`;
		if (`objExists ($tempString[0]+"Bool"+"_"+$tempString[1])`)
			warning ("Object \""+$tempString[0]+"Bool"+"_"+$tempString[1]+"\" Already exists...\n");
		$bool=`createNode -n ($tempString[0]+"Bool"+"_"+$tempString[1]) transform`;
		delete $bool;
		$dupObj=$objs[$i]+"_"+$boxes[$y];
		duplicate -n $dupObj $objs[$i];
		$tempString=`listRelatives -p $dupObj`;
		if ($tempString[0]!="")
			parent -w $dupObj;
		setAttr ($dupObj+".visibility") 0;
		$dupBox=$objs[$i]+"_"+$boxes[$y]+"Box";
		duplicate -n $dupBox $boxes[$y];
		asLockAttr $dupBox 0 0 0 0;
		parent -w $dupBox;
		select -r $dupObj $dupBox;
		refresh;
		$tempString=`polyBoolOp -n $dupObj -op 3 -ch 0 $dupObj $dupBox`;
		if (`objExists $dupObj`) delete $dupObj;
		if (`objExists $dupBox`) delete $dupBox;
		rename $tempString[0] $bool;
		$vs=`polyEvaluate -v $bool`;
		if (!$vs[0])
			delete  $bool;
		else
			{
			parent $bool $joint;
			editDisplayLayerMembers -noRecurse Bool $bool;
			}
		}
	}
eval ($restoreVisCmd);
progressBar -e -ep $gMainProgressBar;

print ("// Boolean created\n");
select -cl;
}

global proc asDeleteBoolean ()
{
string $all[]=`ls -r 1 -type transform "*Bool_*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
if (`objExists Bool`)
	delete Bool;
}

global proc asCreateWarp ()
{
global string $gMainProgressBar;
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
string $dialog=`confirmDialog -t "Warp"
	-m "Attempt to Warp selected geometry to PolyBoxes?"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="OK")
	return;
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	}
if (!`objExists Warp`)
	{
	createDisplayLayer -e -name Warp;
	setAttr Warp.color 28;
	setAttr Warp.displayType 2;
	}
int $sideFactor,$isEndJoint,$divisions;
int $tempInt[];
float $pos[],$facePos[];
string $restoreVisCmd;
string $tempString[],$tempString2[],$boxes[];
string $sel[]=`ls -sl`;
string $wrapBox,$SG;
string $multiSGs[];
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
createNode -n closestSampler closestPointOnMesh;

$tempString=`listRelatives -ad -type transform BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -s -ni $tempString[$i]`;
	if ($tempString2[0]!="")
		$boxes[size($boxes)]=$tempString[$i];
	}

for ($i=0;$i<size($sel);$i++)
	{
	$restoreVisCmd+="setAttr "+$sel[$i]+".v "+`getAttr ($sel[$i]+".v")`+";";
	setAttr ($sel[$i]+".v") 0;
	}
if (`objExists PolyBoxes`)
	{
	$restoreVisCmd+="setAttr PolyBoxes.v "+`getAttr PolyBoxes.v`+";";
	setAttr PolyBoxes.v 0;
	}
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -ni -s $sel[$i]`;
	string $meshNode=$tempString[0];
	$tempString=`listConnections ($tempString[0]+".instObjGroups")`;
	if ($tempString[0]!="")
		$SG=$tempString[0];
	else
		{
		//faceAssigned shaders
		for ($y=0;$y<`getAttr -s ($meshNode+".instObjGroups.objectGroups")`;$y++)
			{
			if($y==0)
				{
				//temp copy of mesh, so we can freeze xforms
				$tempString=`duplicate -n tempMesh $sel[$i]`;
				setAttr -l 0 tempMesh.tx;setAttr -l 0 tempMesh.ty;setAttr -l 0 tempMesh.tz;
				setAttr -l 0 tempMesh.rx;setAttr -l 0 tempMesh.ry;setAttr -l 0 tempMesh.rz;
				setAttr -l 0 tempMesh.sx;setAttr -l 0 tempMesh.sy;setAttr -l 0 tempMesh.sz;
				setAttr -l 0 tempMesh.v 0;
				catchQuiet (`parent -w tempMesh`);
				makeIdentity -a 1 -t 1 -r 1 -s 1 tempMesh;
				connectAttr -f tempMesh.outMesh closestSampler.inMesh;
				}
			$tempString=`listConnections -type shadingEngine ($meshNode+".instObjGroups.objectGroups["+$y+"].objectGrpColor")`;
			if ($tempString[0]!="")
				$multiSGs[size($multiSGs)]=$tempString[0];
			}
		}
	progressBar -e -st ("Creating Warps for:"+$sel[$i]) -bp -ii 1 -min 0 -max (size($boxes)) $gMainProgressBar;
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;return;}
		progressBar -e -s 1 $gMainProgressBar;
		if (`gmatch $boxes[$y] "*_L_*"`)
			$sideFactor=-1;
		else
			$sideFactor=1;
		$joint=`substitute "Box" $boxes[$y] ""`;
		tokenize $boxes[$y] "_" $tempString;
		for ($z=1;$z<99;$z++)
			if (!`objExists ($tempString[0]+"Warp"+$z+"_"+$tempString[1])`)
				break;
		$warpBox=$tempString[0]+"Warp"+$z+"_"+$tempString[1];
		$isEndJoint=0;
		$tempString=`listRelatives -type joint -c $joint`;
		if (!size($tempString))
			$isEndJoint=1;
		else if (!`sets -im DeformSet $tempString[0]`)
			$isEndJoint=1;			
		duplicate -n $warpBox $boxes[$y];
		setAttr -k 1 -l 0 ($warpBox+".tx");setAttr -k 1 -l 0 ($warpBox+".ty");setAttr -k 1 -l 0 ($warpBox+".tz");
		setAttr -k 1 -l 0 ($warpBox+".rx");setAttr -k 1 -l 0 ($warpBox+".ry");setAttr -k 1 -l 0 ($warpBox+".rz");
		parent $warpBox	$joint;
		$divisions=2;
		if ($joint=="Head_M")
			$divisions=4;
		catch (`polySmooth -mth 0 -dv $divisions -bnr 1 -c 1 -kb 1 -ksb 1 -khe 1 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 $warpBox`);
		scale -r -ocp 1 0.7 0.7 ($warpBox+".e[0:15]");
		scale -r -ocp 1 0.9 0.9 ($warpBox+".vtx[34:50]") ($warpBox+".vtx[52]") ($warpBox+".vtx[54]") ($warpBox+".vtx[56]") ($warpBox+".vtx[58]") ($warpBox+".vtx[60]") ($warpBox+".vtx[62]") ($warpBox+".vtx[64]") ($warpBox+".vtx[74:89]");
		select $sel[$i];
		select -add $warpBox;
		transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;

		select $warpBox;
		DeleteHistory;

		//round ends
		if (size($multiSGs))
			{
			$tempInt=`polyEvaluate -f $warpBox`;
			for ($z=0;$z<$tempInt[0];$z++)
				{
				if (`progressBar -q -ic $gMainProgressBar`)
					{progressBar -e -ep $gMainProgressBar;return;}
				$pos=`xform -q -ws -t ($warpBox+".f["+$z+"]")`;
				$facePos[0]=$facePos[1]=$facePos[2]=0;
				for ($a=0;$a<size($pos);$a=$a+3)
					{$facePos[0]+=$pos[$a];$facePos[1]+=$pos[$a+1];$facePos[2]+=$pos[$a+2];}
				$facePos[0]/=(size($pos)/3);$facePos[1]/=(size($pos)/3);$facePos[2]/=(size($pos)/3);
				setAttr closestSampler.inPosition $facePos[0] $facePos[1] $facePos[2];
				int $closestFaceIndex=`getAttr closestSampler.closestFaceIndex`;
				for ($a=0;$a<size($multiSGs);$a++)
					if (`sets -im $multiSGs[$a] ($sel[$i]+".f["+$closestFaceIndex+"]")`)
						sets -e -forceElement $multiSGs[$a] ($warpBox+".f["+$z+"]");
				}

			}
		else
			{
			$tempString=`listRelatives -ni -s $warpBox`;
			sets -e -forceElement $SG $tempString[0];
			}

		editDisplayLayerMembers -noRecurse Warp $warpBox;
		refresh;
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
progressBar -e -ep $gMainProgressBar;
eval ($restoreVisCmd);

print ("// Warp created\n");
select -cl;
}

global proc asDeleteWarp ()
{
string $all[]=`ls -r 1 -type transform "*Warp*_*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
if (`objExists Warp`)
	delete Warp;
}


global proc asCreateMannequin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

if (`objExists MannequinGeometry`)
	error "MannequinGeometry already exists";
createNode -n MannequinGeometry transform;
parent MannequinGeometry "Geometry";

if (!`objExists Mannequin`)
	{
	createDisplayLayer -e -name Mannequin;
	setAttr Mannequin.color 24;
	setAttr Mannequin.displayType 2;
	editDisplayLayerMembers -noRecurse Mannequin  MannequinGeometry;
	}
float $charHeight=`asgetCharHeight`;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[],$children[];
float $temp[],$temp2[],$temp3[];
int $sideFactor;
vector $childVec;
string $skipJoints[]={"Spine[0-9]*","Root_M","Chest_M","Jaw_M","Head_*","Eye_*"};

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;
setAttr Mannequin_Geometry.v 0;
setAttr Skeleton_Geometry.v 0;

$tempString=`listRelatives -c -type transform Mannequin_Geometry`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 1;

for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if (`gmatch $deformJointsList[$i] "Wrist_*"`)
		for ($y=0;$y<size($children);$y++)
			if (`gmatch $children[$y] "MiddleFinger1_*"`)
				$childJoint=$children[$y];
	if ($childJoint=="")
		continue;
	if (`gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	int $skipMe=0;

	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$children=`listRelatives -c -type joint $childJoint`;
		$childJoint=$children[0];
		}
	$temp=`xform -q -ws -t $deformJointsList[$i]`;
	$temp2=`xform -q -ws -t $childJoint`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;

	//spine
	if ($deformJointsList[$i]=="Root_M" || `gmatch $deformJointsList[$i] "*Spine[0-9]*"` || `gmatch $deformJointsList[$i] "*Chest*"` || `gmatch $deformJointsList[$i] "*Head_*"`)
		{
		if (`gmatch $deformJointsList[$i] "Head_*"`)
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Head`;
		else
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Root`;
		$poly=$tempString[0];
//		parentConstraint $deformJointsList[$i] $poly;
		delete `parentConstraint $deformJointsList[$i] $poly`;
		parent $poly MannequinGeometry;
		xform -os -s ($lenght/1) ($charHeight/10) ($charHeight/10) $poly;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}

	

	for ($y=0;$y<size($skipJoints);$y++)
		if (`gmatch $deformJointsList[$i] $skipJoints[$y]`)
			$skipMe=1;
	if ($skipMe) continue;

	if (`gmatch $deformJointsList[$i] "*Ankle*"` || `gmatch $deformJointsList[$i] "Toes*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Foot`;
		$poly=$tempString[0];
		xform -ws -t $temp[0] 0 $temp[2] $poly;
		xform -os -s ($lenght/1) ($lenght/1) ($lenght/1) $poly;
		//take on -ws .ry
		$temp3=`xform -q -ws -ro $deformJointsList[$i]`;
		if (`gmatch $deformJointsList[$i] "*Ankle*"`)
			$temp3=`xform -q -ws -ro $childJoint`;
		xform -ws -ro 0 ($temp3[1]-90) 0 $poly;
		//move forward
		move -r -os -wd 0 0 ($lenght/-4.0) $poly;
//		parentConstraint -mo $deformJointsList[$i] $poly;
		delete `parentConstraint -mo $deformJointsList[$i] $poly`;
		parent $poly MannequinGeometry;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}
	else
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Limb") Mannequin_Limb`;
		$poly=$tempString[0];
		xform -os -s ($lenght) ($lenght/2) ($lenght/2) $poly;
		if (`gmatch $deformJointsList[$i] "Wrist*"`)
			setAttr ($poly+".sy") (`getAttr ($poly+".sy")`*3);
		if (`gmatch $deformJointsList[$i] "Toes*"`)
			setAttr ($poly+".sz") (`getAttr ($poly+".sz")`*3);
		if (`gmatch $deformJointsList[$i] "*Finger*"`)
			xform -os -s $lenght ($charHeight/70) ($charHeight/70) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($lenght*1.1) ($charHeight/10) ($charHeight/10) $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`)
			{
			setAttr ($poly+".sx") (`getAttr ($poly+".sx")`*-1);
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 $poly;
			}
//		parentConstraint $deformJointsList[$i] $poly;
		delete `parentConstraint $deformJointsList[$i] $poly`;
		parent $poly MannequinGeometry;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		setAttr ($poly+"Shape.opposite") 0;
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}
	$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Sphere`;
	$poly=$tempString[0];
	xform -os -s ($lenght/2) ($lenght/2) ($lenght/2) $poly;
	if (`gmatch $deformJointsList[$i] "*Finger*"`)
		xform -os -s ($charHeight/50) ($charHeight/50) ($charHeight/50) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "Wrist*"`)
		xform -os -s ($charHeight/20) ($charHeight/20) ($charHeight/20) $poly;
	if (`gmatch $deformJointsList[$i] "Shoulder_*"` || `gmatch $deformJointsList[$i] "Hip_*"`)
		xform -os -s ($charHeight/7) ($charHeight/7) ($charHeight/7) $poly;

//	parentConstraint $deformJointsList[$i] $poly;
	delete `parentConstraint $deformJointsList[$i] $poly`;
	parent $poly MannequinGeometry;
	catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//	scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
	refresh;
	}
if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;

if (`objExists shaderMannequin`) delete shaderMannequin;
if (`objExists shaderMannequinSG`) delete shaderMannequinSG;
shadingNode -n shaderMannequin -asShader lambert;
sets -renderable true -noSurfaceShader true -empty -name shaderMannequinSG;
connectAttr -f shaderMannequin.outColor shaderMannequinSG.surfaceShader;
setAttr -type float3 shaderMannequin.color 0.78 0.63 0.42;
setAttr shaderMannequin.ambientColor -type double3 0.53 0.42 0.25;

sets -e -forceElement shaderMannequinSG MannequinGeometry;


print ("// Mannequin created\n");
select -cl;
}

global proc asDeleteMannequin ()
{
string $deleteObjs[]={"MannequinGeometry","Mannequin_Geometry","Mannequin","wood","woodSG","woodShader"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreateRetopo ()
{
string $sel[]=`ls -sl`;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 object";
if (!`objExists skinCage`)
	error "SkinCage not found, this must be created first. This is in the \"Deform(option2)\" section.";
if (`objExists retopo`)
	error "object \"retopo\" already exists, Choose \"delete retopo\", before creating a new one";

string $cage="skinCage";
if (`objExists skinSub`)
	{
	$cage="skinSub";
	print ("// skinSub cage detected, using this instead of skinCage.\n");
	}

if (`objExists retopo`) delete retopo;
select -cl;
createDisplayLayer -e -name "Retopo" -number 1 -nr;
setAttr Retopo.visibility 1;setAttr Retopo.color 5;
//setAttr Retopo.displayType 2;
duplicate -n retopo $cage;
$tempString=`listConnections -p 1 -s 1 -d 0 retopo.drawOverride`;
if (size($tempString))
	disconnectAttr $tempString[0] retopo.drawOverride;
editDisplayLayerMembers -noRecurse Retopo retopo;
if (`objExists Geometry`) parent retopo Geometry;

addAttr -ln hiResMesh -dt "string" retopo;
setAttr -type "string" retopo.hiResMesh $sel[0];
select $sel[0] retopo;

int $centerVtx[]=`asGetRetopoCenterVtxs`;
transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 0 -transferColors 0 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3 -flipUVs 0 -colorBorders 1 ;
select retopo;
DeleteHistory;
polyNormalPerVertex -ufn true retopo;
polySoftEdge -angle 180 -ch 0 retopo;
asRestoreRetopoCenterVtx $centerVtx;
select retopo;
}

global proc asDeleteRetopo ()
{
string $deleteObjs[]={"retopo","Retopo","retopoHeadEdgeFinder"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
}

global proc asUpdateRetopo ()
{
string $sel[]=`ls -sl`;
if (!`gmatch $sel[0] "retopo*"`)
	error "\"retopo\" not selected, Select the entire \"retopo\" object, or vertices on the \"retopo\" object";
string $hiResMesh=`getAttr retopo.hiResMesh`;
if (!`objExists $hiResMesh`)
	error "Could not find HiResMesh, check the name in this attribute \"retopo.hiResMesh\"";
int $centerVtx[]=`asGetRetopoCenterVtxs`;
select $hiResMesh $sel;
transferAttributes -transferPositions 1 -transferNormals 1 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3 -flipUVs 0 -colorBorders 1 ;
asRestoreRetopoCenterVtx $centerVtx;
select retopo;
DeleteHistory;
select $sel;
}

global proc asMirrorRetopo (int $L2R)
{
string $sel[]=`ls -sl`;
if (!`objExists skinCage`)
	error "SkinCage not found, this must be created first. This is in the \"Deform(option2)\" section.";
string $cage="skinCage";
if (`objExists skinSub`)
	{
	$cage="skinSub";
	print ("// skinSub cage detected, using this instead of skinCage.\n");
	}
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;
int $oppositeVtxNr;
int $numVtxs[]=`polyEvaluate -v $cage`;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($cage+".outMesh") closestSampler.inMesh;
for ($i=0;$i<$numVtxs[0];$i++)
	{
	$pos=`xform -q -ws -t ($cage+".vtx["+$i+"]")`;
	if ($pos[0]<$centerTolerance && $pos[0]>($centerTolerance*-1))
		continue;//Todo:should snap to center
	if ($L2R && $pos[0]<0) continue;
	if (!$L2R && $pos[0]>0) continue;
	setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
	$oppositeVtxNr=`getAttr closestSampler.closestVertexIndex`;
	$pos=`xform -q -ws -t ("retopo.vtx["+$i+"]")`;
	xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] ("retopo.vtx["+$oppositeVtxNr+"]");
	}
delete closestSampler;
select $sel;
}

global proc int[] asGetRetopoCenterVtxs ()
{
int $centerVtx[];
int $numVtxs[]=`polyEvaluate -v retopo`;
float $pos[];
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;

for ($i=0;$i<$numVtxs[0];$i++)
	{
	$pos=`xform -q -ws -t ("retopo.vtx["+$i+"]")`;
	if ($pos[0]<$centerTolerance && $pos[0]>($centerTolerance*-1))
		$centerVtx[size($centerVtx)]=$i;
	}
return $centerVtx;
}

global proc asRestoreRetopoCenterVtx (int $centerVtx[])
{
float $pos[];
for ($i=0;$i<size($centerVtx);$i++)
	{
	$pos=`xform -q -ws -t ("retopo.vtx["+$centerVtx[$i]+"]")`;
	xform -ws -t 0 $pos[1] $pos[2] ("retopo.vtx["+$centerVtx[$i]+"]");
	}
}

global proc asNormalMapRetopo ()
{
string $hiResMesh=`getAttr retopo.hiResMesh`;

performSurfaceSampling 1;
surfaceSamplingAddTargets( "retopo", true );
surfaceSamplingAddSource( $hiResMesh, true );
int $arraySize = `optionVar -q "surfaceSamplingOutputArraySize"`;
if ($arraySize<3)
	addMapUIFrame 0;
surfaceSamplingChangeXResolutionDragCmd 2048 0;
}

global proc asBindRetopo ()
{
int $numVtxsCage[],$numVtxsRetopo[];
string $tempString[];
string $cage="skinCage";
if (`objExists retopoSC`) error "retopoSC already exists. Try to UnBind first, before doing a nwe Bind";
if (`objExists skinSub`)
	{
	$cage="skinSub";
	print ("// skinSub cage detected, using this instead of skinCage.\n");
	}
duplicate -n skinCage2 skinCage;
parent -w skinCage2;
select skinCage2;
asSelectDeformJoints;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
select skinCage skinCage2;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
/*
if (`objExists skinSub`)
	{
	createNode -n subWrapPolySmoothProxy2 polySmoothProxy;
	polyCube -n skinSub2  -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
	connectAttr skinCage2Shape.outMesh subWrapPolySmoothProxy2.inputPolymesh;
	connectAttr subWrapPolySmoothProxy2.output skinSub2.inMesh;
	doBakeNonDefHistory( 1, {"prePost" });
	delete skinCage2;
	}
*/

select retopo;
asSelectDeformJoints;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] retopoSC;
select skinCage2 retopo;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//re-copyWeights, if topology match, with meshes aligned, for imroved results
$numVtxsCage=`polyEvaluate -v skinCage2`;
$numVtxsRetopo=`polyEvaluate -v retopo`;
if ($numVtxsCage[0]==$numVtxsRetopo[0])
	{
	select skinCage2 retopo;
	blendShape -n TempBS -w 0 1;
	select skinCage2 retopo;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	delete TempBS;
	}

delete skinCage2;
}

global proc asUnBindRetopo ()
{
select retopo;
DeleteHistory;
}

global proc asCreateFaceRetopo ()
{
int $vtxNr,$twistCurves;
float $dist,$minDist,$scaleY;
float $pos[],$pos2[],$rot[];
string $asScriptLocation=`asGetScriptLocation`;
string $headTopologyDir=$asScriptLocation+"/AdvancedSkeleton5Files/div/headTopology/";
string $file,$prePosCmd,$restoreExistingLocPosCmd,$locator;
string $faces[],$retopoHeadFaces[],$retopoHeadVtxs[],$bodyHeadConnectionVtxs[],$headBodyConnectionVtxs[],$locators[],$neckLocs[],$tempString[],$tempString2[];
string $deleteObjs[]={"closestSampler","retopoHeadEdgeFinder"};

if (`objExists FKJaw_M`) if (!`asFaceRemoveBodyJaw`) return;

if (!`objExists Neck_M_middleCurve`) error "SkinCage Neck Curve curve not found, unable to proceed";
if (`objExists FaceGroup`) error "FaceGroup already exists, unable to proceed";
if (`objExists headTopology`)
	{
	if (`objExists guidesGroup`)
		{
		$tempString=`listRelatives -ad -type transform guidesGroup`;
		for ($i=0;$i<size($tempString);$i++)
			{
			if (!`gmatch $tempString[$i] "*Loc[0-9]*"`) continue;
			$pos=`xform -q -ws -t $tempString[$i]`;
			$restoreExistingLocPosCmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$tempString[$i]+";";
			}
		}
	asDeleteFaceRetopo 0;
	}

for ($obj in $deleteObjs) if (`objExists $obj`) delete $obj;

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
select -cl;

string $curves[]={"Neck_M_middleCurve","Head_M_middleCurve","HeadEnd_M_middleCurve"};
if (`attributeExists inbetweenJoints Neck`)
	$twistCurves=`getAttr Neck.inbetweenJoints`;
if (`attributeExists twistJoints Neck`)
	$twistCurves=`getAttr Neck.twistJoints`;
for ($i=1;$i<$twistCurves+1;$i++)
	$curves[size($curves)]=("Neck_M_twistCurve"+$i);

for ($i=0;$i<size($curves);$i++)
	for ($y=0;$y<5;$y++)
		{
		$pos=`xform -q -ws -t ($curves[$i]+".cv["+$y+"]")`;
		setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr=`getAttr closestSampler.closestVertexIndex`;
		select -add ("skinCage.vtx["+$vtxNr+"]");
		}
ConvertSelectionToContainedFaces;

$faces=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($faces);$i++)
	select -add `substitute "skinCage" $faces[$i] "retopo"`;
$retopoHeadFaces=`ls -sl -fl`;

if (`objExists SkinSub`) //tmp resolve smoothProxyFaces via material
	{
	shadingNode -n tempShader -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name tempShaderSG;
	setAttr tempShader.color -type double3 0 0 0; 
	connectAttr -f tempShader.outColor tempShaderSG.surfaceShader;
	duplicate -n tempSkinCage skinCage;
	parent -w tempSkinCage;
	select -cl;
	for ($i=0;$i<size($faces);$i++)
		select -add `substitute "skinCage" $faces[$i] "tempSkinCage"`;
	sets -e -forceElement tempShaderSG;
//	polySmooth  -mth 0 -sdt 2 -ovb 1 -ofb 3 -ofc 0 -ost 1 -ocr 0 -dv 1 -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 tempSkinCage;
	polySmooth  -mth 0 -dv 1 -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 tempSkinCage;
	$tempString=`sets -q tempShaderSG`;
	clear $retopoHeadFaces;
	for ($i=0;$i<size($tempString);$i++)
		$retopoHeadFaces[size($retopoHeadFaces)]=`substitute "tempSkinCage" $tempString[$i] "retopo"`;
	delete tempSkinCage tempShader tempShaderSG;
	}
select $retopoHeadFaces;
ConvertSelectionToVertices;
$retopoHeadVtxs=`ls -sl -fl`;
duplicate -n retopoHeadEdgeFinder retopo;
$retopoHeadVtxs=`asobjSetCast "" $retopoHeadVtxs retopoHeadEdgeFinder`;

select retopo;
cluster -n retopoCluster -envelope 1;
delete $retopoHeadFaces;
delete retopoCluster;
$tempString=`listConnections -s 1 -d 0 retopoShape.inMesh`;
rename $tempString[0] retopoHeadDeleteComponent;

//import mayaFile
$file=$headTopologyDir+`optionMenu -q -v asCreateFaceRetopoOptionMenu`;
file -i -rdn -mergeNamespacesOnClash false -rpr "guides" $file;
setAttr FaceGroup.v 0;
parent headTopology Geometry;
parent FaceGroup Group;
createNode -n FaceFitRetopoAttach -p FaceGroup transform;
setAttr headTopology.v 0;

//attached faceFitCurves to headTopology
$tempString=`listRelatives -ad -type nurbsCurve FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="TongueCurveShape") continue;
	if (`gmatch $tempString[$i] "*CurveShape"`)
		{
		select $tempString[$i] headTopology;
		$tempString2=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
		//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
		rename $tempString2[0] ($tempString[$i]+"TempWrap");
		$tempString2=`listConnections ($tempString[$i]+"TempWrap.basePoints[0]")`;
		parent $tempString2[0] FaceFitRetopoAttach;
		}
	}
//attached faceFit Locators to headTopology
$tempString=`listRelatives -ad -type locator FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	$locator=$tempString2[0];
	$pos=`getAttr ($tempString[$i]+".worldPosition")`;
	curve -n ($tempString[$i]+"TempWrapCurve") -d 1 -p $pos[0] $pos[1] $pos[2] -p $pos[0] $pos[1] $pos[2] -k 0 -k 1;
	setAttr ($tempString[$i]+"TempWrapCurve.inheritsTransform") 0;
	$tempString2=`listRelatives -p $locator`;
	parent ($tempString[$i]+"TempWrapCurve") FaceFitRetopoAttach;
	geometryConstraint -weight 1 ($tempString[$i]+"TempWrapCurve")  $locator;

	select ($tempString[$i]+"TempWrapCurve") headTopology;
	$tempString2=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
	//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
	rename $tempString2[0] ($tempString[$i]+"TempWrap");
	$tempString2=`listConnections ($tempString[$i]+"TempWrap.basePoints[0]")`;
	parent $tempString2[0] FaceFitRetopoAttach;
	}

//place at head
float $neckPos[]=`xform -q -ws -t Neck_M_middleProfileShape.cv[0]`;
float $headEndPos[]=`xform -q -ws -t HeadEnd_M`;
scale -r -p 0 0 0 ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) FaceFitSkeleton;
scale -r -p 0 0 0 ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) headTopology.vtx[0:9999];
scale -r -p 0 0 0 ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) guidesGroup;
move -r 0 $neckPos[1] 0 FaceFitSkeleton;
move -r 0 $neckPos[1] 0 headTopology.vtx[0:9999];
move -r 0 $neckPos[1] 0 guidesGroup;

//store current locator positions
$tempString=`listRelatives -ad -type transform guidesGroup`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*Loc[0-9]*"`) $locators[size($locators)]=$tempString[$i];
for ($i=0;$i<size($locators);$i++)
	{
	$pos=`xform -q -ws -t $locators[$i]`;
	$prePosCmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$locators[$i]+";";
	}
addAttr -ln prePosCmd -dt "string" guidesGroup;
setAttr -type "string" guidesGroup.prePosCmd $prePosCmd;

//restore $restoreExistingLocPosCmd, if locators were already existing
tokenize $restoreExistingLocPosCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	catchQuiet (`evalEcho($tempString[$i])`);

//find bodyHeadConnectionVtxs
connectAttr -f retopo.outMesh closestSampler.inMesh;
for ($i=0;$i<size($retopoHeadVtxs);$i++)
	{
	$pos=`xform -q -ws -t $retopoHeadVtxs[$i]`;
	setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$vtxNr=`getAttr closestSampler.closestVertexIndex`;
	$pos2=`xform -q -ws -t ("retopo.vtx["+$vtxNr+"]")`;
	if (`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`<0.001)
		$bodyHeadConnectionVtxs[size($bodyHeadConnectionVtxs)]=("retopo.vtx["+$vtxNr+"]");
	if (!`attributeExists bodyHeadConnectionVtxs retopo`)
		addAttr -ln bodyHeadConnectionVtxs -dt "string" retopo;
	setAttr -type "string" retopo.bodyHeadConnectionVtxs `stringArrayToString $bodyHeadConnectionVtxs " "`;
	}
//find  headBodyConnectionVtxs
if (!`attributeExists headBodyConnectionVtxs retopo`)
	addAttr -ln headBodyConnectionVtxs -dt "string" retopo;
connectAttr -f headTopology.outMesh closestSampler.inMesh;
$pos=`xform -q -ws -t HeadProfileSideLoc6`;
setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
$vtxNr=`getAttr closestSampler.closestVertexIndex`;
select ("headTopology.vtx["+$vtxNr+"]");
ConvertSelectionToEdges;
string $edges[]=`ls -sl -fl`;
int $minNumEdgesInLoop=999;
for ($i=0;$i<size($edges);$i++)
	{
	select $edges[$i];
	SelectEdgeLoopSp;
	$tempString=`ls -sl -fl`;
	if (size($tempString)<$minNumEdgesInLoop)
		{
		$minNumEdgesInLoop=size($tempString);
		ConvertSelectionToVertices;
		$headBodyConnectionVtxs=`ls -sl -fl`;
		setAttr -type "string" retopo.headBodyConnectionVtxs `stringArrayToString $headBodyConnectionVtxs " "`;
		}
	}
//place neckLocs to nearest $bodyHeadConnectionVtxs
for ($i=0;$i<size($locators);$i++)
	if (`getAttr ($locators[$i]+".overrideColor")`==24)
		$neckLocs[size($neckLocs)]=$locators[$i];
for ($i=0;$i<size($neckLocs);$i++)
	{
	$pos=`xform -q -ws -t $neckLocs[$i]`;
	$minDist=999;
	for ($y=0;$y<size($bodyHeadConnectionVtxs);$y++)
		{
		$pos2=`xform -q -ws -t $bodyHeadConnectionVtxs[$y]`;
		$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
		if ($dist<$minDist)
			{
			$minDist=$dist;
			xform -ws -t $pos2[0] $pos2[1] $pos2[2] $neckLocs[$i];
			}
		}
	}

delete retopoHeadEdgeFinder;
for ($obj in $deleteObjs) if (`objExists $obj`) delete $obj;
asFaceUpdateInfo 1;
print "// Now move the Locators, to match the head/face of your model.\n";
select -cl;
}

global proc asDeleteFaceRetopo (int $keepNewRetopo)
{
string $deleteObjs[]={"headTopology","retopoHeadDeleteComponent","retopoHeadJoint","guidesGroup","MainCurves","ProfileCurves"};
for ($obj in $deleteObjs) if (`objExists $obj`) delete $obj;
$deleteObjs=`ls "guides_*"`;
for ($obj in $deleteObjs) if (`objExists $obj`) delete $obj;
if (`objExists guidesRN`)
	{
	lockNode -l 0 guidesRN;
	delete guidesRN;
	}
if (!$keepNewRetopo)
	{
	if (`objExists headTopologyGeometry`) delete headTopologyGeometry;
	if (`objExists FaceGroup`) delete FaceGroup;
	}
if (!$keepNewRetopo && `objExists bodyTopology`)
	{
	delete retopo;
	setAttr bodyTopology.v 1;
	rename bodyTopology retopo;
	}
asFaceUpdateInfo 1;
}

global proc asMatchGuidesFaceRetopo ()
{
int $numVtxs[]=`polyEvaluate -v headTopology`;
float $pos[];
string $tempString[],$locators[],$curves[],$mirrorCurves[],$nonAverageVtxs[],$centerXvtxs[];
string $hiResMesh=`getAttr retopo.hiResMesh`;
string $restoreLocPosCmd;
$tempString[0]=`getAttr retopo.headBodyConnectionVtxs`;
string $headBodyConnectionVtxs[]=`stringToStringArray $tempString[0] " "`;
if (`objExists retopoHeadJoint`)
	error "Match guides has already been executed. You can scrube the timeline from 0 to 10, to see the alignment";
if (!`objExists headTopology`)
	error "headTopology object not found, click \"Geometry: Create\" first";

$tempString=`listRelatives -ad -type transform guidesGroup`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`gmatch $tempString[$i] "*Loc[0-9]*"`) $locators[size($locators)]=$tempString[$i];
	if (`gmatch $tempString[$i] "*Curve*"`) $curves[size($curves)]=$tempString[$i];
	}

for ($i=0;$i<size($locators);$i++)
	{
	if (!`gmatch $locators[$i] "*Loc[0-9]*"`) continue;
	$pos=`xform -q -ws -t $locators[$i]`;
	$restoreLocPosCmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$locators[$i]+";";
	}

eval (`getAttr guidesGroup.prePosCmd`);

for ($i=0;$i<size($curves);$i++)
	{
	if ($curves[$i]=="HeadProfileSideCurve" || $curves[$i]=="noseProfileCurve") continue;
	duplicate -n ($curves[$i]+"mirror") $curves[$i];
	$mirrorCurves[size($mirrorCurves)]=$curves[$i]+"mirror";
	asLockAttr ($curves[$i]+"mirror") 1 1 0 0;
	setAttr ($curves[$i]+"mirror.sx") -1;
	connectAttr -f ($curves[$i]+".worldSpace[0]") ($curves[$i]+"mirror.create");
	}

//duplicate -n headTopologyOrig headTopology;
//setAttr headTopologyOrig.v 0;

for ($i=0;$i<$numVtxs[0];$i++)
	{
	$pos=`xform -q -ws -t ("headTopology.vtx["+$i+"]")`;
	if ($pos[0]<0.001 && $pos[0]>-0.001)
		$centerXvtxs[size($centerXvtxs)]="headTopology.vtx["+$i+"]";
	}

select FaceGroup;
joint -n retopoHeadJoint;
select headTopology retopoHeadJoint;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] headTopologySC;
setAttr headTopologySC.useComponents 1;

select headTopology $curves $mirrorCurves;
skinClusterInfluence 1 "-ug -dr 4 -ps 0 -ns 100";

eval ($restoreLocPosCmd);

asAlignBodyFaceRetopo;

clear $tempString;
asSelectCurveVtx upperLipMainCurve2;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx upperLipMainCurve2mirror;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx lowerLipMainCurve2;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx lowerLipMainCurve2mirror;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx eyeLidMainCurve;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx eyeLidMainCurvemirror;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx EyeBrowMainCurve2;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx EyeBrowMainCurve2mirror;select -add $tempString;$tempString=`ls -sl`;
if (`objExists EarCurve`)
	{asSelectCurveVtx EarCurve;select -add $tempString;$tempString=`ls -sl`;}
asSelectCurveVtx noseProfileCurve;select -add $tempString;$tempString=`ls -sl`;
GrowPolygonSelectionRegion;$tempString=`ls -sl`;
$nonAverageVtxs=`stringArrayCatenate $nonAverageVtxs $tempString`;

select headTopology.vtx[0:9999];
select -d $headBodyConnectionVtxs;
select -d $nonAverageVtxs;
$tempString=`ls -sl`;
select $hiResMesh $tempString;
transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 0 -transferColors 0 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;
select $tempString;
polyAverageVertex -i 10;
select $hiResMesh $tempString;
transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 0 -transferColors 0 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;

for ($i=0;$i<size($centerXvtxs);$i++)
	{
	$pos=`xform -q -ws -t $centerXvtxs[$i]`;
	xform -ws -t 0 $pos[1] $pos[2] $centerXvtxs[$i];
	}

setAttr headTopology.v 1;
select -cl;
}

global proc asShrinkWrapFaceRetopo ()
{
string $tempString[];
$tempString[0]=`getAttr retopo.headBodyConnectionVtxs`;
string $headVtxs[]=`stringToStringArray $tempString[0] " "`;

select headTopology;
ConvertSelectionToVertices;
select -d $headVtxs;
polyAverageVertex -i 10 -ch 1;

}

global proc asAlignBodyFaceRetopo ()
{
float $mag,$minMag;
float $posA[],$posB[];
string $nearestVtx;
string $sel[]=`ls -sl`;
string $tempString[];

$tempString[0]=`getAttr retopo.bodyHeadConnectionVtxs`;
string $bodyVtxs[]=`stringToStringArray $tempString[0] " "`;
$tempString[0]=`getAttr retopo.headBodyConnectionVtxs`;
string $headVtxs[]=`stringToStringArray $tempString[0] " "`;

for ($i=0;$i<size($headVtxs);$i++)
	{
	$posA=`xform -q -ws -t $headVtxs[$i]`;
	$minMag=99999;
	for ($y=0;$y<size($bodyVtxs);$y++)
		{
		$posB=`xform -q -ws -t $bodyVtxs[$y]`;
		$mag=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		if ($mag<$minMag)
			{
			$minMag=$mag;
			$nearestVtx=$bodyVtxs[$y];
			}
		}
	$posB=`xform -q -ws -t $nearestVtx`;
	xform -ws -t $posB[0] $posB[1] $posB[2] $headVtxs[$i];
	}
}

global proc asConnectBodyFaceRetopo ()
{
int $form,$spans,$degrees,$numCv;
float $posA[];
string $sel[]=`ls -sl`;
string $tempString[];
string $restoreCrvsCmd;

//`detach` wrapped-on FaceFitSkeleton
$tempString=`listRelatives -ad -type nurbsCurve FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*CurveShape"`)
		{
		$form=`getAttr ($tempString[$i]+".form")`;
		$spans=`getAttr ($tempString[$i]+".spans")`;
		$degrees=`getAttr ($tempString[$i]+".degree")`;
		if ($form==2) $numCv=$spans;
		else $numCv=$spans+$degrees;
		for ($y=0;$y<$numCv;$y++)
			{
			$posA=`xform -q -ws -t ($tempString[$i]+".cv["+$y+"]")`;
			$restoreCrvsCmd+="xform -ws -t "+$posA[0]+" "+$posA[1]+" "+$posA[2]+" "+$tempString[$i]+".cv["+$y+"];";
			}
		}
setAttr FaceGroup.v 1;
refresh;
setAttr FaceGroup.v 0;
delete FaceFitRetopoAttach;
evalEcho ($restoreCrvsCmd);

rename retopo bodyTopology;
duplicate -n headTopologyForMerge headTopology;
duplicate -n bodyTopologyForMerge bodyTopology;
setAttr headTopology.v 0;
setAttr bodyTopology.v 0;

polyUnite -ch 0 -mergeUVSets 0 -name retopo bodyTopologyForMerge headTopologyForMerge;
addAttr -ln hiResMesh -dt "string" retopo;
setAttr -type "string" retopo.hiResMesh `getAttr bodyTopology.hiResMesh`;
delete headTopologyForMerge bodyTopologyForMerge;
//parent headTopology Geometry;
parent retopo Geometry;
editDisplayLayerMembers -noRecurse Retopo retopo;

polyMergeVertex -d 0.0001 -am 1 -ch 0 retopo;
select headTopology;
DeleteHistory;

asDeleteFaceRetopo 1;

if (`objExists retopoSC`)
	{
	rename retopoSC bodyTopologySC;
	select retopo;
	asSelectDeformJoints;
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] retopoSC;
	select bodyTopology retopo;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}
delete bodyTopology;

catchQuiet (`select $sel`);
}

global proc asCreateEyesFaceRetopo ()
{
float $pos[],$rot[];
float $eyeSize;
float $height=`getAttr "Main.height"`;
string $asScriptLocation=`asGetScriptLocation`;
string $headTopologyEyeBallDir=$asScriptLocation+"/AdvancedSkeleton5Files/div/headTopologyEyeBall/";
string $file,$side;

if (`objExists headTopologyEyes`)
	{
	select headTopologyEyes;
	error "headTopologyEyes already exists";
	}
createNode -n headTopologyEyes -p Geometry transform;
$file=$headTopologyEyeBallDir+`optionMenu -q -v asCreateFaceRetopoEyeBallOptionMenu`;
file -i $file;
parent eyeball headTopologyEyes;

$rot=`xform -q -ws -ro Eye_R`;
xform -r -ro $rot[0] ($rot[1]-90) 0 eyeball.vtx[0:999];
$pos=`xform -q -ws -t Eye_R`;
move -r $pos[0] $pos[1] $pos[2] eyeball.vtx[0:999];

$eyeSize=$height/30.0;
scale -r -p $pos[0] $pos[1] $pos[2] $eyeSize $eyeSize $eyeSize eyeball.vtx[0:999];

rename eyeball eyeball_R;
duplicate -n eyeball_L eyeball_R;
scale -r -p 0 0 0 -1 1 1 eyeball_L.vtx[0:999];
polyNormal -normalMode 0 -userNormalMode 0 -ch 0 eyeball_L;

asLockAttr headTopologyEyes 1 1 1 1;
addAttr -k 1 -ln "size" -at double -dv 1 headTopologyEyes;

$side="_R";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1) {$side="_L";}
	select ("eyeball"+$side);
	$tempString=`newCluster " -envelope 1"`;
	rename $tempString[0] ("eyeballCluster"+$side);
	rename $tempString[1] ("eyeballClusterHandle"+$side);
	setAttr ("eyeballClusterHandle"+$side+".v") 0;
	parent ("eyeballClusterHandle"+$side) headTopologyEyes;
	connectAttr headTopologyEyes.size ("eyeballClusterHandle"+$side+".sx");connectAttr headTopologyEyes.size ("eyeballClusterHandle"+$side+".sy");connectAttr headTopologyEyes.size ("eyeballClusterHandle"+$side+".sz");
//	select ("eyeball"+$side);
//	asChooseInput ("asFaceEye"+$side+"TextField");
	}

//asBuildFitEyeBall;
print "//Eyes created, ajust the scale with the size attribute.\n";
select headTopologyEyes;
}

global proc asBindEyesFaceRetopo ()
{
string $side="_R";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1) {$side="_L";}
	select ("eyeball"+$side);
	DeleteHistory;
	select Head_M ("eyeball"+$side);
	newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
	}
print "//Eyes skinned to eye-joints.\n";
select -cl;
}

global proc asCreateTeethFaceRetopo ()
{
float $pos[];
float $height=`getAttr "Main.height"`;
if (`objExists headTopologyTeeth`)
	{
	select teethLocator;
	error "headTopologyTeeth already exists";
	}
string $asScriptLocation=`asGetScriptLocation`;
string $headTopologyTeethDir=$asScriptLocation+"/AdvancedSkeleton5Files/div/headTopologyTeeth/";
string $file=$headTopologyTeethDir+`optionMenu -q -v asCreateFaceRetopoTeethOptionMenu`;
file -i $file;
parent headTopologyTeeth Geometry;

$pos=`xform -q -ws -t Head_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] -s ($height/20.0) ($height/20.0) ($height/20.0) teethLocator;
$pos=`xform -q -ws -t Eye_R`;
setAttr teethLocator.tz $pos[2];

select teethLocator;
}

global proc asBindTeethFaceRetopo ()
{
select upperTeeth lowerTeeth tongue;
DeleteHistory;
delete teethLocator teethClusterHandle;

select upperTeeth lowerTeeth tongue Head_M;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";

select -cl;
print "// Bind teeth complete.\n";
}

global proc asFaceRigPrepRetopo ()
{
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$tempString3[];
string $newSelectionString;

setAttr FaceGroup.v 1;

//Pre section
select retopo;
asChooseInput asFaceGeometryTextField;
select retopo;
string $optionalAllHeadObjs[]={"eyeball_R","eyeball_L","upperTeeth","lowerTeeth","tongue"};
for ($i=0;$i<size($optionalAllHeadObjs);$i++)
	if (`objExists $optionalAllHeadObjs[$i]`)
		select -add $optionalAllHeadObjs[$i];
asChooseInput asFaceAllFaceGeoTextField;
if (`objExists eyeball_R`) {select eyeball_R;asChooseInput asFaceEye_RTextField;}
if (`objExists eyeball_L`) {select eyeball_L;asChooseInput asFaceEye_LTextField;}
if (`objExists upperTeeth`) {select upperTeeth;asChooseInput asFaceUpperTeethTextField;}
if (`objExists lowerTeeth`) {select lowerTeeth;asChooseInput asFaceLowerTeethTextField;}
if (`objExists tongue`) {select tongue;asChooseInput asFaceTongueTextField;}


//Fit section
if (`objExists eyeball_R`)
	asBuildFitEyeBall;
if (`objExists tongue`)
	{
	asCreateFaceFit Tongue "" 0 0 0;
	$posA=`xform -q -ws -t tongue.vtx[111]`;xform -ws -t 0 $posA[1] $posA[2] Tongue0;
	$posA=`xform -q -ws -t tongue.vtx[35]`; xform -ws -t 0 $posA[1] $posA[2] Tongue1;
	$posA=`xform -q -ws -t tongue.vtx[198]`;xform -ws -t 0 $posA[1] $posA[2] Tongue2;
	$posA=`xform -q -ws -t tongue.vtx[64]`; xform -ws -t 0 $posA[1] $posA[2] Tongue3;
	$posA=`xform -q -ws -t tongue.vtx[167]`;xform -ws -t 0 $posA[1] $posA[2] Tongue4;
	}

if (`objExists upperTeeth`)
	{
	asCreateFaceFit TeethCollider "" 0 0 0;
	$posA=`xform -q -ws -t upperTeeth.vtx[904]`;
	$posB=`xform -q -ws -t upperTeeth.vtx[685]`;
	xform -ws -t 0 $posA[1] $posB[2] TeethCollider;
	setAttr TeethCollider.sz (($posA[2]-$posB[2])*2.7);
	setAttr TeethCollider.sx ($posB[0]*2.7);
	}

asFaceFitJawCurves;

catchQuiet (`select $sel`);
}

global proc asSelectMatchingComponents (string $destMesh)
{
int $edgeSelection=0;
float $pos[];

string $sel[]=`ls -sl`;
if (`gmatch $sel[0] "*.e[[]*"`) $edgeSelection=1;
if (`objExists closestSampler`) delete closestSampler;
if ($edgeSelection)
	ConvertSelectionToVertices;
string $vtxs[]=`ls -sl -fl`;

createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($destMesh+".outMesh") closestSampler.inMesh;
select -cl;
for ($i=0;$i<size($vtxs);$i++)
	{
	$pos=`xform -q -ws -t $vtxs[$i]`;
	setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	select -add ("retopo.vtx["+`getAttr closestSampler.closestVertexIndex`+"]");
	}
if ($edgeSelection)
	ConvertSelectionToContainedEdges;
if (`objExists closestSampler`) delete closestSampler;
}

global proc asHidePolyBoxes (int $onOff)
{
if (!`objExists "BoxesGeometry"`)
	error "BoxesGeometry does not exists !\n";
setAttr -l 0 "BoxesGeometry.visibility";
setAttr -l ($onOff) "BoxesGeometry.visibility" (!$onOff);
if (!$onOff)
	setAttr -l ($onOff) "BoxesGeometry.visibility";
}

global proc asMirrorGeometry (string $geometry, int $L2R)
{
if (!`asConfirmIfNotInBuildPose`)
	return;
int $vs[];
float $scale[3],$pos[3];
string $box,$matchBox;
string $allPCs[]=`listRelatives -type transform -c ($geometry+"Geometry")`;
for ($i=0;$i<size($allPCs);$i++)
	{
	$box=`substitute "ParentConstraint" $allPCs[$i] ""`;
	if ($L2R)
		$matchBox=`substitute "_L" $box "_R"`;
	else
		$matchBox=`substitute "_R" $box "_L"`;

	if ($box==$matchBox || `gmatch $box "*_M"`)
		continue;

	if (!`objExists $matchBox`)
		continue;

	$scale=`getAttr ($box+".scale")`;
	if (!`getAttr -l ($matchBox+".scaleX")`)
		setAttr -type float3 ($matchBox+".scale") $scale[0] $scale[1] $scale[2];
	$vs=`polyEvaluate -v $box`;
	for ($y=0;$y<$vs[0];$y++)
		{
		$pos=`xform -q -ws -t ($box+".vtx["+$y+"]")`;
		xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($matchBox+".vtx["+$y+"]");
		}
	}
}

global proc asMirrorControlCurves (int $L2R, string $set)
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
string $controlObjects[]=`sets -q $set`;
string $shapes[],$tempString[],$tempString2[];
string $oppositeShape,$oppositeControlObject;
float $pos[];
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($controlObjects);$i++)
	{
	$shapes=`listRelatives -s $controlObjects[$i]`;
	if ($shapes[0]=="")
		continue;
	$objType=`objectType $shapes[0]`;
	if ($objType!="nurbsCurve" && $objType!="nurbsSurface")
		continue;

	if ($L2R)
		{
		if (!`gmatch $shapes[0] "*_L*"`)
			continue;
		}
	else
		{
		if (!`gmatch $shapes[0] "*_R*"`)
			continue;
		}

	if ($L2R)
		{
		$oppositeShape=`substitute "_L" $shapes[0] "_R"`;
		$oppositeControlObject=`substitute "_L" $controlObjects[$i] "_R"`;
		}
	else
		{
		$oppositeShape=`substitute "_R" $shapes[0] "_L"`;
		$oppositeControlObject=`substitute "_R" $controlObjects[$i] "_L"`;
		}

	if (!`objExists $oppositeShape`)
		continue;

	if ($objType=="nurbsSurface")
		{
		select ($shapes[0]+".cv[0:999][0:999]");
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			{
			//Correct if its not the Shape object returned by `ls`;
			tokenize $tempString[$y] "." $tempString2;
			if (`objectType $tempString2[0]`=="transform")
				$tempString[$y]=$shapes[0]+"."+$tempString2[1];

			$pos=`xform -q -ws -t $tempString[$y]`;
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] `substitute $shapes[0] $tempString[$y] $oppositeShape`;
			}
		continue;
		}

	$form=`getAttr ($shapes[0]+".form")`;
	$spans=`getAttr ($shapes[0]+".spans")`;
	$degrees=`getAttr ($shapes[0]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;

	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($shapes[0]+".cv["+$y+"]")`;
		if ($y==0)	$z=2;
		if ($y==1)	$z=3;
		if ($y==2)	$z=0;
		if ($y==3)	$z=1;
		if ($y==4)	$z=2;
		if ($set=="SkinCageCurvesSet")
			{
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$z+"]");
			if ($y==2)
				xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv[4]");
			}
		else
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$y+"]");
		}

	//Mirror slideJoints
	if ($set=="SkinCageCurvesSet")
		{
		string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $controlObjects[$i]`;
		int $haveSliderJoint[4];
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
				$haveSliderJoint[$y]=1;
			else
				$haveSliderJoint[$y]=0;
		if ($haveSliderJoint[0] || $haveSliderJoint[1] || $haveSliderJoint[2] || $haveSliderJoint[3])
			{
			select $oppositeControlObject;
			asCreateSliders;
			//mirror .slide values
			for ($y=0;$y<4;$y++)
				{
				string $sliderJoint=$skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y;
				string $oppositeSliderJoint;
				if ($L2R) $oppositeSliderJoint=`substitute "_L" $sliderJoint "_R"`;
				else $oppositeSliderJoint=`substitute "_R" $sliderJoint "_L"`;
				if ($y==0) $oppositeSliderJoint=`substitute "0" $oppositeSliderJoint "2"`;
				if ($y==1) $oppositeSliderJoint=`substitute "1" $oppositeSliderJoint "3"`;
				if ($y==2) $oppositeSliderJoint=`substitute "2" $oppositeSliderJoint "0"`;
				if ($y==3) $oppositeSliderJoint=`substitute "3" $oppositeSliderJoint "1"`;
				if (`objExists $sliderJoint` && `objExists $oppositeSliderJoint`)
					setAttr ($oppositeSliderJoint+".slide") `getAttr ($sliderJoint+".slide")`;
				}
			}
		else // sliders might have been deleted, this should also mirror
			{
			string $oppositeSkinCurveSliderInfo[]=`asSkinCurveSliderInfo $oppositeControlObject`;
			int $oppositeHaveSliderJoint[4];
			for ($y=0;$y<4;$y++)
				if (`objExists ($oppositeSkinCurveSliderInfo[0]+"_"+$oppositeSkinCurveSliderInfo[1]+"Slider"+$y)`)
					$oppositeHaveSliderJoint[$y]=1;
			if ($oppositeHaveSliderJoint[0] || $oppositeHaveSliderJoint[1] || $oppositeHaveSliderJoint[2] || $oppositeHaveSliderJoint[3])
				{
				select $oppositeControlObject;
				asDeleteSliders;
				}
			}
		}
	}
select $sel;
}

global proc asScaleControlCurves ()
{
//scale selected if any control curves are selected, otherwice scale all
float $scale=`floatField -q -v ScaleCCFloatField`;
string $controlObjects[];
string $sel[]=`ls -sl`;
for ($i=0;$i<size($sel);$i++)
	if (`sets -im ControlSet $sel[$i]`)
		$controlObjects[size($controlObjects)]=$sel[$i];
if (!size($controlObjects))
	$controlObjects=`sets -q "ControlSet"`;
string $controlCurves[];
string $tempString[];
for ($i=0;$i<size($controlObjects);$i++)
	{
	$tempString=`listRelatives -s $controlObjects[$i]`;
	if (!size($tempString))
		continue;
	select -cl;
	refresh;
	select -cl;
	for ($y=0;$y<100;$y++)
		select -add ($tempString[0]+".cv["+$y+"]");
	scale -r $scale $scale $scale;
	}
select $sel;
}

global proc string[] asSkinCurveSliderInfo (string $skinCurve)
{
string $info[];//[0]=$deformJoint [1]=start/middle/end [2]=restoreWeightsToJoint
string $childJoint;
string $tempString[];
tokenize $skinCurve "_" $tempString;
string $deformJoint=$tempString[0]+"_"+$tempString[1];
$info[0]=$deformJoint;
if (`gmatch $skinCurve "*_middleProfile"`)
	$info[1]="middle";
if (`gmatch $skinCurve "*_startProfile"`)
	$info[1]="start";
if (`gmatch $skinCurve "*_endProfile"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile1"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile[2-9]"`)
	{
	//First some traversing to find the childJoint
	$tempString=`listRelatives -c -type joint $deformJoint`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
		if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
		}
	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -c -type joint $childJoint`;
		$childJoint="";
		for ($i=0;$i<size($tempString);$i++)
			{
			if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
			if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
			}
		}
	//Then see if it`s the lastTwister
	int $stringLenght=`size $skinCurve`;
	int $twistNr=`substring $skinCurve $stringLenght $stringLenght`;
	string $nextTwistProfile=`substring $skinCurve 1 ($stringLenght-1)`+($twistNr+1);
	if (!`objExists $nextTwistProfile`)
		{
		$info[0]=$childJoint;
		$info[1]="start";
		}
	}
//[2]=restoreWeightsToJoint
if (`gmatch $skinCurve "*_twistProfile1"`)
	{
	tokenize $skinCurve "_" $tempString;
	string $twistJoint=$tempString[0]+"Part1_"+$tempString[1];
	if (`objExists $twistJoint`)
		$info[2]=$twistJoint;
	else
		$info[2]=$info[0];
	}
else
	{
	$tempString=`listRelatives -p $info[0]`;
	if (`gmatch $skinCurve "*_endProfile"`)
		$info[2]=$info[0];
	else
		$info[2]=$tempString[0];
	}
return $info;
}

global proc asConvertSoftModToControl ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $softModHandle;
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*oftMod*Handle"`)
		$softModHandle=$sel[$i];
if ($softModHandle=="")
	error "SoftMod must be selected";

if (!`objExists ClusterControlMirrorSoftModHandle`)
	if (`promptDialog -t "Name" -m "Enter Name of new control:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
		return;
string $name="FK"+`promptDialog -query -text`;
string $side="_R";
if (`objExists ($name+$side)` && !`objExists ClusterControlMirrorSoftModHandle`)
	error ("\""+$name+$side+"\" Already exists, choose another name");
setToolTo $gSelect;
string $tempString[],$historyNodes[],$deformJoints[],$vtxs[],$historyNodes[];
string $softMod,$mesh,$skinCluster,$nearestJoint,$buildPoseCmd,$newCtrlBuildPoseCmd,$maxWeightVts;
int $haveSkinCluster;
int $mirror=`checkBox -q -v asClusterControlMirrorCheckBox`;
int $middle=`checkBox -q -v asClusterControlMiddleCheckBox`;
float $mag,$vtxMag,$nearestJointDist,$falloffRadius,$falloffMode,$weight,$maxWeight,$magAB,$magAC;
float $pos[],$currentPos[],$vtxCurrentPos[],$originPos[],$vtxOriginPos[],$currentTrans[],$tempFloatA[],$tempFloatB[],$tempFloatC[];

if (!`objExists ClusterSystem`)
	{
	createNode -n ClusterSystem -p MotionSystem transform;
	setAttr ClusterSystem.inheritsTransform 0;
	}
$currentPos=`xform -q -ws -piv $softModHandle`;
$currentTrans=`getAttr ($softModHandle+".t")`;
setAttr -type float3 ($softModHandle+".t") 0 0 0;
$originPos=`xform -q -ws -piv $softModHandle`;
$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
$softMod=$tempString[0];
$falloffRadius=`getAttr ($softMod+".falloffRadius")`;
$falloffMode=`getAttr ($softMod+".falloffMode")`;
$tempString=`listConnections -type mesh ($softMod+".outputGeometry")`;
$mesh=$tempString[0];
if ($originPos[0]>0)
	{
	$side="_L";
	}
if ($middle)
	{
	$originPos[0]=0;
	setAttr ($softModHandle+".originX") 0;
	setAttr ($softMod+".falloffCenterX") 0;
	$side="_M";
	}

//create control
if (!`objExists asClusterControlShader`)
	{
	shadingNode -n asClusterControlShader -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name asClusterControlShaderSG;
	connectAttr -f asClusterControlShader.outColor asClusterControlShaderSG.surfaceShader;
	setAttr -type float3 asClusterControlShader.color 1 0 0;
	}
float $scale=`asGetScale`;
$tempString=`sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r ($scale/5.0) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0`;
rename $tempString[0] ($name+$side);
sets -e -forceElement asClusterControlShaderSG ($name+$side);
sets -add "ControlSet" ($name+$side);
setAttr ($name+$side+"Shape.overrideEnabled") 1;
setAttr ($name+$side+"Shape.overrideColor") 13;
createNode -n ($name+"Attach"+$side) transform;
createNode -n ($name+"Offset"+$side) transform;
createNode -n ($name+"Subtract"+$side) transform;
parent ($name+$side) ($name+"Subtract"+$side);
parent ($name+"Subtract"+$side) ($name+"Offset"+$side);
parent ($name+"Offset"+$side) ($name+"Attach"+$side);
parent ($name+"Attach"+$side) ClusterSystem;

//orientConstraint to nearest joint
$deformJoints=`listRelatives -type joint -ad "DeformationSystem"`;
$nearestJointDist=9999;
for ($i=0;$i<size($deformJoints);$i++)
	{
	if (`gmatch $deformJoints[$i] "*Part[0-9]*"`)
		continue;
	$pos=`xform -q -ws -t $deformJoints[$i]`;
	$mag=`mag<<$pos[0]-$originPos[0],$pos[1]-$originPos[1],$pos[2]-$originPos[2]>>`;
	if ($mag<$nearestJointDist)
		{
		$nearestJoint=$deformJoints[$i];
		$nearestJointDist=$mag;
		}
	}
parent -w ($name+"Offset"+$side);
orientConstraint $nearestJoint ($name+"Attach"+$side);
parent ($name+"Offset"+$side) ($name+"Attach"+$side);
connectAttr Main.s ($name+"Attach"+$side+".s");

//avoid double Xform
createNode -n ($name+"PlusMinusAverage"+$side) plusMinusAverage;
setAttr ($name+"PlusMinusAverage"+$side+".operation") 2;
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[1]");
disconnectAttr ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
parent -w ($name+"Offset"+$side);
connectAttr -f ($name+"PlusMinusAverage"+$side+".output3D") ($name+"Subtract"+$side+".t");
xform -ws -t $originPos[0] $originPos[1] $originPos[2] ($name+"Offset"+$side);

//create cluster
select $mesh;
$tempString=`cluster -n ($name+"Cluster"+$side) -envelope 1`;
setAttr -type float3 ($name+"Cluster"+$side+"HandleShape.origin") $originPos[0] $originPos[1] $originPos[2];
xform -piv $originPos[0] $originPos[1] $originPos[2] ($name+"Cluster"+$side+"Handle");
parent ($name+"Cluster"+$side+"Handle") ClusterSystem;
setAttr -l 1 ($name+"Cluster"+$side+"Handle.v") 0;

connectAttr ($name+$side+".t") ($name+"Cluster"+$side+"Handle.t");
connectAttr ($name+$side+".r") ($name+"Cluster"+$side+"Handle.r");
connectAttr ($name+$side+".s") ($name+"Cluster"+$side+"Handle.s");

//set clusterWeights
select $mesh;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $originPos[0] $originPos[1] $originPos[2];
$vtxs=`ls -sl -fl`;
polySelectConstraint -m 0;
//$mag=`mag<<$currentPos[0]-$originPos[0],$currentPos[1]-$originPos[1],$currentPos[2]-$originPos[2]>>`;
//speed up by disable other deformers
$historyNodes=`listHistory -pdo 1 -il 2 $mesh`;
for ($i=0;$i<size($historyNodes);$i++)
	setAttr ($historyNodes[$i]+".nodeState") 1;
setAttr ($softMod+".nodeState") 0;
percent -v 0 ($name+"Cluster"+$side) ($mesh+".vtx[0:99999]");
progressBar -e -st ("Converting SoftMod ("+$side+")") -bp -ii 1 -min 0 -max (size($vtxs)) $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
for ($y=0;$y<size($vtxs);$y++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		print "// Cancelled.\n";
		delete ($name+"Offset"+$side) ($name+"Attach"+$side) ($name+"Cluster"+$side+"Handle");
		setAttr -type float3 ($softModHandle+".t") $currentTrans[0] $currentTrans[1] $currentTrans[2];
		select $softModHandle;
		return;
		}
	progressBar -e -s 1 $gMainProgressBar;
	setAttr -type float3 ($softModHandle+".t") 0 1 0;
	$vtxCurrentPos=`xform -q -ws -t $vtxs[$y]`;
	setAttr -type float3 ($softModHandle+".t") 0 0 0;
	$vtxOriginPos=`xform -q -ws -t $vtxs[$y]`;
//	$vtxMag=`mag<<$vtxCurrentPos[0]-$vtxOriginPos[0],$vtxCurrentPos[1]-$vtxOriginPos[1],$vtxCurrentPos[2]-$vtxOriginPos[2]>>`;
//	$weight=$vtxMag/1.0;
	$weight=($vtxCurrentPos[1]-$vtxOriginPos[1])/1.0;
	percent -v $weight ($name+"Cluster"+$side) $vtxs[$y];
	if ($weight>$maxWeight)
		{
		$maxWeightVts=$vtxs[$y];
		$maxWeight=$weight;
		}
	}
for ($i=0;$i<size($historyNodes);$i++)
	setAttr ($historyNodes[$i]+".nodeState") 0;
progressBar -e -ep $gMainProgressBar;

//Attach to the vert that will have the highest weight, via CurveFromMeshEdge;
select $maxWeightVts;
ConvertSelectionToEdges;
$tempString=`ls -sl -fl`;
select $tempString[0];
$tempString=`duplicateCurve -ch 1 -rn 0 -local 0`;
rename $tempString[0] ($name+"Curve"+$side);
rename $tempString[1] ($name+"CurveFromMeshEdge"+$side);
parent ($name+"Curve"+$side) ClusterSystem;
setAttr -l 1 ($name+"Curve"+$side+".v") 0;
createNode -n ($name+"PointOnCurveInfo"+$side) pointOnCurveInfo;
setAttr ($name+"PointOnCurveInfo"+$side+".turnOnPercentage") 1;
connectAttr -f ($name+"Curve"+$side+"Shape.worldSpace[0]") ($name+"PointOnCurveInfo"+$side+".inputCurve");
connectAttr -f ($name+"PointOnCurveInfo"+$side+".position") ($name+"Attach"+$side+".t");
//determine PointOnCurveInfo.parameter
$tempFloatA=`xform -q -ws -t $maxWeightVts`;
$tempFloatB=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
$magAB=`mag<<$tempFloatA[0]-$tempFloatB[0],$tempFloatA[1]-$tempFloatB[1],$tempFloatA[2]-$tempFloatB[2]>>`;
setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 1;
$tempFloatC=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
$magAC=`mag<<$tempFloatA[0]-$tempFloatC[0],$tempFloatA[1]-$tempFloatC[1],$tempFloatA[2]-$tempFloatC[2]>>`;
if ($magAB<$magAC)
	setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 0;
parent ($name+"Offset"+$side) ($name+"Attach"+$side);

//reorderDeformers
$historyNodes=`listHistory -pdo 1 $mesh`;
for ($y=0;$y<size($historyNodes);$y++)
	if (`nodeType $historyNodes[$y]`=="skinCluster")
		{
		$haveSkinCluster=1;
		$skinCluster=$historyNodes[$y];
		}
if ($haveSkinCluster)
	catch (`reorderDeformers $skinCluster ($name+"Cluster"+$side) $mesh`);

//update buildPose
$newCtrlBuildPoseCmd="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$name+$side+";";
$buildPoseCmd=`getAttr buildPose.udAttr`;
setAttr -type "string" buildPose.udAttr ($buildPoseCmd+$newCtrlBuildPoseCmd);

//xform -ws -t $currentPos[0] $currentPos[1] $currentPos[2] ($name+$side);

if ($mirror && !`objExists ClusterControlMirrorSoftModHandle`)
	{
	select $mesh;
	$tempString=`softMod`;
	rename $tempString[0] ClusterControlMirrorSoftMod;
	rename $tempString[1] ClusterControlMirrorSoftModHandle;
	setAttr -type float3 ClusterControlMirrorSoftModHandle.origin ($originPos[0]*-1) $originPos[1] $originPos[2];
	setAttr ClusterControlMirrorSoftMod.falloffCenter ($originPos[0]*-1) $originPos[1] $originPos[2];
	xform -piv ($originPos[0]*-1) $originPos[1] $originPos[2] ClusterControlMirrorSoftModHandle;
	setAttr ClusterControlMirrorSoftMod.falloffMode $falloffMode;
	setAttr ClusterControlMirrorSoftMod.falloffRadius $falloffRadius;
	select ClusterControlMirrorSoftModHandle;
	asConvertSoftModToControl;
	}

delete $softModHandle;
select ($name+$side);
print ("// Control created\n");
}

global proc asPaintClusterControlWeights ()
{
global string $artSelectObject;

string $sel[]=`ls -sl`;
string $tempString[]=`listConnections ($sel[0]+".r")`;
string $clusterHandle=$tempString[0];
$tempString=`listConnections ($clusterHandle+".worldMatrix")`;
string $cluster=$tempString[0];
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$tempString[0];
select $clusterSet;
select `ls -sl -o`;

artAttrToolScript 4 "cluster";
$artSelectObject="";
eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$cluster+".weights\")");
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$cluster+".weights\")");
toolPropertyWindow;
}

global proc asCreateMoCap ()
{
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
if (`objExists "MoCap"`)
	error "MoCap skeleton already exists !";
if (!`objExists "Main"`)
	error "No AdvancedSKeleton In Scene!";
//HipSwingerStabilizer_orientConstraint1
if (!`objExists HipSwingerStabilizerTarget2`)
	{
	string $dialog=`confirmDialog -t "Confirm"
	-m "HipSwinger controllers needs \"stabilize\" attribute for Mocap.\nAdd this now ?"
	-b "OK" -b "Skip" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
	if ($dialog=="Cancel")
		return;
	if ($dialog=="OK")
		{
		//Added for MoCap to rotate Root joint
		duplicate -n HipSwingerStabilizerTarget2 HipSwingerStabilizerTarget;
		parent HipSwingerStabilizerTarget2 FKExtraRoot_M;
		orientConstraint HipSwingerStabilizerTarget2 HipSwingerStabilizer;
		if (!`attributeExists stabilize HipSwinger_M`)
			addAttr -k 1 -ln stabilize -at double -min 0 -max 10 -dv 0 HipSwinger_M;
		if (`objExists HipSwingerStabilizerUnitConversion`) delete HipSwingerStabilizerUnitConversion;
		createNode -n HipSwingerStabilizerUnitConversion unitConversion;
		setAttr HipSwingerStabilizerUnitConversion.conversionFactor 0.1;
		connectAttr HipSwinger_M.stabilize HipSwingerStabilizerUnitConversion.input;
		connectAttr HipSwingerStabilizerUnitConversion.output HipSwingerStabilizer_orientConstraint1.HipSwingerStabilizerTargetW0;
		createNode -n HipSwingerStabilizerReverse reverse;
		connectAttr HipSwingerStabilizerUnitConversion.output HipSwingerStabilizerReverse.inputX;
		connectAttr HipSwingerStabilizerReverse.outputX HipSwingerStabilizer_orientConstraint1.HipSwingerStabilizerTarget2W1;	
		}
	}

string $deformJoints[]=`listRelatives -type joint -ad "DeformationSystem"`;
string $keyDeformJoints[],$tempString[],$parent[],$names[],$extra[];
string $extr;
for ($a=$i=0;$a<size($deformJoints);$a++)
	{
	if (`gmatch $deformJoints[$a] "*_50"`)
		continue;
	if (`gmatch $deformJoints[$a] "*Slider[0-9]*"`)
		continue;
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $deformJoints[$a]`)
			continue;
	tokenize $deformJoints[$a] "_" $tempString;
	$extr="FKExtra"+$tempString[0]+"_"+$tempString[1];
	if (`gmatch $deformJoints[$a] "*Part[0-9]*"`)
		continue;
	$keyDeformJoints[$i]=$deformJoints[$a];
	$extra[$i]=$extr;
	$tempString[0]=$keyDeformJoints[$i];
	for ($y=0;$y<99;$y++)
		{
		$tempString=`listRelatives -p $tempString[0]`;
		if (!`gmatch $tempString[0] "*Part[0-9]*"`)
			{
			tokenize $tempString[0] "_" $tempString;
			$parent[$i]=$tempString[0]+"_MoCap_"+$tempString[1];
			break;
			}
		}
	tokenize $keyDeformJoints[$i] "_" $tempString;
	string $name=$tempString[0]+"_MoCap_"+$tempString[1];
	if (!`stringArrayCount $name $names`)
		{
		$names[$i]=$name;
		$i++;
		}
	}

string $topJoint;
for ($i=0;$i<size($names);$i++)
	{
	select -cl;
	joint -n $names[$i];
	if ($i==size($names)-1)
		{
		createNode -n "MoCap" transform;
		createNode -n "CenterOffset" transform;
		asAlign "CenterOffset" RootExtraX_M 1 0 0 0;
		parent "MoCap" "Group";
		parent "CenterOffset" "MoCap";
		parent $names[$i] "CenterOffset";
		connectAttr ($names[$i]+".translate") ("RootExtraX_M.translate");
		$topJoint=$names[$i];
		}
	asAlign $names[$i] $keyDeformJoints[$i] 1 1 1 0;
	setAttr ($names[$i]+".rotateOrder") 1;
	if (`objExists $extra[$i]`)
		setAttr ($extra[$i]+".rotateOrder") 1;
	}

for ($i=0;$i<size($names);$i++)
	{
	if (`objExists $parent[$i]`)
		parent $names[$i] $parent[$i];
	}
for ($i=0;$i<size($names);$i++)
	{
	if (`objExists ($names[$i]+"_blendColor")`)
		delete ($names[$i]+"_blendColor");
	createNode -n ($names[$i]+"_blendColor") blendColors;
	connectAttr ($names[$i]+".rotate") ($names[$i]+"_blendColor.color1");
	addAttr -k 1 -ln "blend" -at double -min 0 -max 1 -dv 1 $names[$i];
	connectAttr ($names[$i]+".blend") ($names[$i]+"_blendColor.blender");
	if (`objExists $extra[$i]`)
		connectAttr ($names[$i]+"_blendColor.output") ($extra[$i]+".rotate");
	}
setAttr "MoCap.translateZ" ($charHeight/-3);
//orientConstraint -mo $topJoint "RootExtraX_M";
select $sel;
}

global proc asSetAllFK ()
{
string $controlSetMembers[]=`sets -q ControlSet`;
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
		setAttr ($controlSetMembers[$i]+".FKIKBlend") 0;

if (`objExists HipSwinger_M`)
	if (`attributeExists stabilize HipSwinger_M`)
		setAttr "HipSwinger_M.stabilize" 0;
}

global proc float asGetSceneFps () 
{
float $fps;
string $fpsName=`currentUnit -q -time`;
if ($fpsName=="game") $fps=15;
if ($fpsName=="film") $fps=24;
if ($fpsName=="pal") $fps=25;
if ($fpsName=="ntsc") $fps=30;
if ($fpsName=="show") $fps=48;
if ($fpsName=="palf") $fps=50;
if ($fpsName=="ntscf") $fps=60;
if ($fpsName=="millisec") $fps=1000;
if ($fpsName=="sec") $fps=1;
if ($fpsName=="min") $fps=0.0166667;
if ($fpsName=="hour") $fps=0.000277778;
if (`gmatch $fpsName "*fps"`)
	$fps=`substitute "fps" $fpsName ""`;
return $fps;
}

global proc asReadBVH ()
{
global string $gMainProgressBar;
string $filename=`fileDialog -dm "*.bvh"`;
if (!`file -q -ex $filename`)
	return;

if (!`objExists bvhFile`)
	createNode -n bvhFile transform;

select -cl;
string $topNodesBefore[]=`ls -as`;

int $i=-1;
int $x,$lineNum,$frameNr,$motionBegin,$motionHasBegun;
int $jointNum,$chNum;
int $numChannels[];
float $offsetX,$offsetY,$offsetZ,$value;
float $rot[];
$fileId=`fopen $filename "r"`;
string $nextLine = `fgetline $fileId`;
while ( size( $nextLine ) > 0 )
	{
	if (`gmatch $nextLine "Frame Time:*"`)
		$motionBegin=1;
	if ($motionBegin)
		$lineNum++;
	$nextLine = `fgetline $fileId`;
	}
$motionBegin=0;
fclose $fileId;
$fileId=`fopen $filename "r"`;
$nextLine = `fgetline $fileId`;
string $joints[],$buffer[],$channels[],$localChannels[];
float $currentTime=`currentTime -q`;
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
currentTime -e -20;

progressBar -e -st "AdvancedSkeleton" -bp -ii 1 -min 0 -max ($lineNum+1) $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
while ( size( $nextLine ) > 0 )
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		progressBar -e -ep $gMainProgressBar;
		fclose $fileId;
		}

	tokenize $nextLine $buffer;
	if (`gmatch $nextLine "*}*"`)
		pickWalk -d up;
	if (`gmatch $nextLine "*JOINT*"` || `gmatch $nextLine "*ROOT*"` || `gmatch $nextLine "*End Site*"`)
		{
		$i++;
		$joints[$i]=$buffer[1];
		if ($joints[$i]=="Site")
			$joints[$i]=$joints[$i]+$i;
		joint -n ("MoCap"+$joints[$i]);
		setAttr ("MoCap"+$joints[$i]+".rotateOrder") 2;
		if (`gmatch $nextLine "*JOINT*"`)
			setKeyframe ("MoCap"+$joints[$i]+".rotate");
		}
	if (`gmatch $nextLine "*OFFSET*"`)
		{
		$offsetX=$buffer[1];
		$offsetY=$buffer[2];
		$offsetZ=$buffer[3];
		setAttr -type float3 ("MoCap"+$joints[$i]+".translate") $offsetX $offsetY $offsetZ;
		}
	if (`gmatch $nextLine "*CHANNELS*"`)
		{
		$numChannels[$i]=$buffer[1];
		for ($x=2;$x<size($buffer);$x++)
			$channels[$i]=$channels[$i]+`asReWord $buffer[$x]`+";";
		}

	if ($motionBegin)
		$motionHasBegun=1;
	if (`gmatch $nextLine "Frame Time:*"`)
		$motionBegin=1;
	if ($motionHasBegun)
		{
		progressBar -e -s 1 $gMainProgressBar;
		$jointNum=0;
		tokenize $channels[$jointNum] ";" $localChannels;
		$chNum=-1;
		for ($y=0;$y<size($buffer);$y++)
			{
			$chNum++;
			if ($chNum>$numChannels[$jointNum]-1)
				{
				$jointNum++;
				if (`gmatch $joints[$jointNum] "Site*"`)
					$jointNum++;
				tokenize $channels[$jointNum] ";" $localChannels;
				$chNum=0;
				}
			$value=$buffer[$y];
//			currentTime -e ($frameNr+1);
			if (`gmatch $localChannels[$chNum] "*rotate*"`)
				{
				if ($localChannels[$chNum]=="rotateX")
					$rot[0]=$value;
				if ($localChannels[$chNum]=="rotateY")
					$rot[1]=$value;
				if ($localChannels[$chNum]=="rotateZ")
					$rot[2]=$value;
				if ($chNum==2 || $chNum==5)
					{
					asSetMoCapRot ("MoCap"+$joints[$jointNum]) $rot;
					setKeyframe -t $frameNr ("MoCap"+$joints[$jointNum]+".rotate");
					}
				}
			else
				setKeyframe -v $value -t $frameNr ("MoCap"+$joints[$jointNum]+"."+$localChannels[$chNum]);
			}
		$frameNr++;
		}
	$nextLine = `fgetline $fileId`;
	}
progressBar -e -ep $gMainProgressBar;
currentTime -e $currentTime;
autoKeyframe -state $autoKeyframe;
fclose $fileId;

string $topNodesAfter[]=`ls -as`;
string $moCapTopNode;
for ($i=0;$i<size($topNodesAfter);$i++)
	{
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		{
		$moCapTopNode=$topNodesAfter[$i];
		parent $moCapTopNode bvhFile;
		}
	}

//clean statics
string $bhvJoints[]=`listRelatives -ad -type joint bvhFile`;
select $bhvJoints;
delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1;

//Scale to match Root height
string $tempString[]=`listConnections -scn 1 ($moCapTopNode+".ty")`;
if ($tempString[0]!="")
	{
	$tyAnimCurve=$tempString[0];
	string $tempString[]=`listRelatives -c -type joint DeformationSystem`;
	string $root=$tempString[0];
	float $rootHeigh=`getAttr ($root+".ty")`;
	float $keyValues[]=`keyframe -in 0 -q -vc $tyAnimCurve`;
	float $scaleFactor=$rootHeigh/$keyValues[0];
	setAttr -type float3 bvhFile.s $scaleFactor $scaleFactor $scaleFactor;
	}
//Scale keys to match frameRate
float $bvhFps=`floatField -q -v asBVHfps`;
float $sceneFps=`asGetSceneFps`;
float $scaleTime=$sceneFps/$bvhFps;
string $animCurves[];
select -cl;
for ($i=0;$i<size($bhvJoints);$i++)
	{
	$animCurves=`listConnections -s 1 -d 0 -scn 1 -type animCurve $bhvJoints[$i]`;
	for ($y=0;$y<size($animCurves);$y++)
		selectKey -add -k -t "0:99999" $animCurves[$y];
	}
scaleKey -iub false -ts $scaleTime -tp 0 -fs $scaleTime -fp 0 -vs 1 -vp 0 -animation keys ;

playbackOptions -min 0 -ast 0 -max ($frameNr*$scaleTime) -aet ($frameNr*$scaleTime);
currentTime 0;

select -cl;
}

global proc asDeleteMocap ()
{
if (`objExists MoCap`)
	delete MoCap;
delete `ls -type blendColors "*_MoCap_*_blendColor"`;
}

global proc asDeleteBHV ()
{
if (`objExists bvhFile`)
	delete bvhFile;
string $mocapJoints[]=`listRelatives -ad -type joint MoCap`;
for ($i=0;$i<size($mocapJoints);$i++)
	setAttr -type float3 ($mocapJoints[$i]+".r") 0 0 0;
}

global proc asAutoMapMocap ()
{
float $charHeight=`asgetCharHeight`;
string $tempString[]=`listRelatives -c -type joint bvhFile`;
string $bvhTopJoint=$tempString[0];
$tempString=`listRelatives -c -type joint CenterOffset`;
string $moCapTopJoint=$tempString[0];
$tempString=`pointConstraint $bvhTopJoint $moCapTopJoint`;
setAttr ($tempString[0]+".offsetZ") ($charHeight/3);

catch (`orientConstraint -mo $bvhTopJoint $moCapTopJoint`);

catch (`orientConstraint -mo MoCapRightUpLeg Hip_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftUpLeg Hip_MoCap_L`);
catch (`orientConstraint -mo MoCapRightLeg Knee_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftLeg Knee_MoCap_L`);
catch (`orientConstraint -mo MoCapRightFoot Ankle_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftFoot Ankle_MoCap_L`);
catch (`orientConstraint -mo MoCapRightToeBase Toes_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftToeBase Toes_MoCap_L`);

catch (`orientConstraint -mo MoCapLowerBack Root_MoCap_M`);
catch (`orientConstraint -mo MoCapSpine Spine1_MoCap_M`);
catch (`orientConstraint -mo MoCapSpine1 Chest_MoCap_M`);
catch (`orientConstraint -mo MoCapRightShoulder Scapula_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftShoulder Scapula_MoCap_L`);
catch (`orientConstraint -mo MoCapRightArm Shoulder_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftArm Shoulder_MoCap_L`);
catch (`orientConstraint -mo MoCapRightForeArm Elbow_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftForeArm Elbow_MoCap_L`);
catch (`orientConstraint -mo MoCapRightHand Wrist_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftHand Wrist_MoCap_L`);

catch (`orientConstraint -mo MoCapRThumb ThumbFinger2_MoCap_R`);
catch (`orientConstraint -mo MoCapLThumb ThumbFinger2_MoCap_L`);

catch (`orientConstraint -mo MoCapNeck1 Neck_MoCap_M`);
catch (`orientConstraint -mo MoCapHead Head_MoCap_M`);
}

global proc asDeleteMocapMap ()
{
delete `listRelatives -ad -type constraint MoCap`;
string $mocapJoints[]=`listRelatives -ad -type joint MoCap`;
for ($i=0;$i<size($mocapJoints);$i++)
	setAttr -type float3 ($mocapJoints[$i]+".r") 0 0 0;
}

global proc asSetMoCapRot (string $obj, float $rot[])
{
setAttr -type float3 ($obj+".rotate") 0 0 0;
float $rotX=$rot[0];
float $rotY=$rot[1];
float $rotZ=$rot[2];
rotate -r -os 0 0 $rotZ $obj;
rotate -r -os $rotX 0 0 $obj;
rotate -r -os 0 $rotY 0 $obj;
}

global proc string asReWord (string $bvhWord)
{
if ($bvhWord=="Xposition")
	return "translateX";
if ($bvhWord=="Yposition")
	return "translateY";
if ($bvhWord=="Zposition")
	return "translateZ";
if ($bvhWord=="Xrotation")
	return "rotateX";
if ($bvhWord=="Yrotation")
	return "rotateY";
if ($bvhWord=="Zrotation")
	return "rotateZ";
return "";
}

global proc asCreateGameSkeletonUnreal ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

if (`objExists |root`) delete |root;

//make sure all names for Unreal joints are avaiable
string $destJoints[]={"root","spine_01","spine_02","spine_03","neck_01","head"};
string $sideDestJoints[];
string $SIDE="_R";
string $side="_r";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1) {$SIDE="_L";$side="_l";}
	$sideDestJoints={("clavicle"+$side),("upperarm"+$side),("upperarm_twist_01"+$side),("lowerarm"+$side),("lowerarm_twist_01"+$side),("hand"+$side),
		("index_01"+$side),("index_02"+$side),("index_03"+$side),
		("middle_01"+$side),("middle_02"+$side),("middle_03"+$side),
		("ring_01"+$side),("ring_02"+$side),("ring_03"+$side),
		("pinky_01"+$side),("pinky_02"+$side),("pinky_03"+$side),
		("thumb_01"+$side),("thumb_02"+$side),("thumb_03"+$side),
		("thigh"+$side),("thigh_twist_01"+$side),("calf"+$side),("calf_twist_01"+$side),("foot"+$side),("ball"+$side)};
	}
$destJoints=`stringArrayCatenate $destJoints $sideDestJoints`;
for ($i=0;$i<size($destJoints);$i++)
	if (`objExists $destJoints[$i]`)
		{
		select $destJoints[$i];
		error ("A object with the name \""+$destJoints[$i]+"\" already exists, rename this to another name first.");
		}

string $unrealFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asUnreal.ma";
if (!`file -q -ex $unrealFile`)
	error ("Not found:"+$unrealFile);
file -i $unrealFile;

if (`objExists Main`)
	{
	pointConstraint Main root;
	orientConstraint Main root;
	setAttr root_orientConstraint1.offsetX -90;
	}
if (`objExists Root_M`)
	{
	pointConstraint Root_M pelvis;
	orientConstraint Root_M pelvis;
	setAttr pelvis_orientConstraint1.offsetX 180;
	}
if (`objExists RootPart1_M`)
	{
	pointConstraint RootPart1_M spine_01;
	orientConstraint RootPart1_M spine_01;
	setAttr spine_01_orientConstraint1.offsetX 180;
	}
else if (`objExists Root_M` && `objExists Spine1_M`)
	{
	pointConstraint Spine1_M spine_01;
	orientConstraint Spine1_M spine_01;
	setAttr spine_01_orientConstraint1.offsetX 180;
	delete spine_01_orientConstraint1 spine_01_pointConstraint1;
	pointConstraint Root_M Spine1_M spine_01;
	}
if (`objExists Spine1_M`)
	{
	pointConstraint Spine1_M spine_02;
	orientConstraint Spine1_M spine_02;
	setAttr spine_02_orientConstraint1.offsetX 180;
	}
if (`objExists Chest_M`)
	{
	pointConstraint Chest_M spine_03;
	orientConstraint Chest_M spine_03;
	setAttr spine_03_orientConstraint1.offsetX 180;
	}
$SIDE="_R";
$side="_r";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1) {$SIDE="_L";$side="_l";}
	if (`objExists ("Scapula"+$SIDE)`)
		{
		pointConstraint ("Scapula"+$SIDE) ("clavicle"+$side);
		orientConstraint ("Scapula"+$SIDE) ("clavicle"+$side);
		setAttr -type float3 ("clavicle"+$side+"_orientConstraint1.offset") 180 0 180;
		}
	if (`objExists ("Shoulder"+$SIDE)`)
		{
		pointConstraint ("Shoulder"+$SIDE) ("upperarm"+$side);
		orientConstraint ("Shoulder"+$SIDE) ("upperarm"+$side);
		setAttr -type float3 ("upperarm"+$side+"_orientConstraint1.offset") 180 0 180;
		}
	if (`objExists ("Elbow"+$SIDE)`)
		{
		pointConstraint ("Elbow"+$SIDE) ("lowerarm"+$side);
		orientConstraint ("Elbow"+$SIDE) ("lowerarm"+$side);
		setAttr -type float3 ("lowerarm"+$side+"_orientConstraint1.offset") 180 0 180;
		}
	if (`objExists ("ShoulderPart1"+$SIDE)`)
		{
		pointConstraint ("ShoulderPart1"+$SIDE) ("upperarm_twist_01"+$side);
		orientConstraint ("ShoulderPart1"+$SIDE) ("upperarm_twist_01"+$side);
		setAttr -type float3 ("upperarm_twist_01"+$side+"_orientConstraint1.offset") 180 0 180;
		}
	if (`objExists ("ElbowPart1"+$SIDE)`)
		{
		pointConstraint ("ElbowPart1"+$SIDE) ("lowerarm_twist_01"+$side);
		orientConstraint ("ElbowPart1"+$SIDE) ("lowerarm_twist_01"+$side);
		setAttr -type float3 ("lowerarm_twist_01"+$side+"_orientConstraint1.offset") 180 0 180;
		}
	if (`objExists ("Wrist"+$SIDE)`)
		{
		pointConstraint ("Wrist"+$SIDE) ("hand"+$side);
		orientConstraint ("Wrist"+$SIDE) ("hand"+$side);
		setAttr -type float3 ("hand"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("PinkyFinger1"+$SIDE)`)
		{
		pointConstraint ("PinkyFinger1"+$SIDE) ("pinky_01"+$side);
		orientConstraint ("PinkyFinger1"+$SIDE) ("pinky_01"+$side);
		setAttr -type float3 ("pinky_01"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("PinkyFinger2"+$SIDE)`)
		{
		pointConstraint ("PinkyFinger2"+$SIDE) ("pinky_02"+$side);
		orientConstraint ("PinkyFinger2"+$SIDE) ("pinky_02"+$side);
		setAttr -type float3 ("pinky_02"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("PinkyFinger3"+$SIDE)`)
		{
		pointConstraint ("PinkyFinger3"+$SIDE) ("pinky_03"+$side);
		orientConstraint ("PinkyFinger3"+$SIDE) ("pinky_03"+$side);
		setAttr -type float3 ("pinky_03"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("RingFinger1"+$SIDE)`)
		{
		pointConstraint ("RingFinger1"+$SIDE) ("ring_01"+$side);
		orientConstraint ("RingFinger1"+$SIDE) ("ring_01"+$side);
		setAttr -type float3 ("ring_01"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("RingFinger2"+$SIDE)`)
		{
		pointConstraint ("RingFinger2"+$SIDE) ("ring_02"+$side);
		orientConstraint ("RingFinger2"+$SIDE) ("ring_02"+$side);
		setAttr -type float3 ("ring_02"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("RingFinger3"+$SIDE)`)
		{
		pointConstraint ("RingFinger3"+$SIDE) ("ring_03"+$side);
		orientConstraint ("RingFinger3"+$SIDE) ("ring_03"+$side);
		setAttr -type float3 ("ring_03"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("MiddleFinger1"+$SIDE)`)
		{
		pointConstraint ("MiddleFinger1"+$SIDE) ("middle_01"+$side);
		orientConstraint ("MiddleFinger1"+$SIDE) ("middle_01"+$side);
		setAttr -type float3 ("middle_01"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("MiddleFinger2"+$SIDE)`)
		{
		pointConstraint ("MiddleFinger2"+$SIDE) ("middle_02"+$side);
		orientConstraint ("MiddleFinger2"+$SIDE) ("middle_02"+$side);
		setAttr -type float3 ("middle_02"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("MiddleFinger3"+$SIDE)`)
		{
		pointConstraint ("MiddleFinger3"+$SIDE) ("middle_03"+$side);
		orientConstraint ("MiddleFinger3"+$SIDE) ("middle_03"+$side);
		setAttr -type float3 ("middle_03"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("IndexFinger1"+$SIDE)`)
		{
		pointConstraint ("IndexFinger1"+$SIDE) ("index_01"+$side);
		orientConstraint ("IndexFinger1"+$SIDE) ("index_01"+$side);
		setAttr -type float3 ("index_01"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("IndexFinger2"+$SIDE)`)
		{
		pointConstraint ("IndexFinger2"+$SIDE) ("index_02"+$side);
		orientConstraint ("IndexFinger2"+$SIDE) ("index_02"+$side);
		setAttr -type float3 ("index_02"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("IndexFinger3"+$SIDE)`)
		{
		pointConstraint ("IndexFinger3"+$SIDE) ("index_03"+$side);
		orientConstraint ("IndexFinger3"+$SIDE) ("index_03"+$side);
		setAttr -type float3 ("index_03"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("ThumbFinger1"+$SIDE)`)
		{
		pointConstraint ("ThumbFinger1"+$SIDE) ("thumb_01"+$side);
		orientConstraint ("ThumbFinger1"+$SIDE) ("thumb_01"+$side);
		setAttr -type float3 ("thumb_01"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("ThumbFinger2"+$SIDE)`)
		{
		pointConstraint ("ThumbFinger2"+$SIDE) ("thumb_02"+$side);
		orientConstraint ("ThumbFinger2"+$SIDE) ("thumb_02"+$side);
		setAttr -type float3 ("thumb_02"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("ThumbFinger3"+$SIDE)`)
		{
		pointConstraint ("ThumbFinger3"+$SIDE) ("thumb_03"+$side);
		orientConstraint ("ThumbFinger3"+$SIDE) ("thumb_03"+$side);
		setAttr -type float3 ("thumb_03"+$side+"_orientConstraint1.offset") 90 0 180;
		}

	if (`objExists ("Hip"+$SIDE)`)
		{
		pointConstraint ("Hip"+$SIDE) ("thigh"+$side);
		orientConstraint ("Hip"+$SIDE) ("thigh"+$side);
		}
	if (`objExists ("HipPart1"+$SIDE)`)
		{
		pointConstraint ("HipPart1"+$SIDE) ("thigh_twist_01"+$side);
		orientConstraint ("HipPart1"+$SIDE) ("thigh_twist_01"+$side);
		}
	if (`objExists ("Knee"+$SIDE)`)
		{
		pointConstraint ("Knee"+$SIDE) ("calf"+$side);
		orientConstraint ("Knee"+$SIDE) ("calf"+$side);
		}
	if (`objExists ("Knee"+$SIDE)` && `objExists ("Ankle"+$SIDE)`)
		{
		pointConstraint ("Knee"+$SIDE) ("Ankle"+$SIDE) ("calf_twist_01"+$side);
		orientConstraint ("Knee"+$SIDE) ("calf_twist_01"+$side);
		}
	if (`objExists ("Ankle"+$SIDE)`)
		{
		pointConstraint ("Ankle"+$SIDE) ("foot"+$side);
		orientConstraint ("Ankle"+$SIDE) ("foot"+$side);
		}
	if (`objExists ("Toes"+$SIDE)`)
		{
		pointConstraint ("Toes"+$SIDE) ("ball"+$side);
		orientConstraint ("Toes"+$SIDE) ("ball"+$side);
		setAttr ("ball"+$side+"_orientConstraint1.offsetZ") 180;
		}
	}
if (`objExists Neck_M`)
	{
	pointConstraint Neck_M neck_01;
	orientConstraint Neck_M neck_01;
	setAttr neck_01_orientConstraint1.offsetX 180;
	}
if (`objExists Head_M`)
	{
	pointConstraint Head_M head;
	orientConstraint Head_M head;
	setAttr head_orientConstraint1.offsetX 180;
	}

select -cl;
print ("// GameSkeleton created\n");
}

global proc asDeleteGameSkeletonUnreal ()
{
if (`objExists |root`) delete |root;
}

global proc asTransferSkinUnreal ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

string $scs[]=`ls -type skinCluster`;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $sourceJoints[]={"Root_M","Spine1_M","RootPart1_M","Chest_M","Neck_M","Head_M"};
string $destJoints[]={"pelvis","spine_01","spine_02","spine_03","neck_01","head"};
string $scps[],$sideSourceJoints[],$sideDestJoints[];
string $SIDE="_R";
string $side="_r";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1) {$SIDE="_L";$side="_l";}
	$sideSourceJoints={("Scapula"+$SIDE),("Shoulder"+$SIDE),("ShoulderPart1"+$SIDE),("Elbow"+$SIDE),("ElbowPart1"+$SIDE),("Wrist"+$SIDE),
//		("Cup"+$SIDE),
		("IndexFinger1"+$SIDE),("IndexFinger2"+$SIDE),("IndexFinger3"+$SIDE),
		("MiddleFinger1"+$SIDE),("MiddleFinger2"+$SIDE),("MiddleFinger3"+$SIDE),
		("RingFinger1"+$SIDE),("RingFinger2"+$SIDE),("RingFinger3"+$SIDE),
		("PinkyFinger1"+$SIDE),("PinkyFinger2"+$SIDE),("PinkyFinger3"+$SIDE),
		("ThumbFinger1"+$SIDE),("ThumbFinger2"+$SIDE),("ThumbFinger3"+$SIDE),
		("Hip"+$SIDE),("HipPart1"+$SIDE),("Knee"+$SIDE),("Knee"+$SIDE),("Ankle"+$SIDE),("Toes"+$SIDE)};
	$sideDestJoints={("clavicle"+$side),("upperarm"+$side),("upperarm_twist_01"+$side),("lowerarm"+$side),("lowerarm_twist_01"+$side),("hand"+$side),
//		("hand"+$side),
		("index_01"+$side),("index_02"+$side),("index_03"+$side),
		("middle_01"+$side),("middle_02"+$side),("middle_03"+$side),
		("ring_01"+$side),("ring_02"+$side),("ring_03"+$side),
		("pinky_01"+$side),("pinky_02"+$side),("pinky_03"+$side),
		("thumb_01"+$side),("thumb_02"+$side),("thumb_03"+$side),
		("thigh"+$side),("thigh_twist_01"+$side),("calf"+$side),("calf_twist_01"+$side),("foot"+$side),("ball"+$side)};
	$sourceJoints=`stringArrayCatenate $sourceJoints $sideSourceJoints`;
	$destJoints=`stringArrayCatenate $destJoints $sideDestJoints`;
	}

//transfer $sourceJoints to $destJoints
for ($i=0;$i<size($sourceJoints);$i++)
	{
	if (!`objExists $sourceJoints[$i]` || !`objExists $destJoints[$i]`)
		continue;
	$scps=`listConnections -p 1 ($sourceJoints[$i]+".worldMatrix[0]")`;
	for ($y=0;$y<size($scps);$y++)
		connectAttr -f ($destJoints[$i]+".worldMatrix[0]") $scps[$y];
	}

//any joints `under` head, to be assigned to head
string $tempString[]=`listRelatives -ad -type joint Head_M`;
for ($i=0;$i<size($tempString);$i++)
	{
	$scps=`listConnections -p 1 ($tempString[$i]+".worldMatrix[0]")`;
	for ($y=0;$y<size($scps);$y++)
		connectAttr -f head.worldMatrix[0] $scps[$y];
	}

for ($i=0;$i<size($scs);$i++)
	{
	for ($y=0;$y<size($deformJointsList);$y++)
		asRemoveInfluence $deformJointsList[$y] $scs[$i];
	}
for ($i=0;$i<size($scs);$i++)
	freezeSkinCluster $scs[$i];
dgdirty -a;
print ("// Skinning transferred to Unreal Skeleton\n");
}

global proc asCreatePartialJoints ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $dialog=`confirmDialog -t "Confirm"
	-m "Create Partial Joints for all deformJoints ?"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`objExists "DeformSet"`)
	return;

float $charHeight=`asgetCharHeight`;
int $sideFactor;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $children[],$partialJoints[],$zero[],$parents[],$buffer[],$tempString[];
for ($i=0;$i<size($deformJointsList);$i++)
	{
	$children=`listRelatives -type joint -c $deformJointsList[$i]`;
	$parents=`listRelatives -type joint -p $deformJointsList[$i]`;
	if (!size($children) || !size($parents) || `gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	select $deformJointsList[$i];
	tokenize $deformJointsList[$i] "_" $buffer;
	$partialJoints[$i]=$buffer[0]+"50_"+$buffer[1];
	$partialJoints[$i]=$buffer[0]+"_"+$buffer[1]+"_50";
	$zero[$i]=$buffer[0]+"_"+$buffer[1]+"_00";
	if (`objExists $partialJoints[$i]`)
		error ("PartialJoints already exists");
	joint -n $partialJoints[$i];
	parent $partialJoints[$i] $parents[0];
	setAttr ($partialJoints[$i]+".rotateOrder") `getAttr ($deformJointsList[$i]+".rotateOrder")`;
	setAttr ($partialJoints[$i]+".segmentScaleCompensate") 0;
	addAttr -ln partialJoint -at bool $partialJoints[$i];
	sets -add "DeformSet" $partialJoints[$i];
	select $parents[0];
	createNode -n $zero[$i] transform;
	parent $zero[$i] $parents[0];
	setAttr -type float3 ($zero[$i]+".t") 0 0 0;
	setAttr -type float3 ($zero[$i]+".r") 0 0 0;
	setAttr ($zero[$i]+".rotateOrder") `getAttr ($deformJointsList[$i]+".rotateOrder")`;
	addAttr -ln partialJoint -at bool $zero[$i];
	$tempString=`orientConstraint $zero[$i] $deformJointsList[$i] $partialJoints[$i]`;
	$tempString=`pointConstraint $deformJointsList[$i] $partialJoints[$i]`;
	setAttr ($tempString[0]+".offsetX") ($sideFactor*$charHeight/5000);
	}
select -cl;
for ($i=0;$i<size($deformJointsList);$i++)
	if (`gmatch $partialJoints[$i] "*_?_50"`)
		select -add $partialJoints[$i];
}

global proc asDeletePartialJoints ()
{
if (!`objExists "DeformSet"`)
	return;

string $DeformationSystemNodes[]=`listRelatives -ad "DeformationSystem"`;
for ($i=0;$i<size($DeformationSystemNodes);$i++)
	if (`attributeExists partialJoint $DeformationSystemNodes[$i]`)
		delete $DeformationSystemNodes[$i];
}

global proc asCreateJointGroups ()
{
string $deformJoints[]=`listRelatives -ad -type joint DeformationSystem`;
string $tempString[],$tempString2[];
string $constraint;

for ($i=0;$i<size($deformJoints);$i++)
	{
	if (`gmatch $deformJoints[$i] "*Part[0-9]*"` || `gmatch $deformJoints[$i] "Spine*"` || `gmatch $deformJoints[$i] "Chest*"`)
		continue;
	$tempString=`listConnections ($deformJoints[$i]+".rx")`;
	$constraint=$tempString[0];
	if($constraint=="")
		continue;

	createNode -n ($deformJoints[$i]+"JointGroup") transform;
	asAlign ($deformJoints[$i]+"JointGroup") $deformJoints[$i] 1 1 0 1;
	$tempString=`listRelatives -p $deformJoints[$i]`;
	parent ($deformJoints[$i]+"JointGroup") $tempString[0];
	parent $deformJoints[$i] ($deformJoints[$i]+"JointGroup");

	if (`objExists ("IKX"+$deformJoints[$i])`)
		{
		createNode -n ("IKXJointGroup"+$deformJoints[$i]) transform;
		asAlign ("IKXJointGroup"+$deformJoints[$i]) $deformJoints[$i] 1 1 0 1;
		parent ("IKXJointGroup"+$deformJoints[$i]) ("IKX"+$deformJoints[$i]);
		}

	$tempString=`listConnections -s 1 -d 0 -p 1 -c 1 $constraint`;
	for ($y=0;$y<size($tempString);$y=$y+2)
		{
		if (`gmatch $tempString[$y] "*targetJointOrient"`)
			{
			disconnectAttr $tempString[$y+1] $tempString[$y];
			setAttr -type float3 $tempString[$y] 0 0 0;
			continue;
			}
		if (`gmatch $tempString[$y+1] "IKX*"`)
			{
			$tempString2[0]=`substitute "IKX" $tempString[$y+1] "IKXJointGroup"`;
			catchQuiet (`connectAttr -f $tempString2[0] $tempString[$y]`);
			}
		}
	}
print "// JointGroups created\n";
select -cl;
}

global proc asPopulateDrivingSystemsPopupMenu (string $action)
{
string $popupMenu="as"+$action+"DrivingSystemsPopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
int $numKeys,$delete;
if ($action=="Delete") $delete=1;
float $keyValues[];
string $cmd,$animCurve;
string $drivingSystems[],$tempString[],$attrs[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	if (`gmatch $drivingSystems[$i] "*_L"` && $action=="Edit")
		continue;
	//$menu1s
	setParent -menu $popupMenu;
	$sm=1;
	if ($action=="Graph") $sm=0;
	$lev1Menu=`menuItem -sm $sm -l $drivingSystems[$i]`;
	if ($action=="Graph")
		{
		string $udAttrs[]=`listAttr -ud $drivingSystems[$i]`;
		$cmd="select ";
		for ($attr in $udAttrs)
			{
			$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$attr)`;
			for ($node in $tempString)
				$cmd+=$node+" ";
			}
		$cmd+=";GraphEditor;";
		menuItem -e -c $cmd $lev1Menu;
		continue;
		}

	//$menu2s
	$attrs=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		{
		setParent -menu $lev1Menu;
		$lev2Menu=`menuItem -sm $sm -l $attrs[$y]`;
	
		//$menu3s
		$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$attrs[$y])`;
		$animCurve=$tempString[0];
		$numKeys=`keyframe -q -keyframeCount $animCurve`;
		for ($x=0;$x<$numKeys;$x++)
			{
			$keyValues=`keyframe -in $x -q -fc $animCurve`;
			$keyValues[0]=`asRoundOff $keyValues[0] 3`;
			if($keyValues[0]==0)
				continue;
			$cmd="asEditDrivingSystem "+$delete+" "+$drivingSystems[$i]+" "+$attrs[$y]+" "+$keyValues[0];
			setParent -menu $lev2Menu;
			$lev3Menu=`menuItem -sm 0 -l $keyValues[0] -c $cmd`;
			}
		}
	}
}

global proc asAutoFindAndEditDrivingSystem ()
{
string $drivingSystems[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
string $drivingSystem="";
string $driveAttr="";
float $driveValue=0;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	string $udAttrs[]=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($udAttrs);$y++)
		{
		float $value=`getAttr ($drivingSystems[$i]+"."+$udAttrs[$y])`;
		$value=`asRoundOff $value 3`;
		if ($value!=0)
			{
			if ($drivingSystem!="")
				error ("Found multiple driver values set: "+$drivingSystem+"."+$driveAttr+" AND "+$drivingSystems[$i]+"."+$udAttrs[$y]);
			$drivingSystem=$drivingSystems[$i];
			$driveAttr=$udAttrs[$y];
			$driveValue=$value;
			}
		}
	}
if ($drivingSystem=="")
	warning "Either right click on this button to edit specific drive-values, or set a driver-value, and click the button";
else
	asEditDrivingSystem 0 $drivingSystem $driveAttr $driveValue;
}

global proc asEditDrivingSystem (int $delete, string $obj, string $attr, float $value)
{
int $numDriven;
float $drivenValues[];
string $stripName;
string $drivenObjs[],$drivenAttrs[],$drivenSdkNode[];
string $tempString2[];
string $tempString[]=`listConnections -scn 1 ($obj+"."+$attr)`;
setAttr ($obj+"."+$attr) $value;
for ($i=0;$i<size($tempString);$i++)
	if (size(`ls -type animCurve $tempString[$i]`))	
		{
		tokenize $tempString[$i] "_" $tempString2;
		$drivenSdkNode[$numDriven]="";
		for ($y=0;$y<size($tempString2)-1;$y++)
			{
			$drivenSdkNode[$numDriven]=$drivenSdkNode[$numDriven]+$tempString2[$y];
			if ($y<size($tempString2)-2)
				$drivenSdkNode[$numDriven]=$drivenSdkNode[$numDriven]+"_";
			}
		$stripName=`substring $tempString[$i] 5 99`;
		if (`gmatch $stripName "[0-9]*"`)
			$stripName=`substring $stripName 2 99`;
		tokenize $stripName "_" $tempString2;
		$drivenObjs[$numDriven]="";
		for ($y=0;$y<size($tempString2)-1;$y++)
			{
			$drivenObjs[$numDriven]=$drivenObjs[$numDriven]+$tempString2[$y];
			if ($y<size($tempString2)-2)
				$drivenObjs[$numDriven]=$drivenObjs[$numDriven]+"_";
			}
		string $drivenAttr=$tempString2[size($tempString2)-1];
		if (`gmatch $drivenAttr "*[0-9]"`)
			{
			int $numChars=size($drivenAttr);
			$drivenAttr=`substring $drivenAttr 1 ($numChars-1)`;
			}
		$drivenAttrs[$numDriven]=$drivenAttr;
		$drivenValues[$numDriven]=`getAttr ($drivenSdkNode[$numDriven]+"."+$drivenAttrs[$numDriven])`;
		$numDriven++;
		}

asGoToBuildPose bodySetup;

if ($delete)
	{
	//remove entry in buildPose
	string $buildPoseCmd=`getAttr buildPose.udAttr`;
	tokenize $buildPoseCmd ";" $tempString;
	string $newBuildPoseCmd="";
	for ($i=0;$i<size($tempString);$i++)
		if (!`gmatch $tempString[$i] ("setAttr "+$obj+"."+$attr+"*")`)
			$newBuildPoseCmd+=$tempString[$i]+";";
	setAttr -type "string" buildPose.udAttr $newBuildPoseCmd;
	//remove associated SdkXforms (that dont have another drivers driving them as well)
	$tempString=`listConnections -scn 1 -s 0 -d 1 ($obj+"."+$attr)`;
	for ($i=0;$i<size($tempString);$i++)
		if (size(`ls -type animCurve $tempString[$i]`))
			{
			$tempString2=`listConnections -scn 1 -s 0 -d 1 ($tempString[$i]+".output")`;
			$SdkXform=$tempString2[0];
			$tempString2=`listConnections -scn 1 -s 1 -d 0 $SdkXform`;
			if(size($tempString2)==1)
				{
				parent `listRelatives -c $SdkXform` `listRelatives -p $SdkXform`;
				delete $SdkXform;
				}
			}
	//remove attr
	deleteAttr ($obj+"."+$attr);
	//remove controller if there`s no attributes left
	$tempString=`listAttr -ud $obj`;
	if (!size($tempString))
		delete $obj;
	return;
	}

for ($i=0;$i<size($drivenObjs);$i++)
	setAttr ($drivenObjs[$i]+"."+$drivenAttrs[$i]) $drivenValues[$i];
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
headsUpDisplay -s 2 -b 0 -bs "medium" -l ("Editing Driving System:  "+$obj+"."+$attr+"="+$value) -lfs "large" HUDEDSMode;
rowLayout -e -en 1 asDSEditChoicesRowLayout;

//select one of the drivenControls, to hint what to modify
select $drivenObjs;
}

global proc asDrivingSystemEditCancel ()
{
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
rowLayout -e -en 0 asDSEditChoicesRowLayout;
asGoToBuildPose bodySetup;
}

global proc asDrivingSystemEditApply ()
{
asCreateDrivingSystem;
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
rowLayout -e -en 0 asDSEditChoicesRowLayout;
}

global proc asCreateDrivingSystemLayout ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global string $asDSAltPivot;
global int $asDSAdvancedOptions;
string $tempString[];
tokenize $asDSMessage "\n" $tempString;
int $maxTextLines=35;
if (size($tempString)>$maxTextLines)
	{
	$asDSMessage="";
	for ($i=0;$i<$maxTextLines;$i++)
		$asDSMessage+=$tempString[$i]+"\n";
	$asDSMessage+="...And "+(size($tempString)-$maxTextLines)+" more..";
	}
columnLayout -adj 0;
columnLayout -adj 0;
	text -l $asDSMessage;
	separator -h 10 -st none;
	setParent..;
columnLayout -adj 1 asDSInputsColumnLayout;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Name:";
		textField -w 80 asDSAttrNameTextField;
		setParent..;
	rowLayout -nc 3 asDSControlNameRowLayout;
		text -w 100 -l "Control Name:";
		textField -w 80 asDSObjNameTextField;
		setParent..;
	rowLayout -en 0 -nc 4 asDSUseControlRowLayout; 
	    separator -w 5 -st none;
	    checkBox -w 95 -l "Use Control:"
	    	-onc "optionMenu -e -en 1 asDSObjNameOptionMenu;rowLayout -e -en 0 asDSControlNameRowLayout;checkBox -e -en 0 asDSMirrorCheckBox;"
	    	-ofc "optionMenu -e -en 0 asDSObjNameOptionMenu;rowLayout -e -en 1 asDSControlNameRowLayout;checkBox -e -en 1 asDSMirrorCheckBox;"
	    	asDSUseControlCheckBox;
    	optionMenu -en 0 asDSObjNameOptionMenu;
		setParent..;
	if ($asDSAdvancedOptions)
		{
		separator;
		text -l "Attribute limits:";
		rowLayout -en 1 -nc 8;
			checkBox -w 40 -v 1 -l "min:" asDSAttrHasMin;
			floatField -w 30 -v 0 -pre 1 asDSAttrMin;
			separator -w 10 -st none;
			checkBox -w 40 -v 1 -l "max:" asDSAttrHasMax;
			floatField -w 30 -v 10 -pre 1 asDSAttrMax;
			setParent..;
		separator -h 5 -st none;
		checkBox -l "Use Soft limits" -v 1 asDSAttrSoftLimits;
		}
	separator -h 10 -st none;
	setParent..;
columnLayout -adj 0;
	rowLayout -nc 3 asDSMirrorRowLayout;
			text -w 100 -l "Mirror:";
    	checkBox -l "" -v 1 asDSMirrorCheckBox;
		setParent..;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "asCreateDrivingSystemGetName;layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;

//populate asDSObjNameOptionMenu
string $drivingSystems[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
if (size($drivingSystems))
	rowLayout -e -en 1 asDSUseControlRowLayout;
setParent -menu asDSObjNameOptionMenu;

//This proc also used by CreateNewBlendShape, then $drivingSystems are actuall faceCtrls
if ($asDSMessage=="Create New BlendShape")
	{
	clear $drivingSystems;
	if (`objExists ctrlBox`)
		{
		$tempString=`listRelatives -c -type transform ctrlBox`;
		for ($i=0;$i<size($tempString);$i++)
			$drivingSystems[$i]=`substitute "Box" $tempString[$i] ""`;
		}
	}

for ($i=0;$i<size($drivingSystems);$i++)
	{
	if (`gmatch $drivingSystems[$i] "*_L"`)
		continue;
	menuItem -l $drivingSystems[$i];
	}

//fill out fields if we are editing
if ($asDSObjName!="")
	{
	textField -e -ed 0 -tx $asDSAttrName asDSAttrNameTextField;
	rowLayout -e -en 0 asDSControlNameRowLayout;
	checkBox -e -en 1 -v 1 asDSUseControlCheckBox;
	optionMenu -e -en 1 -v $asDSObjName asDSObjNameOptionMenu;
	columnLayout -e -m 0 asDSInputsColumnLayout;

	string $oppositeObjName="";
	if (`gmatch $asDSObjName "*_R"`) $oppositeObjName=`substitute "_R" $asDSObjName "_L"`;
	if (`gmatch $asDSObjName "*_L"`) $oppositeObjName=`substitute "_L" $asDSObjName "_R"`;
	if (!`objExists $oppositeObjName`)
		{
		checkBox -e -v 0 asDSMirrorCheckBox;
		rowLayout -e -en 0 asDSMirrorRowLayout;
		}
	}
}

global proc string asCreateSDKXform (string $drivenObj)
{
global string $asDSAltPivot;
string $tempString[]=`listRelatives -p $drivenObj`;
string $parent=$tempString[0];
string $child=$drivenObj;
int $isFace=0;
if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $drivenObj`)
		$isFace=1;

string $sdkXform;
if (`gmatch $parent "*Extra*"`)
	{
	$child=$parent;
	$tempString=`listRelatives -p $parent`;
	$parent=$tempString[0];
	}
for ($y=1;$y<99;$y++)
	{
	$sdkXform="SDK"+$y+$drivenObj;
	if (!`objExists $sdkXform`)
		break;
	}
createNode -n $sdkXform -p $parent transform;
sets -add AllSet $sdkXform;
setAttr ($sdkXform+".rotateOrder") `getAttr ($drivenObj+".rotateOrder")`;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1;

//$asDSAltPivot
// could be _R, but should be _L
if (`gmatch $drivenObj "*_L"` && `gmatch $asDSAltPivot "*_R"`)
	$asDSAltPivot=`substitute "_R" $asDSAltPivot "_L"`;
if ($asDSAltPivot!="" && `objExists $asDSAltPivot`)
	{
	createNode -n ($sdkXform+"AltPivotOffset1") transform;
	createNode -n ($sdkXform+"AltPivotOffset2") transform;
	sets -add AllSet ($sdkXform+"AltPivotOffset1") ($sdkXform+"AltPivotOffset2");
	asAlign ($sdkXform+"AltPivotOffset1") $asDSAltPivot 1 1 0 1;
	asAlign ($sdkXform+"AltPivotOffset2") $sdkXform 1 1 0 0;
	asAlign $sdkXform $asDSAltPivot 1 1 0 1;
	$tempString=`listRelatives -p $sdkXform`;
	parent ($sdkXform+"AltPivotOffset1") $tempString[0];
	parent $sdkXform ($sdkXform+"AltPivotOffset1");
	parent ($sdkXform+"AltPivotOffset2") $sdkXform;
	parent $child ($sdkXform+"AltPivotOffset2");
	}

parent $child $sdkXform;
return $sdkXform;
}

global proc asCreateDrivingSystemGetName ()
{
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSAttrHasMin;
global int $asDSAttrHasMax;
global int $asDSAttrSoftLimits;
global float $asDSAttrMin;
global float $asDSAttrMax;
global int $asDSMirror;
int $result;
$asDSAttrName=`textField -q -tx asDSAttrNameTextField`;
if (`rowLayout -q -en asDSControlNameRowLayout`)
	$asDSObjName=`textField -q -tx asDSObjNameTextField`;
else
	$asDSObjName=`optionMenu -q -v asDSObjNameOptionMenu`;
$asDSAttrHasMin=1;
$asDSAttrHasMax=1;
$asDSAttrSoftLimits=1;
$asDSAttrMin=0;
$asDSAttrMax=10;
if (`checkBox -q -ex asDSAttrHasMin`) $asDSAttrHasMin=`checkBox -q -v asDSAttrHasMin`;
if (`checkBox -q -ex asDSAttrHasMax`) $asDSAttrHasMax=`checkBox -q -v asDSAttrHasMax`;
if (`checkBox -q -ex asDSAttrSoftLimits`) $asDSAttrSoftLimits=`checkBox -q -v asDSAttrSoftLimits`;
if (`floatField -q -ex asDSAttrMin`) $asDSAttrMin=`floatField -q -v asDSAttrMin`;
if (`floatField -q -ex asDSAttrMax`) $asDSAttrMax=`floatField -q -v asDSAttrMax`;
$asDSMirror=`checkBox -q -v asDSMirrorCheckBox`;
}

global proc string[] asCreateDrivingSystem ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global string $asDSAltPivot;
global int $asDSAttrHasMin;
global int $asDSAttrHasMax;
global int $asDSAttrSoftLimits;
global int $asDSMirror;
global int $asDSAdvancedOptions;
global int $asBuilding;
global int $asRebuilding;
global float $asDSAttrMin;
global float $asDSAttrMax;

if (!`objExists FitSkeleton`)
	error "FitSkeleton not found";

$asDSAdvancedOptions=0;
int $modifier=`getModifiers`;
if ($modifier==4)
	$asDSAdvancedOptions=1;
int $isFace=0;
string $sel[]=`ls -sl`;
string $sdkXforms[];

int $isEditing,$reusingSdkXform,$useExistingController;
float $runValues[],$pos[],$drivenValues[];
float $poseValue,$currentValue,$maxDistAmoungDrivens,$minX,$maxX,$minY,$maxY,$minZ,$maxZ,$difX,$difY,$difZ,$controlScale,$min,$dist;
string $parent,$child,$obj,$drivenObj,$drivenAttr,$m,$controllerName,$sdkXform,$side,$oppositeSide;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$drivens[],$sdkDrivens[],$runObjAttrs[],$checkObjAttr[],$drivenObjs[],$buildPoseCmds[],$runCmds[];
string $existingSdkXforms[];
float $driverValue=10;
float $scale=`asGetScale`;
float $sideTreshold=0.0001*$scale;

//Do we come from AdvancedSkeleton BUILD Mode ?
int $comeFromASBuild=0;
if ($asBuilding || $asRebuilding)
	$comeFromASBuild=1;
else
	{
	$asDSObjName="";
	$asDSAttrName="";
	}

//Do we come from EditDrivingSystemMode ?
int $comeFromEDSMode=0;
if (`headsUpDisplay -q -ex HUDEDSMode`)
	{
	$tempString[0]=`headsUpDisplay -q -l HUDEDSMode`;
	tokenize $tempString[0] "[:]" $tempString;
	$tempString[1]=`strip $tempString[1]`;
	tokenize $tempString[1] "=" $tempString;
	$driverValue=$tempString[1];
	tokenize $tempString[0] "[.]" $tempString;
	$asDSObjName=$tempString[0];
	$asDSAttrName=$tempString[1];
	$comeFromEDSMode=1;
	}

//Find driven attribute(s)
//get $buildPoseCmds
$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
if (`objExists FaceControlSet`)
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}

for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<size($buildPoseCmds);$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
	{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			tokenize $objAttr "." $tempString3;
			$obj=$tempString3[0];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
			$poseValue=0;
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if($z>5) $poseValue=1;//scale
			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];

			if (`gmatch $checkObjAttr[$z] "FKIK*"`)//filter FKIK* as this might be just to get to FK.
				continue;

			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				{
				$tempString2=`listRelatives -p $obj`;
				if ($tempString2[0]=="DrivingSystem")
					error ("Found \""+$checkObjAttr[$z]+"\", which is a DrivingSystem attribute. To modify this right>click on the \"Edit\" button");
				else
					{
					//Creating new DrivingSystem
					$drivens[size($drivens)]=$checkObjAttr[$z];
					if (!`stringArrayCount $obj $drivenObjs`)
						$drivenObjs[size($drivenObjs)]=$obj;
					}
				if (`gmatch $checkObjAttr[$z] "*_L*[.]*"`)
					error ("Found modified values on the Left side ("+$checkObjAttr[$z]+"), Only modify Right side (or middle)");
				}
			}
		}
	}
if (size($drivens)==0)
	error ("Found no driven attributes, all controls are in Build-Pose");

string $buildPoseNode="buildPose";
if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $drivenObjs[0]`)
		{
		$isFace=1;
		$buildPoseNode="faceBuildPose";
		}

if ($comeFromEDSMode)
	{
	$isEditing=1;
	$m="Edit:  "+$asDSObjName+"."+$asDSAttrName+"="+$driverValue+"\n\n";
	for ($i=0;$i<size($drivens);$i++)
		{
		float $value=`getAttr $drivens[$i]`;
		$value=`asRoundOff $value 3`;
		$m+=$drivens[$i]+" = "+$value+"\n";	
		}
	}
else
	{
	$m="Create system to drive these attributes?\n\n";
	for ($i=0;$i<size($drivens);$i++)
		{
		float $value=`getAttr $drivens[$i]`;
		$value=`asRoundOff $value 3`;
		$m+=$drivens[$i]+" = "+$value+"\n";
		}
	}

$asDSMessage=$m;

if (!$comeFromASBuild)
	{
	string $dialogResult=`layoutDialog -t "Confirm" -ui asCreateDrivingSystemLayout`;
	if ($dialogResult!="OK")
		return {""};
	if (`objExists $asDSObjName`)
		{
		$tempString=`listRelatives -p $asDSObjName`;
		if ($tempString[0]!="DrivingSystem")
			error ("Object \""+$asDSObjName+"\" already exists, choose a unique name.");
		}
	}

$side="_M";
for ($i=0;$i<size($drivenObjs);$i++)
	{
	if (`gmatch $drivenObjs[$i] "*_R"`) $side="_R";
	if (`gmatch $drivenObjs[$i] "*_L"`) $side="_L";
	if ($side!="_M") break;
	}
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1 && !$asDSMirror)
		continue;
	if ($b==-1 && $side=="_M")
		continue;
	if      ($b==-1 && $side=="_R") {$side="_L";$oppositeSide="_R";}
	else if ($b==-1 && $side=="_L") {$side="_R";$oppositeSide="_L";}
	for ($i=0;$i<size($drivenObjs);$i++)
		if ($b==-1)
			$drivenObjs[$i]=`substitute $oppositeSide $drivenObjs[$i] $side`;
	for ($i=0;$i<size($drivens);$i++)
		if ($b==-1)
			$drivens[$i]=`substitute $oppositeSide $drivens[$i] $side`;

	string $controllerName=$asDSObjName;
	if (!`gmatch $controllerName "*_[A-Z]"`)
		$controllerName+=$side;
	if ($asDSObjName=="")
		for ($y=1;$y<99;$y++)
			{
			$controllerName="DrivingSystem"+$y+$side;
			if (!`objExists $controllerName`)
				break;
			}

//	if ($b==-1){$side=$oppositeSide;if ($side=="_R") $oppositeSide="_L";if ($side=="_L") $oppositeSide="_R";}
	if (`objExists $controllerName`) //use-existing-Control
		{
		$useExistingController=1;
//		$controllerName=$asDSObjName;
		if ($b==-1) $controllerName=`substitute $oppositeSide $controllerName $side`;
		}
	else
		asCreateDrivingSystemController $controllerName $drivenObjs;

	string $attrName=$asDSAttrName;
	if ($attrName=="")
		for ($y=1;$y<99;$y++)
			{
			$attrName="driver"+$y;
			if (!`attributeExists $attrName $controllerName`)
				break;
			}

	if (!`attributeExists $attrName $controllerName`)
		{
		addAttr -k 1 -ln $attrName -at double $controllerName;
		if ($asDSAttrHasMin && $asDSAttrSoftLimits)
			addAttr -e -ln "test2" -hasSoftMinValue 1 -softMinValue $asDSAttrMin ($controllerName+"."+$attrName);
		if ($asDSAttrHasMin && !$asDSAttrSoftLimits)
			addAttr -e -ln "test2" -min $asDSAttrMin ($controllerName+"."+$attrName);
		if ($asDSAttrHasMax && $asDSAttrSoftLimits)
			addAttr -e -ln "test2" -hasSoftMaxValue 1 -softMaxValue $asDSAttrMax ($controllerName+"."+$attrName);
		if ($asDSAttrHasMax && !$asDSAttrSoftLimits)
			addAttr -e -ln "test2" -max $asDSAttrMax ($controllerName+"."+$attrName);
		}
	else
		{
		if ($driverValue<0)
			addAttr -e -softMinValue $driverValue ($controllerName+"."+$attrName);
		else if ($driverValue>10)
			addAttr -e -softMaxValue $driverValue ($controllerName+"."+$attrName);
		}

	for ($i=0;$i<size($drivens);$i++)
		{
		tokenize $drivens[$i] "[.]" $tempString;
		$drivenAttr=$tempString[1];
		$reusingSdkXform=0;
		if ($drivenObj!=$tempString[0])//first attr in new obj
			{
			$drivenObj=$tempString[0];
			
			//See if there is a existing SDKXfrom for this driver/target combo
			$existingSdkXforms=`ls ("SDK*"+$drivenObj)`;
			for ($y=0;$y<size($existingSdkXforms);$y++)
				{
				$tempString2=`listConnections -scn 1 -s 1 -d 0 $existingSdkXforms[$y]`;
				for ($z=0;$z<size($tempString2);$z++)
					{
					$tempString3=`listConnections -scn 1 -s 1 -d 0 -p 1 $tempString2[$z]`;
					for ($a=0;$a<size($tempString3);$a++)
						if ($tempString3[$a]==$controllerName+"."+$attrName)
							{
							$sdkXform=$existingSdkXforms[$y];
							$reusingSdkXform=1;
							}
					}
				}
			if (!$reusingSdkXform)
				$sdkXform=`asCreateSDKXform $drivenObj`;
			$sdkDrivens[$i]=$sdkXform+"."+$drivenAttr;
			}
		$sdkDrivens[$i]=$sdkXform+"."+$drivenAttr;
		$sdkXforms[size($sdkXforms)]=$sdkXform;
		}
	
	if ($b==1)
		for ($i=0;$i<size($sdkDrivens);$i++)
			$drivenValues[$i]=`getAttr $drivens[$i]`;

	if ($b==-1)	//use asMirror to get mirrorValues
		{
		string $restorePoseCmd=`asGetRestorePoseCmd`;
		if (`window -q -ex tempWindow`)
			deleteUI tempWindow;
		window tempWindow;
		columnLayout;
		optionMenu tempWindowOptionMenu;
			menuItem -l ":";
		text -l "ControlSet " tempWindowControlSetsText;
		optionVar -sv asMOSide "asMOSideR2L";
		optionVar -sv asMOSpace "asMOSpaceMain";
		optionVar -sv asMOAxis "asMOAxisX";
		optionVar -sv asMOSelOnly "asMOSelOnlyAll";
		if ($isFace)
			text -e -l "FaceControlSet " tempWindowControlSetsText;
		asMirror tempWindow;
		for ($i=0;$i<size($sdkDrivens);$i++)
			$drivenValues[$i]=`getAttr $drivens[$i]`;
		deleteUI tempWindow;
		eval($restorePoseCmd);
		}

	for ($i=0;$i<size($sdkDrivens);$i++)
		setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenValues[$i] -dv $driverValue -cd ($controllerName+"."+$attrName) $sdkDrivens[$i];
	string $restorePoseCmd=`asGetRestorePoseCmd`;
	if ($isFace)
		asGoToBuildPose faceSetup;
	else
		asGoToBuildPose bodySetup;
	for ($i=0;$i<size($sdkDrivens);$i++)
		setDrivenKeyframe -itt "linear" -ott "linear" -v `getAttr $drivens[$i]` -dv 0 -cd ($controllerName+"."+$attrName) $sdkDrivens[$i];
	for ($i=0;$i<size($sdkDrivens);$i++)
		setInfinity -pri cycleRelative -poi cycleRelative $sdkDrivens[$i];
	eval($restorePoseCmd);
	if (!$isEditing)
		setAttr -type "string" ($buildPoseNode+".udAttr") (`getAttr ($buildPoseNode+".udAttr")`+";setAttr "+$controllerName+"."+$attrName+" 0;");
	//AltPivot attribute
	for ($i=0;$i<size($sdkDrivens);$i++)
		{
		if ($asDSAltPivot=="")
			continue;
		$tempString=`listConnections $sdkDrivens[$i]`;
		addAttr -ln altPivot -dt "string" $tempString[0];
		setAttr -type "string" ($tempString[0]+".altPivot") $asDSAltPivot;
		}
	}
select -cl;
if ($isFace)
	asGoToBuildPose faceSetup;
else
asGoToBuildPose bodySetup;
if (!$useExistingController)
	asOptimizeDrivingSystemControllers;
if (!$asBuilding && !$asRebuilding)
	asDrivingSystemToFitSkeleton;
return $sdkXforms;
}

global proc asOptimizeDrivingSystemControllers ()
{
string $sel[]=`ls -sl`;
int $numChar;
float $maxDist,$maxY;
float $pos[3],$pos2[3];
string $constraintTo,$deformJoint,$rlaChild,$endJoint;
string $tempString[],$animCurves[],$allDrivenObjs[],$allDrivenDeformJoints[],$longNames[],$parents[],$drivingSystems[];
createNode -n tempSamplerOffset transform;
createNode -n tempSampler -p tempSamplerOffset transform;

if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
for ($a=0;$a<size($drivingSystems);$a++)
	{
	$tempString=`listConnections -s 1 -d 0 ($drivingSystems[$a]+".tx")`;
	if ($tempString[0]!="" && `objectType $tempString[0]`=="parentConstraint")
		delete $tempString[0];
//	if (`objExists ($drivingSystems[$a]+"_parentConstraint1")`)
//		delete ($drivingSystems[$a]+"_parentConstraint1");
	asLockAttr $drivingSystems[$a] 0 0 0 1;

	//Find common ancestors
	clear $allDrivenDeformJoints;
	clear $longNames;
	$animCurves=`listConnections -s 0 -d 1 -type animCurve $drivingSystems[$a]`;	
	for ($i=0;$i<size($animCurves);$i++)
		{
		tokenize $animCurves[$i] "_" $tempString;
		$numChar=`size $animCurves[$i]` - `size($tempString[size($tempString)-1])` - 1;
		$allDrivenObjs[$i]=`substring $animCurves[$i] 4 $numChar`;
		if (`gmatch $allDrivenObjs[$i] "[0-9]*"`)
			$allDrivenObjs[$i]=`substring $allDrivenObjs[$i] 2 99`;
		$deformJoint=$allDrivenObjs[$i];
		if (`gmatch $allDrivenObjs[$i] "FK*"`)
			$deformJoint=`substitute "FK" $allDrivenObjs[$i] ""`;
		if (!`stringArrayCount $deformJoint $allDrivenDeformJoints`)
			$allDrivenDeformJoints[size($allDrivenDeformJoints)]=$deformJoint;
		}
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		$tempString=`ls -l $allDrivenDeformJoints[$i]`;
		$longNames[$i]=$tempString[0];
		select $drivingSystems[$a];
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 1 0 $allDrivenDeformJoints[$i] $drivingSystems[$a];
		}
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		tokenize $longNames[$i] "|" $parents;
		for ($y=size($parents)-2;$y>-1;$y--)
			{
			$numOthersHaveThisParent=0;
			for ($z=0;$z<size($longNames);$z++)
			if (`gmatch $longNames[$z] ("*|"+$parents[$y]+"|*")`)
				$numOthersHaveThisParent++;
			if ($numOthersHaveThisParent==size($longNames))
				{
				$constraintTo=$parents[$y];
				$i=999;$y=-999;$z=999;
				}
			}
		}

	delete `parentConstraint $drivingSystems[$a] tempSamplerOffset`;
	$pos=`xform -q -ws -t $constraintTo`;
	$maxDist=0;
	$maxY=0;
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		$endJoint=$allDrivenDeformJoints[$i];
		$rlaChild=`asRlaChild $allDrivenDeformJoints[$i]`;
		if ($rlaChild!="")
			$endJoint=$rlaChild;
		$pos2=`xform -q -ws -t $endJoint`;
		float $mag=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		if ($mag>$maxDist)
			$maxDist=$mag;
		delete `pointConstraint $endJoint tempSampler`;
		float $yValue=`getAttr tempSampler.ty`;
		$yValue=`abs($yValue)`;
		if ($yValue>$maxY)
			$maxY=$yValue;
		if ($maxY<$maxDist/2.0) $maxY=$maxDist/2.0; // cap at half lenght
		}
	if ($maxDist<0.01) $maxDist=0.5;
	if ($maxY<0.01) $maxY=0.5;

	delete `pointConstraint $constraintTo $drivingSystems[$a]`;
	if (`objExists ($drivingSystems[$a]+"_aimConstraint1")`)
		delete ($drivingSystems[$a]+"_aimConstraint1");
	parentConstraint -mo $constraintTo $drivingSystems[$a];
	setAttr -type float3 ($drivingSystems[$a]+".s") ($maxDist*1.2) ($maxY*1.2) 1;
	asLockAttr $drivingSystems[$a] 1 1 1 1;
	}
if (`objExists tempSamplerOffset`)
	delete tempSamplerOffset;

select $sel;
}

global proc asCreateDrivingSystemController (string $objName, string $drivenObjs[])
{
int $isChildOfOtherDriven;
string $tempString[],$tempString2[];
string $constraintTo="Root_M";

$tempString=`circle -n $objName -c 0 0 0 -nr 0 0 1 -sw 180 -r 1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
$objName=$tempString[0];
scale -r -1 1 1 ($objName+".cv[0:10]");
sets -add AllSet $objName;
sets -add AllSet ($objName+"Shape");
sets -add ControlSet $objName;
setAttr ($objName+"Shape.overrideEnabled") 1;
setAttr ($objName+"Shape.overrideColor") 17;
if (!`objExists DrivingSystem`)
	{
	createNode -n DrivingSystem -p MotionSystem transform;
	connectAttr Main.drvSysVis DrivingSystem.v;
	sets -add AllSet DrivingSystem;
	}
parent $objName DrivingSystem;

string $deformJoint=$drivenObjs[0];
if (`gmatch $drivenObjs[0] "FK*"`)
$deformJoint=`substitute "FK" $drivenObjs[0] ""`;
if (`objExists $deformJoint`)
	$constraintTo=$deformJoint;
asAlign $objName $drivenObjs[0] 1 1 0 0;
string $rlaChild=`asRlaChild $deformJoint`;
if (`objExists $rlaChild`)
	{
	float $scale=`getAttr ($rlaChild+".tx")`;
	setAttr -type float3 ($objName+".s") $scale $scale $scale;
//	scale -r $scale $scale $scale ($objName+".cv[0:10]");
	}

string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
//if (`objExists ($objName+"_pointConstraint1")`)
//	delete ($objName+"_pointConstraint1");
if (`objExists $constraintTo`)
	parentConstraint -mo $constraintTo $objName;
eval($restorePoseCmd);
asLockAttr $objName 1 1 1 1;
}

global proc asCreateAngleAttrs (string $joint)
{
string $sel[]=`ls -sl`;
string $restorePoseCmd=`asGetRestorePoseCmd`;
if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
float $charHeight=`asgetCharHeight`;
int $sideFactor=1;
if (`gmatch $joint "*_L"`)
	$sideFactor=-1;
string $FKjoint=$joint;
if (`objExists ("FK"+$joint)`)
	$FKjoint="FK"+$joint;
string $XYZ[]={"X","Y","Z"};
string $xyz[]={"x","y","z"};
string $RGB[]={"R","G","B"};
string $posNegs[]={"Pos","Neg"};
for ($i=0;$i<size($XYZ);$i++)
	{
	addAttr -k 1 -ln ("angle"+$XYZ[$i]) -at double $joint;
	addAttr -k 0 -ln ("angle"+$XYZ[$i]) -at double $FKjoint;
	setAttr -e -channelBox true ("FK"+$joint+".angle"+$XYZ[$i]);
	connectAttr -f ($joint+".angle"+$XYZ[$i]) ($FKjoint+".angle"+$XYZ[$i]);
	}
if (!`objExists AngleSystem`)
	{
	createNode -n AngleSystem -p MotionSystem transform;
	setAttr AngleSystem.inheritsTransform 0;
	}

string $tempString[]=`listRelatives -p $joint`;
string $parent=$tempString[0];

createNode -n ($joint+"AngleSamplerBaseParent") -p AngleSystem transform;
createNode -n ($joint+"AngleSamplerBase") -p ($joint+"AngleSamplerBaseParent") transform;
pointConstraint $parent ($joint+"AngleSamplerBaseParent");
orientConstraint $parent ($joint+"AngleSamplerBaseParent");
delete `orientConstraint $joint ($joint+"AngleSamplerBase")`;
pointConstraint $joint ($joint+"AngleSamplerBase");

for ($i=1;$i<size($XYZ);$i++)
	for ($y=0;$y<size($posNegs);$y++)
		{
		string $loc=$joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y];
		spaceLocator -n $loc;
		parent $loc ($joint+"AngleSamplerBase");
		setAttr -type float3 ($loc+".t") 0 0 0;
		setAttr -type float3 ($loc+".r") 0 0 0;
		setAttr -type float3 ($loc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
		}
setAttr ($joint+"AngleSamplerYPos.tz") ($sideFactor*-1*0.7071104);
setAttr ($joint+"AngleSamplerYNeg.tz") ($sideFactor*0.7071104);
setAttr ($joint+"AngleSamplerZPos.ty") ($sideFactor*0.7071104);
setAttr ($joint+"AngleSamplerZNeg.ty") ($sideFactor*-1*0.7071104);

createNode -n ($joint+"AngleSamplerRotate") -p ($joint+"AngleSamplerBase") transform;
orientConstraint $joint ($joint+"AngleSamplerRotate");

string $loc=$joint+"AngleSamplerEnd";
spaceLocator -n $loc;
parent $loc ($joint+"AngleSamplerRotate");
setAttr -type float3 ($loc+".t") ($sideFactor*0.7071104) 0 0;
setAttr -type float3 ($loc+".r") 0 0 0;
setAttr -type float3 ($loc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);

for ($y=0;$y<size($posNegs);$y++)
	{
	createNode -n ($joint+"OneMinus"+$posNegs[$y]) plusMinusAverage;
	setAttr ($joint+"OneMinus"+$posNegs[$y]+".operation") 2;
	setAttr -type float3 ($joint+"OneMinus"+$posNegs[$y]+".input3D[0]") 1 1 1;
	}
//Y & Z
for ($i=1;$i<size($XYZ);$i++)
	{
	for ($y=0;$y<size($posNegs);$y++)
		{
		createNode -n ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]) distanceBetween;
		connectAttr -f ($joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y]+"Shape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point1");
		connectAttr -f ($joint+"AngleSamplerEndShape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point2");
		connectAttr -f ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".distance") ($joint+"OneMinus"+$posNegs[$y]+".input3D[1].input3D"+$xyz[$i]);
		}
	createNode -n ($joint+"AngleCondition"+$XYZ[$i]) condition;
	setAttr ($joint+"AngleCondition"+$XYZ[$i]+".operation") 2;
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".firstTerm");
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".secondTerm");
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".colorIfTrue"+$RGB[$i]);
	createNode -n ($joint+"AngleInverse"+$XYZ[$i]) unitConversion;
	setAttr ($joint+"AngleInverse"+$XYZ[$i]+".conversionFactor") -1;
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleInverse"+$XYZ[$i]+".input");
	connectAttr -f ($joint+"AngleInverse"+$XYZ[$i]+".output") ($joint+"AngleCondition"+$XYZ[$i]+".colorIfFalse"+$RGB[$i]);
	connectAttr -f ($joint+"AngleCondition"+$XYZ[$i]+".outColor.outColor"+$RGB[$i]) ($joint+".angle"+$XYZ[$i]);
	}
//X
createNode -n ($joint+"AngleXMultiplyDivide") multiplyDivide;
setAttr ($joint+"AngleXMultiplyDivide.operation") 2;
setAttr -type float3 ($joint+"AngleXMultiplyDivide.input2") 90 1 1;
if (`objExists ("TwistBalancer"+$joint)`) // tapping into existing twist system
	connectAttr -f ("TwistBalancer"+$joint+".rx") ($joint+"AngleXMultiplyDivide.input1.input1X");
else // create twist deriver
	{
	select ($joint+"AngleSamplerBase");
	joint -n ($joint+"AngleXUnTwist");
	joint -n ($joint+"AngleXUnTwistEnd");
	setAttr ($joint+"AngleXUnTwistEnd.tx") ($charHeight/12.0*$sideFactor);
	select ($joint+"AngleXUnTwist");
	joint -n ($joint+"AngleXBalancer");
	orientConstraint -mo ($joint) ($joint+"AngleXBalancer");
	ikHandle -n ($joint+"AngleXUnTwistIK") -ns 2 -sol "ikRPsolver" -sj ($joint+"AngleXUnTwist") -ee ($joint+"AngleXUnTwistEnd");
	parent ($joint+"AngleXUnTwistIK") ($joint+"AngleSamplerBase");
	parentConstraint -mo $joint ($joint+"AngleXUnTwistIK");
	createNode -n ($joint+"AngleXUnTwistPoleVec") -p ($joint+"AngleSamplerBase") transform;
	poleVectorConstraint ($joint+"AngleXUnTwistPoleVec") ($joint+"AngleXUnTwistIK");
	connectAttr -f ($joint+"AngleXBalancer.rx") ($joint+"AngleXMultiplyDivide.input1.input1X");
	}
connectAttr ($joint+"AngleXMultiplyDivide.output.outputX") ($joint+".angleX");

setAttr -l 1 ($joint+"AngleSamplerBaseParent.v") 0;
eval($restorePoseCmd);
select $sel;
}

global proc string asCreateBlendedAttribute (string $drivers[])
{
string $sel[]=`ls -sl`;
string $tempString[],$driverObjs[],$driverAttrs[];
string $attr,$setAnglesCmd;
for ($i=0;$i<size($drivers);$i++)
	{
	tokenize $drivers[$i] "[.]" $tempString;
	$driverObjs[$i]=$tempString[0];
	$driverAttrs[$i]=$tempString[1];
	$attr+=$driverAttrs[$i];
	if (`getAttr $drivers[$i]`>=0)
		$attr+="Pos";
	else
		$attr+="Neg";
	if ($i<size($drivers)-1)
		$attr+="_";

	$tempString[0]="FK"+`substitute "angle" $drivers[$i] "rotate"`;
	if (`objExists $tempString[0]`)
		$setAnglesCmd+="setAttr "+$tempString[0]+" "+`getAttr $tempString[0]`+";";
	}

createNode -n BlendedCorrectiveDriver transform;
addAttr -ln driverObj -dt "string" BlendedCorrectiveDriver;
setAttr -type "string" BlendedCorrectiveDriver.driverObj $driverObjs[0];
addAttr -ln driverAttr -dt "string" BlendedCorrectiveDriver;
setAttr -type "string" BlendedCorrectiveDriver.driverAttr $attr;

if (`attributeExists $attr $driverObjs[0]`)
	{
	select $sel;
	return $attr;
	}

addAttr -k 0 -ln $attr -at double $driverObjs[0];
setAttr -e -channelBox true ($driverObjs[0]+"."+$attr);
if (!`gmatch $driverObjs[0] "FK*"` && `objExists ("FK"+$driverObjs[0])`)
	{
	addAttr -k 0 -ln $attr -at double ("FK"+$driverObjs[0]);
	setAttr -e -channelBox true ("FK"+$driverObjs[0]+"."+$attr);
	connectAttr ($driverObjs[0]+"."+$attr) ("FK"+$driverObjs[0]+"."+$attr);
	}

string $mpd,$sr;
string $previousOutput=$driverObjs[0]+"."+$driverAttrs[0];
for ($i=1;$i<size($drivers);$i++)
	{
	$sr=$driverObjs[0]+$attr+"SetRange"+$i;
	$mpd=$driverObjs[0]+$attr+"MultiplyDivide"+$i;
	createNode -n $sr setRange;

	connectAttr -f $previousOutput ($sr+".valueX");
	connectAttr -f ($driverObjs[$i]+"."+$driverAttrs[$i]) ($sr+".valueY");
	setAttr -type float3 ($sr+".max") 1 1 1;
	setAttr ($sr+".oldMaxX") `getAttr ($sr+".valueX")`;
	setAttr ($sr+".oldMaxY") `getAttr ($sr+".valueY")`;
	addAttr -k 1 -ln dvX -at double -dv `getAttr ($sr+".valueX")` $sr;
	addAttr -k 1 -ln dvY -at double -dv `getAttr ($sr+".valueY")` $sr;

	createNode -n $mpd multiplyDivide;
	connectAttr ($sr+".outValueX") ($mpd+".input1.input1X");
	connectAttr ($sr+".outValueY") ($mpd+".input2.input2X");
	if (`getAttr ($sr+".valueX")`<0)	//reverse negative numbers X
		{
		setAttr ($sr+".minX") 1;
		setAttr ($sr+".maxX") 0;
		setAttr ($sr+".oldMinX") (`getAttr ($sr+".oldMaxX")`);
		setAttr ($sr+".oldMaxX") 0;
		}
	if (`getAttr ($sr+".valueY")`<0)	//reverse negative numbers Y
		{
		setAttr ($sr+".minY") 1;
		setAttr ($sr+".maxY") 0;
		setAttr ($sr+".oldMinY") (`getAttr ($sr+".oldMaxY")`);
		setAttr ($sr+".oldMaxY") 0;
		}
	if ($i==(size($drivers))-1)
		{
		addAttr -ln setAnglesCmd -dt "string" $mpd;
		setAttr -type "string" ($mpd+".setAnglesCmd") $setAnglesCmd;
		}
	$previousOutput=($mpd+".outputX");

	}
connectAttr -f $previousOutput ($driverObjs[0]+"."+$attr);
select $sel;
return $attr;
}

global proc string[] asSetBlendedAttribute (string $driverObj, string $driverAttr, float $value, int $getDriversMode)
{
string $tempString[],$drivers[];
string $setAnglesCmd;
int $connectedToMultDiv=1;
string $plug=$driverObj+"."+$driverAttr;
float $dvs[];
while ($connectedToMultDiv)
	{
	$connectedToMultDiv=0;
	$tempString=`listConnections -s 1 -d 0 -scn 1 $plug`;
	string $nodeA=$tempString[0];
	if(size($tempString)>0)
		{
		if (`objectType $nodeA`=="multiplyDivide")
			{
			$connectedToMultDiv=1;
			$plug=$nodeA+".input1.input1X";
			if (`attributeExists setAnglesCmd $nodeA`)
				$setAnglesCmd=`getAttr ($nodeA+".setAnglesCmd")`;
			}
		else if (`objectType $nodeA`=="setRange")
			{
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($nodeA+".valueY")`;
			$drivers[size($drivers)]=$tempString[0];
			$dvs[size($dvs)]=`getAttr ($nodeA+".dvY")`;
			
			$tempString=`listConnections -s 1 -d 0 -p 0 -scn 1 ($nodeA+".valueX")`;
			string $nodeB=$tempString[0];
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($nodeA+".valueX")`;
			if (`objectType $nodeB`=="multiplyDivide")
				{
				$connectedToMultDiv=1;
				$plug=$nodeA+".valueX";
				}
			else
				{
				$drivers[size($drivers)]=$tempString[0];
				$dvs[size($dvs)]=`getAttr ($nodeA+".dvX")`;
				}
			}
		}
	
	}

//For inbetweens, just find the values were all inputs are equal, and sum up to total
if ($value<1)
	for ($i=0;$i<size($dvs);$i++)
		{
		float $temp=`pow $dvs[$i] 2`;
		$dvs[$i]=`sqrt($temp*$value)`;
		}

for ($i=0;$i<size($drivers);$i++)
	if (!$getDriversMode)
		{
		string $setDriver=$drivers[$i];
		if (`gmatch $setDriver "*[.]angle*"`)// blended angles
			eval $setAnglesCmd;
		else
			{
			string $FKDriver="FK"+$drivers[$i];
			if (`objExists $FKDriver`)
				$setDriver=$FKDriver;
			setAttr $setDriver $dvs[$i];
			}
		}
$drivers=`sort $drivers`;
return $drivers;
}

global proc string asCreateCorrectiveShape ()
{
global int $asSkipConfirm;
string $sel[]=`ls -sl -o`;
string $tempString[],$tempString2[];
if(size($sel)==0)
	error "No mesh selected, select geometry on your character";
if (size($sel)>1)
	error "More than 1 object selected, Only 1 object must be selected";
if (`gmatch $sel[0] "*__*"`)
	error "Selected object IS a Corrective Shape. Select geometry on your character";
if ($sel[0]!="")
	if (`objectType $sel[0]`=="mesh")
		$sel=`listRelatives -p $sel[0]`;
$tempString=`listRelatives -ni -s $sel[0]`;
if ($tempString[0]=="")
	error "Selected Object is not geometry";
if (`objectType $tempString[0]`!="mesh")
	error "Selected object is not a mesh";

string $controlSetMembers[];
if (`objExists ControlSet`)
	$controlSetMembers=`sets -q ControlSet`;

//string $tr[]={"t","r"};
//string $xyz[]={"x","y","z"};
string $drivers[],$keyableAttr[];
string $objAttr;
float $poseValue,$currentValue;
//Find driving attribute(s)
string $buildPoseCmds[],$runCmds[];
//get $buildPoseCmds
if (`objExists ControlSet`)
	$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
if (`objExists FaceControlSet`)
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}
string $runObjAttrs[],$checkObjAttr[];
float $runValues[];
for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<2;$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
			$poseValue=0;
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if($z>5) $poseValue=1;//scale
			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];

			if (`gmatch $checkObjAttr[$z] "FKExtra*"`)//must filter FKExtraJaw_M & FKExtraEye_*, so just filter all Extra
				continue;
			if (`gmatch $checkObjAttr[$z] "FKIK*"`)//filter FKIK* as this might be just to get to FK.
				continue;
			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				$drivers[size($drivers)]=$checkObjAttr[$z];
			}
		}
	}
if (size($drivers)==0)
	error ("Found no driving attribute, all values are in Build-Pose");

//For twistDistributed limbs, if not using "Angle", then rx is not excepted, neighter is any mix
if (!`checkBox -q -v asCorrectiveAngleCheckBox`)
	{
	if (`gmatch $drivers[0] "*[.]rotateX"` || `size($drivers)`>1)
		{
		tokenize $drivers[0] "[.]" $tempString;
		int $numChar=size($tempString[0]);
		string $fitJoint=`substring $tempString[0] 3 ($numChar-2)`;
		if (`objExists $fitJoint`)
			if (`attributeExists twistJoints $fitJoint` || `attributeExists inbetweenJoints $fitJoint`)
				{
				warning "Due to \"twistJoints\" or \"inbetweenJoints\" beeing used, rotation values will not work, Now turning On \"Angle\" rotations.";
				checkBox -e -v 1 asCorrectiveAngleCheckBox;
				asCreateCorrectiveShape;
				return "";
				}
		}
	}

for ($i=0;$i<size($drivers);$i++)
	{
	string $nonFKDriver=`substitute "FK" $drivers[$i] ""`;
	if (`objExists $nonFKDriver`)
//		if (!`gmatch $drivers[0] "FK*[.]translate*"`) //(FK*.t* dont have zero default values)
			$drivers[$i]=$nonFKDriver;
	}

tokenize $drivers[0] "[.]" $tempString;
string $deformObj=$sel[0];
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $directDriverAttr=$driverAttr;
float $dv=`getAttr $drivers[0]`;
float $idv=0;

//angle driver
if (`checkBox -q -v asCorrectiveAngleCheckBox`)
	if (`gmatch $driverAttr "r*"`)//rotation && !blended
		{
		if (!`attributeExists "angleX" $driverObj`)
			asCreateAngleAttrs $driverObj;

		//Max 90 degrees
		float $FKdv=`getAttr ("FK"+$drivers[0])`;
		if (abs($FKdv)>90)
			{
			warning ("Angle rotation more than 90 degrees, now reducing rotation to 90.");
			if ($dv>0) $dv=90;
			if ($dv<0) $dv=-90;
			setAttr ("FK"+$drivers[0]) $dv;
			}
		for ($i=0;$i<size($drivers);$i++)
			{
			if (`gmatch $drivers[$i] "*[.]rotate*"`)
				{
				$drivers[$i]=`substitute "rotate" $drivers[$i] "angle"`;
				$driverAttr=`substitute "rotate" $driverAttr "angle"`;
				}
			$idv=$dv;
			$dv=`getAttr ($driverObj+"."+$driverAttr)`;
			if (`gmatch $driverAttr "*X"` && `objExists ("TwistBalancer"+$driverObj)`)
				{
				//$idv special case if RX from a twist-system
				$idv=`getAttr ("TwistBalancer"+$driverObj+"."+$directDriverAttr)`;
				}
			}
		//2 rotation attributes could be translated to 3 angle attributes
		string $XYZ[]={"X","Y","Z"};
		if (size($drivers)>1)
			for ($i=0;$i<size($drivers);$i++)
				{
				for ($y=0;$y<size($XYZ);$y++)
					{
					string $check=$driverObj+".angle"+$XYZ[$y];
					float $checkVal=`getAttr $check`;
					if (abs($checkVal)>0.001)
						if (!`stringArrayCount $check $drivers`)
							{
							$drivers[size($drivers)]=$check;
							$drivers=`sort $drivers`;
							}
					}
				}
		}

if (size($drivers)>1)
	{
	//We might have arrived back here from already created blendAttr
	if (`objExists BlendedCorrectiveDriver`)
		{
		$driverObj=`getAttr BlendedCorrectiveDriver.driverObj`;
		$driverAttr=`getAttr BlendedCorrectiveDriver.driverAttr`;
		$dv=`getAttr ($driverObj+"."+$driverAttr)`;
		}
	else
		{
		string $m="Create Corrective Shape from blend of these drivers?\n\n";
		for ($i=0;$i<size($drivers);$i++)
			{
			float $value=`getAttr $drivers[$i]`;
			$value=`asRoundOff $value 3`;
			$m+=$drivers[$i]+" = "+$value+"\n";
			}
		if (!$asSkipConfirm)
			if (`confirmDialog -t "Multiple Drivers Found"
				-m $m
				-b "OK" -b "Cancel" -db "Cancel"
				-ds "Cancel"`!="OK")
					return "";
		asCreateBlendedAttribute $drivers;
		asCreateCorrectiveShape;
		return "";
		}
	}

string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
$dv=`asRoundOff $dv 3`;

float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr+"__"+$posNeg;

if (size($drivers)==1 && !$asSkipConfirm)
	{
	string $dialog=`confirmDialog -t "Single Driver Found"
		-m ("Create Corrective Shape from this driver?\n\n"+$driverObj+"."+$driverAttr+" = "+$dv)
		-b "OK" -b "Cancel" -db "Cancel"
		-ds "Cancel"`;
	if ($dialog!="OK")
		return "";
	}

asCorrectiveDuplicate $attrCode $sel[0];

addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;

return $attrCode;
}

global proc float asCorrectiveGetIV (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
float $iv=1;
string $bs=$deformObj+"Corrective";
if (!`objExists $bs`)
	return 1;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
float $maxKeyVal;
string $weights[]=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount ($driverObj+"__"+$driverAttr+"__"+$posNeg) $weights`)
	{
	$tempString=`listConnections ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
	float $keyXValues[]=`keyframe -q -fc $tempString[0]`;
	float $keyYValues[]=`keyframe -q -vc $tempString[0]`;
	float $xvalueAtOneY=$keyXValues[size($keyXValues)-1];
	for ($i=0;$i<size($keyYValues);$i++)
		if ($keyYValues[$i]==1)
			$xvalueAtOneY=$keyXValues[$i];

	$iv=$dv/$xvalueAtOneY;
	$iv=`asRoundOff $iv 3`;
	}
return $iv;
}

global proc asCorrectiveDuplicate (string $attrCode, string $source)
{
float $charHeight=`asgetCharHeight`;
duplicate -n $attrCode $source;
asLockAttr $attrCode 0 0 0 0;
string $tempString[]=`listRelatives -p $attrCode`;
if ($tempString[0]!="")
	parent -w $attrCode;
$tempString=`listRelatives -f -s $attrCode`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`=="mesh")
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];
$tempString=`listRelatives -f -s $attrCode`;
rename $tempString[0] ($attrCode+"Shape");

rowLayout -e -en 1 asCorrectiveEditChoicesRowLayout;
button -e -en 0 asCreateCorrectiveButton;
button -e -en 0 asEditCorrectiveButton;
button -e -en 0 asDeleteCorrectiveButton;
button -e -en 0 asGraphCorrectiveButton;
string $group="Group";
if (!`objExists "Group"`) if (`objExists FaceGroup`) $group="FaceGroup";	
setAttr ($group+".v") 0;

$tempString=`ls -sl -l $source`;
if (!`gmatch $tempString[0] "|Group|*"`)
	{
	setAttr ($source+".v") 0;
	if (!`attributeExists "correctiveShapeModeHidden" $group`)
		addAttr -ln "correctiveShapeModeHidden" -dt "string" $group;
	setAttr -type "string" ($group+".correctiveShapeModeHidden") $source;
	}

//setAttr ($attrCode+".tx") ($charHeight*0.5);
select $attrCode;
SculptGeometryTool;

headsUpDisplay -s 2 -b 0 -bs "medium" -l "Corrective Shape Mode" -lfs "large" HUDCSMMode;
scriptJob -runOnce true -e deleteAll "asExitCorrectiveShapeMode";
scriptJob -runOnce true -nodeDeleted $attrCode "asExitCorrectiveShapeMode";
}

global proc asConnectCorrectiveShape ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $tempString[];
if (size($sel)<1)
	error "Select the Corrective Shape";
if (`gmatch $sel[0] "*[.]*"`)
	$sel=`ls -sl -o`;
if (`objectType $sel[0]`!="transform")
	{
	$tempString=`listRelatives -p $sel[0]`;
	$sel[0]=$tempString[0];
	}
if (size($sel)!=1)
	error "Select only the Corrective Shape";
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
string $restoreCmds[];
tokenize `substituteAllString $sel[0] "__"  "|"` "|" $tempString;
string $deformObj=$tempString[0];
string $driverObj=$tempString[1];
string $driverAttr=$tempString[2];
float $dv=`getAttr ($sel[0]+".driverValue")`;
float $idv=`getAttr ($sel[0]+".indirectDriverValue")`;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
float $iv=`getAttr ($sel[0]+".inbetweenValue")`;
int $deleteMode=`objExists DeleteCorrectiveShape`;
string $deltaShape=$driverObj+"__"+$driverAttr+"__"+$posNeg;
string $sdk=$deformObj+"Corrective_"+$deltaShape;
float $keyXValues[];
if (`objExists $sdk`)
	$keyXValues=`keyframe -q -fc $sdk`;
if ($sel[0]==$deformObj)
	error "Can not use itself as Corrective Shape, Select the Corrective Shape";
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;

int $isJoystick=0;
$tempString=`ls -l $driverObj`;
if (`gmatch $tempString[0] "*|ctrlBox|*"`)
	$isJoystick=1;
float $mirrorDv=$dv;
string $mirrorPosNeg=$posNeg;
if (($driverAttr=="translateX" && !$isJoystick) || (`gmatch $driverObj "FK*"` && `gmatch $driverAttr "translate*"`))
	{
	$mirrorDv=$dv*-1;
	if ($posNeg=="pos") $mirrorPosNeg="neg";
	if ($posNeg=="neg") $mirrorPosNeg="pos";
	}
int $doMirror=0;
string $mirrorDriverObj,$FKMirrorDriverObj,$mirrorDeltaShape,$mirrorSdk;
string $side="_R";
string $mirrorDriverAttr=$driverAttr;
string $mirrorSide="_L";
if (`gmatch $driverObj "*_L"`)
	{
	$side="_L";
	$mirrorSide="_R";
	}
if (`checkBox -q -v asCorrectiveMirrorCheckBox`)
	{
	$mirrorDriverObj=`substitute $side $driverObj $mirrorSide`;
	$FKMirrorDriverObj=`substitute $side $FKDriverObj $mirrorSide`;
	$mirrorDeltaShape=`substitute $side $deltaShape $mirrorSide`;
	if ($mirrorPosNeg!=$posNeg)
		$mirrorDeltaShape=`substitute $posNeg $mirrorDeltaShape $mirrorPosNeg`;
	$mirrorSdk=`substitute $side $sdk $mirrorSide`;

	if (`objExists $mirrorDriverObj` && $driverObj!=$mirrorDriverObj)
		{
		$doMirror=1;
		//angle attrs
		if (`gmatch $driverAttr "angle*"`)
			if (!`attributeExists "angleX" $mirrorDriverObj`)
				asCreateAngleAttrs $mirrorDriverObj;
		//blended attrs
		if (`gmatch $driverAttr "*_*"`)
			{
			string $drivers[]=`asSetBlendedAttribute $driverObj $driverAttr 0 1`;
			string $mirroredDrivers[];
			float $driverValues[],$mirroredDriverValues[],$rotates[];
			for ($i=0;$i<size($drivers);$i++)
				{
				$driverValues[$i]=`getAttr $drivers[$i]`;
				$mirroredDriverValues[$i]=$driverValues[$i];
				$mirroredDrivers[$i]=`substitute $side $drivers[$i] $mirrorSide`;
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						$rotates=`getAttr ($FKDriverObj+".r")`;
						setAttr -type float3 ($FKDriverObj+".r") 0 0 0;
						}
					}
				else
					setAttr $drivers[$i] 0;
				if ((`gmatch $mirroredDrivers[$i] "*[.]translateX"` && !$isJoystick) || (`objExists ("FK"+$driverObj)` && `gmatch $mirroredDrivers[$i] "*[.]translate*"`))
					$mirroredDriverValues[$i]=$driverValues[$i]*-1;
				//temporary mirror blended pose
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						setAttr -type float3 ($FKMirrorDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
					}
				else
					setAttr $mirroredDrivers[$i] $mirroredDriverValues[$i];
				}
			//asCreateBlendedAttribute
			$mirrorDriverAttr=`asCreateBlendedAttribute $mirroredDrivers`;
			$mirrorDeltaShape=$mirrorDriverObj+"__"+$mirrorDriverAttr+"__pos";
			//restore blended pose
			for ($i=0;$i<size($drivers);$i++)
				{
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						setAttr -type float3 ($FKMirrorDriverObj+".r") 0 0 0;
						setAttr -type float3 ($FKDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
						}
					}
				else
					{
					setAttr $mirroredDrivers[$i] 0;
					setAttr $drivers[$i] $driverValues[$i];					
					}
				}
			}
		}
	}

string $history[]=`listHistory $deformObj`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			{
			setAttr ($history[$i]+".envelope") 0;
			$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
			}
duplicate -n $deltaShape $deformObj;
asLockAttr $deltaShape 0 0 0 0;
$tempString=`listRelatives -p $deltaShape`;
if ($tempString[0]!="")
	parent -w $deltaShape;

addAttr -k 1 -ln driverValue -at double -dv $dv $deltaShape;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $deltaShape;
if($doMirror && !$deleteMode)
	{
	duplicate -n $mirrorDeltaShape $deformObj;
	asLockAttr $mirrorDeltaShape 0 0 0 0;
	$tempString=`listRelatives -p $mirrorDeltaShape`;
	if ($tempString[0]!="")
		parent -w $mirrorDeltaShape;
	addAttr -k 1 -ln driverValue -at double -dv $mirrorDv $mirrorDeltaShape;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $mirrorDeltaShape;
	}

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

//Inverse shapes from other deformers
//if (`gmatch $driverAttr "*_*"` && `objExists ($deformObj+"Corrective")`)
duplicate -n ($deltaShape+"_componentReverse") $deformObj;
$tempString=`listRelatives -p ($deltaShape+"_componentReverse")`;
if ($tempString[0]!="")
	parent -w ($deltaShape+"_componentReverse");
select $sel[0] $deformObj ($deltaShape+"_componentReverse");
blendShape -n ($deltaShape+"_componentReverseBS") -frontOfChain -w 0 1 -w 1 1;

$history=`listHistory $deformObj`;
string $weights[];
if (`objExists ($deformObj+"Corrective.w")`)
	$weights=`listAttr -m ($deformObj+"Corrective.w")`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			if ($history[$i]==($deformObj+"Corrective"))
				if (`gmatch $driverAttr "*_*"`)
					for ($y=0;$y<size($weights);$y++)
						{
						if ($weights[$y]!=$deltaShape)
							setAttr ($deformObj+"Corrective."+$weights[$y]) 0;
						}
select ($deltaShape+"_componentReverse");
DeleteHistory;
select ($deltaShape+"_componentReverse") $sel[0];
blendShape -n ($deltaShape+"_componentReverseBS2") -frontOfChain -w 0 1;
select $sel[0];
DeleteHistory;
for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);
delete ($deltaShape+"_componentReverse");

//Restore bsTargets that were rest to Zero, by dgdirty. SDK`s will ensure restore.
dgdirty -a;
//eval ($resetTargetsRestoreCmd);

select $deltaShape $deformObj;
asCorrectiveConnectBS;

$weights=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
	setAttr ($deformObj+"Corrective."+$deltaShape) 1;

int $incOnce,$numVtxMoved;
int $numVtxs[]=`polyEvaluate -v $deltaShape`;
float $mag,$prevMag,$move;
float $tol=0.001;
float $selPos[]=`xform -q -ws -t $sel[0]`;
float $deformPos[]=`xform -q -ws -t $deformObj`;
xform -ws -t $deformPos[0] $deformPos[1] $deformPos[2] $sel[0];
float $posA[3],$posA2[3],$posB[3],$temp[3];
string $xyz[]={"x","y","z"};

//get current FKIK blend values
string $controlSetMembers[];
if (`objExists ControlSet`) $controlSetMembers=`sets -q ControlSet`;
string $restoreFKIKCmds[];
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`gmatch $controlSetMembers[$i] "FKIK*_*"`)
		if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
			$restoreFKIKCmds[size($restoreFKIKCmds)]="setAttr "+$controlSetMembers[$i]+".FKIKBlend "+`getAttr ($controlSetMembers[$i]+".FKIKBlend")`+";";

string $restorePoseCmd=`asGetRestorePoseCmd`;
if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;

float $zv=`getAttr ($driverObj+"."+$driverAttr)`;
$zv=`asRoundOff $zv 3`;
float $mirrorZv;
if($doMirror)
	{
	$mirrorZv=`getAttr ($mirrorDriverObj+"."+$mirrorDriverAttr)`;
	$mirrorZv=`asRoundOff $mirrorZv 3`;
	}

//restore all FKIK blend values as berfore GoToBuildPose, since we might have changed to FK to do corrective
for ($i=0;$i<size($restoreFKIKCmds);$i++)
	eval ($restoreFKIKCmds[$i]);

eval($restorePoseCmd);
dgdirty -a;

//Go to `Corrective` Pose, (not guranteed to already be in this pose, specially if editing Existing target)
//asGoToCorrectivePose $driverObj $driverAttr $dv;
//refresh;

$tempString=`listRelatives -f -s $deformObj`;
string $preDeformMesh;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		$preDeformMesh=$tempString[$i];

//matrix loop utilities
float $xPoint[],$yPoint[],$zPoint[],$newPos[];
createNode -n correctiveMatrixUtilities transform;
createNode -n matrix2xform parentConstraint;
createNode -n matrix2scale scaleConstraint;
createNode -n invMReaderOffset transform;
addAttr -ln theMatrix -dt "matrix" invMReaderOffset;
createNode -n invMReader -p invMReaderOffset transform;
createNode -n invMNewPos -p invMReader transform;
createNode -n defOffset transform;
createNode -n corPos -p defOffset transform;
connectAttr -f corPos.translate invMNewPos.translate;
connectAttr -f corPos.rotate invMNewPos.rotate;
connectAttr -f corPos.scale invMNewPos.scale;
//invMReaderOffset.theMatrix to matrixInverter.xform
createNode -n matrixInverter transform;
createNode -n matrix2xform2 parentConstraint;
createNode -n matrix2scale2 scaleConstraint;
connectAttr invMReaderOffset.theMatrix  matrix2xform2.target[0].targetParentMatrix;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateX matrixInverter.translate.translateX;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateY matrixInverter.translate.translateY;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateZ matrixInverter.translate.translateZ;
connectAttr matrix2xform2.constraintRotate.constraintRotateX matrixInverter.rotate.rotateX;
connectAttr matrix2xform2.constraintRotate.constraintRotateY matrixInverter.rotate.rotateY;
connectAttr matrix2xform2.constraintRotate.constraintRotateZ matrixInverter.rotate.rotateZ;
connectAttr invMReaderOffset.theMatrix matrix2scale2.target[0].targetParentMatrix;
connectAttr matrix2scale2.constraintScale matrixInverter.scale;
//matrixInverter.inverseMatrix to invMReader.xform
connectAttr matrixInverter.inverseMatrix matrix2xform.target[0].targetParentMatrix;
connectAttr matrix2xform.constraintTranslate.constraintTranslateX invMReader.translate.translateX;
connectAttr matrix2xform.constraintTranslate.constraintTranslateY invMReader.translate.translateY;
connectAttr matrix2xform.constraintTranslate.constraintTranslateZ invMReader.translate.translateZ;
connectAttr matrix2xform.constraintRotate.constraintRotateX invMReader.rotate.rotateX;
connectAttr matrix2xform.constraintRotate.constraintRotateY invMReader.rotate.rotateY;
connectAttr matrix2xform.constraintRotate.constraintRotateZ invMReader.rotate.rotateZ;
connectAttr matrixInverter.inverseMatrix matrix2scale.target[0].targetParentMatrix;
connectAttr matrix2scale.constraintScale invMReader.scale;
parent matrix2xform matrix2scale invMReaderOffset defOffset matrixInverter matrix2xform2 matrix2scale2 correctiveMatrixUtilities;
//setAttr ($deformObj+"Corrective.envelope") 0;

//Existing blendShape nodes causes a inverse (&multiplied) deformation, so envelope off these.
$history=`listHistory $deformObj`;
clear $restoreCmds;
string $bsNodes[];
string $skinCluster;
for ($i=0;$i<size($history);$i++)
	{
	if (`objectType $history[$i]`=="skinCluster" && $skinCluster=="")
		$skinCluster=$history[$i];
	if (`objectType $history[$i]`=="blendShape" && $history[$i]!="asFaceBS")
		{
		setAttr ($history[$i]+".envelope") 0;
		$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
		}
	}

//Make sure the corrective is the first BS before the skinCluster
catchQuiet (`reorderDeformers $skinCluster ($deformObj+"Corrective") $deformObj`);
//And before "asFaceBS"
if (`objExists "asFaceBS"`)
	catchQuiet (`reorderDeformers "asFaceBS" ($deformObj+"Corrective") $deformObj`);

//xyz Offsets`s
move -r 1 0 0 ($preDeformMesh+".vtx[0:999999]");
duplicate -n xOffsetts $deformObj;
move -r -1 1 0 ($preDeformMesh+".vtx[0:999999]");
duplicate -n yOffsetts $deformObj;
move -r 0 -1 1 ($preDeformMesh+".vtx[0:999999]");
duplicate -n zOffsetts $deformObj;
move -r 0 0 -1 ($preDeformMesh+".vtx[0:999999]");
asLockAttr xOffsetts 0 0 0 0;
asLockAttr yOffsetts 0 0 0 0;
asLockAttr zOffsetts 0 0 0 0;
parent xOffsetts yOffsetts zOffsetts correctiveMatrixUtilities;

progressBar -e -st ("Computing Delta Shape") -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
for ($i=0;$i<$numVtxs[0];$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		progressBar -e -ep $gMainProgressBar;
		xform -ws -t $selPos[0] $selPos[1] $selPos[2] $sel[0];
		blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
		delete $deltaShape;
		if (`objExists $mirrorDeltaShape`)
			delete $mirrorDeltaShape;
		delete correctiveMatrixUtilities;
		select $sel[0];
		print ("// Corrective Shape Cancelled	\n");
		return;
		}
	if ($deleteMode)
		break;
	progressBar -e -s 1 $gMainProgressBar;

	$posA=`xform -q -ws -t ($deformObj+".vtx["+$i+"]")`;
	$posB=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;

	if (abs($posA[0]-$posB[0])<$tol && abs($posA[1]-$posB[1])<$tol && abs($posA[2]-$posB[2])<$tol)
		continue;

	$numVtxMoved++;

	//inverseMatrix
	float $nonDefPos[]=`xform -q -ws -t ($preDeformMesh+".vtx["+$i+"]")`;
	float $defPos[]=`xform -q -ws -t ($deformObj+".vtx["+$i+"]")`;
	float $corPos[]=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;
	xform -ws -t $nonDefPos[0] $nonDefPos[1] $nonDefPos[2] invMReaderOffset;

	xform -ws -t $defPos[0] $defPos[1] $defPos[2] defOffset;
	xform -ws -t $corPos[0] $corPos[1] $corPos[2] corPos;

	$xPoint=`xform -q -ws -t ("xOffsetts.vtx["+$i+"]")`;
	$yPoint=`xform -q -ws -t ("yOffsetts.vtx["+$i+"]")`;
	$zPoint=`xform -q -ws -t ("zOffsetts.vtx["+$i+"]")`;

	setAttr -type "matrix" invMReaderOffset.theMatrix 
	($xPoint[0]-$defPos[0]) ($xPoint[1]-$defPos[1]) ($xPoint[2]-$defPos[2]) 0
	($yPoint[0]-$defPos[0]) ($yPoint[1]-$defPos[1]) ($yPoint[2]-$defPos[2]) 0
	($zPoint[0]-$defPos[0]) ($zPoint[1]-$defPos[1]) ($zPoint[2]-$defPos[2]) 0
	0 0 0 1;

	$newPos=`xform -q -ws -t invMNewPos`;
	xform -ws -t $newPos[0] $newPos[1] $newPos[2] ($deltaShape+".vtx["+$i+"]");
	}
progressBar -e -ep $gMainProgressBar;
//setAttr ($deformObj+"Corrective.envelope") 1;
delete correctiveMatrixUtilities;
xform -ws -t $selPos[0] $selPos[1] $selPos[2] $sel[0];
print ("//Calculated "+$numVtxMoved+" vtx for deltashape\n");

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
eval($restorePoseCmd);
dgdirty -a;

if($doMirror && !$deleteMode)
	{
	createNode -n ($deltaShape+"MirrorGroup") transform;
	parent $deltaShape ($deltaShape+"MirrorGroup");
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	duplicate -n ($mirrorDeltaShape+"Default") $mirrorDeltaShape;
	select ($mirrorDeltaShape+"Default") $deltaShape;
	blendShape -n tempMirrorCorrectiveBS -frontOfChain;
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 1;
	select $mirrorDeltaShape $deltaShape;
	doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" };
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 0;
	select $mirrorDeltaShape;
	DeleteHistory;
	delete ($mirrorDeltaShape+"Default");
	select $mirrorDeltaShape $deformObj;
	asCorrectiveConnectBS;
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	}
if ($deleteMode)
	{
	string $existingTargets[]=`listAttr -m ($deformObj+"Corrective.w")`;
	print ("deleting "+$deltaShape+", (inbetweenValue="+$iv+", value="+$dv+")\n");
	blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
	selectKey -add -k -f $dv $sdk;
	cutKey -animation keys -clear;
	}
delete $deltaShape;
delete $sel[0];
if($doMirror && !$deleteMode)
	delete $mirrorDeltaShape ($deltaShape+"MirrorGroup");
if ($deleteMode)
	delete DeleteCorrectiveShape;
$weights=`listAttr -m ($deformObj+"Corrective.w")`;
if ($iv<1)
	;//print ("Inbetweener..skipping SDK..\n");
if ($iv==1) //SDK for inbetweens not done here
	if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
		{
		if (`objExists $sdk`) if (size($keyXValues)<2) delete $sdk;
		setDrivenKeyframe 														-v 0 -dv $zv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv $dv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		if($doMirror && !$deleteMode)
			{
			if (`objExists $mirrorSdk`) {float $mirrorKeyValues[]=`keyframe -q -fc $mirrorSdk`;if (size($mirrorKeyValues)<2) delete $mirrorSdk;}
			setDrivenKeyframe 														-v 0 -dv $mirrorZv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv $mirrorDv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			}
		}

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;


string $group="Group";
if (!`objExists "Group"`) if (`objExists FaceGroup`) $group="FaceGroup";	
setAttr ($group+".v") 1;
asExitCorrectiveShapeMode;
autoKeyframe -state $autoKeyframe;
select $deformObj;
setToolTo $gSelect;
}

global proc asCancelCorrectiveShape ()
{
global string $gSelect;
string $tempString[];
string $rootLevelObjects[]=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		{
		delete $rootLevelObjects[$i];
		tokenize $rootLevelObjects[$i] "_" $tempString;
		if (`objExists $tempString[0]`)
			select $tempString[0];
		}
if (`objExists "Group"`)
	setAttr "Group.v" 1;
asExitCorrectiveShapeMode;
setToolTo $gSelect;
}

global proc asExitCorrectiveShapeMode ()
{
//setAttr "Group.v" 1; crashes maya :(
rowLayout -e -en 0 asCorrectiveEditChoicesRowLayout;
button -e -en 1 asCreateCorrectiveButton;
button -e -en 1 asEditCorrectiveButton;
button -e -en 1 asDeleteCorrectiveButton;
button -e -en 1 asGraphCorrectiveButton;

string $group="Group";
if (!`objExists "Group"`) if (`objExists FaceGroup`) $group="FaceGroup";	

if (`attributeExists "correctiveShapeModeHidden" $group`)
	setAttr (`getAttr ($group+".correctiveShapeModeHidden")`+".v") 1;
if (`headsUpDisplay -q -ex HUDCSMMode`)
	headsUpDisplay -rem HUDCSMMode;
}

global proc asCorrectiveConnectBS ()
{
int $numLetters;
string $sel[]=`ls -sl`;
string $deltaShape=$sel[0];
string $deformObj=$sel[1];
string $tempString[];
tokenize `substituteAllString $deltaShape "__"  "|"` "|" $tempString;
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $posNeg="pos";
if (`getAttr ($deltaShape+".driverValue")`<0)
	$posNeg="neg";
float $iv=`getAttr ($deltaShape+".inbetweenValue")`;
int $existingTargetNr=-1;
if (`objExists ($deformObj+"Corrective")`) //BSnode Exists (Adding Target to BS node)
	{
	int $inputTargetGroups[]=`getAttr -mi ($deformObj+"Corrective.inputTarget[0].inputTargetGroup")`;
	string $existingTargets[]=`listAttr -m ($deformObj+"Corrective.w")`;
	for ($i=0;$i<size($existingTargets);$i++)
		{
		if ($existingTargets[$i]==$deltaShape)
			$existingTargetNr=$i;
		}
	if ($existingTargetNr!=-1 && $iv==1) // BSnode and BStarget Exists (Replacing target)
		{
		print ("// Replacing BlendShape Target\n");
		connectAttr -f ($deltaShape+".worldMesh[0]") ($deformObj+"Corrective.inputTarget[0].inputTargetGroup["+$inputTargetGroups[$existingTargetNr]+"].inputTargetItem[6000].inputGeomTarget");
		}
	else if ($iv<1 || $iv>1) // BSnode and `similar` target Exists (This must be a inbetween target)
		{
		print ("// connecting inbeween shape at: "+$iv+" for targetNr: "+$existingTargetNr+"\n");
		blendShape -e -inBetween -t $deformObj $inputTargetGroups[$existingTargetNr] $deltaShape $iv ($deformObj+"Corrective");
		//add a key, so this inbeween can be extracted
		setDrivenKeyframe -v $iv -dv `getAttr ($deltaShape+".driverValue")` -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg);
		}
	else
		{
		print ("// Creating New BlendShape\n");
		//Somtimes Maya errors: "Specified blendShape not found in history...";
		print ("blendShape -e -t "+$deformObj+" "+`size($existingTargets)`+" "+$deltaShape+" 1 "+$deformObj+"Corrective;\n");
		blendShape -e -t $deformObj `size($existingTargets)` $deltaShape 1 ($deformObj+"Corrective");
		}
	}
else
	{
	blendShape -n ($deformObj+"Corrective") -frontOfChain;
//	$tempString=`listConnections ($deformObj+"Corrective.outputGeometry[0]")`;
//	rename $tempString[0] ($deformObj+"PB");
	}
}

global proc asPopulateCorrectivePopupMenu (string $action)
{
string $popupMenu="as"+$action+"CorrectiveShapesPopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
string $correctiveBS[]=`ls -r 1 -type blendShape "*Corrective"`;
int $menuExisted,$en;
float $keyXValues[],$keyYValues[];
string $label,$menu,$lev1Menu,$lev2Menu,$lev3Menu,$lev4Menu,$lev5Menu;
string $weights[],$tempString[],$menu2s[],$menu3s[],$menu4s[];
string $menu2Label,$prevMenu2Label,$menu3Label,$prevMenu3Label,$menu4Label,$prevMenu4Label;
for ($i=0;$i<size($correctiveBS);$i++)
	{
	string $deformObj=`substitute "Corrective" $correctiveBS[$i] ""`;
	setParent -menu $popupMenu;
	$sm=1;
	if ($action=="Graph")
		$sm=0;
	$lev1Menu=`menuItem -sm $sm -l $deformObj`;
	if ($action=="Graph")
		{
		menuItem -e -c ("select "+$correctiveBS[$i]+";GraphEditor;") $lev1Menu;
		continue;
		}
	$weights=`listAttr -m ($correctiveBS[$i]+".w")`;
	$weights=`sort $weights`;
	for ($y=0;$y<size($weights);$y++)
		{
		tokenize `substituteAllString $weights[$y] "__"  "|"` "|" $tempString;
		string $driverObj=$tempString[0];
		string $driverAttr=$tempString[1];
		string $posNeg=$tempString[2];
		setParent -menu $lev1Menu;

		//$menu2s
		$prevMenu2Label=$menu2Label;
		$menu2Label=$driverObj;
		if ($menu2Label==$prevMenu2Label)//Re-use
			setParent -menu $lev2Menu;
		else
			{
			setParent -menu $lev1Menu;
			$lev2Menu=`menuItem -sm 1 -l $menu2Label`;
			}
	
		//$menu3s
		$prevMenu3Label=$menu3Label;
		$menu3Label=$driverAttr;
		if ($menu3Label==$prevMenu3Label && $menu2Label==$prevMenu2Label)//Re-use
			setParent -menu $lev3Menu;
		else
			{
			setParent -menu $lev2Menu;
			$lev3Menu=`menuItem -sm 1 -l $menu3Label`;
			}

		//$menu4s
		$prevMenu4Label=$menu4Label;
		$menu4Label=$posNeg;
//		if ($menu4Label==$prevMenu4Label)//Re-use
//			setParent -menu $lev4Menu;
//		else
			{
			setParent -menu $lev3Menu;
			$lev4Menu=`menuItem -sm 1 -l $menu4Label`;
			}

		$sdk=`listConnections ($correctiveBS[$i]+"."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
		$keyXValues=`keyframe -q -fc $sdk`;
		$keyYValues=`keyframe -q -vc $sdk`;
		$haveKeyAtOne=0;
		for ($z=0;$z<size($keyYValues);$z++)
			if ($keyYValues[$z]==1)
				$haveKeyAtOne=1;
		if (!$haveKeyAtOne)
			warning "Found No keys at with \"Y\" value of 1, Unable to determine which shape is not a inbetween";
		float $smallestKeyXValue=99;
		for ($z=0;$z<size($keyXValues);$z++)
			if (abs($keyXValues[$z])<$smallestKeyXValue)
				$smallestKeyXValue=abs($keyXValues[$z]);
		for ($z=0;$z<size($keyXValues);$z++)
			{
			if (($keyXValues[$z]>=0 && $keyXValues[$z]==$smallestKeyXValue) || ($keyXValues[$z]<0 && $keyXValues[$z]==-1*$smallestKeyXValue))
				continue;
			float $roundFactor;
			if ($keyXValues[$z]>0) $roundFactor=0.5;
			else $roundFactor=-0.5;
			$keyXValues[$z]=(trunc($keyXValues[$z]*`pow 10 3`+$roundFactor)/`pow 10 3`); //round to precition of 3
			$cmd="";
			if ($action=="Delete")
				$cmd="createNode -n DeleteCorrectiveShape transform;";
			if ($action=="Edit" || $action=="Delete")
				$cmd+="asEditCorrectiveShape "+$deformObj+" "+$driverObj+" "+$driverAttr+" \""+$keyXValues[$z]+"\" ";
			if ($action=="Delete")
				$cmd+=";asConnectCorrectiveShape;";
			$en=1;
			$label=$keyXValues[$z];
			if ($action=="Delete")
				if ($keyYValues[$z]==1 && size($keyXValues)>2)
//				if (($keyXValues[$z]>0 && size($keyXValues)>2 && $z==size($keyXValues)-1)
//				 || ($keyXValues[$z]<0 && size($keyXValues)>2 && $z==0))
					$en=0;
//			if (($keyXValues[$z]>0 && $z<size($keyXValues)-1) || ($keyXValues[$z]<0 && $z>0))
			if ($keyYValues[$z]!=1)
				$label+=" (inbtw)";
			setParent -menu $lev4Menu;
			menuItem -en $en -l $label -c $cmd;
			}
		}
	}
}

global proc float asSetRotationFromAngle (string $driverObj, string $driverAttr, float $dv)
{
//Dont set `mix` values
if (`gmatch $driverAttr "*_*"`)
	return 1;
string $XYZ=`substitute "angle" $driverAttr ""`;
float $a=1-`abs($dv)`;
float $c=0.707;
float $b=0.707;
float $rads = ((`pow $b 2`) + (`pow $c 2`) - (`pow $a 2`)) /( 2*$b*$c);
float $deg=90-`acosd($rads)`;
if ($dv<0)
	$deg*=-1;
setAttr ("FK"+$driverObj+".rotate"+$XYZ) $deg;
return $deg;
}

global proc asGoToCorrectivePose (string $driverObj, string $driverAttr, float $dv)
{
string $FKIK;
string $tempString[],$tempString2[],$tempString3[],$tempString4[];
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;

//inbetween changes the driverValue
int $numChar=size($driverObj);
string $fitJoint=`substring $driverObj 1 ($numChar-2)`;
if (`objExists $fitJoint`)
	if (`attributeExists inbetweenJoints $fitJoint`)
		$dv=$dv*(`getAttr ($fitJoint+".inbetweenJoints")`+1);

if (!`getAttr -settable ($FKDriverObj+"."+$driverAttr)`)//blended (including blended angles
	{
	asSetBlendedAttribute $driverObj $driverAttr $dv 0;
	if (`gmatch $driverAttr "angle*"`)//single angles (not blended angles)
		$idv=`asSetRotationFromAngle $driverObj $driverAttr $dv`;
	}
else
	setAttr ($FKDriverObj+"."+$driverAttr) $dv;

//Set FKIK to FK (if FK exists)
if (`objExists ("FK"+$driverObj)` && `objExists ("FKX"+$driverObj)` && `objExists ("IKX"+$driverObj)` && `objExists ("FKOffset"+$driverObj)`)
	{
	$tempString=`listConnections ($driverObj+".rx")`;
	if ($tempString[0]!="")
		$tempString2=`listAttr -ud $tempString[0]`;
	if ($tempString2[1]!="")
		$tempString3=`listConnections ($tempString[0]+"."+$tempString2[1])`;
	if (`objExists ($tempString3[0]+".input")`)
		$tempString4=`listConnections ($tempString3[0]+".input")`;
	if ($tempString4[0]!="")
		$FKIK=$tempString4[0];
	if (`objExists $FKIK`)
		setAttr ($FKIK+".FKIKBlend") 0;
	}
}

global proc asEditCorrectiveShape (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
//print ("asEditCorrectiveShape "+$deformObj+" "+$driverObj+" "+$driverAttr+" "+$dv+"\n");
float $idv;
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
//string $restorePoseCmd=`asGetRestorePoseCmd`;
if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;

asGoToCorrectivePose $driverObj $driverAttr $dv;

string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr;
float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
		
if (`objExists $attrCode`)
	warning ("Object "+$attrCode+" already exists");
else
	{
	asCorrectiveDuplicate $attrCode $deformObj;
	addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
	addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;
	}
//asGoToBuildPose bodySetup;
//eval($restorePoseCmd);
autoKeyframe -state $autoKeyframe;
dgdirty -a;
}

global proc asCBDCreateCurves ()
{
string $sel[]=`ls -sl`;
string $mesh=`textField -q -tx asBodyCorrectiveCBDMeshTextField`;
string $fkControl=`textField -q -tx asBodyCorrectiveCBDFKControlTextField`;
string $joint=`substitute "FK" $fkControl ""`;
string $curveCmd,$curve,$slideSideNr,$axis,$parentJoint,$childJoint,$getXFrom,$deleteSlidersCmd;
string $tempString[],$curves[],$startProfile;
float $pos[],$tempPos[];
float $fat,$parentfat,$childfat;
int $haveSkinCage=`objExists SkinCage`;
int $rotYonly,$rotZonly,$singleAxisPositive;

if (!`gmatch $fkControl "FK*"`)
	error "Select FK-controller(s)";
if ($mesh=="")
	error "Mesh must be chosen";

if (!$haveSkinCage)
	{
	asCreateSkinCage;
	asSkinCurvesToWidth;
	setAttr SkinCage.v 0;
	setAttr SkinCurves1.v 0;
	setAttr SkinCurves2.v 0;
	}
select -cl;
if (`objExists tempLoc`)
	delete tempLoc;
if (`objExists curveDeformationObjects`)
	delete `sets -q curveDeformationObjects`;
createNode -n curveDeformationObjects objectSet;
createNode -n curveDeformationSetup transform;
sets -add curveDeformationObjects curveDeformationSetup;
addAttr -ln mesh -dt "string" curveDeformationSetup;
setAttr -l 1 -type "string" curveDeformationSetup.mesh $mesh;
addAttr -ln fkControl -dt "string" curveDeformationSetup;
setAttr -l 1 -type "string" curveDeformationSetup.fkControl $fkControl;

$tempString=`listRelatives -type joint -p $joint`;
while (`gmatch $tempString[0] "*Part[0-9]*"`)
	$tempString=`listRelatives -type joint -p $tempString[0]`;
$parentJoint=$tempString[0];
$tempString=`listRelatives -type joint -c $joint`;
while (`gmatch $tempString[0] "*Part[0-9]*"`)
	$tempString=`listRelatives -type joint -c $tempString[0]`;
$childJoint=$tempString[0];
$fat=`getAttr ($joint+".fat")`*`getAttr  ($joint+".fatZ")`;
$parentfat=`getAttr ($parentJoint+".fat")`*`getAttr  ($parentJoint+".fatZ")`;
$childfat=`getAttr ($childJoint+".fat")`*`getAttr  ($childJoint+".fatZ")`;

//find $startProfile & $endProfile
if (`objExists ($joint+"_startProfile")`) $startProfile=$joint+"_startProfile";
else
	for ($y=20;$y>0;$y--)
		if (`objExists ($parentJoint+"_twistProfile"+$y)`)
			{
			$startProfile=$parentJoint+"_twistProfile"+$y;
			break;
			}

if (`objExists ($joint+"_endProfile")`) $endProfile=$joint+"_endProfile";
else
	if (`objExists ($joint+"_twistProfile1")`)
		$endProfile=$joint+"_twistProfile1";
//if (!`objExists $endProfile`)
//	$endProfile=$childJoint+"_middleProfile";

//Ensure sliders
if (!`objExists ($joint+"_middleSlider0")`) {select ($joint+"_middleProfile");asCreateSliders;$deleteSlidersCmd+="select "+$joint+"_middleProfile;asDeleteSliders;";}
if (!`objExists ($joint+"_startSlider0")`)
	if (`objExists $startProfile`){select $startProfile;asCreateSliders;$deleteSlidersCmd+="select "+$startProfile+";asDeleteSliders;";}
	else
		{
		for ($i=0;$i<5;$i++)
			if (`objExists ($joint+"_middleSlider"+$i)`)
				{
				duplicate -n ($joint+"_startSlider"+$i) ($joint+"_middleSlider"+$i);
				parent ($joint+"_startSlider"+$i) $joint;
				setAttr ($joint+"_startSlider"+$i+".tx") `getAttr ($joint+".tx")`;
				}
		}
if (!`objExists ($joint+"_endSlider0")`)
	if (`objExists $endProfile`){select $endProfile;asCreateSliders;$deleteSlidersCmd+="select "+$endProfile+";asDeleteSliders;";}
	else
		{
		for ($i=0;$i<5;$i++)
			if (`objExists ($joint+"_middleSlider"+$i)`)
				{
				duplicate -n ($joint+"_endSlider"+$i) ($joint+"_middleSlider"+$i);
				parent ($joint+"_endSlider"+$i) $joint;
				setAttr ($joint+"_endSlider"+$i+".tx") `getAttr ($childJoint+".tx")`;
				}
		}

//$rotYonly,$rotZonly & $singleAxisPositive
$rotYonly=$rotZonly=0;
if (!`objExists ($joint+"_middleSlider0")`) $rotYonly=1;
if (!`objExists ($joint+"_middleSlider1")`) $rotZonly=1;
$singleAxisPositive=0;
if ($rotYonly && `getAttr ($joint+".jointOrientY")`>0) $singleAxisPositive=1;
if ($rotZonly && `getAttr ($joint+".jointOrientZ")`>0) $singleAxisPositive=1;
addAttr -k 1 -ln "rotYonly" -at bool -dv $rotYonly curveDeformationSetup;
addAttr -k 1 -ln "rotZonly" -at bool -dv $rotZonly curveDeformationSetup;
addAttr -k 1 -ln "singleAxisPositive" -at bool -dv $singleAxisPositive curveDeformationSetup;

spaceLocator -n tempLoc;
pointConstraint $parentJoint $joint $childJoint tempLoc;
parent tempLoc $joint;
setAttr -type float3 tempLoc.r 0 0 0;

for ($a=1;$a>-2;$a=$a-2)
	{
	if ($a==1)  $axis="Y";
	if ($a==-1) $axis="Z";
	if ($rotYonly && $axis=="Y") continue;
	if ($rotZonly && $axis=="Z") continue;

	for ($b=1;$b>-2;$b=$b-2)
		{
		$curveCmd="curve -d 3";
		if ($b==1)  $curve="deformationCurve"+$axis+"1";
		if ($b==-1) $curve="deformationCurve"+$axis+"2";
		if ($a==1  && $b==1)  $slideSideNr="2";
		if ($a==1  && $b==-1) $slideSideNr="0";
		if ($a==-1 && $b==1)  $slideSideNr="3";
		if ($a==-1 && $b==-1) $slideSideNr="1";

		$curves[size($curves)]=$curve;
		setAttr -type float3 ("tempLoc_pointConstraint1.offset") 0 0 0;
		for ($y=0;$y<9;$y++)
			{
			if ($y==0)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 1;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 0;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 0;
				setAttr ("tempLoc_pointConstraint1.offset"+$axis) ($parentfat*$b);
				$pos=`xform -q -ws -t tempLoc`;
				}
			if ($y==1)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 3;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 0;
				$pos=`xform -q -ws -t tempLoc`;
				}
			if ($y==2)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 1;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 0;
				setAttr ("tempLoc_pointConstraint1.offset"+$axis) ((($fat+$parentfat)/2.0)*$b);
				$pos=`xform -q -ws -t tempLoc`;
				}

			if ($y<3 && `gmatch $joint "*_R"` && `gmatch $parentJoint "*_M"` && $curve!="deformationCurveZ1")
				{//Branching such as Hip, not to extend to far across axis
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 0;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				$tempPos=`xform -q -ws -t tempLoc`;
				$pos[0]=$tempPos[0];
				}
			if ($y<3 && `gmatch $joint "*_R"` && $pos[0]>0)
				$pos[0]=0;

			if ($y==3)
				{
				$pos=`xform -q -ws -t ($joint+"_startSlider"+$slideSideNr)`;
				}
			if ($y==4)
				{
				$pos=`xform -q -ws -t ($joint+"_middleSlider"+$slideSideNr)`;
				}
			if ($y==5)
				{
				$pos=`xform -q -ws -t ($joint+"_endSlider"+$slideSideNr)`;
				}
			if ($y==6)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 0;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 1;
				setAttr ("tempLoc_pointConstraint1.offset"+$axis) ((($fat+$childfat)/2.0)*$b);
				$pos=`xform -q -ws -t tempLoc`;
				}
			if ($y==7)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 0;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 3;
				$pos=`xform -q -ws -t tempLoc`;
				}
			if ($y==8)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 0;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 0;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 1;
				setAttr ("tempLoc_pointConstraint1.offset"+$axis) ($childfat*$b);
				$pos=`xform -q -ws -t tempLoc`;
				}
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			}
		$curveCmd+=" -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 6 -k 6";
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] $curve;
		setAttr ($curve+".dispCV") 1;
		parent $curve curveDeformationSetup;
		select $childJoint $parentJoint ($joint+"_startSlider"+$slideSideNr) ($joint+"_middleSlider"+$slideSideNr) ($joint+"_endSlider"+$slideSideNr) $curve;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($curve+"SC");
		for ($y=0;$y<9;$y++)
			{
			if ($y==0) skinPercent -tv $parentJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==1) skinPercent -tv $parentJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==2) skinPercent -tv $parentJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==3) skinPercent -tv ($joint+"_startSlider"+$slideSideNr) 1	($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==4) skinPercent -tv ($joint+"_middleSlider"+$slideSideNr) 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==5) skinPercent -tv ($joint+"_endSlider"+$slideSideNr) 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==6) skinPercent -tv $childJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==7) skinPercent -tv $childJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==8) skinPercent -tv $childJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			}
		}
	}
if (`objExists deformationCurveZ1` && `objExists deformationCurveY2`)
	reorder -relative -1 deformationCurveZ1;
delete tempLoc;

addAttr -k 1 -ln haveSkinCage -at bool -dv $haveSkinCage curveDeformationSetup;
addAttr -ln deleteSlidersCmd -dt "string" curveDeformationSetup;
setAttr -type "string" curveDeformationSetup.deleteSlidersCmd $deleteSlidersCmd;

select $curves;
}

global proc asCBDCreateTestAnim ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
string $fkControl=`getAttr curveDeformationSetup.fkControl`;
int $rotYonly=`getAttr curveDeformationSetup.rotYonly`;
int $rotZonly=`getAttr curveDeformationSetup.rotZonly`;
int $singleAxisPositive=`getAttr curveDeformationSetup.singleAxisPositive`;
float $singleAxisRotValue=-90;
if ($singleAxisPositive)
	$singleAxisRotValue=90;

currentTime 0;
if ($rotYonly || $rotZonly)
	{
	playbackOptions -min 0 -ast 0 -aet 10 -max 10;
	if ($rotYonly) setKeyframe ($fkControl+".ry");
	if ($rotZonly) setKeyframe ($fkControl+".rz");
	currentTime 10;
	if ($rotYonly)	{setAttr ($fkControl+".ry") $singleAxisRotValue;setKeyframe ($fkControl+".ry");}
	if ($rotZonly)	{setAttr ($fkControl+".rz") $singleAxisRotValue;setKeyframe ($fkControl+".rz");}
	}
else
	{
	playbackOptions -min 0 -ast 0 -aet 80 -max 80;
	setKeyframe ($fkControl+".r");
	currentTime 10;setAttr ($fkControl+".ry") 90;setKeyframe ($fkControl+".r");
	currentTime 20;setAttr ($fkControl+".ry") 0;setKeyframe ($fkControl+".r");
	currentTime 30;setAttr ($fkControl+".ry") -90;setKeyframe ($fkControl+".r");
	currentTime 40;setAttr ($fkControl+".ry") 0;setKeyframe ($fkControl+".r");
	currentTime 50;setAttr ($fkControl+".rz") 90;setKeyframe ($fkControl+".r");
	currentTime 60;setAttr ($fkControl+".rz") 0;setKeyframe ($fkControl+".r");
	currentTime 70;setAttr ($fkControl+".rz") -90;setKeyframe ($fkControl+".r");
	currentTime 80;setAttr ($fkControl+".rz") 0;setKeyframe ($fkControl+".r");
	}
refresh;
currentTime 5;
}

global proc asCBDHideMesh ()
{
string $source=`textField -q -tx asBodyCorrectiveCBDMeshTextField`;
if (`objExists $source`)
	setAttr ($source+".v") 0;
}

global proc asCBDCreateDeformMesh ()
{
float $pos[];
float $radius;
float $currentTime=`currentTime -q`;
string $tempString[];
string $existingSkinCluster,$newSkinCluster;
currentTime 0;

if (`objExists Corrective`) delete Corrective;
if (`objExists deformationLoft`) delete deformationLoft;

string $mesh=`getAttr curveDeformationSetup.mesh`;
string $fkControl=`getAttr curveDeformationSetup.fkControl`;
string $joint=`substitute "FK" $fkControl ""`;
int $rotYonly=`getAttr curveDeformationSetup.rotYonly`;
int $rotZonly=`getAttr curveDeformationSetup.rotZonly`;
int $singleAxisPositive=`getAttr curveDeformationSetup.singleAxisPositive`;
string $curves[]=`listRelatives -c curveDeformationSetup`;

select $curves;
//	select $curves[0] $curves[2] $curves[1] $curves[3];
$tempString=`loft -n deformationLoft -ch 1 -u 1 -c 1 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true`;
setAttr deformationLoftShape.curvePrecisionShaded 4;
setAttr deformationLoft.v 0;
parent deformationLoft curveDeformationSetup;

duplicate -n Corrective $mesh;
asLockAttr Corrective 0 0 0 0;
parent Corrective curveDeformationSetup;
setAttr Corrective.v 1;
$tempString=`listRelatives -s Corrective`;
for ($z=0;$z<size($tempString);$z++)
	if (`getAttr ($tempString[$z]+".intermediateObject")`)
		delete $tempString[$z];

//skinCluster first (fir out-of-bounds-regions)
$tempString=`listHistory -pdo 1 $mesh`;
for ($y=0;$y<size($tempString);$y++)
	if (`nodeType $tempString[$y]` == "skinCluster")
		$existingSkinCluster=$tempString[$y];
select Corrective `listConnections ($existingSkinCluster+".matrix")`;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] CorrectiveSC;
$tempString=`listConnections CorrectiveSC.message`;
rename $tempString[0] CorrectiveSCSet;
select $mesh Corrective;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

sets -add curveDeformationObjects $curves deformationLoft Corrective;
select -r Corrective deformationLoft;$tempString=`doWrapArgList "7" { "1","0","1", "2", "0", "1", "1", "0" }`;
//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
rename $tempString[0] CorrectiveWrap;
$tempString=`listConnections CorrectiveWrap.message`;
rename $tempString[0] CorrectiveWrapSet;
if (`gmatch $joint "*_R"`)
	{
	polySelectConstraint -m 3 -t 1 -d 3 -db 0 999 -da 1 0 0 -dp 999 0 0;
	sets -remove CorrectiveWrapSet `ls -sl`;
	}

$pos=`xform -q -ws -t $fkControl`;
select Corrective;
$radius=(`getAttr ($joint+".fat")`*`getAttr ($joint+".fatZ")`)*6;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $radius -dp $pos[0] $pos[1] $pos[2];
$tempString=`ls -sl`;
polySelectConstraint -m 0;
catchQuiet (`sets -remove CorrectiveSCSet $tempString`);
asInvertSelection;
sets -remove CorrectiveWrapSet `ls -sl`;
ConvertSelectionToFaces;
delete;
$tempString=`listConnections -s 1 -d 0 Corrective.inMesh`;
rename $tempString[0] CorrectiveDeleteComponent;

currentTime $currentTime;
}

global proc asCBDShowOriginal ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
setAttr ($mesh+".v") 1;
setAttr Corrective.v 0;
}

global proc asCBDShowNew ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
setAttr ($mesh+".v") 0;
setAttr Corrective.v 1;
}

global proc asCBBakeDeformMesh ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
string $fkControl=`getAttr curveDeformationSetup.fkControl`;
int $rotYonly=`getAttr curveDeformationSetup.rotYonly`;
int $rotZonly=`getAttr curveDeformationSetup.rotZonly`;
int $singleAxisPositive=`getAttr curveDeformationSetup.singleAxisPositive`;

setAttr ($mesh+".v") 1;
textField -e -tx Corrective asBakeToCorrective1TextField;
textField -e -tx $mesh asBakeToCorrective2TextField;

if (`objExists CorrectiveDeleteComponent`)
	delete CorrectiveDeleteComponent;

string $checkBoxes[]=`rowLayout -q -ca asBakeAxisRowLayout`;
for ($i=0;$i<size($checkBoxes);$i++)
	if ($rotYonly || $rotZonly)
		checkBox -e -v 0 $checkBoxes[$i];
	else
		checkBox -e -v 1 $checkBoxes[$i];
checkBox -e -v 0 asBakeX1CheckBox;
checkBox -e -v 0 asBakeX2CheckBox;
if ($rotYonly && $singleAxisPositive) checkBox -e -v 1 asBakeY1CheckBox;
if ($rotYonly && !$singleAxisPositive) checkBox -e -v 1 asBakeY2CheckBox;
if ($rotZonly && $singleAxisPositive) checkBox -e -v 1 asBakeZ1CheckBox;
if ($rotZonly && !$singleAxisPositive) checkBox -e -v 1 asBakeZ2CheckBox;

if ($rotYonly || $rotZonly)
	checkBox -e -v 0 asCorrectiveAngleCheckBox;
else
	checkBox -e -v 1 asCorrectiveAngleCheckBox;

select $fkControl;
asBakeIntoCorrectiveShapes;
textField -e -tx "" asBakeToCorrective1TextField;
textField -e -tx "" asBakeToCorrective2TextField;

asCBCleanup;
print "// CurveBased Deformation Corrective BlendShape complete.\n";
}

global proc asCBCleanup ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
string $fkControl=`getAttr curveDeformationSetup.fkControl`;
eval (`getAttr curveDeformationSetup.deleteSlidersCmd`);
if (!`getAttr curveDeformationSetup.haveSkinCage`)
	asDeleteSkinCage;

delete `sets -q curveDeformationObjects`;
setAttr ($mesh+".v") 1;
string $tempString[]=`listConnections -s 1 -d 0 -type animCurveTA $fkControl`;
for ($i=0;$i<size($tempString);$i++)
	delete $tempString[$i];
setAttr -type float3 ($fkControl+".r") 0 0 0;
}

global proc asBakeIntoCorrectiveShapes ()
{
global int $asSkipConfirm;
string $sel[]=`ls -sl`;
string $source=`textField -q -tx asBakeToCorrective1TextField`;
string $dest=`textField -q -tx asBakeToCorrective2TextField`;
if ($source=="" || !`objExists $source` || `gmatch $source "*[.]*"`)
	error "Source not valid";
if ($dest=="" || !`objExists $dest` || `gmatch $dest "*[.]*"`)
	error "Destination not valid";
string $tempString[]=`listRelatives -s -ni $source`;
string $sourceShape=$tempString[0];
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
asSetAllFK;
select -cl;
$asSkipConfirm=1;
string $xyz[]={"x","x","y","y","z","z"};
float $rots[]={90,-90,90,-90,90,-90};
for ($i=0;$i<size($sel);$i++)
	{
	print ("// Start checking:"+$sel[$i]+"\n");
	if (!`gmatch $sel[$i] "FK*"`)
		continue;
	if (!`sets -im ControlSet $sel[$i]`)
		continue;
	if (`gmatch $sel[$i] "FKExtra*"`)
		continue;
	if (`gmatch $sel[$i] "FKRoot*"`)
		continue;
	for ($y=0;$y<size($xyz);$y++)
		{
		if ($y==0 && !`checkBox -q -v asBakeX1CheckBox`) continue;
		if ($y==1 && !`checkBox -q -v asBakeX2CheckBox`) continue;
		if ($y==2 && !`checkBox -q -v asBakeY1CheckBox`) continue;
		if ($y==3 && !`checkBox -q -v asBakeY2CheckBox`) continue;
		if ($y==4 && !`checkBox -q -v asBakeZ1CheckBox`) continue;
		if ($y==5 && !`checkBox -q -v asBakeZ2CheckBox`) continue;
		print ("// Baking:"+$sel[$i]+".r"+$xyz[$y]+"="+$rots[$y]+"\n");
		setAttr ($sel[$i]+".r"+$xyz[$y]) $rots[$y];
		refresh;
		select $dest;
		$corrective=`asCreateCorrectiveShape`;
		$tempString=`listRelatives -s -ni $corrective`;
		$correctiveShape=$tempString[0];
		connectAttr -f ($sourceShape+".outMesh") ($correctiveShape+".inMesh");
		asConnectCorrectiveShape;
		setAttr ($sel[$i]+".r"+$xyz[$y]) 0;
		}
	}
$asSkipConfirm=0;
eval($restorePoseCmd);
select $sel;
}

global proc string asGetRestorePoseCmd ()
{
string $restorePoseCmd;
string $controlSetMembers[];
if (`objExists ControlSet`) $controlSetMembers=`sets -q ControlSet`;
if (`objExists FaceControlSet`)
	{
	string $faceControlSetMembers[]=`sets -q FaceControlSet`;
	$controlSetMembers=`stringArrayCatenate $controlSetMembers $faceControlSetMembers`;
	}
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	string $attrs[]=`listAttr -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		{
		if (`getAttr -l ($controlSetMembers[$i]+"."+$attrs[$y])`)
			continue;
		if (!`getAttr -settable ($controlSetMembers[$i]+"."+$attrs[$y])`)
			continue;
		$restorePoseCmd+="setAttr "+$controlSetMembers[$i]+"."+$attrs[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$attrs[$y])`+";";
		}
	}

return $restorePoseCmd;
}

global proc asJointVis (int $onOff)
{
if (!`objExists Main`)
	return;
string $joints[]=`listRelatives -type joint -ad Main`;
int $drawStyle=0;
if (!$onOff)
	$drawStyle=2;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".drawStyle") $drawStyle;
}

global proc asSkinCurvesToWidth ()
{
if (!`objExists SkinCurves2` || !`objExists SkinCurves1`)
	error "SkinCurves not found. Create SkinCage first";
float $pos[],$pos2[];
string $skinCurves1[]=`listConnections SkinCurves1.drawInfo`;
string $skinCurves2[]=`listConnections SkinCurves2.drawInfo`;
string $tempString[];
string $joint,$aboveBelowProfile,$belowProfile,$parentJoint,$parentTarget;
for ($i=0;$i<size($skinCurves1);$i++)
	{
	tokenize $skinCurves1[$i] "_" $tempString;
	$joint="";
	for ($y=0;$y<size($tempString)-1;$y++)
		{
		$joint+=$tempString[$y];
		if ($y<size($tempString)-2)
			$joint+="_";
		}
	if (!`objExists $joint`)
		continue;
	$tempString=`listRelatives -type joint -p $joint`;
	while (`gmatch $tempString[0] "*Part[0-9]*"`)
		$tempString=`listRelatives -type joint -p $tempString[0]`;
	$parentJoint=$tempString[0];
	if (!`objExists $parentJoint`)
		continue;
	$tempString=`listRelatives -type joint -c $joint`;
	$childJoint=$tempString[0];
	if (!`objExists $childJoint`)
		continue;

	//ignore `inbetween` joints
	$tempString=`listRelatives -type joint -c $joint`;
	if (`gmatch $tempString[0] "*Part[0-9]*"` && !`attributeExists twistAmount $tempString[0]`)
		continue;
	$tempString=`listRelatives -type joint -p $joint`;
	if (`gmatch $tempString[0] "*Part[0-9]*"` && !`attributeExists twistAmount $tempString[0]`)
		continue;

	for ($a=0;$a<2;$a++)
		{
		// find profile
		$aboveBelowProfile="";
		if ($a==0 && !`attributeExists noStartCurve $joint`)
			{
			if (`objExists ($joint+"_startProfile")`)
				$aboveBelowProfile=$joint+"_startProfile";
			else
				{
				for ($y=20;$y>0;$y--)
					if (`objExists ($parentJoint+"_twistProfile"+$y)`)
						{
						$aboveBelowProfile=$parentJoint+"_twistProfile"+$y;
						break;
						}
				}
			if ($aboveBelowProfile=="")
				continue;
			}
		if ($a==1)
			{
			if (`objExists ($joint+"_endProfile")`)
				$aboveBelowProfile=$joint+"_endProfile";
			else
				{
				for ($y=1;$y<21;$y++)
					if (`objExists ($joint+"_twistProfile"+$y)`)
						{
						$aboveBelowProfile=$joint+"_twistProfile"+$y;
						break;
						}
				}
			}
		if ($aboveBelowProfile=="" || `gmatch $aboveBelowProfile "Neck*"`)//skip neck
			continue;
	
		// place profile
		int $targetIds[2]={0,1};
		$tempString=`listRelatives -p $aboveBelowProfile`;
		string $offsetNode=$tempString[0];
		string $parentConstraint=$offsetNode+"_pointConstraint1";
		string $scaleConstraint=$offsetNode+"_scaleConstraint1";
		string $targetAttrs[]=`listAttr -ud $parentConstraint`;
		setAttr -type float3 ($parentConstraint+".offset") 0 0 0;
		$tempString=`listConnections ($parentConstraint+".target[0].targetParentMatrix")`;
		if ($tempString[0]==`substitute "Profile" $skinCurves1[$i] "Curve"`)
			{
			$targetIds={1,0};
			$tempString=`listConnections ($parentConstraint+".target[1].targetParentMatrix")`;
			if ($tempString[0]=="")
				continue;
			}
		$parentTarget=$tempString[0];
		$pos=`xform -q -ws -t $skinCurves1[$i]`;
		$pos2=`xform -q -ws -t $parentTarget`;
		float $toParentDist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	
		$tempString=`listRelatives -c $skinCurves1[$i]`;
		$innerCurve=$tempString[0];
		$pos=`xform -q -ws -t ($innerCurve+".cv[0]")`;
		$pos2=`xform -q -ws -t ($innerCurve+".cv[1]")`;
		float $curveHeight=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		$pos=`xform -q -ws -t ($innerCurve+".cv[1]")`;
		$pos2=`xform -q -ws -t ($innerCurve+".cv[2]")`;
		float $curveWidth=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		float $hwAverage=($curveHeight+$curveWidth)/2.0;
	
		if ($targetAttrs[1]!="")
			{
			float $weight=($hwAverage/2.0)/$toParentDist;
			if ($weight>1)
				$weight=1;
			setAttr ($parentConstraint+"."+$targetAttrs[$targetIds[0]]) $weight;
			setAttr ($parentConstraint+"."+$targetAttrs[$targetIds[1]]) (1-$weight);
			setAttr ($scaleConstraint+"."+$targetAttrs[$targetIds[0]]) $weight;
			setAttr ($scaleConstraint+"."+$targetAttrs[$targetIds[1]]) (1-$weight);
			}
		}
	}
}

global proc asAddWristDetails ()
{
global string $gMove;
float $pos[],$pos2[];
string $sel[]=`ls -sl`;
string $cv,$vtx;
string $tempString[],$locs[],$locVtxs[],$locCageVtxs[],$locCageMirrorVtxs[];
string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";

file -i $asGeometryFile;
setAttr WristDetails.v 1;
setAttr WristDetailsLocators.v 1;
parent -w WristDetails WristDetailsLocators;
if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;

$locs=`listRelatives -c WristDetailsLocators`;
for ($i=0;$i<size($locs);$i++)
	{
	tokenize $locs[$i] "_" $tempString;
	$cv=$tempString[0]+"_"+$tempString[1]+"_"+$tempString[2]+"."+$tempString[3]+"["+$tempString[4]+"]";
	if (!`objExists $cv`)
		{
		if (`objExists closestSampler`) delete closestSampler;
		warning ("Skipped, because \""+$cv+"\" not found");
		delete WristDetails WristDetailsLocators;
		return;
		}
	$pos=`xform -q -ws -t $cv`;
	$pos2=`xform -q -ws -t $locs[$i]`;
	setAttr closestSampler.inPosition $pos2[0] $pos2[1] $pos2[2];
	connectAttr -f WristDetails.outMesh closestSampler.inMesh;
	$vtx="WristDetails.vtx["+`getAttr closestSampler.closestVertexIndex`+"]";
	$locVtxs[$i]=$vtx;

	//get $locCageVtxs
	connectAttr -f skinCage.outMesh closestSampler.inMesh;
	setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$locCageVtxs[$i]="skinCage.vtx["+`getAttr closestSampler.closestVertexIndex`+"]";
	xform -ws -t $pos[0] $pos[1] $pos[2] $vtx;
	//get $mirrorVtx as well
	setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
	$locCageMirrorVtxs[$i]="skinCage.vtx["+`getAttr closestSampler.closestVertexIndex`+"]";
	}
delete WristDetailsLocators;

select $locVtxs;
asInvertSelection;

$pos=`xform -q -ws -t ThumbFinger2_R_startCurve.cv[2]`;
$pos2=`xform -q -ws -t ThumbFinger2_R_middleCurve.cv[2]`;
xform -ws -t ($pos[0]+($pos[0]-$pos2[0])) ($pos[1]+($pos[1]-$pos2[1])) ($pos[2]+($pos[2]-$pos2[2])) WristDetails.vtx[30];
select -d WristDetails.vtx[30];

for ($i=0;$i<15;$i++)
	polyAverageVertex -i 10 -ch 0;

setToolTo $gMove;
$pos=`manipMoveContext -q -position "Move"`;
scale -r -p $pos[0] $pos[1] $pos[2] 1.13 1.13 1.13;

select -r skinCage WristDetails;
transferAttributes -transferPositions 0 -transferNormals 0 -transferUVs 2 -transferColors 0 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;
select -r WristDetails;
DeleteHistory;

select $locCageVtxs $locCageMirrorVtxs;
ConvertSelectionToContainedFaces;
delete;

//combine and merge, via new skinCage
rename skinCage skinCageOld;
rename skinClusterSkinCage skinClusterSkinCageOld;
rename wrapSkinCage wrapSkinCageOld;
duplicate -n WristDetailsMirrored WristDetails;
scale -r -p 0 0 0 -1 1 1 WristDetailsMirrored.vtx[0:9999];
duplicate -n skinCageCopy skinCageOld;
polyUnite -n skinCage -ch 0 -mergeUVSets 1 skinCageCopy WristDetails WristDetailsMirrored;
parent skinCage Cages;
editDisplayLayerMembers -noRecurse SkinCage skinCage;
delete skinCageCopy;
polyMergeVertex -ch 0 -d 0.001 -am 1 skinCage;
//bindSkin
select `listConnections skinClusterSkinCageOld.matrix`;
select -add skinCage;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] skinClusterSkinCage;
select -r skinCageOld skinCage;
copySkinWeights  -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
delete skinCageOld;
//wrap
$cylinders=`ls -type transform "*_poly"`;
select -cl;
deformer -type wrap skinCage;
for ($i=0;$i<size($cylinders);$i++)
	{
	$tempString=`listRelatives -p $cylinders[$i]`;
	if ($tempString[0]!="MeshGeometry")
		continue;
	select -r skinCage;
	select -add $cylinders[$i];
	AddWrapInfluence;
	}
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] wrapSkinCage;
reorderDeformers "skinClusterSkinCage" "wrapSkinCage" "skinCage";

if (`objExists closestSampler`) delete closestSampler;
select $sel;
}

global proc asCreateGroinLocators ()
{
if (`objExists GroinStart`) delete GroinStart;
if (`objExists GroinSide`) delete GroinSide;
spaceLocator -n GroinStart;
spaceLocator -n GroinSide;
float $posA[]=`xform -q -ws -t Root`;
float $posB[]=`xform -q -ws -t Root_M_middleCurve.cv[2]`;
xform -ws -t 0 ($posA[1]*0.9) $posA[2] GroinStart;
xform -ws -t $posB[0] ($posB[1]*1.03) $posA[2] GroinSide;
select -cl;
}

global proc asAdjustGroinArea ()
{
float $pos[];
float $posGroinStart[]=`xform -q -ws -t GroinStart`;
float $posGroinSide[]=`xform -q -ws -t GroinSide`;

if (!`objExists Root_M_middleCurve` || !`objExists Hip_R_startProfileShape`)
	{
	if (`objExists GroinStart`) delete GroinStart;
	if (`objExists GroinSide`) delete GroinSide;
	warning "Skipped, because required profile-curves not found";
	return;
	}

$pos=`xform -q -ws -t Root_M_middleProfile`;
xform -ws -t 0 $posGroinSide[1] $pos[2] Root_M_middleProfile;

$pos=`xform -q -ws -t Root_M_middleCurve.cv[2]`;
xform -ws -t $pos[0] ($pos[1]*1.00) $pos[2] Hip_R_startProfileShape.cv[3];
$pos=`xform -q -ws -t Root_M_middleProfileShape.cv[2]`;
xform -ws -t $pos[0] ($pos[1]*0.95) $pos[2] Hip_R_middleProfileShape.cv[3];

$pos=`xform -q -ws -t Root_M_middleCurve.cv[1]`;
xform -ws -t $pos[0] ($pos[1]*1.00) $pos[2] Hip_R_startProfileShape.cv[0] Hip_R_startProfileShape.cv[4];
$pos=`xform -q -ws -t Root_M_middleProfileShape.cv[1]`;
xform -ws -t $pos[0] ($pos[1]*0.95) $pos[2] Hip_R_middleProfileShape.cv[0] Hip_R_middleProfileShape.cv[4];

$pos=`xform -q -ws -t Hip_R_middleProfileShape.cv[2]`;
xform -ws -t $pos[0] ($posGroinStart[1]*0.95) $pos[2] Hip_R_middleProfileShape.cv[2];
$pos=`xform -q -ws -t Hip_R_middleProfileShape.cv[1]`;
xform -ws -t $pos[0] ($posGroinStart[1]*0.95) $pos[2] Hip_R_middleProfileShape.cv[1];

$pos=`xform -q -ws -t Hip_R_startProfileShape.cv[2]`;
xform -ws -t 0 ($posGroinStart[1]*1.00) $pos[2] Hip_R_startProfileShape.cv[2];
$pos=`xform -q -ws -t Hip_R_startProfileShape.cv[1]`;
xform -ws -t 0 ($posGroinStart[1]*1.00) $pos[2] Hip_R_startProfileShape.cv[1];

scale -r 1.2 1.2 1.2 Hip_R_startProfile;

//might overlap with twistProfiles
int $twistJoints=`getAttr Hip.twistJoints`;
for ($i=1;$i<$twistJoints+1;$i++)
	{
	$pos=`xform -q -ws -t ("Hip_R_twistProfileShape"+$i+".cv[1]")`;
	if ($pos[1]>$posGroinStart[1])
		move -r 0 (($pos[1]-$posGroinStart[1])*-1.2) 0 ("Hip_R_twistProfileShape"+$i+".cv[1:2]");
	}

asMirrorControlCurves 0 SkinCageCurvesSet;

if (`objExists GroinStart`) delete GroinStart;
if (`objExists GroinSide`) delete GroinSide;
}

global proc asCreateSkinCage ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;
string $tempString[];

if (`objExists MeshGeometry`)
	{
	asRebuildSkinCage;
	return;
	}

createNode -n Cages transform;
parent Cages Geometry;
createNode -n MeshGeometry transform;
parent MeshGeometry Geometry;
setAttr "MeshGeometry.overrideEnabled" 1;
createNode -n MeshCurves transform;
parent MeshCurves Geometry;
createNode -n NurbsGeometry transform;
setAttr NurbsGeometry.v 0;
parent NurbsGeometry Geometry;
sets -em -name SkinCageCurvesSet;
sets -add "Sets" SkinCageCurvesSet;

select -cl;
createDisplayLayer -e -name "SkinCage" -number 1 -nr;
createDisplayLayer -e -name "SkinCurves1" -number 2 -nr;
createDisplayLayer -e -name "SkinCurves2" -number 3 -nr;
setAttr SkinCurves2.visibility 0; setAttr SkinCurves2.displayType 0; setAttr SkinCurves2.color 13;
setAttr SkinCurves1.visibility 1; setAttr SkinCurves1.displayType 0; setAttr SkinCurves1.color 14;
setAttr SkinCage.displayType 2;


//Build tubes
string $topNodes[]=`listRelatives -type joint -c DeformationSystem`;
asAnalyzeChainJoints $topNodes[0];

//pickup single brancers
string $children[];
$tempString=`asListAllDecents $topNodes[0]`;
for ($i=0;$i<size($tempString);$i++)
	{
	$children=`asListChildren $tempString[$i]`;
	if (size($children)>0)
		if (!`objExists ($tempString[$i]+"_middleCurve")`)
			asBuildChainCurves {$tempString[$i]};
	}


//Branch
asCreateBranchBoxes;

//merge copies.
select `ls -as "*_copy" "*_branch"`;
$tempString=`polyUnite -ch 0 -n skinCage`;
setAttr ($tempString[0]+".keepBorder") 0;
polyMergeVertex -d 0.0001 -am 1 -ch 1 skinCage;
select skinCage;
DeleteHistory;
polyNormal -normalMode 2 -userNormalMode 0 -ch 0 skinCage;
DeleteHistory;
parent skinCage Cages;
editDisplayLayerMembers -noRecurse SkinCage skinCage;
string $middleCurves[]=`ls -type transform "*_middleCurve"`;

//UV
polyAutoProjection -ch 0 -lm 0 -pb 0 -ibd 0 -cm 0 -l 2 -sc 1 -o 1 -p 6 -ps 0.2 -ws 0 skinCage;

//skinn
string $joint,$twistJoint;
select -cl;
for ($i=0;$i<size($middleCurves);$i++)
	{
	$joint=`substitute "_middleCurve" $middleCurves[$i] ""`;
	select -add $joint;
	//include twistJoints
	for ($y=1;$y<99;$y++)
		{
		tokenize $joint "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$y+"_"+$tempString[1];
		if (`objExists $twistJoint`)
			select -add ($twistJoint);
		else
			break;
		}
	//include nonListedParents
	$tempString=`listRelatives -type joint -p $joint`;
	if (size($tempString))
		if (!`objExists ($tempString[0]+"_middleCurve")`)
			if (!`gmatch $tempString[0] "*Part[0-9]*"`)
				select -add $tempString[0];
	//include 50`s
	if (`objExists ($joint+"_50")`)
		select -add ($joint+"_50");
	//deselect endJoints
	$tempString=`listRelatives -type joint -c $joint`;
	if (!`size($tempString)`)
		select -d $joint;
	}
select -add skinCage;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] skinClusterSkinCage;
select -r `listRelatives -c MeshGeometry`;
select `ls -sl -ni "*_poly"`;
select -add skinCage;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
string $cylinders[]=`ls -type transform "*_poly"`;
for ($i=0;$i<size($cylinders);$i++)
	{
	delete `listConnections ($cylinders[$i]+"Shape.inMesh")`;
	setAttr -l 1 ($cylinders[$i]+".v") 0;
	}

//wrap
$cylinders=`ls -type transform "*_poly"`;
select -cl;
deformer -type wrap skinCage;
for ($i=0;$i<size($cylinders);$i++)
	{
	select -r skinCage;
	select -add $cylinders[$i];
	AddWrapInfluence;
	}
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] wrapSkinCage;

reorderDeformers "skinClusterSkinCage" "wrapSkinCage" "skinCage";

//scale profileCurves to markers
float $scale=`asGetScale`;
float $sideTreshold=0.0001*$scale;
$fitSkeletonJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitSkeletonJoints);$i++)
		{
		$fitSkeletonSide[$i]="_R";
		$pos=`xform -q -ws -t $fitSkeletonJoints[$i]`;
		if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
			$fitSkeletonSide[$i]="_M";

		$side=$fitSkeletonSide[$i];
		if ($b==-1 && $fitSkeletonSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";

		string $profileCurve=$fitSkeletonJoints[$i]+$side+"_middleProfile";
		if (`objExists $profileCurve`)
			{
			if (!`attributeExists fat $fitSkeletonJoints[$i]`)
				continue;
			float $fat=`getAttr ($fitSkeletonJoints[$i]+$side+".fat")`;
			float $fatY=`getAttr ($fitSkeletonJoints[$i]+$side+".fatY")`;
			float $fatZ=`getAttr ($fitSkeletonJoints[$i]+$side+".fatZ")`;
//			float $sca[3]=`getAttr ($fitSkeletonJoints[$i]+".s")`;
//			setAttr -type float3 ($profileCurve+".s") $sca[0] $sca[1] $sca[2];
//			setAttr ($profileCurve+".sx") $scale;
//			setAttr ($profileCurve+".sy") ($fat*$fatY*$scale);
//			setAttr ($profileCurve+".sz") ($fat*$fatZ*$scale);
			setAttr ($profileCurve+".sy") ($fat*$fatY);
			setAttr ($profileCurve+".sz") ($fat*$fatZ);
			refresh;
			}
		}

//Profiles tweaks
asProfileTweaks;
asMirrorControlCurves 0 SkinCageCurvesSet;
print "// SkinCage created\n";
select -cl;
}

global proc asDeleteSkinCage ()
{
string $deleteObjs[]={"skinCage","SkinSub","Cages","MeshGeometry","MeshCurves","NurbsGeometry","SkinCage","SkinCurves1","SkinCurves2","SkinCageCurvesSet"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
}

global proc asRebuildSkinCage ()
{
string $restoreShapesCmds[];
string $profileCurveShapes[]=`ls -type nurbsCurve "*ProfileShape*"`;
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($profileCurveShapes);$i++)
	{
	$form=`getAttr ($profileCurveShapes[$i]+".form")`;
	$spans=`getAttr ($profileCurveShapes[$i]+".spans")`;
	$degrees=`getAttr ($profileCurveShapes[$i]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($profileCurveShapes[$i]+".cv["+$y+"]")`;
		$restoreShapesCmds[size($restoreShapesCmds)]="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$profileCurveShapes[$i]+".cv["+$y+"];";
		}
	}

asDeleteSkinCage;
asCreateSkinCage;
for ($i=0;$i<size($restoreShapesCmds);$i++)
	print ($restoreShapesCmds[$i]+"\n");
for ($i=0;$i<size($restoreShapesCmds);$i++)
	catchQuiet (`eval $restoreShapesCmds[$i]`);
}

global proc asProfileTweaks ()
{
int $reverseKnee;
int $cvs[],$oppositeCvs[],$flipCvs[];
float $dist,$minDist;
float $pos1[],$pos2[],$pos3[],$sca1[],$sca2[];
string $heelFitJoint,$toesFitJoint,$cv,$closestCv;
string $tempString[];

string $ankleProfileEnds[]=`ls -type transform "*Ankle*_*endProfile"`;
for ($i=0;$i<size($ankleProfileEnds);$i++)
	{
	string $ankle=`substitute "_endProfile" $ankleProfileEnds[$i] ""`;
	int $numChar=size($ankle);
	string $fitAnkle=`substring $ankle 1 ($numChar-2)`;
	string $side=`substring $ankle ($numChar-1) 99`;
	int $b=1;
	if ($side=="_L") $b=-1;
	$heelFitJoint=$toesFitJoint="";
	$reverseKnee=0;
	$tempString=`listRelatives -c -type joint $fitAnkle`;
	for ($y=0;$y<size($tempString);$y++)
		{
		string $label=`asLabel $tempString[$y]`;
		if (`gmatch $label "*Heel*"`)
			$heelFitJoint=$tempString[$y];
		if (`gmatch $label "*Toes*"`)
			$toesFitJoint=$tempString[$y];
		}
	if ($heelFitJoint=="")
		continue;
	if ($toesFitJoint!="")
		{
		$pos1=`xform -q -ws -t ($toesFitJoint+$side+"_middleProfile.cv[0]")`;
		$pos2=`xform -q -ws -t ($toesFitJoint+$side+"_middleProfile.cv[2]")`;
		if ($pos1[1]>$pos2[1])
			$reverseKnee=1;
		}
	float $anklePos[]=`xform -q -ws -t $ankleProfileEnds[$i]`;
	float $heelPos[]=`xform -q -ws -t $heelFitJoint`;
	if (`gmatch $ankleProfileEnds[$i] "*_R_*"`)
		{
		$cvs={0,1,4};
		if ($reverseKnee) $cvs={2,3};
		}
	else
		{
		$cvs={2,3};
		if ($reverseKnee) $cvs={0,1,4};
		}
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`xform -q -os -t ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t ($heelPos[0]*$b) $heelPos[1] $heelPos[2] ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		move -r -os 0 0 $existingPos[2] ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		scale -r -p $anklePos[0] $anklePos[1] $anklePos[2] 1.2 1.2 1 ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		}

	}

string $toeProfileMiddle[]=`ls -type transform "*Toes*Profile"`;
for ($i=0;$i<size($toeProfileMiddle);$i++)
	{
	$reverseKnee=0;
	$pos1=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv[0]")`;
	$pos2=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv[2]")`;
	if ($pos1[1]>$pos2[1])
		$reverseKnee=1;
	$transformPos=`xform -q -ws -t $toeProfileMiddle[$i]`;
	if (`gmatch $toeProfileMiddle[$i] "*_R_*"`)
		{
		$cvs={0,1,4};$oppositeCvs={2,3};
		if ($reverseKnee) {$cvs={2,3};$oppositeCvs={0,1,4};}
		}
	else
		{
		$cvs={2,3};$oppositeCvs={0,1,4};
		if ($reverseKnee) {$cvs={0,1,4};$oppositeCvs={2,3};}
		}
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t $existingPos[0] 0 $existingPos[2] ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]");
		scale -r -p $transformPos[0] $transformPos[1] $transformPos[2] 1.2 1.2 1 ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]"); 
		}
	for ($y=0;$y<size($oppositeCvs);$y++)
		{
		if (`gmatch $toeProfileMiddle[$i] "*_start*"`)
			scale -r -p $transformPos[0] $transformPos[1] $transformPos[2] 0.5 0.5 1 ($toeProfileMiddle[$i]+".cv["+$oppositeCvs[$y]+"]"); 
		}
	}
if (`objExists Neck_M_startCurve` && `objExists Chest_M_middleProfile`)
	{
	$sca1=`getAttr Chest_M_middleProfile.s`;
	$sca2=`getAttr Neck_M_middleProfile.s`;
	for ($i=0;$i<5;$i++)
		{
		$pos1=`xform -q -ws -t ("Neck_M_middleProfile.cv["+$i+"]")`;
		setAttr -type float3 Neck_M_middleProfile.s $sca1[0] $sca1[1] $sca1[2];
		$pos2=`xform -q -ws -t ("Neck_M_middleProfile.cv["+$i+"]")`;
		setAttr -type float3 Neck_M_middleProfile.s $sca2[0] $sca2[1] $sca2[2];
		xform -ws -t ($pos1[0]*1.1) (($pos1[1]+$pos2[1])/2.0) (($pos1[2]+$pos2[2])/2.0) ("Neck_M_startProfile.cv["+$i+"]");
		}
	}
}

global proc asCreateSliders ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
int $error = 0;
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";

if (`objExists closestSampler`)
	delete closestSampler;
if (!`objExists SlideSystem`)
	createNode -n SlideSystem -p MotionSystem transform;

int $sideFactor=1;
int $vtxNr[];
int $bendAxis;
string $tempString[],$branchVtxs[],$branchVtxSliderNrs[];
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*_L_*"`)
		$sideFactor=-1;
	else
		$sideFactor=1;

	$bendAxis=0;//all directions
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];

	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -type joint -p $parent`;
		$parent=$tempString[0];
		}
	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $firstPa=$tempString[0];

	if ($skinCurveSliderInfo[1]=="")
		{
		print ("// Skipping "+$sel[$i]+", as it`s not defining start or end or middle of deformation\n");
		continue;
		}
	string $stEnMid=$skinCurveSliderInfo[1];
	if (`objExists ($deformJoint+"_"+$stEnMid+"Slider0")` || `objExists ($deformJoint+"_"+$stEnMid+"Slider1")`)
		continue;

	createNode -n messureTemp transform;
	pointConstraint $sel[$i] messureTemp;
	parent messureTemp $firstPa;
	if ($skinCurveSliderInfo[1]=="end")
		parent messureTemp $deformJoint;
	float $xOffset=`getAttr messureTemp.tx`;
	delete messureTemp;

	//create the 50joint
	int $baseStrucExists=0;
	if (`objExists ($deformJoint+"_Slide50")`)
		$baseStrucExists=1;
	if (!$baseStrucExists)
		{
		select $deformJoint;
		joint -n ($deformJoint+"_Slide50");
		sets -add DeformSet ($deformJoint+"_Slide50");
		setAttr ($deformJoint+"_Slide50.rotateOrder") `getAttr ($deformJoint+".rotateOrder")`;
		parent ($deformJoint+"_Slide50") $firstPa;
		createNode -n ($deformJoint+"_Slide00") transform;
		parent ($deformJoint+"_Slide00") $deformJoint;
		setAttr -type float3 ($deformJoint+"_Slide00.t") 0 0 0;
		setAttr -type float3 ($deformJoint+"_Slide00.r") 0 0 0;
		setAttr ($deformJoint+"_Slide00.rotateOrder") `getAttr ($deformJoint+".rotateOrder")`;
		parent ($deformJoint+"_Slide00") $firstPa;
		duplicate -n ($deformJoint+"_Slide00Offset") ($deformJoint+"_Slide00");
		parent ($deformJoint+"_Slide00") ($deformJoint+"_Slide00Offset");
		$tempString=`orientConstraint ($deformJoint+"_Slide00") $deformJoint ($deformJoint+"_Slide50")`;
//		setAttr ($tempString[0]+".interpType") 2; //`shortest` seem to be stable
//	shortest works best on elbow that has twists
		$tempString=`pointConstraint $deformJoint ($deformJoint+"_Slide50")`;
		setAttr ($tempString[0]+".offsetX") ($sideFactor*$charHeight/5000);
		}

	//only 2 for elbow/knee, determine $bendAxis
	if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
		{
		float $jo[]=`getAttr ($deformJoint+".jointOrient")`; // check jointOrient to find bend axis
		if (abs($jo[1])>abs($jo[2])) $bendAxis=1;// .joY greater than .joZ, so not a Zbender
		if (abs($jo[2])>abs($jo[1])) $bendAxis=2;// .joZ greater than .joY, so not a Ybender
		}

	for ($y=0;$y<4;$y++)
		{
		//only 2 for elbow/knee, determine $bendAxis
		if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
			{
			if ($bendAxis==1) if ($y==0 || $y==2) continue;
			if ($bendAxis==2) if ($y==1 || $y==3) continue;
			}
		if ($skinCurveSliderInfo[1]=="start") select $firstPa;
		if ($skinCurveSliderInfo[1]=="middle") select ($deformJoint+"_Slide50");
		if ($skinCurveSliderInfo[1]=="end") select $deformJoint;
		joint -n ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		sets -add ("DeformSet") ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		float $posA[3]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		float $posB[3]=`xform -q -ws -t ($sel[$i]+".cv["+($y+1)+"]")`;
		float $pos[3]={(($posA[0]+$posB[0])/2.0), (($posA[1]+$posB[1])/2.0), (($posA[2]+$posB[2])/2.0)};
		xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_"+$stEnMid+"Slider"+$y);

		if (!$baseStrucExists)
			{
			// recylcle these between starters, enders, and middlers
			createNode -n ($deformJoint+"_SlideDist"+$y) distanceBetween	;
			createNode -n ($deformJoint+"_SlideStart"+$y) transform;
			createNode -n ($deformJoint+"_SlideEnd"+$y) transform;
//			connectAttr -f ($deformJoint+"_SlideStart"+$y+".t") ($deformJoint+"_SlideDist"+$y+".point1");
			connectAttr -f ($deformJoint+"_SlideEnd"+$y+".t") ($deformJoint+"_SlideDist"+$y+".point2");
//			$tempString=`spaceLocator`;rename $tempString[0] ($deformJoint+"_SlideStart"+$y);
//			$tempString=`spaceLocator`;rename $tempString[0] ($deformJoint+"_SlideEnd"+$y);
//			setAttr -type float3 ($deformJoint+"_SlideStart"+$y+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
//			setAttr -type float3 ($deformJoint+"_SlideEnd"+$y+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
			parent ($deformJoint+"_SlideStart"+$y) $firstPa;
			parent ($deformJoint+"_SlideEnd"+$y) $firstPa;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_SlideStart"+$y);
			xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_SlideEnd"+$y);		
			parent ($deformJoint+"_SlideEnd"+$y) ($deformJoint+"_Slide50");
			setAttr ($deformJoint+"_SlideEnd"+$y+".tx") 0;
			float $temp[3]=`getAttr ($deformJoint+"_SlideEnd"+$y+".t")`;
			float $mag=`mag <<$temp[0],$temp[1],$temp[2]>>`*$sideFactor;
			$temp[0]=`getAttr ($deformJoint+".tx")`;
			setAttr -type float3 ($deformJoint+"_SlideStart"+$y+".t") ($temp[0]-$mag) 0 0;
			parent ($deformJoint+"_SlideStart"+$y) SlideSystem;
			parent ($deformJoint+"_SlideEnd"+$y) ($deformJoint+"_SlideStart"+$y);
//			parentConstraint -mo $firstPa ($deformJoint+"_SlideStart"+$y);
			parentConstraint -mo $deformJoint ($deformJoint+"_SlideStart"+$y);
			parentConstraint -mo ($deformJoint+"_Slide50") ($deformJoint+"_SlideEnd"+$y);
			//behaviour
			createNode -n ($deformJoint+"_SlideDistNormalize"+$y) multiplyDivide;
			setAttr ($deformJoint+"_SlideDistNormalize"+$y+".operation") 2;
			connectAttr ($deformJoint+"_SlideDist"+$y+".distance") ($deformJoint+"_SlideDistNormalize"+$y+".input1X");
			setAttr ($deformJoint+"_SlideDistNormalize"+$y+".input2X") `getAttr ($deformJoint+"_SlideDistNormalize"+$y+".input1X")`;
			}

		//they all share `_SlideMultiply` & `SlideReducer` & `_SlidePlusOffset`
		createNode -n ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y) multiplyDivide;
		setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") 0.3;
		if ($skinCurveSliderInfo[1]=="start")
			setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") -0.3;
		//on opposide side, the start and end must move opposite direction
		if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
			setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") (`getAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X")`*$sideFactor);
		createNode -n ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y) multiplyDivide;
		addAttr -k 1 -ln slide -at double -dv 1 ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		connectAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".slide") ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".input2X");
		connectAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".input1X");
		createNode -n ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y) plusMinusAverage;
		connectAttr ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[0]");
		if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
			{
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y) plusMinusAverage;
			setAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".operation") 2;
			connectAttr ($deformJoint+"_SlideDistNormalize"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".input1D[0]");
			setAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".input1D[1]") 1;

			connectAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input1X");
			setAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[1]") $xOffset;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"Slider"+$y+".tx");
			}
		if ($skinCurveSliderInfo[1]=="middle")
			{
			string $slideAxis="z";
			if ($bendAxis==2)
				$slideAxis="y";
			if (($bendAxis==0) && ($y==0 || $y==2))
				$slideAxis="y";
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y) reverse;
			connectAttr ($deformJoint+"_SlideDistNormalize"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".inputX");
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y) condition;
			if (`getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis)`>0)
				setAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".operation") 4;
			else
				setAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".operation") 2;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".firstTerm");
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".colorIfFalseR");
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y) multiplyDivide;
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y) multiplyDivide;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".input1X");
			setAttr ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".input2X") -1;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".colorIfTrueR");
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".outColorR") ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input1X");

			setAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[1]") `getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis)`;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis);

			}

		//skinning
		skinCluster -e -lw false -wt 0 -ai ($deformJoint+"_"+$stEnMid+"Slider"+$y) skinClusterSkinCage;
		float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$y) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
		if ($bendAxis==0) //all directions
			{
			if ($y>0) skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+($y-1)) 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
			if ($y==3) skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider3") 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[0]+"]");
			}
		if (($bendAxis==1 && $y==3) || ($bendAxis==2 && $y==2)) //last loop for Z or Ybender
			{
			int $pickupVtx=2;
			int $sliderNr=1;
			if ($bendAxis==2) {$pickupVtx=1;$sliderNr=0;}
			float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$sliderNr) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			$pickupVtx=4;
			$sliderNr=3;
			if ($bendAxis==2) {$pickupVtx=3;$sliderNr=2;}
			$temp=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$sliderNr) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			}
		}

	//branchVtx`s edgeloopCheck to see if there`s a extra vtx, if so.. this is a `brancher`
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	$branchVtxSliderNrs=`asGetBranchedVtx $tempString 1`;
	for ($y=0;$y<size($branchVtxs);$y++)
		skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$branchVtxSliderNrs[$y]) 1 skinClusterSkinCage $branchVtxs[$y];
	}

if (`objExists closestSampler`)
	delete closestSampler;
print "// Sliders created\n";
select $sel;
}

global proc string[] asGetBranchedVtx (string $inputVtxs[], int $vertsOrSliderNr)
{
string $return[],$branchVtxs[],$branchVtxSliderNrs[];
string $connectVtx0s[],$connectVtx1s[],$connectVtx2s[],$connectVtx3s[];
for ($y=0;$y<4;$y++)
	{
	select $inputVtxs[$y];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $inputVtxs[$y];
	$tempString=`ls -sl -fl`;
	if ($y==0) $connectVtx0s=$tempString;
	if ($y==1) $connectVtx1s=$tempString;
	if ($y==2) $connectVtx2s=$tempString;
	if ($y==3) $connectVtx3s=$tempString;
	}
for ($y=0;$y<size($connectVtx0s);$y++) {
	if (`stringArrayCount $connectVtx0s[$y] $connectVtx1s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=0;}
if (`stringArrayCount $connectVtx0s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=3;}}
for ($y=0;$y<size($connectVtx1s);$y++)
	if (`stringArrayCount $connectVtx1s[$y] $connectVtx2s`) {$branchVtxs[size($branchVtxs)]=$connectVtx1s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=1;}
for ($y=0;$y<size($connectVtx2s);$y++)
	if (`stringArrayCount $connectVtx2s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx2s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=2;}
if ($vertsOrSliderNr)
	$return=$branchVtxSliderNrs;
else
	$return=$branchVtxs;
return $return;
}

global proc asDeleteSliders ()
{
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
int $error = 0;
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
string $tempString[];
int $vtxNr[];
for ($i=0;$i<size($sel);$i++)
	{
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];
	int $haveSliderJoint[4];
	for ($y=0;$y<4;$y++)
		{
		//skinning
		float $pos[]=`xform -q -ws -t $sel[$i]`;
		createNode -n closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker1;
		$pos=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		createNode -n closestSamplerShrinker2 -p closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker2;
		$pos=`xform -q -ws -t closestSamplerShrinker2`;
		scale -r 0.832 0.832 0.832 closestSamplerShrinker1;
		setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		delete closestSamplerShrinker1;
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		}
	//$branchVtxs
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	for ($y=0;$y<size($branchVtxs);$y++)
		{
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage $branchVtxs[$y];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage $branchVtxs[$y];
		}
	//delete the joint
	for ($y=0;$y<4;$y++)
		if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
			delete ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y);

	//remove 50 system, if no longer required
	int $remove50=0;
	if (!`objExists ($skinCurveSliderInfo[0]+"_SlideDistNormalize1")`)
		{
		if (`objExists ($skinCurveSliderInfo[0]+"_Slide50")`)
			delete ($skinCurveSliderInfo[0]+"_Slide50");
		if (`objExists ($skinCurveSliderInfo[0]+"_Slide00")`)
			delete ($skinCurveSliderInfo[0]+"_Slide00");
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+"SlideStart"+$y)`)
				delete ($skinCurveSliderInfo[0]+"_"+"SlideStart"+$y);
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
select -cl;
}

global proc string asListParent (string $obj)
{
string $tempString[]=`listRelatives -type joint -p $obj`;
return $tempString[0];
}

global proc string[] asListChildren (string $obj)
{
int $skip,$skipChildrenToo;
string $result[];
string $tempString[]=`listRelatives -type joint -c $obj`;
string $tempString2[];
string $skips[]={"Slider[0-9]","Slide50","Cup_","Scapula_","ThumbFinger1_","FootSideOuter_","FootSideInner_","Heel_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
for ($i=0;$i<size($tempString);$i++)
	{
	$skip=$skipChildrenToo=0;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempString[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skipChildrenToo=1;
	if (`attributeExists noMiddleCurve $tempString[$i]`)
		{
		$skip=1;
		$skipChildrenToo=1;
		}
	if ($skip)
		{
		if (!$skipChildrenToo)
			{
			$tempString2=`listRelatives -type joint -c $tempString[$i]`;
			for ($z=0;$z<size($tempString2);$z++)
				{
				$skip=0;
				for ($y=0;$y<size($skips);$y++)
					if (`gmatch $tempString2[$z] ("*"+$skips[$y]+"*")`)
						$skip=1;
				if (!$skip)
					$result[size($result)]=$tempString2[$z];
				}
			}
		}
	else
		if ($tempString[$i]!="")
			$result[size($result)]=$tempString[$i];
	}
return $result;
}

global proc string[] asListAllDecents (string $obj)
{
int $skip,$skipChildrenToo;
string $result[];
string $tempString[]=`listRelatives -type joint -ad $obj`;
string $tempStringFullPath[]=`listRelatives -type joint -ad -f $obj`;
string $skips[]={"Slider[0-9]","Slide50","Cup_","Scapula_","ThumbFinger1_","FootSideOuter_","FootSideInner_","Heel_","Jaw_","Eye_","_50","Float","Part[0-9]_","Part[0-9][0-9]_"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
for ($i=0;$i<size($tempString);$i++)
	{
	if (size(`ls $tempString[$i]`)>1)
		$tempString[$i]=$tempStringFullPath[$i];
	$skip=$skipChildrenToo=0;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempStringFullPath[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skip=1;
	if (!$skip)
		$result[size($result)]=$tempString[$i];
	}
return $result;
}

global proc asAnalyzeChainJoints (string $firstJoint)
{
string $kids[]=`asListChildren $firstJoint`;
string $chainJoints[],$tempString[];
clear $chainJoints;
float $pos[3];

//If $firstJoint is "*Part[0-9]*", then downscan until solid firstJoint
if (`gmatch $firstJoint "*Part[0-9]*"`)
	{
	string $child=$firstJoint;
	for ($i=0;$i<99;$i++)
		{
		$tempString=`asListChildren $child`;
		$child=$tempString[0];
		if (!`gmatch $child "*Part[0-9]*"`)
			break;
		}
	$firstJoint=$child;
	clear $kids;
	$kids=`asListChildren $firstJoint`;
	}


while(size($kids)==1)
	{
	if (size($chainJoints)==0)
		$chainJoints[size($chainJoints)]=$firstJoint;
	if (!`gmatch $kids[0] "*Part[0-9]*"`)
		$chainJoints[size($chainJoints)]=$kids[0];
	$tempString=`asListChildren $kids[0]`;
	clear $kids;
	for ($y=0;$y<size($tempString);$y++)
			$kids[size($kids)]=$tempString[$y];
	}

if (size($kids)>1)
	for ($y=0;$y<size($kids);$y++)
		asAnalyzeChainJoints $kids[$y];

//Root exception
if ($chainJoints[0]=="Spine1_M")
	stringArrayInsertAtIndex(0, $chainJoints, "Root_M");

if (size($chainJoints))
	if (!`objExists ($chainJoints[0]+"_middleCurve")`)
		asBuildChainCurves $chainJoints;
}

global proc asBuildChainCurves (string $chainJoints[])
{
int $childIsTwistJoint,$twistJointNr,$inbetweenJoints;
int $firstChildMinusX[],$spineJoint[],$terminator[],$topJoint[],$downTwist[],$upTwist[];
float $twistAmount,$rotXoffSet;
float $charHeight=`asgetCharHeight`;
string $curve,$startCurve,$endCurve,$twistCurve,$surface,$poly,$parent,$parentChainJoint,$childChainJoint,$twistJoint,$skinToJoint,$fitJoint;
string $tempString[],$tempString2[],$children[],$siblings[],$curves[],$startCurves[],$middleCurves[],$endCurves[],$twistCurves[];
float $scale;
float $pos1[],$pos2[],$pos3[];

//if (size($chainJoints)==1)
//	return;
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (`gmatch $chainJoints[$i] "Head_M"` || `gmatch $chainJoints[$i] "Hair_M"` || `gmatch $chainJoints[$i] "Root_M"` || `gmatch $chainJoints[$i] "Spine*_M"` || `gmatch $chainJoints[$i] "Chest_M"` || `gmatch $chainJoints[$i] "Tail*_M"`)
		$spineJoint[$i]=1;
	$tempString=`asListChildren $chainJoints[$i]`;
	if (size($tempString))
		if (`getAttr ($tempString[0]+".tx")`<0)
			$firstChildMinusX[$i]=1;
	if (size($tempString)==0)
		$terminator[$i]=1;
	if (`asListParent $chainJoints[$i]`=="")
		$topJoint[$i]=1;
	}

//Middlecurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	$middleCurve=$chainJoints[$i]+"_middleCurve";
	$middleCurves[size($middleCurves)]=$middleCurve;
	asCreateMeshCurve $middleCurve;
	$profileCurve=`substitute "Curve" $middleCurve "Profile"`;
	$scale=$charHeight/40;
	if (`gmatch $chainJoints[$i] "Wrist_*"`)
		$scale=$charHeight/80;
	if (`gmatch $chainJoints[$i] "Elbow_*"`)
		$scale=$charHeight/60;
	if (`gmatch $chainJoints[$i] "*Finger*"`)
		$scale=$charHeight/140;
	if ($spineJoint[$i])
		$scale=$charHeight/15;
	xform -os -s $scale $scale $scale $profileCurve;

	asAlign $profileCurve $chainJoints[$i] 1 1 0 0;
	if ($terminator[$i])
		asAlign $profileCurve `asListParent $chainJoints[$i]` 0 1 0 0;
	parent $profileCurve MeshCurves;
	editDisplayLayerMembers -noRecurse SkinCurves1 $profileCurve;

	refresh;
	}

//Find x-angle difference, to detect changes such as reversed-knees
for ($i=0;$i<size($chainJoints)-1;$i++)
	{
	spaceLocator -n tempLoc;
	parent tempLoc ($chainJoints[$i]+"_middleProfile");
	xform -os -t 0 0 0 -ro 0 0 0 tempLoc;
	aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $chainJoints[$i+1] $chainJoints[$i+1] tempLoc;
	$rotXoffSet=`getAttr tempLoc.rx`;
	delete tempLoc;
	if (!`gmatch $chainJoints[$i+1] "*_L"`)
		if ($rotXoffSet>90 || $rotXoffSet<-90)
			{
			print ("// Flip in jointChain detected, un-flipping skinCage: "+$chainJoints[$i+1]+" : "+$rotXoffSet+"\n");
			rotate -r -eu ($rotXoffSet*-1) 0 0 ($chainJoints[$i+1]+"_middleProfile");
			}
	}

//Twistcurves (includes partialJoints)
for ($i=0;$i<size($chainJoints);$i++)
	{
	$childIsTwistJoint=1;
	$joint=$chainJoints[$i];
	tokenize $joint "_" $tempString;
	$fitJoint=$tempString[0];
	$inbetweenJoints=2;
	if (`attributeExists inbetweenJoints $fitJoint`)
		$inbetweenJoints=`getAttr ($fitJoint+".inbetweenJoints")`;
	$twistJointNr=1;
	while($childIsTwistJoint)
		{
		$childIsTwistJoint=0;
		$tempString=`asListChildren $joint`;
		$twistJoint=$tempString[0];
		for ($y=0;$y<size($tempString);$y++)
			if (`gmatch $tempString[$y] "*Part[0-9]*"`)
				$twistJoint=$tempString[$y];
		$joint=$twistJoint;
//		if (`gmatch $joint "*Part[0-9]*"` && `attributeExists twistAmount $joint`)
		if (`gmatch $joint "*Part[0-9]*"`)
			$childIsTwistJoint=1;
		else
			break;
		if ($childIsTwistJoint)
			{
			$downTwist[$i]=$downTwist[$i]+1;
			$twistCurve=$chainJoints[$i]+"_twistCurve"+$downTwist[$i];
			$twistCurves[size($twistCurves)]=$twistCurve;
			asCreateMeshCurve $twistCurve;
			$profileCurve=`substitute "Curve" $twistCurve "Profile"`;
			createNode -n ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") transform;
			parent ($chainJoints[$i]+"_twistProfile"+$downTwist[$i]) ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			parent ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") MeshCurves;
			editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
			asAlign ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") $twistJoint 1 1 0 0;
			$twistAmount=0.5;
			if (`attributeExists twistAmount $twistJoint`)
				$twistAmount=`getAttr ($twistJoint+".twistAmount")`*1;
			else if (`objExists ("FKX"+$twistJoint+"_orientConstraint1")`)
				{
//actually.. cant take inbetweenamount as twistAmount, cause inbetween "adds up to 1", before reacing the end
//				$tempString=`listAttr -ud ("FKX"+$twistJoint+"_orientConstraint1")`;
//				$twistAmount=`getAttr ("FKX"+$twistJoint+"_orientConstraint1."+$tempString[0])`;
				$twistAmount=(1.0/($inbetweenJoints+1))*$twistJointNr;
				}
			pointConstraint -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			pointConstraint -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			}
		$twistJointNr++;
		}
	if ($i>0 && $downTwist[$i-1])
		$upTwist[$i]=$downTwist[$i-1];
	}

//Startcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		$startCurve=$chainJoints[$i]+"_startCurve";
		$startCurves[size($startCurves)]=$startCurve;
		asCreateMeshCurve $startCurve;
		$profileCurve=`substitute "Curve" $startCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_startCurveOffset") transform;
		parent ($chainJoints[$i]+"_startProfile") ($chainJoints[$i]+"_startCurveOffset");
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_startCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		//first startCurve
		if ($i==0)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_startProfile.tx") 0.482;
			else
				setAttr ($chainJoints[$i]+"_startProfile.tx") -0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		if ($i>0)
			{
			pointConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			}
		}
	}

//Endcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		$endCurve=$chainJoints[$i]+"_endCurve";
		$endCurves[size($endCurves)]=$endCurve;
		asCreateMeshCurve $endCurve;
		$profileCurve=`substitute "Curve" $endCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_endCurveOffset") transform;
		parent ($chainJoints[$i]+"_endProfile") ($chainJoints[$i]+"_endCurveOffset");
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_endCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		//last endCurve
		if ($i==size($chainJoints)-1)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_endProfile.tx") -0.482;
			else
				setAttr ($chainJoints[$i]+"_endProfile.tx") 0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		if ($i<size($chainJoints)-1)
			{
			pointConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			}
		}
	}

for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_startCurve";
	$curves[size($curves)]=$chainJoints[$i]+"_middleCurve";
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_endCurve";
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		$curves[size($curves)]=$chainJoints[$i]+"_twistCurve"+$y;


	//branch
	$children=`asListChildren $chainJoints[$i]`;
	$tempString[0]=`asListParent $chainJoints[$i]`;
	$parent=$tempString[0];
	if ($parent!="")
		$siblings=`asListChildren $parent`;
	if (!(size($children)>1 || size($siblings)>1))
		continue;
	}

$surface=$chainJoints[0]+"_surface";
$poly=$chainJoints[0]+"_poly";
if (size($chainJoints)==1)
		extrude -n $surface -ch 1 -rn false -po 0 -et 0 -upn 1 -length ($charHeight/-250) -rotation 0 -scale 1 -dl 3 $curves;
else
	loft -n $surface -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 0 -rsn true $curves;
parent $surface NurbsGeometry;
nurbsToPoly -n $poly -mnd 1 -ch 1 -f 3 -pt 0 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0 -es 0 -ntr 0 -mrt 0 -uss 1 $surface;
polySoftEdge -angle 0 -ch 1 $poly;
if (`gmatch $chainJoints[0] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 $poly;
//polyMergeVertex -d 0.01 -am 1 -ch 1 $poly;
polyMergeVertex -d 0.0001 -am 1 -ch 1 $poly;
//displaySmoothness -polygonObject 3;
duplicate -n ($poly+"_copy") $poly;
parent $poly MeshGeometry;

//Create SkinCluster
select $chainJoints;
//include parentJoint
$tempString=`listRelatives -type joint -p $chainJoints[0]`;
if (size($tempString))
	select -add $tempString[0];
//deselect endJoints
for ($i=0;$i<size($chainJoints);$i++)
	{
	$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
	if (!`size($tempString)`)
		select -d $chainJoints[$i];
	}
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -type joint -c $tempString[$i]`;
	if (size($tempString2))
		select -add $tempString[$i];
	}
//include twistJoints
for ($i=0;$i<size($chainJoints);$i++)
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		select -add ($tempString[0]+"Part"+$y+"_"+$tempString[1]);
		}
//include 50`s
for ($i=0;$i<size($chainJoints);$i++)
	if (`objExists ($chainJoints[$i]+"_50")`)
		select -add ($chainJoints[$i]+"_50");
select -add $poly;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";

float $temp[3];
int $vertIndex;
if (`objExists closestSampler`)
	delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($poly+"Shape.outMesh") closestSampler.inMesh;
$tempString=`listConnections ($poly+"Shape.inMesh")`;
string $skinCluster=$tempString[0];

//Skinning cylinders
for ($i=0;$i<size($chainJoints);$i++)
	{
	//Middlecurves
	for ($y=0;$y<4;$y++)
		{
		$temp=`xform -q -ws -t ($chainJoints[$i]+"_middleCurve.cv["+$y+"]")`;
		setAttr closestSampler.inPositionX $temp[0];
		setAttr closestSampler.inPositionY $temp[1];
		setAttr closestSampler.inPositionZ $temp[2];
		$vertIndex=`getAttr closestSampler.closestVertexIndex`;
		$skinToJoint=$chainJoints[$i];
		$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
		if (!`size($tempString)`)
			{
			$tempString2=`listRelatives -type joint -p $chainJoints[$i]`;
			if (`size($tempString2)`)
				$skinToJoint=$tempString2[0];
			}

		skinPercent -tv $skinToJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		$tempString=`listRelatives -type joint -p $chainJoints[$i]`;
		if (!$spineJoint[$i])
			if (size($tempString))
				if ($skinToJoint==$chainJoints[$i])
					skinPercent -tv $tempString[0] 0.5 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		if (`objExists ($chainJoints[$i]+"_50")`)
			skinPercent -tv ($chainJoints[$i]+"_50") 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
		}

	//Twistcurves
	for ($z=1;$z<$downTwist[$i]+1;$z++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$z+"_"+$tempString[1];
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_twistCurve"+$z+".cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $twistJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}

		}

	//Startcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$topJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_startCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			if ($i>0)
				skinPercent -tv $chainJoints[$i-1] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			else
				{
				$tempString=`listRelatives -type joint -p $chainJoints[0]`;
				skinPercent -tv $tempString[0] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
				}
			}
		}
	//Endcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_endCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $chainJoints[$i] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}
		}
	}
if (size($children)==0)
	{
	$endJoint=$chainJoints[size($chainJoints)-1];
	polyPlane -n ($endJoint+"_cap_copy") -w 1 -h 1 -sx 1 -sy 1 -ax 1 0 0 -cuv 2 -ch 0;
	if (`gmatch $endJoint "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($endJoint+"_cap_copy");
	setAttr -type float3 ($endJoint+"_cap_copy.s") ($scale*2*(1/1.2)) ($scale*2*(1/1.2)) ($scale*2*(1/1.2));
	asAlign ($endJoint+"_cap_copy") $endJoint 1 1 0 0;
	asAlign ($endJoint+"_cap_copy") `asListParent $endJoint` 0 1 0 0;
	}
}

global proc asCreateMeshCurve (string $curve)
{
$tempString[0]=`curve -d 1 -p 0 -1 1 -p 0 1 1 -p 0 1 -1 -p 0 -1 -1 -p 0 -1 1`;
rename $tempString[0] $curve;
reverseCurve -ch 0 -rpo 1 $curve;
$profileCurve=`substitute "Curve" $curve "Profile"`;
duplicate -n $profileCurve $curve;
sets -add SkinCageCurvesSet $profileCurve;
scale -r 1.2 1.2 1.2 $profileCurve;
parent $curve $profileCurve;
connectAttr ($profileCurve+".worldSpace[0]") ($curve+".create");
setAttr ($curve+".v") 0;
}

global proc asCreateBranchBoxes ()
{
int $sortedNr[],$closestParentCvs[],$closestChildCvs[],$furthestParentCvs[],$furthestChildCvs[];
int $tempInt,$hasRChild,$hasLChild,$vtxNr;
string $parentCurve,$firstChild,$nextChild,$polyCreateFacetCmd,$backFront,$spreadMostAxis;
string $tempString[],$tempString2[],$children[],$childrenCurves[],$sortedChildren[];
float $minX,$maxX,$minY,$maxY,$minZ,$maxZ,$min,$dist;
float $pos[3],$pos1[3],$pos2[3],$childPos[3],$deltaPos[3],$spreadMostVector[3],$cubePos[3],$temp[3],$temp2[3];
float $Xs[],$Ys[],$Zs[],$sortValues[],$sortedValues[];
string $joints[]=`asListAllDecents DeformationSystem`;

for ($i=0;$i<size($joints);$i++)
	{
	$tempString=`asListChildren $joints[$i]`;
	if (size($tempString)<2) // branching only with 2 or more children
		continue;

	if ($joints[$i]=="Root_M" && !`objExists Root_M_middleCurve`)
		asBuildChainCurves {"Root_M"};
//	if ($joints[$i]=="Root_M")
//		continue;

	//find $children
	clear $children;
	clear $sortedChildren;
	clear $childrenCurves;
	for ($y=0;$y<size($tempString);$y++) // child with no child of it`s own, is not a branch
		{
		$tempString2=`asListChildren $tempString[$y]`;
		if (size($tempString2))
			$children[size($children)]=$tempString[$y];
		}

	if (size($children)<2) // branching only with 2 or more children (check again, now that `false` children has been removed)
		continue;

	//For the Root, drop Spine as child
	if ($joints[$i]=="Root_M" && `stringArrayCount "Spine1_M" $children`)
		$children=`stringArrayRemove {"Spine1_M"} $children`;

	//find $spreadMostVector
	$minX=99;$minY=99;$minZ=99;
	$maxX=-99;$maxY=-99;$maxZ=-99;
	for ($y=0;$y<size($children);$y++)
		{
//		$temp=`xform -q -ws -t $children[$y]`;
		$temp=`getAttr ($children[$y]+".t")`;
		if ($tempString[0]!=$joints[$i])//might not be `direct` child
			{
			createNode -n tempTransform -p $joints[$i] transform;
			asAlign tempTransform $children[$y] 1 0 0 0;
			$temp=`getAttr tempTransform.t`;
			delete tempTransform;
			}
		if ($temp[0]<$minX) $minX=$temp[0];
		if ($temp[0]>$maxX) $maxX=$temp[0];
		if ($temp[1]<$minY) $minY=$temp[1];
		if ($temp[1]>$maxY) $maxY=$temp[1];
		if ($temp[2]<$minZ) $minZ=$temp[2];
		if ($temp[2]>$maxZ) $maxZ=$temp[2];
		}
	$xDif=$maxX+abs($minX);$yDif=$maxY+abs($minY);$zDif=$maxZ+abs($minZ);

	if ($yDif>$zDif) {$spreadMostVector={0,1,0};$spreadMostAxis="y";}
	if ($zDif>$yDif) {$spreadMostVector={0,0,1};$spreadMostAxis="z";}


	//sort children (by distance between themselves)
	for ($y=0;$y<size($children);$y++)
		{
//		$temp=`xform -q -ws -t $children[$y]`;
		$temp=`getAttr ($children[$y]+".t")`;
		$tempString=`listRelatives -p $children[$y]`;
		if ($tempString[0]!=$joints[$i])//might not be `direct` child
			{
			createNode -n tempTransform -p $joints[$i] transform;
			asAlign tempTransform $children[$y] 1 0 0 0;
			$temp=`getAttr tempTransform.t`;
			delete tempTransform;
			}
		$Xs[$y]=$temp[0];$Ys[$y]=$temp[1];$Zs[$y]=$temp[2];
		}
	$min=999;
	if ($spreadMostVector[0]) $sortValues=$Xs;
	if ($spreadMostVector[1]) $sortValues=$Ys;
	if ($spreadMostVector[2]) $sortValues=$Zs;

	for ($y=0;$y<size($children);$y++)
		{
		$sortedValues=`sort $sortValues`;
		}
	for ($y=0;$y<size($sortedValues);$y++)
		{
		for ($z=0;$z<size($children);$z++)
			if ($sortValues[$z]==$sortedValues[$y])
				$sortedChildren[$y]=$children[$z];
		}

	//find $parentCurve
	$parentCurve=$joints[$i]+"_middleCurve";
	if (`objExists ($joints[$i]+"_endCurve")`)
		$parentCurve=($joints[$i]+"_endCurve");

	//find $childrenCurves
	for ($y=0;$y<size($sortedChildren);$y++)
		{
		if (`objExists ($sortedChildren[$y]+"_startCurve")`)
			$childrenCurves[size($childrenCurves)]=$sortedChildren[$y]+"_startCurve";
		else if (`objExists ($sortedChildren[$y]+"_middleCurve")`)
			$childrenCurves[size($childrenCurves)]=$sortedChildren[$y]+"_middleCurve";
		}

	//aimed $childrenCurves
	for ($y=0;$y<size($childrenCurves);$y++)
		{
		duplicate -n ($childrenCurves[$y]+"TempAimed") $childrenCurves[$y];
		parent -w ($childrenCurves[$y]+"TempAimed");
		float $aimVec[]={1,0,0};
//		if (`gmatch ($childrenCurves[$y]) "*_L_*"`)
		if (!`gmatch $joints[$i] "*_L"` && `gmatch $childrenCurves[$y] "*_L_*"`)
			$aimVec={-1,0,0};

		if ($joints[$i]=="Root_M")
			$aimVec[0]=$aimVec[0]*-1;

		createNode -n ($childrenCurves[$y]+"TempAimedTarget") transform;
		parent ($childrenCurves[$y]+"TempAimedTarget") $childrenCurves[$y];
		xform -os -t 1 0 0 -ro 0 0 0 ($childrenCurves[$y]+"TempAimedTarget");
//		$tempString=`aimConstraint -aimVector $aimVec[0] $aimVec[1] $aimVec[2] -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $aimAt $aimAt ($childrenCurves[$y]+"TempAimed")`;
		$tempString=`aimConstraint -aimVector $aimVec[0] $aimVec[1] $aimVec[2] -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $joints[$i] ($childrenCurves[$y]+"TempAimedTarget") ($childrenCurves[$y]+"TempAimed")`;
		delete $tempString[0];
		}

	if ($spreadMostAxis=="x")//not real
		{
		$closestParentCvs[0]=1;
		$closestParentCvs[1]=2;
		$closestChildCvs[0]=1;
		$closestChildCvs[1]=2;
		}
	if ($spreadMostAxis=="y")//e.g. wrist
		{
		$closestParentCvs[0]=0;
		$closestParentCvs[1]=1;
		$closestChildCvs[0]=0;
		$closestChildCvs[1]=1;
		}
	if ($spreadMostAxis=="z")//e.g. chest
		{
		$closestParentCvs[0]=1;
		$closestParentCvs[1]=2;
		$closestChildCvs[0]=1;
		$closestChildCvs[1]=2;
		}

	//sideFace1
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[1]+"]")`;
	$pos2=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[0]+"]")`;
	$pos3=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
	$pos4=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchStart -ch 0 -tx 1 -s 1";
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
	$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
	$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
	eval ($polyCreateFacetCmd);
	if (`gmatch $childrenCurves[0] "*_L_*"` && `gmatch $joints[$i] "*_L*"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($joints[$i]+"_branchStart");

	//child2childFace`s
	int $childACv[]=`asCvFlip $closestChildCvs`;
	for ($y=0;$y<size($childrenCurves)-1;$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
		$pos3=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
		$pos4=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
		$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branch"+$y+" -ch 0 -tx 1 -s 1";
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
		$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
		eval ($polyCreateFacetCmd);
		if (`gmatch $childrenCurves[$y] "*_L_*"` && `gmatch $joints[$i] "*_L"`)
			polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($joints[$i]+"_branch"+$y);
		}

	//sideFace2
	int $childACv2[]=`asCvFlip $closestParentCvs`;
	int $lastChildNr=size($childrenCurves)-1;
	$pos1=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[1]+"]")`;
	$pos2=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[0]+"]")`;
	$pos3=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[0]+"]")`;
	$pos4=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[1]+"]")`;
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchEnd -ch 0 -tx 1 -s 1";
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
	$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
	$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
	eval ($polyCreateFacetCmd);
	if (`gmatch $childrenCurves[$lastChildNr] "*_L_*"` && `gmatch $joints[$i] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchEnd");

	//backFace n-sided
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchBack -ch 0 -tx 1 -s 1";
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[1]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	for ($y=0;$y<size($childrenCurves);$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		}
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[1]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	eval ($polyCreateFacetCmd);

	//frontFace n-sided
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchFront -ch 0 -tx 1 -s 1";
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[0]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	for ($y=0;$y<size($childrenCurves);$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		}
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[0]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	eval ($polyCreateFacetCmd);
	polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchFront");

	//polySplit
	for ($a=0;$a<2;$a++)
		{
		if ($a==0) $backFront="Back";
		if ($a==1) $backFront="Front";
		for ($y=1;$y<size($childrenCurves)-1;$y++)
			{
			$vtxNr=0;
			$pos1=`xform -q -ws -t ($joints[$i]+"_branch"+$backFront+".vtx[0]")`;
			$pos2=`xform -q -ws -t ($joints[$i]+"_branch"+$backFront+".vtx[99]")`;
			$pos=`xform -q -ws -t ($joints[$i]+"_branch"+$backFront+".vtx["+(($y*2)+1)+"]")`;
			if (`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>` < `mag<<$pos1[0]-$pos[0],$pos1[1]-$pos[1],$pos1[2]-$pos[2]>>`)
				$vtxNr=99;
			polyConnectComponents -ch 0 ($joints[$i]+"_branch"+$backFront+".vtx["+$vtxNr+"]") ($joints[$i]+"_branch"+$backFront+".vtx["+(($y*2)+1)+"]");
			$pos=`xform -q -ws -t ($joints[$i]+"_branch"+$backFront+".vtx["+(($y*2)+2)+"]")`;
			if (`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>` < `mag<<$pos1[0]-$pos[0],$pos1[1]-$pos[1],$pos1[2]-$pos[2]>>`)
				$vtxNr=99;
			polyConnectComponents -ch 0 ($joints[$i]+"_branch"+$backFront+".vtx["+$vtxNr+"]") ($joints[$i]+"_branch"+$backFront+".vtx["+(($y*2)+2)+"]");
			}
		}

	//polyUnite branch-bits
	select ($joints[$i]+"_branchStart") ($joints[$i]+"_branchEnd") ($joints[$i]+"_branchFront") ($joints[$i]+"_branchBack");
	for ($y=0;$y<size($childrenCurves)-1;$y++)
		select -add ($joints[$i]+"_branch"+$y);
	polyUnite -n ($joints[$i]+"_branch") -ch 0 -mergeUVSets 1;

	//wireDeform into place
	wire -n ($joints[$i]+"_branchWire") -dds 0 0.001 -gw false -en 1.0 -ce 0.0 -li 0.0 ($joints[$i]+"_branch");
	for ($y=0;$y<size($childrenCurves);$y++)
		{
		select ($childrenCurves[$y]+"TempAimed");
		select -add ($joints[$i]+"_branch");
		AddWire;
		setAttr ($joints[$i]+"_branchWire.dropoffDistance["+$y+"]") 0.001;
		}
	for ($y=0;$y<size($childrenCurves);$y++)
		{
		pointConstraint $childrenCurves[$y] ($childrenCurves[$y]+"TempAimed");
//		orientConstraint $childrenCurves[$y] ($childrenCurves[$y]+"TempAimed");
		parent  ($childrenCurves[$y]+"TempAimed") $childrenCurves[$y];
		//round to nearest 90
		$temp[0]=`getAttr ($childrenCurves[$y]+"TempAimed.rx")`;
		$temp[0]=$temp[0]/90.0;
		$temp[0]=trunc($temp[0]+0.5);
		$temp[0]=$temp[0]*90;
		setAttr ($childrenCurves[$y]+"TempAimed.rx") $temp[0];
		}

	//cleanup
	select ($joints[$i]+"_branch");
	DeleteHistory;
	for ($y=0;$y<size($childrenCurves);$y++)
		delete ($childrenCurves[$y]+"TempAimed") ($childrenCurves[$y]+"TempAimedTarget") ($childrenCurves[$y]+"TempAimedBaseWire");
	}
}

global proc int[] asCvFlip (int $vc[])
{
int $flipCv[]=$vc;
if ($vc[0]==0 && $vc[1]==1) $flipCv={3,2};
if ($vc[0]==1 && $vc[1]==0) $flipCv={2,3};

if ($vc[0]==2 && $vc[1]==3) $flipCv={1,0};
if ($vc[0]==3 && $vc[1]==2) $flipCv={0,1};

if ($vc[0]==1 && $vc[1]==2) $flipCv={0,3};
if ($vc[0]==2 && $vc[1]==1) $flipCv={3,0};

if ($vc[0]==0 && $vc[1]==3) $flipCv={1,2};
if ($vc[0]==3 && $vc[1]==0) $flipCv={2,1};
return $flipCv;
}

global proc asCopySkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists skinCage`)
	return;
string $sel[]=`ls -sl`;
int $isComponents=0;
source removeUnusedInfluences;
int $hasSkinCluster,$skinningMethod;
string $skinCluster;
string $selObjs[],$shapes[],$history[],$joints[],$tempString[];

if (`gmatch $sel[0] "*[.]*"`) 
    $isComponents=1;
if ($isComponents)
    {
    $tempString=`ls -sl -o`;
    $selObjs=`listRelatives -p $tempString[0]`;
    }
else
    $selObjs=$sel;

$history=`listHistory -pdo 1 skinCage`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$skinningMethod=`getAttr ($history[$y]+".skinningMethod")`;

for ($i=0;$i<size($selObjs);$i++)
	{
	$shapes=`listRelatives -s -ni $selObjs[$i]`;
	if (size($shapes)<1)
		continue;
	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $selObjs[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}

	if ($hasSkinCluster) // possible joints added to skinCage
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		string $joints2[]=`listConnections ($skinCluster+".matrix")`;
		for ($y=0;$y<size($joints);$y++)
			if (!`stringArrayCount $joints[$y] $joints2`)
				skinCluster -e -lw false -wt 0 -ai $joints[$y] $skinCluster;
		}
	if (!$hasSkinCluster)
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		select $joints;
		select -add $selObjs[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	//copy skin
	select -r skinCage ;
	if ($isComponents)
	    select -add $sel;
	else
		select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	setAttr ($skinCluster+".skinningMethod") $skinningMethod;
	removeUnusedForSkin $skinCluster 0;
	}
select $sel;
}

global proc asHardenWeights ()
{
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
int $hasSkinCluster;
string $maxTransform;
string $tempString[],$history[],$joints[],$transforms[];
float $values[];
string $skinCluster;
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s -ni $sel[$i]`;
	if (size($tempString)<1)
		continue;

	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}
	if (!$hasSkinCluster)
		error ("Object:\""+$sel[$i]+"\" has not skinCluster");		
	$joints=`listConnections ($skinCluster+".matrix")`;
	for ($y=0;$y<size($joints);$y++)
		setAttr ($joints[$y]+".lockInfluenceWeights") 0;

	int $numVtxs[]=`polyEvaluate -v $sel[$i]`;
	progressBar -e -st "Hardening Vtx weight" -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
	for ($y=0;$y<$numVtxs[0];$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
		progressBar -e -s 1 $gMainProgressBar;
		$transforms=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
		$values=`skinPercent -ignoreBelow 0.001 -q -v $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
		float $maxValue=0;
		for ($z=0;$z<size($transforms);$z++)
			{
			if ($values[$z]>$maxValue)
				{
				$maxValue=$values[$z];
				$maxTransform=$transforms[$z];
				}
			}
		skinPercent -tv $maxTransform 1 $skinCluster ($sel[$i]+".vtx["+$y+"]");
		}
	progressBar -e -ep $gMainProgressBar;
	}
}

global proc asApplyDeltaMush ()
{
string $tempString[];
string $confirmResult,$systemCmd;

int $useWBDeltaMush=1;
if (`checkBox -q -ex wbDeltaMush`)
	$useWBDeltaMush=`checkBox -q -v wbDeltaMush`;

if (!$useWBDeltaMush)
	{
	deltaMush -smoothingIterations 10 -smoothingStep 0.5 -pinBorderVertices 1 -envelope 1;
	asConnectDeltaMushScale;
	print "// DeltaMush applied\n";
	return;
	}

asLoadWbDeltaMushPlugin;

eval ("wbDeltaMush -smoothingIterations 10 -smoothingStep 0.5 -pinBorderVertices 1");
asConnectDeltaMushScale;

print "// DeltaMush applied\n";
}

global proc asLoadWbDeltaMushPlugin ()
{
int $haveASPlugPath=0;
string $envVarString=`getenv MAYA_PLUG_IN_PATH`;
string $pluginPaths[];
tokenize $envVarString ";" $pluginPaths;
for ($i=0;$i<size($pluginPaths);$i++)
	{
	if (`gmatch $pluginPaths[$i] "*AdvancedSkeleton5Files*"`) {
		$haveASPlugPath=1;
		break;
		}
	}
if (!$haveASPlugPath)
	asAddModulePath;
if (!`pluginInfo -q -l wbDeltaMushDeformer`)
	{
	$confirmResult=`confirmDialog -t Confirm -m "Plugin not loaded" -b "Load now" -b "Cancel" -db "Ok"`;
	if ($confirmResult!="Load now")
		return;
	chdir (`asGetScriptLocation`+"/AdvancedSkeleton5Files/modules/wbDeltaMushDeformer/"
		   +`asMayaVersionAsFloat`+"/plug-ins/");

	loadPlugin wbDeltaMushDeformer;
	if (!`pluginInfo -q -l wbDeltaMushDeformer`)
		error "Unable to load plugin";
	}
}

global proc asAddModulePath ()
{
global string $gMainProgressBar;
string $tempString[];

string $confirmResult=`confirmDialog -t Confirm -m "wbDeltaMushDeformer not added to MAYA_MODULE_PATH" -b "Add now" -b "Cancel" -db "Ok"`;
if ($confirmResult!="Add now")
	return;
//putenv: for current session
putenv "MAYA_PLUG_IN_PATH"  (`getenv "MAYA_PLUG_IN_PATH"`+";"+`asGetScriptLocation`
							 +"/AdvancedSkeleton5Files/modules/wbDeltaMushDeformer/"
							 +`asMayaVersionAsFloat`+"/plug-ins/");

//setx: for future sessions
string $MPIPfromReg="";
if (`about -win`) // get from registry, as this does not have the auto-added paths from modules
	{
	progressBar -e -st "Adding environment variable" -bp -ii 1 -min 0 -max 3 $gMainProgressBar;
	evalDeferred -lp ("progressBar -e -ep "+$gMainProgressBar);
	
	// add AS_MODULES_PATH whatever it does exist or not
	string $asModulePath = `asGetScriptLocation`+"/AdvancedSkeleton5Files/modules";
	$systemCmd="setx AS_MODULE_PATH "+$asModulePath;
	system ($systemCmd);

	// then we add MAYA_MODULE_PATH
	$systemCmd="reg query HKEY_CURRENT_USER\\Environment /v MAYA_MODULE_PATH";
	$systemReturn=`system ($systemCmd)`;

	if (!`gmatch $systemReturn "*Error*"` && !`gmatch $systemReturn "*ERROR*"`)
		{
		tokenize $systemReturn $tempString;	
		$MPIPfromReg=$tempString[3];
		}
	//string $newMPIP=$MPIPfromReg+";"+`asGetScriptLocation`+"\\AdvancedSkeleton5Files\\modules";
	string $newMPIP=`asGetScriptLocation`+"/AdvancedSkeleton5Files/modules;"+$MPIPfromReg;
	if ($MPIPfromReg!="")
		{
		print "// Found existing paths in MAYA_MODULE_PATH\n";
		print ("// New MAYA_MODULE_PATH="+$newMPIP+"\n");
		}
	$systemCmd="setx MAYA_MODULE_PATH "+$newMPIP;
	print ("// system(\""+$systemCmd+"\")\n");
	system ($systemCmd);
	progressBar -e -ep $gMainProgressBar;
	}
}

global proc asConnectDeltaMushScale ()
{
if (!`objExists Main`)
	return;
string $deltaMushNodes[]=`ls -type deltaMush`;
string $wbDeltaMushNodes[]=`ls -type wbDeltaMush`;
$deltaMushNodes=`stringArrayCatenate $deltaMushNodes $wbDeltaMushNodes`;
for ($i=0;$i<size($deltaMushNodes);$i++)
	{
	if (`isConnected Main.sx ($deltaMushNodes[$i]+".sx")`)
		continue;
	connectAttr Main.sx ($deltaMushNodes[$i]+".sx");
	connectAttr Main.sy ($deltaMushNodes[$i]+".sy");
	connectAttr Main.sz ($deltaMushNodes[$i]+".sz");
	}
}

global proc asWrapExlude ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

string $sel[]=`ls -sl`;
if (!size($sel))
	error "No vertices selected ";
if (!`gmatch $sel[0] "*[.]vtx[[]*"`)
	error "Selection must be  vertices";
string $tempString[]=`listHistory -pdo 1 $sel[0]`;
string $wrapDeformer,$skinCluster;
int $hadSkinCluster=0;
for ($y=0;$y<size($tempString);$y++)
	{
	if (`nodeType $tempString[$y]` == "wrap")
		$wrapDeformer=$tempString[$y];
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
	}
if ($wrapDeformer=="")
	error "No wrap deformer on selected object";

if ($skinCluster=="")
	{
	asCopySkin;
	$tempString=`ls -sl -o`;
	$tempString=`listRelatives -p $tempString[0]`;
	select $tempString[0];
	asSmoothSkin;
	select $sel;
	}
else
	$hadSkinCluster=1;
$tempString=`listHistory -pdo 1 $sel[0]`;
for ($y=0;$y<size($tempString);$y++)
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
$tempString=`listConnections ($wrapDeformer+".message")`;
string $wrapSet=$tempString[0];
$tempString=`listConnections ($skinCluster+".message")`;
string $skinClusterSet=$tempString[0];
sets -rm $wrapSet;
asInvertSelection;
sets -rm $skinClusterSet;
if (!$hadSkinCluster)
	{
	$tempString=`ls -sl -o`;
	select $tempString[0];
	removeUnusedInfluences;
	}
select $sel;
print ("// Selected vertices are now deformed by "+$skinCluster+" instead of wrapDeformer\n");
}

global proc asCreateSkinSub ()
{
string $sel[]=`ls -sl`;
if (!`objExists skinCage`)
	error "\"skinCage\" not found, You must create a skinCage (option2) first.";
if (`objExists skinSub`)
	error "\"skinSub\" already exists.";
if (!`objExists Cages`)
	{
	createNode -n Cages transform;
	parent Cages "Geometry";
	}

createNode -n subWrapPolySmoothProxy polySmoothProxy;
polyCube -n skinSub  -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
parent skinSub Cages;
connectAttr skinCageShape.outMesh subWrapPolySmoothProxy.inputPolymesh;
connectAttr subWrapPolySmoothProxy.output skinSub.inMesh;
select skinSub;
createDisplayLayer -name SkinSub -number 1 -nr;
//setAttr SkinSub.shading 0;
setAttr SkinSub.displayType 2;
setAttr SkinSub.color 30;
setAttr SkinCage.displayType 1;
select $sel;
}

global proc asDeleteSkinSub ()
{
if (`objExists skinSub`)
	delete skinSub;
if (`objExists SkinSub`)
	delete SkinSub;
}

global proc asWrapSkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
if (!`objExists skinSub`)
	error "\"skinSub\" not found, you must create SubWrap first";
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	{
	string $historyNodes[]=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]` == "wrap")
			error ($sel[$i]+" already have wrapDeformer");
	}

if (!`attributeExists wrapDeform Main`)
	{
	addAttr -k 1 -ln "wrapDeform" -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.wrapDeform;
	}
if (!`objExists wrapDeformReverse`)
	{
	createNode -n wrapDeformReverse reverse;
	connectAttr Main.wrapDeform wrapDeformReverse.inputX;
	}
string $tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	select $sel[$i];
	select -add skinSub ;
	CreateWrap;
	}
string $wraps[]=`listConnections -type wrap skinSub.worldMesh`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
float $wrapValues[]={0,0,1,0,0};
string $wrap;

for ($i=0;$i<size($wraps);$i++)
	{
	$wrap=`rename $wraps[$i] ("subWrap"+($i+1))`;
	$tempString=`listConnections ($wrap+".outputGeometry")`;
	setAttr ($wrap+".nodeState") 1;
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (`attributeExists $wrapAttrs[$y] $tempString[0]`) //We could be reattaching, so reuse wrapInfo
			$wrapValues[$y]=`getAttr ($tempString[0]+"."+$wrapAttrs[$y])`;
		setAttr ($wrap+"."+$wrapAttrs[$y]) $wrapValues[$y];
		}
	setAttr skinSub.dropoff 4;
	setAttr skinSub.smoothness 0;
	setAttr skinSub.inflType 2;
	connectAttr wrapDeformReverse.output.outputX ($wrap+".nodeState");
	}
select -cl;
}

global proc asSkinSubAttach ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists skinSub`) error "\"skinSub\" not found, you must create SubWrap first";
if (!`objExists skinCage`) error "\"skinCage\" not found, you must create SubWrap first";
if (!`attributeExists subWrapped skinCage`) error "No SubWraps have been detached";
int $numAttach;
string $msh;
string $tempString[];
$tempString[0]=`getAttr skinCage.subWrapped`;
tokenize $tempString[0] ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	$msh=$tempString[$i];
	if (!`objExists $msh`)
		continue;
	select $msh;
	asWrapSkin;
	$numAttach++;
	}
print ("//"+$numAttach+" SubWrap(s) attached");
}

global proc asSkinSubDetach ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $subWraps[]=`ls -type wrap "subWrap*"`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
string $tempString[],$tempString2[];
string $msh,$subWrappedString;
for ($i=0;$i<size($subWraps);$i++)
	{
	//store wrapInfo on the meshes they deform.
	$tempString=`listHistory -f 1 ($subWraps[$i]+".outputGeometry")`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="mesh")
			{
			$tempString2=`listRelatives -p $tempString[$y]`;
			$msh=$tempString2[0];
			}
	$subWrappedString+=$msh+";";
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (!`attributeExists $wrapAttrs[$y] $msh`) addAttr -ln $wrapAttrs[$y] -at double $msh;
		setAttr ($msh+"."+$wrapAttrs[$y]) `getAttr ($subWraps[$i]+"."+$wrapAttrs[$y])`;
		}
	delete $subWraps;
	print ("//"+`size($subWraps)`+" SubWrap(s) detached");
	}
if (!`attributeExists subWrapped skinCage`)
	addAttr -ln "subWrapped" -dt "string" skinCage;
setAttr -type "string" skinCage.subWrapped $subWrappedString;
}

global proc asSmoothSkin ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
float $pos[];
string $tempString[];
string $smoothJoints[];
if (`objExists Head_M`)
	{
	$tempString=`listRelatives -p Head_M`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]*"`)
		{
		$smoothJoints[size($smoothJoints)]=$parent;
		$tempString=`listRelatives -p $parent`;
		$parent=$tempString[0];
		}
	}
string $lookforJoints[]={"Root_M","Hip_R","Hip_L"};
for ($i=0;$i<size($lookforJoints);$i++)
if (`objExists $lookforJoints[$i]`)
	$smoothJoints[size($smoothJoints)]=$lookforJoints[$i];
string $skinCluster;
setToolTo $gSelect;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`nodeType $tempString[$y]` == "skinCluster")
			$skinCluster=$tempString[$y];
	if ($skinCluster=="")
		error "Found no skinCluster on selected object";
	int $numVtxs[]=`polyEvaluate -v $sel[$i]`;
	progressBar -e -st "Finding Vtx for smoothing" -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
	for ($y=0;$y<$numVtxs[0];$y++)
		for ($z=0;$z<size($smoothJoints);$z++)
			{
			if (`progressBar -q -ic $gMainProgressBar`)
				{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
			if ($z==0)
				progressBar -e -s 1 $gMainProgressBar;
			$tempString=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
			if (`stringArrayCount $smoothJoints[$z] $tempString`)
				{
				select -add ($sel[$i]+".vtx["+$y+"]");
				//middleVtx to root
				if (`gmatch $smoothJoints[$z] "*Root_M*"` || `gmatch $smoothJoints[$z] "*Hip_*"`)
					{
					$pos=`xform -q -ws -t ($sel[$i]+".vtx["+$y+"]")`;
					if ($pos[0]>($charHeight/-5000.0) && $pos[0]<($charHeight/5000.0))
						skinPercent -tv $smoothJoints[$z] 1 $skinCluster ($sel[$i]+".vtx["+$y+"]");
					}
				}
			}
		if (size(`ls -sl`))
			weightHammerVerts;
	}
progressBar -e -ep $gMainProgressBar;
}

global proc asDeleteSkinCurves ()
{
if (!`objExists skinCageShape` || !`objExists skinClusterSkinCage`)
	return;
setAttr skinClusterSkinCage.envelope 0;
duplicate -n asTempMesh skinCageShape;
setAttr skinClusterSkinCage.envelope 1;
string $deleteObjs[]={"SkinCurves1","SkinCurves2","MeshGeometry","MeshCurves","NurbsGeometry"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
string $tempString[]=`listRelatives -s -type mesh skinCage`;
for ($mesh in $tempString)
	if ($mesh!="skinCageShape")
		{
		connectAttr asTempMesh.outMesh ($mesh+".inMesh");
		evalDeferred -lp ("delete asTempMesh");
		break;
		}
}

global proc string asNrToLetter (int $nr)
{
string $letter;
if ($nr==0) $letter="";if ($nr==1) $letter="A";if ($nr==2) $letter="B";
if ($nr==3) $letter="C";if ($nr==4) $letter="D";if ($nr==5) $letter="E";
if ($nr==6) $letter="F";if ($nr==7) $letter="G";if ($nr==8) $letter="H";
if ($nr==9) $letter="I";if ($nr==10) $letter="J";if ($nr==11) $letter="K";
if ($nr==12) $letter="L";if ($nr==13) $letter="M";if ($nr==14) $letter="N";
if ($nr==15) $letter="O";if ($nr==16) $letter="P";if ($nr==17) $letter="Q";
if ($nr==18) $letter="R";if ($nr==19) $letter="S";if ($nr==20) $letter="T";
if ($nr==21) $letter="U";if ($nr==22) $letter="V";if ($nr==23) $letter="W";
if ($nr==24) $letter="X";if ($nr==25) $letter="Y";if ($nr==26) $letter="Z";
return $letter;
}

global proc asAlign (string $object, string $alignToObject, int $translate, int $rotate, int $jointOrient, int $rotateOrder)
{
string $parents[]=`listRelatives -p $object`;
string $orientConstraint[];
float $rotation[];
parent $object $alignToObject;
//Might have generated a Xform
string $generatedXform;
string $tempString[]=`listRelatives -p $object`;
if ($tempString[0]!=$alignToObject)
	$generatedXform=$tempString[0];
if ($translate)
	{
	xform -os -t 0 0 0 $object;
	if ($generatedXform!="")
		xform -os -t 0 0 0 $generatedXform;
	}
if ($rotateOrder)
	setAttr ($object+".rotateOrder") `getAttr ($alignToObject+".rotateOrder")`;
if ($rotate)
	{
	xform -os -ro 0 0 0 $object;
	if ($generatedXform!="")
		xform -os -ro 0 0 0 $generatedXform;
	}
if ($jointOrient && $rotate)
	setAttr -type float3 ($object+".jointOrient") 0 0 0;
	
if (`objExists $parents[0]`)
	parent $object $parents[0];
else
	parent -w $object;

if ($jointOrient && !$rotate)
	{
	if (`getAttr ($alignToObject+".rotateOrder")`!=0)
		warning "Aligning jointOrient for objects without aligning rotation, and non-default rotationOrder, may cause problems.";
	$orientConstraint=`orientConstraint $alignToObject $object`;
	$rotation=`xform -q -os -ro $object`;
	delete $orientConstraint[0];
	setAttr -type float3 ($object+".jointOrient") $rotation[0] $rotation[1] $rotation[2];
	setAttr -type float3 ($object+".rotate") 0 0 0;
	}
}

global proc asImportIconsFile (string $iconsFile)
{
string $beforeObj[]=`ls -l -as`;
string $afterObj[];
int $fromBefore[];
int $readLine;
$fileId=`fopen $iconsFile "r"`;
string $nextLine = `fgetline $fileId`;
string $previousLine;
while ( size( $nextLine ) > 0 )
	{
	if (!$readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
	if (`gmatch $nextLine "createNode nurbsCurve*"`)
		{
		$readLine=1;
		eval ($previousLine);
		$previousLine = $nextLine;
		$nextLine = `fgetline $fileId`;
		continue;
		}
	if ($readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
		else
			{
			$readLine=0;
			eval ($previousLine);
			}
	$previousLine=$nextLine;
	$nextLine = `fgetline $fileId`;
	}
fclose $fileId;
$afterObj=`ls -l -as`;
for ($i=0;$i<size($afterObj);$i++)
	for ($y=0;$y<size($beforeObj);$y++)
		if ($afterObj[$i]==$beforeObj[$y])
			$fromBefore[$i]=1;
for ($i=0;$i<size($afterObj);$i++)
	if (!$fromBefore[$i])
		parent $afterObj[$i] "iconsGroup";
}

global proc asCreateController (string $type, string $name, string $side, string $fitJoint)
{
string $sel[]=`ls -sl`;
select -cl;
int $rotOrder=`getAttr ($fitJoint+".rotateOrder")`;
if ($type=="FK")
	createNode -n ($type+"Offset"+$name+$side) transform;
//	joint -n ($type+"Offset"+$name+$side);//Why joint ?
else
	{
	createNode -n ($type+"Offset"+$name+$side) transform;
	parent ($type+"Offset"+$name+$side) "IKHandle";
	}
setAttr ($type+"Offset"+$name+$side+".rotateOrder") $rotOrder;
createNode -n ($type+"Extra"+$name+$side) transform;
sets -add ControlSet ($type+"Extra"+$name+$side);
setAttr ($type+"Extra"+$name+$side+".rotateOrder") $rotOrder;
parent ($type+"Extra"+$name+$side) ($type+"Offset"+$name+$side);
asLockAttr ($type+"Extra"+$name+$side) 0 0 1 1;
if (`gmatch $name "*Scapula*"`)
	duplicate -n ($type+$name+$side) "Scapula_icon";
else
	duplicate -n ($type+$name+$side) ($type+"_icon");
xform -os -t 0 0 0 -ro 0 0 0 ($type+$name+$side);
setAttr ($type+$name+$side+".rotateOrder") $rotOrder;

if ($side=="_L")
	setAttr -type float3 ($type+$name+$side+".s") -1 -1 -1;

float $height=`getAttr "Main.height"`;
float $defaultCtrlScale=$height/30.0;
float $sca[3]={$defaultCtrlScale,$defaultCtrlScale,$defaultCtrlScale};
string $tempString[]=`listRelatives -c -type joint $fitJoint`;
if ($tempString[0]!="")
	{
	float $pos1[]=`xform -q -ws -t $fitJoint`;
	float $pos2[]=`xform -q -ws -t $tempString[0]`;
	float $boneLenght=`mag<<$pos2[0]-$pos1[0],$pos2[1]-$pos1[1],$pos2[2]-$pos1[2]>>`;
	if ($boneLenght>1)
		$boneLenght=$boneLenght/2.0;
	else
		$boneLenght=$boneLenght+((1-$boneLenght)/2.0);
	$defaultCtrlScale=$defaultCtrlScale*$boneLenght;
	$sca={$defaultCtrlScale,$defaultCtrlScale,$defaultCtrlScale};
	}

if (`attributeExists fat $fitJoint` && `attributeExists fatY $fitJoint` && `attributeExists fatZ $fitJoint`)
	{
	float $fat=`getAttr ($fitJoint+$side+".fat")`;
	float $fatY=`getAttr ($fitJoint+$side+".fatY")`;
	float $fatZ=`getAttr ($fitJoint+$side+".fatZ")`;
//	$sca={$defaultCtrlScale,$fat*$fatY*$scale,$fat*$fatZ*$scale};
	$sca={$defaultCtrlScale,$fat*$fatY,$fat*$fatZ};
	}

string $shapes[]=`listRelatives -s -f ($type+$name+$side)`;
for ($i=0;$i<size($shapes);$i++)
	{
	xform -s $sca[1] $sca[1] $sca[1] ($shapes[$i]+".cv[0:99]");
	xform -s 1.5 1.5 1.5 ($shapes[$i]+".cv[0:99]");
	}
makeIdentity -a 1 -t 1 -r 1 -s 1 ($type+$name+$side);

parent ($type+$name+$side) ($type+"Extra"+$name+$side);

float $pos[]=`xform -q -ws -t ($fitJoint+$side)`;
float $rot[]=`xform -q -ws -ro ($fitJoint+$side)`;
xform -ws -t $pos[0] $pos[1] $pos[2] ($type+"Offset"+$name+$side);
if ($type=="FK")
	xform -ws -ro $rot[0] $rot[1] $rot[2] ($type+"Offset"+$name+$side);
select $sel;
}

global proc asCreateUnTwister (string $fitJoint, string $side, string $twistParent, string $twistParentSide, string $fitJointIK, int $b, int $IkUnTwister, string $ikFollow)
{
float $scale=`asGetScale`;
if (`objExists ("TwistFollow"+$fitJoint+$side)`)
	return;
string $parentIK;
string $tempString[],$iKInfo[],$twistParentIKInfo[];
$iKInfo=`asFitJointIKInfo $fitJoint`;
string $IK=$iKInfo[0];
string $IKChildJoint=$iKInfo[3];
string $IKNumCtrls=$iKInfo[5];
//find $parentIK
if (`objExists ($twistParent+$twistParentSide)`)
	{
	$twistParentIKInfo=`asFitJointIKInfo $twistParent`;
	$parentIK=$twistParentIKInfo[0];
	}
$tempString=`listRelatives -p $fitJoint`;
string $fitJointParent=$tempString[0];

createNode -n ("TwistFollow"+$fitJoint+$side) -p TwistSystem transform;
createNode -n ("TwistFollowParent"+$fitJoint+$side) -p TwistSystem transform;
asAlign ("TwistFollow"+$fitJoint+$side) ($fitJoint+$side) 1 1 0 1;
if (`objExists ("IKSp"+$fitJoint+$side)`)
	asAlign ("TwistFollow"+$fitJoint+$side) ("IKSp"+$fitJoint+$side) 1 1 0 1;
setAttr -l 1 ("TwistFollow"+$fitJoint+$side+".v") 0;
setAttr -l 1 ("TwistFollowParent"+$fitJoint+$side+".v") 0;

if ($IkUnTwister)
	{
	parentConstraint ($ikFollow+$side) ("TwistFollow"+$fitJoint+$side);
	if (`objExists ($twistParent+$twistParentSide)`)
		{
		if (`objExists ("IKSp"+$twistParent+$twistParentSide)`)
			parentConstraint ("IKSp"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);
		else
			parentConstraint ("IKX"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);
		}
	}
else
	{
	asConstraintToFKIK "parent" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX2"+$fitJoint+$side) ("TwistFollow"+$fitJoint+$side);
	if (`objExists ($twistParent+$twistParentSide)`)
		{
		if ($fitJointParent=="Root")
			parentConstraint LegLockConstrained ("TwistFollowParent"+$fitJoint+$side);
		else
			asConstraintToFKIK "parent" $parentIK ("FKX"+$twistParent+$twistParentSide) ("IKX2"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);
		}
	}

if (!`objExists ($twistParent+$twistParentSide)`)
	parentConstraint RootX_M ("TwistFollowParent"+$fitJoint+$side);	
//Makes FKIK mixing less flippy, but `might` cause cycle
//		parent ("TwistFollow"+$fitJoint+$side) ("TwistFollowParent"+$fitJoint+$side);
//setAttr ("TwistFollow"+$fitJoint+$side+"_parentConstraint1.interpType") 2;



select ($fitJoint+$side);
if (`objExists ("IKSp"+$fitJoint+$side)`)
	select ("IKSp"+$fitJoint+$side);
joint -n ("UnTwist"+$fitJoint+$side);
joint -n ("UnTwistEnd"+$fitJoint+$side);
parent ("UnTwist"+$fitJoint+$side) ("TwistFollowParent"+$fitJoint+$side);

if ($IkUnTwister)
	pointConstraint ($ikFollow+$side) ("UnTwist"+$fitJoint+$side);
else
	asConstraintToFKIK "point" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX2"+$fitJoint+$side) ("UnTwist"+$fitJoint+$side);

//stabalize constraint by adding offsetNode
createNode -n ("TwistFollowOffset"+$fitJoint+$side) -p ("TwistFollow"+$fitJoint+$side) transform;
createNode -n ("TwistFollowParentOffset"+$fitJoint+$side) -p ("TwistFollowParent"+$fitJoint+$side) transform;
setAttr -type float3 ("TwistFollowOffset"+$fitJoint+$side+".t") 0 0 0;
setAttr -type float3 ("TwistFollowOffset"+$fitJoint+$side+".r") 0 0 0;
setAttr -type float3 ("TwistFollowParentOffset"+$fitJoint+$side+".t") 0 0 0;
setAttr -type float3 ("TwistFollowParentOffset"+$fitJoint+$side+".r") 0 0 0;
parent ("TwistFollowOffset"+$fitJoint+$side) TwistSystem;
parent ("TwistFollowParentOffset"+$fitJoint+$side) TwistSystem;
parent ("TwistFollow"+$fitJoint+$side) ("TwistFollowOffset"+$fitJoint+$side);
parent ("TwistFollowParent"+$fitJoint+$side) ("TwistFollowParentOffset"+$fitJoint+$side);

setAttr ("UnTwistEnd"+$fitJoint+$side+".translateX") ($b*$scale);
ikHandle -n ("UnTwistIK"+$fitJoint+$side) -ns 2 -sol "ikRPsolver" -sj ("UnTwist"+$fitJoint+$side) -ee ("UnTwistEnd"+$fitJoint+$side);
parent ("UnTwistIK"+$fitJoint+$side) ("TwistFollow"+$fitJoint+$side);
poleVectorConstraint ("UnTwist"+$fitJoint+$side) ("UnTwistIK"+$fitJoint+$side);

select ("UnTwist"+$fitJoint+$side);
joint -n ("TwistBalancer"+$fitJoint+$side);
setAttr ("TwistBalancer"+$fitJoint+$side+".rotateOrder") 5;
if ($IkUnTwister)
	parentConstraint ($ikFollow+$side) ("TwistBalancer"+$fitJoint+$side);
else
	asConstraintToFKIK "parent" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX2"+$fitJoint+$side) ("TwistBalancer"+$fitJoint+$side);
//setAttr ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1.interpType") 2;

//autoTwist & extraTwist attributes
string $autoTwistCtrl="FK"+$fitJoint+$side;
if ($IkUnTwister)
	$autoTwistCtrl="IK"+$IK+$IKNumCtrls+$side;

addAttr -ln "twist" -at double ("TwistBalancer"+$fitJoint+$side);
addAttr -k 0 -ln "autoTwist" -at double -min 0 -max 10 -dv 10 $autoTwistCtrl;
addAttr -k 0 -ln "extraTwist" -at double $autoTwistCtrl;

createNode -n ($autoTwistCtrl+"AutoTwistUnitConversion") unitConversion;
setAttr ($autoTwistCtrl+"AutoTwistUnitConversion.conversionFactor") 0.1;
connectAttr ($autoTwistCtrl+".autoTwist") ($autoTwistCtrl+"AutoTwistUnitConversion.input");

createNode -n ($autoTwistCtrl+"AutoTwistMultiplyDivide") multiplyDivide;
connectAttr -f ($autoTwistCtrl+"AutoTwistUnitConversion.output") ($autoTwistCtrl+"AutoTwistMultiplyDivide.input1X");
connectAttr -f ("TwistBalancer"+$fitJoint+$side+".rotateX") ($autoTwistCtrl+"AutoTwistMultiplyDivide.input2X");
createNode -n ($autoTwistCtrl+"ExtraTwistPlusMinusAverage") plusMinusAverage;
connectAttr -f ($autoTwistCtrl+"AutoTwistMultiplyDivide.outputX") ($autoTwistCtrl+"ExtraTwistPlusMinusAverage.input1D[0]");
connectAttr -f ($autoTwistCtrl+".extraTwist") ($autoTwistCtrl+"ExtraTwistPlusMinusAverage.input1D[1]");
connectAttr -f ($autoTwistCtrl+"ExtraTwistPlusMinusAverage.output1D") ("TwistBalancer"+$fitJoint+$side+".twist");
//	connectAttr -f ($autoTwistCtrl+"ExtraTwistPlusMinusAverage.output1D") IKSpineHandle_M.twist;

}

global proc asInvertSelection ()
{
//Maya 2018 does not seem to work with "InvertSelection" on component selection
string $tempString[]=`ls -sl`;
string $tempString2[]=`ls -sl -o`;
if (`gmatch $tempString[0] "*[.]vtx*"`)
	{
	select ($tempString2[0]+".vtx[0:99999]");
	select -d $tempString;
	}
else if (`gmatch $tempString[0] "*[.]f*"`)
	{
	select ($tempString2[0]+".f[0:99999]");
	select -d $tempString;
	}
else if (`gmatch $tempString[0] "*[.]e*"`)
	{
	select ($tempString2[0]+".e[0:99999]");
	select -d $tempString;
	}
else
	InvertSelection;
}


global proc asUnitConvertAndReverse (string $name, string $driver)
{
createNode -n ($name+"UnitConversion")  unitConversion;
setAttr ($name+"UnitConversion.conversionFactor") 0.1;
connectAttr $driver ($name+"UnitConversion.input");
createNode -n ($name+"Reverse")  reverse;
connectAttr ($name+"UnitConversion.output") ($name+"Reverse.inputX");
}

global proc asSkinWeightBySoftMod (string $joint, string $geometry, string $skinCluster, float $falloffRadius, float $maxWeight)
{
string $vtx;
string $sel[]=`ls -sl`;
string $tempString[];
float $weight;
float $pos[]=`xform -q -ws -t $joint`;

duplicate -n tempMesh $geometry;
select tempMesh;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
rename $tempString[0] TempSoftMod;
rename $tempString[1] TempSoftModHandle;

setAttr -type float3 TempSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
setAttr TempSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
xform -piv $pos[0] $pos[1] $pos[2] TempSoftModHandle;
setAttr TempSoftMod.falloffMode 1;
setAttr TempSoftMod.falloffRadius $falloffRadius;

//temporarily non-normalize to avoid warning "Total over 1" messages
//	setAttr ($skinCluster+".normalizeWeights") 0;

select tempMesh;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
$tempString=`ls -sl -fl`;
polySelectConstraint -m 0;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`objExists eyeLidArea`)
		if (`sets -im eyeLidArea $tempString[$i]`)
			continue;
	if (`objExists lipArea`)
		if (`sets -im lipArea $tempString[$i]`)
			continue;

	$posA=`xform -q -ws -t $tempString[$i]`;
	setAttr TempSoftModHandle.ty 1;
	$posB=`xform -q -ws -t $tempString[$i]`;
	setAttr TempSoftModHandle.ty 0;
	$weight=($posB[1]-$posA[1])*$maxWeight;
	if ($weight<0) $weight=0;
	if ($weight>1) $weight=1;
	$vtx=`substitute tempMesh $tempString[$i] $geometry`;
 	catchQuiet (`skinPercent -tv $joint $weight $skinCluster $vtx`);
	}
//setAttr ($skinCluster+".normalizeWeights") 1;
//skinCluster -e -forceNormalizeWeights $skinCluster;
delete tempMesh;

select $sel;
}

	global proc asFollow (string $driver, string $driven, string $target)
{
if (!`objExists $target`)
	return;
string $setRange=$driver+"SetRangeFollow";
if (!`attributeExists "follow" $driver`)
	{
	addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 0 $driver;
	createNode -n $setRange setRange;
	setAttr ($setRange+".maxX") 1;
	setAttr ($setRange+".minY") 1;
	setAttr ($setRange+".oldMaxX") 10;
	setAttr ($setRange+".oldMaxY") 10;
	connectAttr ($driver+".follow") ($setRange+".value.valueX");
	connectAttr ($driver+".follow") ($setRange+".value.valueY");
	}
createNode -n ($driven+"FollowNoScale") transform;
pointConstraint $target ($driven+"FollowNoScale");
orientConstraint $target ($driven+"FollowNoScale");
parent ($driven+"FollowNoScale") ("IKFollow");

createNode -n ($driven+"Follow") transform;
asAlign ($driven+"Follow") $driven 1 1 0 0;
parent ($driven+"Follow") ("IKFollow");
parentConstraint -mo ($driven+"FollowNoScale") ($driven+"Follow");

createNode -n ($driven+"Static") transform;
asAlign ($driven+"Static") $driven 1 1 0 0;
parent ($driven+"Static") ("IKStatic");
string $tempString[]=`parentConstraint ($driven+"Static") ($driven+"Follow") $driven`;
string $constraint=$tempString[0];
select $constraint;
connectAttr ($setRange+".outValue.outValueY") ($constraint+"."+$driven+"Static"+"W0");
connectAttr($setRange+".outValue.outValueX") ($constraint+"."+$driven+"Follow"+"W1");
}

global proc asConstraintToFKIK (string $type, string $fitJointIK, string $fk, string $ik, string $target)
{
string $contraintCmd="pointConstraint ";
if ($type=="orient")
	$contraintCmd="orientConstraint ";
if ($type=="parent")
	$contraintCmd="parentConstraint ";
if ($type=="scale")
	$contraintCmd="scaleConstraint ";
$contraintCmd+=$fk;
if (`objExists $ik`)
	$contraintCmd+=" "+$ik;
$contraintCmd+=" "+$target;
string $tempString[];
tokenize $target "_" $tempString;
string $side="_"+$tempString[size($tempString)-1];
tokenize $fk "_" $tempString;
string $contraintToSide="_"+$tempString[size($tempString)-1];
$tempString=`eval ($contraintCmd)`;
string $constraint=$tempString[0];
if (`objExists $ik` && `objExists ("FKIKBlend"+$fitJointIK+"Reverse"+$contraintToSide)`)
	{
	connectAttr ("FKIKBlend"+$fitJointIK+"Reverse"+$contraintToSide+".outputX") ($constraint+"."+$fk+"W0");
	connectAttr ("FKIKBlend"+$fitJointIK+"UnitConversion"+$contraintToSide+".output") ($constraint+"."+$ik+"W1");
	}
}

global proc asModelCheckerUI ()
{
if (`window -q -ex asModelChecker`)
	deleteUI asModelChecker;
window -t "Model Checker" asModelChecker;
columnLayout;
	separator -st none -h 10;
	text -l "Check for default Transformation values,";
	text -l "and Model Symmetry.";
	separator -st none -h 5;
	text -l "Select the model, then:";
	separator -st none -h 10;
	button -w 50 -l "Check" -c "asModelCheck Ok";
showWindow;
}

global proc int asModelCheck (string $okMessage)
{
global string $gMainProgressBar;
int $tempInt[];
int $numVtxs,$mirrortVtx,$i;
int $return=1;
float $mag;
float $posA[],$posB[];
string $sel[]=`ls -sl`;
string $m;

if (!size($sel))
	error "Nothing Selected";

//check Transform
$tempFloat=`getAttr ($sel[0]+".t")`;
if ($tempFloat[0]!=0) $m+="TranslateX = "+$tempFloat[0]+", should be 0\n";
if ($tempFloat[1]!=0) $m+="TranslateY = "+$tempFloat[1]+", should be 0\n";
if ($tempFloat[2]!=0) $m+="TranslateZ = "+$tempFloat[2]+", should be 0\n";
$tempFloat=`getAttr ($sel[0]+".r")`;
if ($tempFloat[0]!=0) $m+="RotateX = "+$tempFloat[0]+", should be 0\n";
if ($tempFloat[1]!=0) $m+="RotateY = "+$tempFloat[1]+", should be 0\n";
if ($tempFloat[2]!=0) $m+="RotateZ = "+$tempFloat[2]+", should be 0\n";
$tempFloat=`getAttr ($sel[0]+".s")`;
if ($tempFloat[0]!=1) $m+="ScaleX = "+$tempFloat[0]+", should be 1\n";
if ($tempFloat[1]!=1) $m+="ScaleY = "+$tempFloat[1]+", should be 1\n";
if ($tempFloat[2]!=1) $m+="ScaleZ = "+$tempFloat[2]+", should be 1\n";
$tempFloat=`getAttr ($sel[0]+".rp")`;
if ($tempFloat[0]!=0) $m+="RotatePivotX = "+$tempFloat[0]+", should be 0\n";
if ($tempFloat[1]!=0) $m+="RotatePivotY = "+$tempFloat[1]+", should be 0\n";
if ($tempFloat[2]!=0) $m+="RotatePivotZ = "+$tempFloat[2]+", should be 0\n";
$tempFloat=`getAttr ($sel[0]+".sp")`;
if ($tempFloat[0]!=0) $m+="ScalePivotX = "+$tempFloat[0]+", should be 0\n";
if ($tempFloat[1]!=0) $m+="ScalePivotY = "+$tempFloat[1]+", should be 0\n";
if ($tempFloat[2]!=0) $m+="ScalePivotZ = "+$tempFloat[2]+", should be 0\n";

if ($m!="")
	$m=$m+"\nThe above transform values are Non-Default values.\n"
			+"This can cause error when building FaceSetup.\n\n"
			+"It is recommended that you use the \"Model Clean\" tool,\n"
			+"before rigging.";
if ($m!="")
	{
	$dialog=`confirmDialog -t "Confirm" -m $m -b $okMessage -b "Cancel" -db "Cancel" -ds "Cancel"`;
	if ($dialog!=$okMessage)
		$return=0;
	return $return;
	}

//Symmetry check
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($sel[$i]+".outMesh") closestSampler.inMesh;
$tempInt=`polyEvaluate -v $sel[$i]`;
$numVtxs=$tempInt[0];
select -cl;
progressBar -e -st "Checking symmetry" -bp -ii 1 -min 0 -max $numVtxs $gMainProgressBar;
for ($i=0;$i<$numVtxs;$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;break;}
	progressBar -e -s 1 $gMainProgressBar;
	$posA=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;
	if ($posA[0]>0.001)
		continue;
	setAttr closestSampler.inPosition ($posA[0]*-1) $posA[1] $posA[2];
	$mirrortVtx=`getAttr closestSampler.closestVertexIndex`;
	$posB=`xform -q -ws -t ($sel[0]+".vtx["+$mirrortVtx+"]")`;
	$mag=`mag <<($posA[0]-($posB[0]*-1)),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
	if ($mag>0.001)
		select -add ($sel[0]+".vtx["+$i+"]") ($sel[0]+".vtx["+$mirrortVtx+"]");
	}
progressBar -e -ep $gMainProgressBar;
delete closestSampler;
refresh;
if (size(`ls -sl`))
	{
	$dialog=`confirmDialog -t "Confirm" -m "Selected verticies are not symmetrical" -b $okMessage -b "Cancel" -db "Cancel" -ds "Cancel"`;
	if ($dialog!=$okMessage)
		$return=0;
	}
else
	print "// Model is symmetrical.\n";

return $return;
}

global proc string asNearestFeatherParent (string $ctrl, string $fitJointsCurveGuide)
{
float $scale=`asGetScale`;
float $sideTreshold=0.0001*$scale;
string $nearestJoint,$nearestFeatherParent;
int $arrivedAtTaggedJoint;
float $posA[]=`xform -q -ws -t $ctrl`;
if (`gmatch $ctrl "*_L"`)
	$posA[0]=$posA[0]*-1;
float $posB[];
float $dist;
float $minDist=999;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
string $curveGuideFitJoints[],$tempString[];
for ($i=0;$i<size($fitJoints);$i++)
	{
	if (!`attributeExists curveGuide $fitJoints[$i]`)
		continue;
	if (`getAttr -as ($fitJoints[$i]+".curveGuide")`!=$fitJointsCurveGuide)
		continue;
	$curveGuideFitJoints[size($curveGuideFitJoints)]=$fitJoints[$i];
	$tempString=`listRelatives -ad -type joint $fitJoints[$i]`;
	$curveGuideFitJoints=`stringArrayCatenate $tempString $curveGuideFitJoints`;
	}
for ($i=0;$i<size($curveGuideFitJoints);$i++)
	{
	$posB=`xform -q -ws -t $curveGuideFitJoints[$i]`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist<$minDist)
		{
		$minDist=$dist;
		$nearestJoint=$curveGuideFitJoints[$i];
		}
	}
$tempString=`ls -l $nearestJoint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	if ($arrivedAtTaggedJoint)
		{
		$nearestFeatherParent=$tempString[$i];
		break;
		}
	if (`attributeExists curveGuide $tempString[$i]`)
		$arrivedAtTaggedJoint=1;
	}
if (`gmatch $ctrl "*_R"` && `objExists ($nearestFeatherParent+"_R")`) $nearestFeatherParent+="_R";
else if (`gmatch $ctrl "*_L"` && `objExists ($nearestFeatherParent+"_L")`) $nearestFeatherParent+="_L";
else $nearestFeatherParent+="_M";
return $nearestFeatherParent;
}

global proc asRemoveAllUnusedInfluences ()
{
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $meshes[]=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
	{
	$tempString=`listHistory -pdo 1 $meshes[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			{
			select `listRelatives -p $meshes[$i]`;
			removeUnusedInfluences;
			}
	}
select $sel;
print "// Unused influences removed.\n";
}

global proc asPruneAllClusters ()
{
string $sel[]=`ls -sl`;
//clusters at zero position does not prune well, they loose all weight; workaround temp move ClusterSetup group
if (`objExists ClusterSetup`) setAttr ClusterSetup.tx 1;
if (`objExists LipSetup`) setAttr LipSetup.tx 1;
if (`objExists squashBase_M`) setAttr squashBase_M.tx 1;
if (`objExists FKHead_M`) setAttr FKHead_M.tx 1;//For EyeLash cluster

string $clusters[]=`ls -type cluster`;
for ($i=0;$i<size($clusters);$i++)
	{
	select $clusters[$i];
	PruneCluster;
	}

if (`objExists ClusterSetup`) setAttr ClusterSetup.tx 0;
if (`objExists LipSetup`) setAttr LipSetup.tx 0;
if (`objExists squashBase_M`) setAttr squashBase_M.tx 0;
if (`objExists FKHead_M`) setAttr FKHead_M.tx 0;

select $sel;
print "// Clusters pruned.\n";
}

global proc asSaveUIs ()
{
delete `ls sceneConfigurationScriptNode`;
delete `ls uiConfigurationScriptNode`;
delete `ls -type hyperView`;
flushUndo;
print "// Saved UI hyperGraph layouts, etc now removed.\n";
print "// Note: Save and re-open this file, for this to take effect.\n";
}

global proc asDeleteUnusedJoints ()
{
string $jointChildren[],$tempString[];
string $joints[]=`listRelatives -ad -type joint DeformationSystem`;
for ($i=0;$i<size($joints);$i++)
	{
	$jointChildren=`listRelatives -ad -type joint $joints[$i]`;
	if (size($jointChildren))
		continue;
	$tempString=`listConnections -s 0 -d 1 ($joints[$i]+".worldMatrix")`;
	if (!size($tempString))
		{
		print ("// deleting joint:\""+$joints[$i]+"\"\n");
		delete $joints[$i];
		}
	}
}

global proc freezeSkinCluster (string $skinCluster)
{
if (!`objExists $skinCluster`)
	return;
int $numMatrix;
float $jointMatrix[];
string $tempString[]=`ls -showType $skinCluster`;

$numMatrix=`getAttr -s ($skinCluster+".bindPreMatrix")`;
for ($i=0;$i<$numMatrix;$i++)
	{
	$tempString=`listConnections -s 1 -d 1 ($skinCluster+".matrix["+$i+"]")`;
	if (!`objExists $tempString[0]`)
		continue;
	$jointMatrix=`getAttr ($tempString[0]+".worldInverseMatrix")`;
	setAttr ($skinCluster+".bindPreMatrix["+$i+"]") -type "matrix" $jointMatrix[0] $jointMatrix[1] $jointMatrix[2] $jointMatrix[3] $jointMatrix[4] $jointMatrix[5] $jointMatrix[6] $jointMatrix[7] $jointMatrix[8] $jointMatrix[9] $jointMatrix[10] $jointMatrix[11] $jointMatrix[12] $jointMatrix[13] $jointMatrix[14] $jointMatrix[15];
	}
}

global proc asSetDisplayLayersToR ()
{
string $displayLayers[]=`listConnections layerManager.displayLayerId`;
for ($i=$y=0;$i<size($displayLayers);$i++)
	{
	if ($displayLayers[$i]=="defaultLayer")
		continue;
	setAttr ($displayLayers[$i]+".displayType") 2;
	}
}

global proc float asGetScale ()
{
float $scale=1;
if (!`objExists FitSkeleton`)
	return $scale;
float $maxY;
float $pos[];
$tempString=`asListAllDecents FitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	if ($pos[1]>$maxY)
		$maxY=$pos[1];
	}
if ($maxY>0)
	$scale=$maxY/17.176163;
return $scale;
}

global proc asPublish ()
{
string $sceneName=`file -q -sn`;
if ($sceneName=="")
	error "File not saved, can not publish";
string $tempString[];
string $filePath,$publishFile;
string $basename=`basenameEx $sceneName`;
tokenize $sceneName "/" $tempString;
for ($i=0;$i<size($tempString)-1;$i++)
	$filePath+=$tempString[$i]+"/";
if (`gmatch $sceneName "*[.]mb"`)
	{
	print "// Your working file is already MB format, appending \"_Published\" to the name.\n";
	$publishFile=$filePath+$basename+"_Published.mb";
	}
else
	$publishFile=$filePath+$basename+".mb";
if (`file -q -ex $publishFile`)
	{
	print ("// Publish file already exits, performing incrementalSave for backup.\n");
	file -rename $publishFile;
	incrementalSaveScene;
	file -rename $sceneName;
	}

//string $references[]=`file -q -r`;
//for ($i=0;$i<size($references);$i++)
//	file -importReference $references[$i];
file -f -op "v=0" -typ "mayaBinary" -ea $publishFile;

print ("// Published: \""+$publishFile+"\".\n");
}

global proc asFix5230 ()
{
//AS5.230 had SDK2 come before SDK1 (to get fingerCurl before fingerBend)
//this however is not compatible with "DrivingSystem->Edit",
//so we will swap SDK1`s with SDK2`s, (where SDK2`s appears first)
if (!`objExists FitSkeleton`)
	return;
int $sdkNr;
string $tempString[];
string $matchString;
string $userAttrs[]=`listAttr -ud -s FitSkeleton`;
for ($i=0;$i<size($userAttrs);$i++)
	{
	if (!`gmatch $userAttrs[$i] "drivingSystem_*"`)
		continue;
	string $ds=`substitute "drivingSystem_" $userAttrs[$i] ""`;
	int $numChar=size($ds);
	string $dsObjName=`substring $ds 1 ($numChar-2)`;
	string $dsSide=`substring $ds ($numChar-1) 99`;
	string $sdks[]=`listConnections ("FitSkeleton."+$userAttrs[$i])`;
	string $sdkPlugs[]=`listConnections -p 1 ("FitSkeleton."+$userAttrs[$i])`;
	for ($y=0;$y<size($sdks);$y++)
		{
		$sdkNr=`substring $sdks[$y] 4 4`;
		if ($sdkNr!=2)
			continue;
		tokenize $sdks[$y] "_" $tempString;
		$matchString=`substring $sdks[$y] 1 3`+"[0-9]"+`substring $tempString[0] 5 99`+"_"+$tempString[1]+"_*";
		for ($z=$y+1;$z<size($sdks);$z++)
			if (`gmatch $sdks[$z] $matchString`)
			if (`objExists $sdks[$y]` && `objExists $sdks[$z]`)
				{
				print ("swapping "+$sdks[$y]+" with "+$sdks[$z]+" (for numeric ordering);\n");
				rename $sdks[$z] ("SDK99"+`substring $sdks[$z] 5 99`);
				rename $sdks[$y] ("SDK1"+`substring $sdks[$y] 5 99`);
				rename ("SDK99"+`substring $sdks[$z] 5 99`) ("SDK2"+`substring $sdks[$z] 5 99`);
				}
		}
	}
}

global proc asReBuildAdvancedSkeleton ()
{
global int $asBuilding;
global int $asRebuilding;
global string $gMainProgressBar;

int $asConfirmIfNotInBuildPose=`asConfirmIfNotInBuildPose`;
if (!$asConfirmIfNotInBuildPose)
	return;

asFix5230;

if (!`objExists "Group"`)
	{
	$asBuilding=1;
	asBuildAdvancedSkeleton;//First build
	if (`checkBox -q -ex asRebuildConnections`)
		checkBox -e -m 1 asRebuildConnections;
	if (`button -q -ex asToggleFitSkeletonButton`)
		button -e -m 1 asToggleFitSkeletonButton;
	if (`button -q -ex asBuildAdvancedSkeletonButton`)
		button -e -l "ReBuild AdvancedSkeleton" asBuildAdvancedSkeletonButton;
	$asBuilding=0;
	return;
	}
if (`objExists "prefix_Group"`)
	error "Object \"prefix_Group\" found, which means a previous build failed. Try to Undo previous build, to restore functional AdvancedSkeleton";

if (`objExists "Group"` && `objExists FitSkeleton`)
	if (!`getAttr FitSkeleton.visibility`)
		asToggleFitAdvancedSkeleton;

int $rebuildConnections=`checkBox -q -v asRebuildConnections`;
string $tempString[],$tempString2[],$sources[],$destinations[],$sourcesNoPlug[],$destinationsNoPlug[];
string $roots[];

if (!`objExists FitSkeleton`)
	error "No skeleton to rebuild\n";
parent -w FitSkeleton;

progressBar -e -st "Analyzing AdvancedSkeleton" -bp -ii 0 -min 0 -max (size(`sets -q AllSet`)*2) $gMainProgressBar;

//Pre Rebuild
float $mx[];
string $userAttrs[],$children[],$connections[],$connectionsObj[],$connectCmdsSource[],$connectCmdsDest[];
string $addAttrCmds[],$cmds[],$connectCmds[],$skinClusters[],$jointClusters[];
string $sn,$ln,$at,$k,$cb,$dv,$minMax,$skinCluster;
string $charSet,$objectType,$tr,$xyz,$target,$restorePoseCmd,$preRebuildScript,$postRebuildScript;
int $childIsMember,$alreadyConnected;
int $locked;
int $e[2];
float $range[2];
float $vals[2];

//Pre Rebuild : preRebuildScript
if (!`attributeExists preRebuildScript FitSkeleton`)
	asEnsureFitSkeletonAttributes;
$preRebuildScript=`getAttr FitSkeleton.preRebuildScript`;
if ($preRebuildScript!="")
	evalEcho ($preRebuildScript);

if (`objExists ClusterSystem` && `objExists ControlSet`)
	sets -rm ControlSet `listRelatives -ad ClusterSystem`;

//getting $allSetMembers after preRebuildScript, as it may rename controllers
string $allSet="AllSet";
string $allSetMembers[]=`sets -q $allSet`;
string $controlSet="ControlSet";
string $controlSetMembers[]=`sets -q $controlSet`;

if (`objExists FaceAllSet`)
	if (`sets -im "Sets" FaceAllSet`)
		sets -rm "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	if (`sets -im "Sets" FaceControlSet`)
		sets -rm "Sets" FaceControlSet;

//Pre Rebuild : Bind Pose is not same as Build Pose
if ($asConfirmIfNotInBuildPose==2)
	$restorePoseCmd=`asGetRestorePoseCmd`;

//Pre Rebuild parentConstraints
string $constraintParent,$constraintChild;
string $parentConstraints[]=`ls -type parentConstraint`;
string $parentConstraintParents[],$parentConstraintChildren[];
for ($i=$y=0;$i<size($parentConstraints);$i++)
	{
	if (`sets -im $allSet $parentConstraints[$i]` || `gmatch $parentConstraints[$i] "*Box_*"`)
		continue;
	if ($parentConstraints[$i]=="AimEyeFollow_M_parentConstraint1")//connected multiTarget constraint
		continue;

	$tempString=`listConnections ($parentConstraints[$i]+".target[0].targetJointOrient")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintParent=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	$tempString=`listConnections ($parentConstraints[$i]+".constraintTranslate.constraintTranslateX")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintChild=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	if (!`objExists $constraintParent` || !`objExists $constraintChild`)
		continue;
	if (!`sets -im $allSet $constraintParent` && !`sets -im $allSet $constraintChild`)
		continue;

	$parentConstraintParents[$y]=$constraintParent;
	$parentConstraintChildren[$y]=$constraintChild;
	delete $parentConstraints[$i];
	$y++;
	}

//Pre Rebuild userDefinedAttr
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!`objExists $allSetMembers[$i]`)
		continue;
	$userAttrs=`listAttr -ud $allSetMembers[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		$tempString=`listAttr -sn ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		if (`gmatch $at "*Array"` || $at=="message")
			continue;
		$dv=`getAttr ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$k=`getAttr -k ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$cb=`getAttr -cb ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="string")
			continue;
		if (`gmatch $ln "*W[0-9]"`)
			continue;
		$minMax="";
		if (`attributeQuery -re -n $allSetMembers[$i] $ln`)
			{
			$range=`attributeQuery -r -n $allSetMembers[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	addAttr -k "+$k+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$allSetMembers[$i]+";";
		//Non-keyable
		if ($k=="0" && $cb)
			$addAttrCmds[size($addAttrCmds)]="if (`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	setAttr -cb 1 "+$allSetMembers[$i]+"."+$userAttrs[$y]+";";
		}
	}


//Pre Rebuild Parenting
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!`objExists $allSetMembers[$i]`)
		continue;
	if (`objectType $allSetMembers[$i]`=="objectSet")
		continue;
	$children=`listRelatives -c $allSetMembers[$i]`;
	for ($y=0;$y<size($children);$y++)
		{
		$tempString=`ls $children[$y]`;
		if (size($tempString)>1)
			error ("ObjectName not unique "+$children[$y]+"\n");
		$childIsMember=0;
		for ($z=0;$z<size($allSetMembers);$z++)
			if ($children[$y]==$allSetMembers[$z])
				$childIsMember=1;
		if (!$childIsMember)
			{
			$tempString=`ls -s $children[$y]`;
			if ($tempString[0]!="")
				$cmds[size($cmds)]="parent -r -s "+$children[$y]+" "+$allSetMembers[$i]+";";
			else if (`getAttr ($children[$y]+".inheritsTransform")` && !`gmatch $children[$y] "*_?_[0-9][0-9]"`)
				$cmds[size($cmds)]="parent "+$children[$y]+" "+$allSetMembers[$i]+";";
			else
				$cmds[size($cmds)]="parent -r "+$children[$y]+" "+$allSetMembers[$i]+";";
			}
		}
	if (!$rebuildConnections)
		continue;

	//Incoming connections
	$connections=`listConnections -p 1 -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			continue;
		if ($connections[$y+1]=="Group.message")
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver" || $objectType== "displayLayerManager")
			continue;
		if ($connections[$y+1]=="time1.outTime")
			continue;
		if (`attributeExists drivingSystemOut $connectionsObj[$y+1]`)//drivingSystem SDK`s to be connected elsewhere
			continue;
		$connectCmds[size($connectCmds)]="if (`getAttr -l "+$connections[$y]+"`)  setAttr -l 0 "+$connections[$y]+";connectAttr -f "+$connections[$y+1]+" "+$connections[$y]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y+1];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y];
		}

	//Outgoing connections
	$connections=`listConnections -p 1 -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="materialInfo" || $objectType=="partition")
			continue;
		//changed to allow user-defined selection-set to persist
//		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver")
		if ($objectType=="objectSet")
			if ($connectionsObj[$y+1]=="AllSet" || $connectionsObj[$y+1]=="ControlSet" || $connectionsObj[$y+1]=="DeformSet")
				continue;
		if ($objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver")
			continue;
		if (`gmatch $connections[$y] "*instObjGroups*"` || `gmatch $connections[$y+1] "*instObjGroups*"`)
			if ($objectType!="objectSet")
				continue;
		if ($objectType=="skinCluster")
			$skinClusters[size($skinClusters)]=$connectionsObj[$y+1];
		if ($objectType=="jointCluster")
			$jointClusters[size($jointClusters)]=$connectionsObj[$y+1];
		$connectCmds[size($connectCmds)]="connectAttr -f "+$connections[$y]+" "+$connections[$y+1]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y+1];
		}

	//transformLimits
	if (`objectType $allSetMembers[$i]`=="joint")
		{
		$tr="r";
		for ($y=0;$y<2;$y++)
			{
			if ($y==1)
				continue;
			$xyz="x";
			for ($z=0;$z<3;$z++)
				{
				if ($z==1)
					$xyz="y";
				if ($z==2)
					$xyz="z";
				$e=`eval ("transformLimits -q -e"+$tr+$xyz+" "+$allSetMembers[$i])`;
				if ($e[0] || $e[1])
					{
					$vals=`eval ("transformLimits -q -"+$tr+$xyz+" "+$allSetMembers[$i])`;
					$cmds[size($cmds)]="transformLimits -"+$tr+$xyz+" "+$vals[0]+" "+$vals[1]+" -e"+$tr+$xyz+" "+$e[0]+" "+$e[1]+" "+$allSetMembers[$i]+";";
					}
				}
			}
		}
	}

//Pre Rebuild CurveShapes
//add HipSwingerOffset_M, so placement of this is maintained in ReBuild
if (`objExists "HipSwingerOffset_M"`)
	$controlSetMembers[size($controlSetMembers)]="HipSwingerOffset_M";
string $curveShape;
int $spans,$degree,$numCVs;
float $cvPos[3];
if ($rebuildConnections)
	for ($i=0;$i<size($controlSetMembers);$i++)
		{
		$tempString=`listRelatives -s $controlSetMembers[$i]`;
		for ($z=0;$z<size($tempString);$z++)
			{
			$curveShape=$tempString[$z];
			if (!`objExists $curveShape`)
				continue;
			if (`objectType $curveShape`!="nurbsCurve")
				continue;
			$spans=`getAttr ($curveShape+".spans")`;
			$degree=`getAttr ($curveShape+".degree")`;
			$numCVs=$spans+$degree;
			for ($y=0;$y<$numCVs;$y++)
				{
				$cvPos=`getAttr ($curveShape+".controlPoints["+$y+"]")`;
				$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2]+" "+";";
				}
			//color
			$cmds[size($cmds)]="setAttr "+$curveShape+".overrideColor "+`getAttr ($curveShape+".overrideColor")`+";";
			}
		}

//Pre Rebuild Non-CurveShapes
if ($rebuildConnections)
	for ($i=0;$i<size($controlSetMembers);$i++)
		{
		$tempString=`listRelatives -s $controlSetMembers[$i]`;
		$shape=$tempString[0];
		if (!`objExists $shape`)
			continue;
		if (`objectType $shape`=="nurbsCurve")
			continue;
		$cmds[size($cmds)]="parent -r -s prefix_"+$shape+" "+$controlSetMembers[$i]+";";
		$cmds[size($cmds)]="delete "+$shape+";";
		$cmds[size($cmds)]="rename prefix_"+$shape+" "+$shape+";";
		}

//Pre Rebuild Multi-CurveShapes
if ($rebuildConnections)
	for ($i=0;$i<size($controlSetMembers);$i++)
		{
		$tempString=`listRelatives -s $controlSetMembers[$i]`;
		for ($y=1;$y<size($tempString);$y++)
			{
			if (`sets -im $allSet $tempString[$y]`)
				continue;
			$cmds[size($cmds)]="parent -r -s prefix_"+$tempString[$y]+" "+$controlSetMembers[$i]+";";
			}
		}

//Pre Rebuild Disable expressions to avoid warnings
$tempString=`ls -type expression`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im $allSet $tempString[$i]`)
		setAttr ($tempString[$i]+".nodeState") 1;

//Pre Rebuild joint.drawStyle (joint visibility)
clear $tempString;
if (`objExists |Group`)
	$tempString=`listRelatives -f -type joint -ad |Group`;
for ($i=0;$i<size($tempString);$i++)
	$cmds[size($cmds)]="setAttr "+$tempString[$i]+".drawStyle "+`getAttr ($tempString[$i]+".drawStyle")`+";";

//Rebuild
$allSetMembers[size($allSetMembers)]="Group";
$allSetMembers[size($allSetMembers)]="Sets";
$allSetMembers[size($allSetMembers)]="AllSet";
$allSetMembers[size($allSetMembers)]="ControlSet";
$allSetMembers[size($allSetMembers)]="DeformSet";

for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		$allSetMembers[$i]=`rename $allSetMembers[$i] ("prefix_"+$allSetMembers[$i])`;
	else
		$allSetMembers[$i]="";

//unprefix CylShapes in order to preserve these
$tempString=`ls -type nurbsSurface "*_CylShape*"`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		rename $tempString[$i] `substitute "prefix_" $tempString[$i] ""`;

//unprefix Added Shapes in order to preserve these (they might have `inherited the prefixing from parent transform)
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (!`objExists ("prefix_"+$controlSetMembers[$i])`)
		continue;
	$tempString=`listRelatives -s ("prefix_"+$controlSetMembers[$i])`;
	for ($y=0;$y<size($tempString);$y++)
		if (`gmatch $tempString[$y] "prefix_*"`)
			if (!`sets -im prefix_AllSet $tempString[$y]`)
				rename $tempString[$y] `substitute "prefix_" $tempString[$y] ""`;
	}

progressBar -e -ep $gMainProgressBar;


$asRebuilding=1;
asBuildAdvancedSkeleton;
$asRebuilding=0;


//redo parentConstraints
for ($i=0;$i<size($parentConstraintParents);$i++)
	if (`objExists $parentConstraintParents[$i]` && `objExists $parentConstraintChildren[$i]`)
		parentConstraint -mo $parentConstraintParents[$i] $parentConstraintChildren[$i];


//Post Rebuild
for ($cmd in $addAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
for ($i=0;$i<size($connectCmds);$i++)
	{
	$alreadyConnected=0;
	if (`objExists $connectCmdsSource[$i]` && `objExists $connectCmdsDest[$i]`)
		if (`isConnected -iuc $connectCmdsSource[$i] $connectCmdsDest[$i]`)
			$alreadyConnected=1;
	if (!$alreadyConnected)
		if (catchQuiet (`eval ($connectCmds[$i])`)) warning ("Failed: "+$connectCmds[$i]+"\n");
	}
for ($cmd in $cmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

//reset bindPose
string $bindPose;
string $newSetMembers[]=`sets -q $allSet`;
for ($i=0;$i<size($newSetMembers);$i++)
	{
	if (`objectType $newSetMembers[$i]`=="joint")
		{
		select $newSetMembers[$i];
		$tempString=`dagPose -q -bp`;
		$bindPose=$tempString[0];
		if (`objExists $bindPose`)
			{
			$tempString=`listConnections ($newSetMembers[$i]+".bindPose")`;
			if ($tempString[0]==$bindPose)
				{
				select -add $bindPose;
				dagPose -rs;
				}
			}
		}
	}

if ($asConfirmIfNotInBuildPose==2) //Bind Pose is not same as Build Pose
	{
	tokenize $restorePoseCmd ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		catchQuiet (`eval($tempString[$i])`);
	}

for ($i=0;$i<size($allSetMembers);$i++)
	if (`gmatch $allSetMembers[$i] "*CurveInfo*"`)
		if (`objExists $allSetMembers[$i]`)
			delete $allSetMembers[$i];
for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		catchQuiet (`delete $allSetMembers[$i]`);

$skinClusters=`stringArrayRemoveDuplicates $skinClusters`;
$jointClusters=`stringArrayRemoveDuplicates $jointClusters`;
for ($i=0;$i<size($skinClusters);$i++)
	freezeSkinCluster $skinClusters[$i];
for ($i=0;$i<size($jointClusters);$i++)
	freezeJointCluster $jointClusters[$i];

if (`objExists FaceAllSet`)
	sets -add "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	sets -add "Sets" FaceControlSet;

//if ($runCmd!="")
//	evalEcho $runCmd;

//Post Rebuild : postRebuildScript
$postRebuildScript=`getAttr FitSkeleton.postRebuildScript`;
if ($postRebuildScript!="")
	evalEcho ($postRebuildScript);

eval ("dgdirty -a");

for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		delete $allSetMembers[$i];

select -cl;
}

global proc asBuildAdvancedSkeleton ()
{
global int $asRebuilding;
global string $asDSAltPivot;
global string $gSelect;
string $iconsFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asIcons.ma";

//FitSkeleton from basic joints
string $selJoints[]=`ls -sl -type joint`;
if (!`objExists FitSkeleton` && size($selJoints))
	{
	asCreateFitSkeleton;
	parent $selJoints[0] FitSkeleton;
	}

float $scale=`asGetScale`;
float $sideTreshold=0.0001*$scale;

//preBuild check
if (!`objExists FitSkeleton`)
	error "FitSkeleton not found. You must import a FitSkeleton, or select a joint-chain.\n";
if (!`file -q -ex $iconsFile`)
	error ("File not found:"+$iconsFile);
if (!$asRebuilding)
	if (`objExists "Group"`)
		error "AdvancedSkeleton already exists, use ReBuild instead";
string $tempString[]=`listRelatives -c -type joint FitSkeleton`;
if ($tempString[0]=="")
	error "FitSkeleton has no joints parented to it";
float $firstJointPos[3]=`xform -q -ws -t $tempString[0]`;
if ($tempString[0]=="Root" && ($firstJointPos[0]>$sideTreshold || $firstJointPos[0]<(-1*$sideTreshold)))
	{//Existing Root but not centered, gets renamed, so new centered root gets generated
	rename Root RootSide;
	$tempString=`listRelatives -c -type joint FitSkeleton`;
	}
if ($tempString[0]!="Root")
	{
	if (`objExists "Root"`)
		error "The top-level joint must be named \"Root\", but another object in this scene is already called Root";
	if ($firstJointPos[0]<$sideTreshold && $firstJointPos[0]>(-1*$sideTreshold))
		rename $tempString[0] Root;
	else
		{
		select FitSkeleton;
		joint -n Root;
		xform -ws -t 0 $firstJointPos[1] $firstJointPos[2] Root;
		parent $tempString[0];
		}
	}

if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;

asFitModeManualUpdate; //Ensure joint rotations & jointOrientations & uniqueNames
asOffFitMode;

string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	asEnsureFitJointAttrs $fitJoints[$i];

string $rootIKInfo[]=`asFitJointIKInfo Root`;
string $nonCenteredSpineJoints="";
if ($rootIKInfo[0]=="Spine")
	{
	string $rootIKJoints[]=`asGetIKJoints $rootIKInfo[1] $rootIKInfo[3]`;
	for ($i=0;$i<size($rootIKJoints);$i++)
		{
		float $rootIKJointPos[]=`xform -q -ws -t $rootIKJoints[$i]`;
		if ($rootIKJointPos[0]>$sideTreshold || $rootIKJointPos[0]<($sideTreshold*-1))
			$nonCenteredSpineJoints+="\""+$rootIKJoints[$i]+"\" ";
		}
	if ($nonCenteredSpineJoints!="")
		error ("These Spine joints are not in the center: "+$nonCenteredSpineJoints);
	}


setToolTo $gSelect;
asSetFixedWrapOptions;
int $numLetters,$centerBtwFeet,$inbetweenJoints,$reachedQtoes,$hasChildWithToesLabel;
int $fitJointTwistJoints[],$fitJointUpTwistJoints[],$fitJointBendyJoints[],$fitJointUpBendyJoints[],$fitJointBend[],$fitJointInbetweenJoints[],$fitJointUnTwister[],$fitJointRotOrder[];
int $fitJointIsEndJoint[],$ikLocal[],$ikLocalType[],$isScapula[],$fitJointGlobal[],$fitJointsWheel[],$fitJointFirstAfterIK[],$fitJointNonDef[];
int $fitJointsAim[],$fitJointNoMirror[],$fitJointNoFlip[],$fitJointNoControl[],$fitJointGlobalTranslate[];
int $isIKStart[],$isIKEnd[],$isIKBelowIKEnd[],$fitJointIKNumCtrls[];
int $fitJointLockTx[],$fitJointLockTy[],$fitJointLockTz[],$fitJointLockRx[],$fitJointLockRy[],$fitJointLockRz[],$fitJointLockSx[],$fitJointLockSy[],$fitJointLockSz[];
float $pos[3],$pos2[3],$rot[3],$sca[3],$parentPos[3],$parentRot[3],$temp[3],$temp2[3],$temp3[3];
float $footRotX[],$ikLenght[],$fitJointGlobalValue[];
float $dist,$defaultDistance;
$scale=`asGetScale`;
string $side,$childSide,$parent,$joint,$multipleDivide,$childLabel,$ankle,$heel,$toes,$toesEnd,$bigToe,$pinkyToe,$scapula,$label,$offsetParent,$curveGuide,$ctrl;
string $startJoint,$endJoint,$IKEndJoint;
string $fitJointLabel[],$fitJointSide[],$fitJointParent[],$fitJointParentSide[],$fitJointChild[],$fitJointChildSide[],$fitJointQtoes[];
string $fitJointsAttachTo[],$fitJointsAttachMode[],$fitJointsCurveGuide[],$tempString2[],$tempString3[];
string $asFitJointIKInfo[],$fitJointIK[],$fitJointIKStartJoint[],$fitJointIKMiddleJoint[],$fitJointIKEndJoint[],$fitJointIKSolver[],$IKJoints[],$userAttrs[],$footRollJoints[];
string $allBefore[]=`ls`;

if (`objExists FitSkeletonVisualizers`)
	{
	delete FitSkeletonVisualizers;
	asUpdateButtonEnables;
	}

int $numMainExtras=0;
if (`attributeExists numMainExtras FitSkeleton`)
	$numMainExtras=`getAttr FitSkeleton.numMainExtras`;

createNode -n "iconsGroup" transform;
setAttr "iconsGroup.visibility" 0;
asImportIconsFile $iconsFile;

//--Sets--//
select -cl;
sets -name ControlSet;
sets -name DeformSet;
sets -name AllSet;
sets -name "Sets";
sets -add "Sets" AllSet ControlSet DeformSet;
sets -add ControlSet `listRelatives -c iconsGroup`;

createNode -n "Group" transform;
asLockAttr "Group" 1 1 1 0;
duplicate -n Main Main_icon;
parent Main "Group";
xform -s (0.285*$scale) (0.285*$scale) (0.285*$scale) Main.cv[0:7];
connectAttr -f FitSkeletonShape.worldSpace[0] MainShape.create;
refresh;
disconnectAttr FitSkeletonShape.worldSpace[0] MainShape.create;

for ($i=1;$i<$numMainExtras+1;$i++)
	{
	if ($i==1)
		duplicate -n ("MainExtra"+$i) Main;
	else
		duplicate -n ("MainExtra"+$i) ("MainExtra"+($i-1));
	xform -s 1.1 1.1 1.1 ("MainExtra"+$i+".cv[0:7]");
	setAttr ("MainExtra"+$i+"Shape.overrideColor") (19+$i);
	}
for ($i=1;$i<$numMainExtras;$i++)
	parent ("MainExtra"+$i) ("MainExtra"+($i+1));
if ($numMainExtras>0)
	parent Main MainExtra1;

//--3rd level transforms--//
parent FitSkeleton Main;
createNode -n MotionSystem transform;
createNode -n DeformationSystem transform;
if (!$asRebuilding || !`objExists Geometry`)
	{
	createNode -n Geometry transform;
	setAttr -l 1 Geometry.inheritsTransform 0;
	parent Geometry "Group";
	}
parent MotionSystem DeformationSystem Main;
setAttr -l 0 FitSkeleton.v;
setAttr -l 1 FitSkeleton.v 0;
connectAttr -f MotionSystem.visibility MainShape.visibility;
for ($i=1;$i<$numMainExtras+1;$i++)
	connectAttr -f MotionSystem.visibility ("MainExtra"+$i+"Shape.visibility");

//--4th level transforms--//
createNode -n FKSystem -p MotionSystem transform;
createNode -n IKSystem -p MotionSystem transform;
createNode -n FKIKSystem -p MotionSystem transform;
createNode -n BendSystem -p MotionSystem transform;
createNode -n AimSystem -p MotionSystem transform;
createNode -n RootSystem -p MotionSystem transform;
createNode -n TwistSystem -p MotionSystem transform;
createNode -n GlobalSystem -p MotionSystem transform;
createNode -n ConstraintSystem -p MotionSystem transform;
createNode -n DynamicSystem -p MotionSystem transform;	
setAttr BendSystem.inheritsTransform 0;

//--5th level transforms--//
createNode -n IKJoints -p IKSystem transform;
createNode -n IKHandle -p IKSystem transform;
createNode -n IKFollow -p IKSystem transform;
createNode -n IKStatic -p IKSystem transform;
createNode -n IKCurve -p IKSystem transform;
setAttr IKCurve.inheritsTransform 0;
createNode -n IKMessure -p IKSystem transform;

//--6th level transforms--//
createNode -n IKRootConstraint -p IKHandle transform;

addAttr -k 1 -ln fkVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fkVis;
connectAttr -f Main.fkVis FKSystem.v;
addAttr -k 1 -ln ikVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.ikVis;
connectAttr -f Main.ikVis "IKSystem.v";
addAttr -k 1 -ln fkIkVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fkIkVis;
connectAttr -f Main.fkIkVis FKIKSystem.v;
addAttr -k 1 -ln aimVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimVis;
connectAttr -f Main.aimVis AimSystem.v;
addAttr -k 1 -ln aimFKVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimFKVis;
addAttr -k 1 -ln aimLRVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimLRVis;
addAttr -k 1 -ln fingerVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fingerVis;
addAttr -k 1 -ln bendVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.bendVis;
addAttr -k 1 -ln arrowVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.arrowVis;
addAttr -k 1 -ln drvSysVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.drvSysVis;

connectAttr -f Main.bendVis BendSystem.v;

if (`objExists jointLayer`)
	delete jointLayer;
createNode -n jointLayer displayLayer;
//setAttr jointLayer.displayType 2;


//Zero out endJoints
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$tempString2=`listRelatives -c -type joint $tempString[$y]`;
		if (size($tempString2)==0)
			{
			if (!`getAttr -l ($tempString[$y]+".rx")` && `getAttr -l ($tempString[$y]+".ry")` && `getAttr -l ($tempString[$y]+".rz")`)
				setAttr -type float3 ($tempString[$y]+".rotate") 0 0 0;
			setAttr -type float3 ($tempString[$y]+".jointOrient") 0 0 0;
			}
		}
	}

//Adding inbetweenJoints to FitSkeleton
for ($i=0;$i<size($fitJoints);$i++)
	{
	if (!`attributeExists inbetweenJoints $fitJoints[$i]`)
		continue;
	$inbetweenJoints=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
	if ($inbetweenJoints<1)
		continue;
	$rlaChild=`asRlaChild $fitJoints[$i]`;
	if ($rlaChild=="")
		continue;
	select $fitJoints[$i];
	string $inbetweenJoint;
	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		$inbetweenJoint=$fitJoints[$i]+"Part"+$y;
		joint -n $inbetweenJoint;
		setAttr ($inbetweenJoint+".rotateOrder") `getAttr ($fitJoints[$i]+".rotateOrder")`;
		float $weight=(1.0/($inbetweenJoints+1))*$y;
		$tempString=`pointConstraint -w $weight $rlaChild $inbetweenJoint`;
		pointConstraint -w (1-$weight) $fitJoints[$i] $inbetweenJoint;
		delete $tempString[0];
		addAttr -k 1 -ln tempInbetweener -at bool -dv 1 $inbetweenJoint;
		addAttr -k 1 -ln noControl -at bool -dv 1 $inbetweenJoint;
		float $fat=(`getAttr ($fitJoints[$i]+".fat")`*(1-$weight)) + (`getAttr ($rlaChild+".fat")`*$weight);
		float $fatY=(`getAttr ($fitJoints[$i]+".fatY")`*(1-$weight)) + (`getAttr ($rlaChild+".fatY")`*$weight);
		float $fatZ=(`getAttr ($fitJoints[$i]+".fatZ")`*(1-$weight)) + (`getAttr ($rlaChild+".fatZ")`*$weight);
		addAttr -k 0 -ln fat -at double -dv $fat $inbetweenJoint;
		addAttr -k 0 -ln fatY -at double -dv $fatY $inbetweenJoint;
		addAttr -k 0 -ln fatZ -at double -dv $fatZ $inbetweenJoint;
		}
	parent $rlaChild $inbetweenJoint;
	}

//Analyze
$fitJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	//Analyze $fitJointLabel
	$fitJointLabel[$i]=`asLabel $fitJoints[$i]`;

	//Analyze $fitJointSide
	$fitJointSide[$i]="_R";
	$pos=`xform -q -ws -t $fitJoints[$i]`;
	if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
		$fitJointSide[$i]="_M";

	//Analyze $fitJointNoMirror & $fitJointNoFlip
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`attributeExists noMirror $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noMirror")`)
				$fitJointNoMirror[$i]=1;
		if (`attributeExists noFlip $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noFlip")`)
				$fitJointNoFlip[$i]=1;
		}


	//Analyze $fitJointNoControl
	if (`attributeExists noControl $fitJoints[$i]`)
		$fitJointNoControl[$i]=`getAttr ($fitJoints[$i]+".noControl")`;

	//Analyze $fitJointIsEndJoint
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	if ($tempString[0]=="")
		$fitJointIsEndJoint[$i]=1;
	else
		$fitJointIsEndJoint[$i]=0;

	//Analyze rotateOrder
	$fitJointRotOrder[$i]=`getAttr ($fitJoints[$i]+".rotateOrder")`;

	//Analyze Parent
	$tempString=`listRelatives -p -type joint $fitJoints[$i]`;
	$fitJointParent[$i]=$tempString[0];

	//Analyze ParentSide
	if ($fitJointParent[$i]!="")
		{
		$fitJointParentSide[$i]="_R";
		$temp=`xform -q -ws -t $fitJointParent[$i]`;
		if ($temp[0]<$sideTreshold && $temp[0]>(-1*$sideTreshold))
			$fitJointParentSide[$i]="_M";
		}

	//Analyze Child
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	$fitJointChild[$i]=$tempString[0];
	//Prefer X-down child
	if (size($tempString)>1)
		for ($y=0;$y<size($tempString);$y++)
			{
			$temp=`getAttr ($tempString[$y]+".t")`;
			if ($temp[1]>-0.01 && $temp[1]<0.01 && $temp[2]>-0.01 && $temp[2]<0.01)
				{
				$fitJointChild[$i]=$tempString[$y];
				break;
				}
			}

	//Analyze ChildSide
	if ($fitJointChild[$i]!="")
		{
		$fitJointChildSide[$i]="_R";
		$temp=`xform -q -ws -t $fitJointChild[$i]`;
		if ($temp[0]<$sideTreshold && $temp[0]>(-1*$sideTreshold))
			$fitJointChildSide[$i]="_M";
		}

	//TwistJoints, BendyJoints & inbetweenJoints Require a RlaChild
	if (`asRlaChild $fitJoints[$i]`!="")
		{

		//Analyze TwistJoints
		if (`attributeExists twistJoints $fitJoints[$i]`)
			$fitJointTwistJoints[$i]=`getAttr ($fitJoints[$i]+".twistJoints")`;

		//Analyze BendyJoints
		if (`attributeExists bendyJoints $fitJoints[$i]`)
			$fitJointBendyJoints[$i]=`getAttr ($fitJoints[$i]+".bendyJoints")`;

		//Analyze inbetweenJoints
		if (`attributeExists inbetweenJoints $fitJoints[$i]`)
			$fitJointInbetweenJoints[$i]=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
		if (`attributeExists unTwister $fitJoints[$i]`)
			if ($fitJointInbetweenJoints[$i]>0)
				$fitJointUnTwister[$i]=`getAttr ($fitJoints[$i]+".unTwister")`;
		}

	//Analyze UpTwistJoints
	if ($fitJointParent[$i]!="")
		if (`attributeExists twistJoints $fitJointParent[$i]`)
			if ($fitJoints[$i]==`asRlaChild $fitJointParent[$i]`)
				$fitJointUpTwistJoints[$i]=`getAttr ($fitJointParent[$i]+".twistJoints")`;

	//Analyze UpBendyJoints
	if ($fitJointParent[$i]!="")
		if (`attributeExists bendyJoints $fitJointParent[$i]`)
			if ($fitJoints[$i]==`asRlaChild $fitJointParent[$i]`)
				$fitJointUpBendyJoints[$i]=`getAttr ($fitJointParent[$i]+".bendyJoints")`;

	//Analyze global
	if (`attributeExists "global" $fitJoints[$i]`)
		{
		$fitJointGlobal[$i]=1;
		$fitJointGlobalValue[$i]=`getAttr ($fitJoints[$i]+".global")`;
		if (`attributeExists "globalTranslate" $fitJoints[$i]`)
			$fitJointGlobalTranslate[$i]=`getAttr ($fitJoints[$i]+".globalTranslate")`;
		}


	//Analyze Aim
	if (`attributeExists aim $fitJoints[$i]`)
		$fitJointsAim[$i]=1;

	//Analyze geoAttach
	if (`attributeExists geoAttach $fitJoints[$i]`)
		{
		$fitJointsAttachTo[$i]=`getAttr -asString ($fitJoints[$i]+".geoAttach")`;
		if (`gmatch $fitJointsAttachTo[$i] "*__*"` && !`objExists $fitJointsAttachTo[$i]`)
			{
			$tempString[0]=`substitute "__" $fitJointsAttachTo[$i] ":"`;
			if (`objExists $tempString[0]`)
				$fitJointsAttachTo[$i]=$tempString[0];
			}
		if (`attributeExists geoAttachMode $fitJoints[$i]`)
			$fitJointsAttachMode[$i]=`getAttr -asString ($fitJoints[$i]+".geoAttachMode")`;
		}

	//Analyze curveGuide
	if (`attributeExists curveGuide $fitJoints[$i]`)
		{
		$fitJointsCurveGuide[$i]=`getAttr -asString ($fitJoints[$i]+".curveGuide")`;
		if (`gmatch $fitJointsCurveGuide[$i] "*__*"` && !`objExists $fitJointsCurveGuide[$i]`)
			{
			$tempString[0]=`substitute "__" $fitJointsCurveGuide[$i] ":"`;
			if (`objExists $tempString[0]`)
				$fitJointsCurveGuide[$i]=$tempString[0];
			}
		}

	//Analyze Wheel
	if (`attributeExists wheel $fitJoints[$i]`)
		$fitJointsWheel[$i]=1;

	//Analyze IK
	$asFitJointIKInfo=`asFitJointIKInfo $fitJoints[$i]`;
	$fitJointIK[$i]=$asFitJointIKInfo[0];
	$fitJointIKStartJoint[$i]=$asFitJointIKInfo[1];
	$fitJointIKMiddleJoint[$i]=$asFitJointIKInfo[2];
	$fitJointIKEndJoint[$i]=$asFitJointIKInfo[3];
	$fitJointIKSolver[$i]=$asFitJointIKInfo[4];
	if ($asFitJointIKInfo[5]!="")
		$fitJointIKNumCtrls[$i]=$asFitJointIKInfo[5];
	if ($fitJointIKStartJoint[$i]==$fitJoints[$i])
		$isIKStart[$i]=1;
	if ($fitJointIKEndJoint[$i]==$fitJoints[$i])
		if (!`gmatch $fitJointLabel[$i] "*Toes*"`)
			$isIKEnd[$i]=1;

	//Analyze $isIKBelowIKEnd ($toes/qtoes)
	if ($fitJointIK[$i]!="")
		{
		$asFitJointIKInfo=`asFitJointIKInfo $fitJointIKStartJoint[$i]`;
		$IKEndJoint=$asFitJointIKInfo[3];
		$tempString=`listRelatives -type joint -ad $fitJoints[$i]`;
		if ($fitJoints[$i]!=$IKEndJoint)
		if (!`stringArrayCount $IKEndJoint $tempString`)
			$isIKBelowIKEnd[$i]=1;
		}

	//Analyze $fitJointQtoes (for IKEndJoint)
	$fitJointQtoes[$i]="";
	if ($isIKEnd[$i])
		{
		$tempString=`listRelatives -type joint -ad $fitJoints[$i]`;
		for ($y=0;$y<size($tempString);$y++)
			{
			$childLabel=`asLabel $tempString[$y]`;
			if (`gmatch $childLabel "*QToes*"`)
				$fitJointQtoes[$i]=$tempString[$y];
			}
		}

	//Analyze Non-deform joints
	if (`gmatch $fitJointLabel[$i] "*Heel*"` || `gmatch $fitJointLabel[$i] "*BigToe*"` || `gmatch $fitJointLabel[$i] "*PinkyToe*"`)
		$fitJointNonDef[$i]=1;	

	//Analyze $footRotX
	if (`gmatch $fitJointLabel[$i] "*Foot*"`)
		{
		createNode -n rotationSampler1 transform;
		createNode -n rotationSampler2 -p rotationSampler1 transform;
		setAttr -type float3 rotationSampler1.r 90 0 -90;
		setAttr rotationSampler2.rotateOrder `getAttr ($fitJoints[$i]+".rotateOrder")`;
		orientConstraint $fitJoints[$i] rotationSampler2;
		$footRotX[$i]=`getAttr rotationSampler2.rx`*-1;
		delete rotationSampler1;
		}

	//Analyze $ikLocal
	if (`attributeExists ikLocal $fitJoints[$i]`)
		{
		$ikLocal[$i]=1;
		//backwards compatible (used to be bool attribute)
		if (`getAttr -type ($fitJoints[$i]+".ikLocal")`=="bool" && $ikLocal[$i]==0)
			$ikLocal[$i]=-1;
		$ikLocalType[$i]=`getAttr ($fitJoints[$i]+".ikLocal")`;
		}

	//Analyze FirstAfterIK
	if ($fitJointParent[$i]!="")
		{
		$asFitJointIKInfo=`asFitJointIKInfo $fitJointParent[$i]`;
		if ($fitJointIK[$i]!=$asFitJointIKInfo[0])
			$fitJointFirstAfterIK[$i]=1;
		}

	//Analyze Lock (if out ouf $lockCenterTolerance)
	$pos=`xform -q -ws -t $fitJoints[$i]`;
	float $lockCenterTolerance=0.01*$scale;
	if ($pos[0]<-$lockCenterTolerance || $pos[0]>$lockCenterTolerance)
		{
		if (`getAttr -l ($fitJoints[$i]+".tx")`) $fitJointLockTx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".ty")`) $fitJointLockTx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".tz")`) $fitJointLockTx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".rx")`) $fitJointLockRx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".ry")`) $fitJointLockRy[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".rz")`) $fitJointLockRz[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".sx")`) $fitJointLockSx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".sy")`) $fitJointLockSy[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".sz")`) $fitJointLockSz[$i]=1;
		}
	}

//Analyze $centerBtwFeet
if (`attributeExists centerBtwFeet Root`)
	$centerBtwFeet=`getAttr Root.centerBtwFeet`;

//Analyze $ikLenght
for ($i=0;$i<size($fitJoints);$i++)
	{
	$ikLenght[$i]=0;
	if ($fitJointIK[$i]=="")
		continue;
	$tempString[0]=$fitJointIKEndJoint[$i];
	for ($a=0;$a<99;$a++)
		{
		if ($tempString[0]==$fitJointIKStartJoint[$i])
			break;
		$ikLenght[$i]+=`getAttr ($tempString[0]+".tx")`;
		$tempString=`listRelatives -p $tempString[0]`;
		}
	$ikLenght[$i]=abs($ikLenght[$i]);
	}

//height
float $height,$lenght,$width,$maxFitJoint,$minFitJoint;
for ($a=0;$a<3;$a++)
	{
	$maxFitJoint=0;
	$minFitJoint=99;
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$pos=`xform -q -ws -t $fitJoints[$i]`;
		if ($pos[$a]>$maxFitJoint)
			$maxFitJoint=$pos[$a];
		if ($pos[$a]<$minFitJoint)
			$minFitJoint=$pos[$a];
		}
	if ($a==0) $width=$maxFitJoint-$minFitJoint;
	if ($a==1) $height=$maxFitJoint-$minFitJoint;
	if ($a==2) $lenght=$maxFitJoint-$minFitJoint;
	}
addAttr -ln height -at double Main;
setAttr -l 1 Main.height $height;
//$iconScaleFactor
float $iconScaleFactor=$height;
if ($lenght>$height && $lenght>$width) $iconScaleFactor=$lenght;
if ($width>$height && $width>$lenght) $iconScaleFactor=$width;
$iconScaleFactor=$iconScaleFactor/80.0;

//--Creation--//
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		$pos=`xform -q -ws -t $fitJoints[$i]`;
		$rot=`xform -q -ws -ro $fitJoints[$i]`;
		$joint=$fitJoints[$i]+$side;

		//Creation Deform
		select -cl;
		joint -n $joint;
		sets -add DeformSet $joint;
		setAttr ($joint+".rotateOrder") $fitJointRotOrder[$i];
		xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] $joint;
		xform -ws -ro $rot[0] $rot[1] $rot[2] $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fat")` -ln fat -at double $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fatY")` -ln fatY -at double $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fatZ")` -ln fatZ -at double $joint;

		if ($side=="_L")
			{
			$tempString=`mirrorJoint -mirrorYZ -mirrorBehavior $joint`;
			if (`asMayaVersionAsFloat`<2012)
				$tempString[0]=$joint+"1";
			if ($fitJointNoFlip[$i])
				rotate -r -os 0 0 180 $tempString[0];
			$rot=`xform -q -ws -ro $tempString[0]`;
			xform -ws -ro $rot[0] $rot[1] $rot[2] $joint;
			delete $tempString[0];
			}

		//Creation TwistJoints
		select $joint;
		for ($y=1;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			joint -n ($fitJoints[$i]+"Part"+$y+$side);
			sets -add DeformSet ($fitJoints[$i]+"Part"+$y+$side);
			setAttr ($fitJoints[$i]+"Part"+$y+$side+".rotateOrder") `getAttr ($fitJoints[$i]+".rotateOrder")`;
			}			

		if($fitJoints[$i]=="Root")
			connectAttr -f jointLayer.drawInfo Root_M.drawOverride;
		}

//Parent Deform
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;refresh;

		$joint=$fitJoints[$i]+$side;
		$parentJoint=$fitJointParent[$i]+$parentSide;
		if ($fitJointParent[$i]=="")
			parent $joint DeformationSystem;
		else
			parent $joint $parentJoint;
		}

//Parent TwistJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointTwistJoints[$i]<1)
			continue;refresh;

		float $twistDistance=`getAttr ($fitJointChild[$i]+$childSide+".tx")`/($fitJointTwistJoints[$i]+1.0);
		for ($y=1;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			setAttr ($fitJoints[$i]+"Part"+$y+$side+".tx") $twistDistance;
			//connect scale
			connectAttr ($fitJoints[$i]+$side+".sx") ($fitJoints[$i]+"Part"+$y+$side+".sx");
			connectAttr ($fitJoints[$i]+$side+".sy") ($fitJoints[$i]+"Part"+$y+$side+".sy");
			connectAttr ($fitJoints[$i]+$side+".sz") ($fitJoints[$i]+"Part"+$y+$side+".sz");
			//Exception for last twistJoint, this needs uniform scaling to avoid it`s child to `shear`
			if ($y==$fitJointTwistJoints[$i])
				connectAttr -f ($fitJoints[$i]+$side+".sy") ($fitJoints[$i]+"Part"+$y+$side+".sx");
			}
		

		//reParent child to last twist
		if ($fitJointTwistJoints[$i]>0)
			{
			parent -w ($fitJointChild[$i]+$childSide);//parent to world first, as this ensures auto-inverseScale connect
			parent ($fitJointChild[$i]+$childSide) ($fitJoints[$i]+"Part"+($fitJointTwistJoints[$i])+$side);
//			setAttr ($fitJointChild[$i]+$childSide+".segmentScaleCompensate") 0;
			}
		}

//Freeze rotation(move to jointOrient)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;refresh;

		$joint=$fitJoints[$i]+$side;
		makeIdentity -a 1 -r 1 $joint;
		}

//Advanced Root
asCreateController "Root" "X" "_M" "Root";
xform -s 0.23 0.23 0.23 RootX_M;
setAttr RootX_M.rotateOrder 3;
makeIdentity -a 1 -s 1 RootX_M;
parent RootOffsetX_M RootSystem;
createNode -n RootZeroXform transform;
parent RootZeroXform RootX_M;
parentConstraint RootZeroXform FKSystem;
parentConstraint RootZeroXform IKRootConstraint;

//LegLock
createNode -n LegLockConstrained -p RootSystem transform;
pointConstraint Root_M LegLockConstrained;
createNode -n RootSpineAligned -p RootX_M transform;
orientConstraint -mo Root_M RootSpineAligned;
orientConstraint RootX_M RootSpineAligned LegLockConstrained;
addAttr -k 1 -ln legLock -at double -min 0 -max 10 -dv 0 RootX_M;
createNode -n LegLockUnitConversion unitConversion;
setAttr LegLockUnitConversion.conversionFactor 0.1;
connectAttr RootX_M.legLock LegLockUnitConversion.input;
connectAttr LegLockUnitConversion.output LegLockConstrained_orientConstraint1.RootX_MW0;
createNode -n LegLockReverse reverse;
connectAttr LegLockUnitConversion.output LegLockReverse.inputX;
connectAttr LegLockReverse.outputX LegLockConstrained_orientConstraint1.RootSpineAlignedW1;


//Creation FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;


		asCreateController "FK" $fitJoints[$i] $side $fitJoints[$i];
//		setAttr ("FKExtra"+$fitJoints[$i]+$side+".overrideEnabled") 1;

		select ("FK"+$fitJoints[$i]+$side);
		joint -n ("FKX"+$fitJoints[$i]+$side);
		connectAttr -f jointLayer.drawInfo ("FKX"+$fitJoints[$i]+$side+".drawOverride");
		setAttr ("FKX"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
//		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("FKX"+$fitJoints[$i]+$side);

		if ($fitJointInbetweenJoints[$i])
			{
			parent ("FKX"+$fitJoints[$i]+$side) ("FKExtra"+$fitJoints[$i]+$side);
			for ($y=0;$y<$fitJointInbetweenJoints[$i]+1;$y++)
				{
				$joint="FKX"+$fitJoints[$i]+"Part"+$y+$side;
				if ($y==0)
					{
					$joint="FKX"+$fitJoints[$i]+$side;
					connectAttr ("FK"+$fitJoints[$i]+$side+".t") ($joint+".t");
					}
				orientConstraint ("FK"+$fitJoints[$i]+$side) ("FKExtra"+$fitJoints[$i]+$side) $joint;
				setAttr ($joint+"_orientConstraint1.interpType") 2;//gives more accurate division by 3rds
				float $w=(1.0/($fitJointInbetweenJoints[$i]+1))*($y+1);
				setAttr ($joint+"_orientConstraint1.FK"+$fitJoints[$i]+$side+"W0") $w;
				setAttr ($joint+"_orientConstraint1.FKExtra"+$fitJoints[$i]+$side+"W1") (1-$w);
				}
			}

		if($fitJointGlobal[$i])
			{
			createNode -n ("FKGlobalStatic"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
			setAttr ("FKGlobalStatic"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			duplicate -n ("FKGlobal"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
			duplicate -n ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
			duplicate -n ("GlobalOffset"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);

			parent ("FKGlobal"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
			parent ("FKExtra"+$fitJoints[$i]+$side) ("FKGlobal"+$fitJoints[$i]+$side);
			parent ("Global"+$fitJoints[$i]+$side) ("GlobalOffset"+$fitJoints[$i]+$side);
			parent ("GlobalOffset"+$fitJoints[$i]+$side) GlobalSystem;

			orientConstraint ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side) ("FKGlobal"+$fitJoints[$i]+$side);
			addAttr -k 1 -ln "Global"-at double -min 0 -max 10 -dv $fitJointGlobalValue[$i] ("FK"+$fitJoints[$i]+$side);
			createNode -n ("globalReverse"+$fitJoints[$i]+$side) reverse;
			createNode -n ("globalUnitConversion"+$fitJoints[$i]+$side) unitConversion;
			setAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".conversionFactor") 0.1;
			connectAttr ("FK"+$fitJoints[$i]+$side+".Global") ("globalUnitConversion"+$fitJoints[$i]+$side+".input");
			connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("globalReverse"+$fitJoints[$i]+$side+".inputX");
			connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+$side+"_orientConstraint1.Global"+$fitJoints[$i]+$side+"W0");
			connectAttr ("globalReverse"+$fitJoints[$i]+$side+".outputX") ("FKGlobal"+$fitJoints[$i]+$side+"_orientConstraint1.FKGlobalStatic"+$fitJoints[$i]+$side+"W1");

			if ($fitJointGlobalTranslate[$i])
				{
				pointConstraint ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side) ("FKGlobal"+$fitJoints[$i]+$side);
//				connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+$side+"_pointConstraint1.Global"+$fitJoints[$i]+$side+"W0");
//				connectAttr ("globalReverse"+$fitJoints[$i]+$side+".outputX") ("FKGlobal"+$fitJoints[$i]+$side+"_pointConstraint1.FKGlobalStatic"+$fitJoints[$i]+$side+"W1");


				addAttr -k 1 -ln "GlobalTranslate" -at double -min 0 -max 10 -dv $fitJointGlobalValue[$i] ("FK"+$fitJoints[$i]+$side);
				createNode -n ("globalTranslateReverse"+$fitJoints[$i]+$side) reverse;
				createNode -n ("globalTranslateUnitConversion"+$fitJoints[$i]+$side) unitConversion;
				setAttr ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".conversionFactor") 0.1;
				connectAttr ("FK"+$fitJoints[$i]+$side+".GlobalTranslate") ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".input");
				connectAttr ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".output") ("globalTranslateReverse"+$fitJoints[$i]+$side+".inputX");
				connectAttr ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+$side+"_pointConstraint1.Global"+$fitJoints[$i]+$side+"W0");
				connectAttr ("globalTranslateReverse"+$fitJoints[$i]+$side+".outputX") ("FKGlobal"+$fitJoints[$i]+$side+"_pointConstraint1.FKGlobalStatic"+$fitJoints[$i]+$side+"W1");
				}
			}

		if ($isIKEnd[$i])
			{
			createNode -n ("AlignIKTo"+$fitJoints[$i]+$side) transform;
			setAttr ("AlignIKTo"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			parent ("AlignIKTo"+$fitJoints[$i]+$side) ("FKX"+$fitJoints[$i]+$side);
			setAttr -type float3 ("AlignIKTo"+$fitJoints[$i]+$side+".t") 0 0 0;
			}

		if ($fitJointNoControl[$i])
			{
			setAttr -l 1 ("FK"+$fitJoints[$i]+$side+"Shape.v") 0;
			sets -rm ControlSet {("FK"+$fitJoints[$i]+$side),("FKExtra"+$fitJoints[$i]+$side)};
			}
		}

//Parenting FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		if ($fitJointParent[$i]=="")
			parent ("FKOffset"+$fitJoints[$i]+$side) FKSystem;

		else if ($fitJointFirstAfterIK[$i])
			{
			$parentContraintToXform="FKParentConstraintTo"+$fitJointParent[$i]+$parentSide;
			if (!`objExists $parentContraintToXform`)
				{
				createNode -n $parentContraintToXform -p FKSystem transform;
				//-mo as this prevents Ankle from flipping. nut this make scaleConstraint wrong
				asAlign $parentContraintToXform ($fitJointParent[$i]+$parentSide) 1 0 0 0;
//				parentConstraint -mo ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
				if ($fitJointParent[$i]=="Root")
					parentConstraint LegLockConstrained $parentContraintToXform;
				else
					{
					//point & orient instead of parent, as we dont want inverseScale
					pointConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
					orientConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
					//parentConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
					}

				if ($fitJointParent[$i]=="Wrist")
					connectAttr Main.fingerVis ($parentContraintToXform+".v");
				}
			parent ("FKOffset"+$fitJoints[$i]+$side) $parentContraintToXform;
			connectAttr -f jointLayer.drawInfo ("FKOffset"+$fitJoints[$i]+$side+".drawOverride");
			}
		else
			parent ("FKOffset"+$fitJoints[$i]+$side) ("FKX"+$fitJointParent[$i]+$parentSide);
		}

//FK segmentScaleCompensate
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		//fingers/toes to scale up with hand/foot, and anything below head
		if (`gmatch $fitJoints[$i] "*Finger*"` || `gmatch $fitJoints[$i] "*Cup*"` || `gmatch $fitJoints[$i] "*Toes*"` || $fitJointParent[$i]=="Head")
			{
			setAttr ($fitJoints[$i]+$side+".segmentScaleCompensate") 0;
			$parentContraintToXform="FKParentConstraintTo"+$fitJointParent[$i]+$parentSide;
			if (`objExists $parentContraintToXform`)
				if (!`isConnected ($fitJointParent[$i]+$parentSide+".s") ($parentContraintToXform+".s")`)
					connectAttr ($fitJointParent[$i]+$parentSide+".s") ($parentContraintToXform+".s");
//				scaleConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
//changed scaleConstraint to scaleConnect, to resolve stretchyLeg bending the foot.
			}
		}

//Creation IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;

		select -cl;
		joint -n ("IKX"+$fitJoints[$i]+$side);
		setAttr ("IKX"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
		//Extra child under IKX (IKX2), for the FKIK to constrain to, as this avoids constrain flip.
		createNode -n ("IKX2"+$fitJoints[$i]+$side) -p ("IKX"+$fitJoints[$i]+$side) transform;
		if ($isIKStart[$i])
			{
			createNode -n ("IKParentConstraint"+$fitJoints[$i]+$side) transform;
			setAttr ("IKParentConstraint"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			createNode -n ("IKXOffset"+$fitJoints[$i]+$side) transform;
			setAttr ("IKXOffset"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			parent ("IKX"+$fitJoints[$i]+$side) ("IKXOffset"+$fitJoints[$i]+$side);
			if (`objExists ($fitJointParent[$i]+$parentSide)`)
				{
				$parentPos=`xform -q -ws -t ($fitJointParent[$i]+$parentSide)`;
				$parentRot=`xform -q -ws -ro ($fitJointParent[$i]+$parentSide)`;
				xform -ws -t $parentPos[0] $parentPos[1] $parentPos[2] -ro $parentRot[0] $parentRot[1] $parentRot[2] ("IKParentConstraint"+$fitJoints[$i]+$side);
				if ($fitJointIKSolver[$i]!="ikSplineSolver")
					{
					if ($fitJointParent[$i]=="Root")
						parentConstraint LegLockConstrained ("IKParentConstraint"+$fitJoints[$i]+$side);
					else
						parentConstraint ($fitJointParent[$i]+$parentSide) ("IKParentConstraint"+$fitJoints[$i]+$side);
					}
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKXOffset"+$fitJoints[$i]+$side);
				makeIdentity -a 1 -r 1 ("IKX"+$fitJoints[$i]+$side);
				}
			else
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKParentConstraint"+$fitJoints[$i]+$side);
			asAlign ("IKXOffset"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 1 0 0;
			parent ("IKXOffset"+$fitJoints[$i]+$side) ("IKParentConstraint"+$fitJoints[$i]+$side);
			}
		else
			xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKX"+$fitJoints[$i]+$side);
		if ($isIKStart[$i] && $fitJointIKSolver[$i]=="ikRPsolver")
			{
			createNode -n ("IKMessureFrom"+$fitJoints[$i]+$side) -p ("IKParentConstraint"+$fitJoints[$i]+$side) transform;
			asAlign ("IKMessureFrom"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) 1 1 0 1;
			}
		if ($isIKStart[$i])
			connectAttr -f jointLayer.drawInfo ("IKX"+$fitJoints[$i]+$side+".drawOverride");
		}

//Parenting IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;

		if ($isIKStart[$i])
			parent ("IKParentConstraint"+$fitJoints[$i]+$side) IKJoints;
		else
			{
			parent ("IKX"+$fitJoints[$i]+$side) ("IKX"+$fitJointParent[$i]+$parentSide);
			makeIdentity -a 1 -r 1 ("IKX"+$fitJoints[$i]+$side);
			}
		}

//Constraint to FK (&IK)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		parentConstraint ("FKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
		if ($fitJointIK[$i]!="")
			parentConstraint -w 0 ("IKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
		parent ($fitJoints[$i]+$side+"_parentConstraint1") ConstraintSystem;
		}
// 1-joint-FitSkeleton:
if (`objExists Root_M` && !`objExists Root_M_parentConstraint1`)
	parentConstraint -mo RootX_M Root_M;

//UnTwister (inbetweener option)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointUnTwister[$i])
			{
			$tempString=`listRelatives -c -type joint ($fitJoints[$i]+"Part"+$fitJointInbetweenJoints[$i])`;
			string $unTwisterChild=$tempString[0];
			asCreateUnTwister $unTwisterChild $side $fitJoints[$i] $side "" 1 0 "";
			for ($y=1;$y<$fitJointInbetweenJoints[$i]+1;$y++)
				{
				createNode -n ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side) multiplyDivide;
//				connectAttr ("TwistBalancer"+$unTwisterChild+$side+".rx") ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side+".input1X");
				connectAttr ("TwistBalancer"+$unTwisterChild+$side+".twist") ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side+".input1X");
				setAttr ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side+".input2X") ((1.0/($fitJointInbetweenJoints[$i]+1))*$y);
				connectAttr ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side+".outputX") ($fitJoints[$i]+"Part"+$y+$side+"_parentConstraint1.target[0].targetOffsetRotateX");
				}
			}
		}

//Advanced Aim
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$fitJointsAim[$i])
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;

		if (!`objExists ("Aim"+$fitJoints[$i])`)
			{
			createNode -n ("Aim"+$fitJoints[$i]) -p AimSystem transform;
			createNode -n ("AimOffset"+$fitJoints[$i]) -p ("Aim"+$fitJoints[$i]) transform;
			createNode -n ("AimFollow"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			createNode -n ("AimFollowOn"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			createNode -n ("AimFollowOff"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
			rename $tempString[0] ("Aim"+$fitJoints[$i]+"_M");
			setAttr ("Aim"+$fitJoints[$i]+"_MShape.overrideEnabled") 1;
			setAttr ("Aim"+$fitJoints[$i]+"_MShape.overrideColor") 17;
			sets -add ControlSet ("Aim"+$fitJoints[$i]+"_M");
			scale -r -p 0 0 0 ($scale/3.0) ($scale/3.0) ($scale/3.0) ("Aim"+$fitJoints[$i]+"_M.cv[0:4]");
			parent ("Aim"+$fitJoints[$i]+"_M") ("AimFollow"+$fitJoints[$i]);
			$pos=`xform -q -ws -t $fitJoints[$i]`;
			xform -ws -t 0 $pos[1] ($pos[2]+$scale*2) ("AimOffset"+$fitJoints[$i]);

			//.follow setup
			addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 ("Aim"+$fitJoints[$i]+"_M");
			createNode -n ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M") unitConversion;
			setAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.conversionFactor") 0.1;
			connectAttr ("Aim"+$fitJoints[$i]+"_M.follow") ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.input");
			createNode -n ("Aim"+$fitJoints[$i]+"FollowReverse_M") reverse;
			connectAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.output") ("Aim"+$fitJoints[$i]+"FollowReverse_M.inputX");

			parentConstraint ("AimFollowOn"+$fitJoints[$i]) ("AimFollowOff"+$fitJoints[$i]) ("AimFollow"+$fitJoints[$i]);
			parentConstraint -mo ($fitJointParent[$i]+$fitJointParentSide[$i]) ("AimFollowOn"+$fitJoints[$i]);

			connectAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.output") ("AimFollow"+$fitJoints[$i]+"_parentConstraint1.AimFollowOn"+$fitJoints[$i]+"W0");
			connectAttr ("Aim"+$fitJoints[$i]+"FollowReverse_M.outputX") ("AimFollow"+$fitJoints[$i]+"_parentConstraint1.AimFollowOff"+$fitJoints[$i]+"W1");
			}
		
		if ($side!="_M")
			{
			createNode -n ("AimOffset"+$fitJoints[$i]+$side) -p ("Aim"+$fitJoints[$i]+"_M") transform;
			duplicate -n ("Aim"+$fitJoints[$i]+$side) ("Aim"+$fitJoints[$i]+"_M");
			$tempString=`listRelatives -c -f -type transform ("Aim"+$fitJoints[$i]+$side)`;
			if (`size ($tempString)`) delete $tempString;
			parent ("Aim"+$fitJoints[$i]+$side) ("AimOffset"+$fitJoints[$i]+$side);
			asLockAttr ("Aim"+$fitJoints[$i]+$side) 0 1 1 1;
			deleteAttr ("Aim"+$fitJoints[$i]+$side+".follow");
			setAttr -type float3 ("AimOffset"+$fitJoints[$i]+$side+".s") 0.2 0.2 0.2;
			asAlign ("AimOffset"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 0 0 0;
			setAttr ("AimOffset"+$fitJoints[$i]+$side+".tz") 0;
			connectAttr Main.aimLRVis ("Aim"+$fitJoints[$i]+$side+"Shape.v");
			}
		createNode -n ("FKAim"+$fitJoints[$i]+$side) transform;
		asAlign ("FKAim"+$fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side) 1 1 0 1;
		$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
		parent ("FKAim"+$fitJoints[$i]+$side) $tempString[0];
		aimConstraint -aim 1 0 0 -upVector 0 0 -1 -worldUpVector 0 0 -1 -worldUpType "objectrotation" 
			-worldUpObject ($fitJointParent[$i]+$fitJointParentSide[$i]) ("Aim"+$fitJoints[$i]+$side) ("FKAim"+$fitJoints[$i]+$side);
		parent ("FKOffset"+$fitJoints[$i]+$side) ("FKAim"+$fitJoints[$i]+$side);
		connectAttr Main.aimFKVis ("FK"+$fitJoints[$i]+$side+"Shape.v");
		}


//Advanced IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKEnd[$i])
			continue;

		$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;

		//IKSp jointChain
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			createNode -n ("IKSp"+$fitJointIK[$i]+"Offset"+$side) -p IKJoints transform;
			setAttr -l 1 ("IKSp"+$fitJointIK[$i]+"Offset"+$side+".v") 0;
			asAlign ("IKSp"+$fitJointIK[$i]+"Offset"+$side) ("FKX"+$fitJointIKStartJoint[$i]+$side) 1 0 0 1;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("FKX"+$fitJointIKStartJoint[$i]+$side) ($fitJointIKEndJoint[$i]+$side) ("IKSp"+$fitJointIK[$i]+"Offset"+$side)`;
			select ("IKSp"+$fitJointIK[$i]+"Offset"+$side);
			for ($y=0;$y<size($IKJoints);$y++)
				{
				joint -n ("IKSp"+$IKJoints[$y]+$side);
//				connectAttr ("IKSp"+$IKJoints[$y]+$side+".r") ("IKX"+$IKJoints[$y]+$side+".r");
//				parent ("IKSp"+$fitJointIK[$i]+$IKJoints[$y]+$side) ("IKSp"+$fitJointIK[$i]+"Offset"+$side);
				}
			//distribute IKSp joints straight and evenly
			for ($y=0;$y<size($IKJoints);$y++)
				{
				float $posFactor=0;
				$posFactor=(1.0/(`size($IKJoints)`-1)*$y);
				pointConstraint -w (1-$posFactor) ($fitJointIKStartJoint[$i]+$side) ("IKSp"+$IKJoints[$y]+$side);
				pointConstraint -w $posFactor ($fitJointIKEndJoint[$i]+$side) ("IKSp"+$IKJoints[$y]+$side);
				delete ("IKSp"+$IKJoints[$y]+$side+"_pointConstraint1");
				}
			//parent IKSp joints
//			for ($y=1;$y<size($IKJoints)-1;$y++)
//				parent ("IKSp"+$IKJoints[$y+1]+$side) ("IKSp"+$IKJoints[$y]+$side);
			}

		//IKfake, first & last 2 joints in splineIK chain are `fake`, so that`real` can blend btw fake and ..AlignTo (for fixed end.rot in stretchy mode)
		//Also IKfake3 ensures correct twist distribution, as splikeIK twist assumes `end bone`
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			select ("IKSp"+$fitJointIKStartJoint[$i]+$side);
			joint -n ("IKfake0"+$fitJointIK[$i]+$side);
			setAttr -l 1 ("IKfake0"+$fitJointIK[$i]+$side+".v") 0;
			parent ("IKfake0"+$fitJointIK[$i]+$side) ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side);
			$tempString=`listRelatives -c ("IKSp"+$fitJointIKStartJoint[$i]+$side)`;
			parent $tempString[0] ("IKfake0"+$fitJointIK[$i]+$side);
			$tempString=`listRelatives -p ("IKSp"+$fitJointIKEndJoint[$i]+$side)`;
			select $tempString[0];
//			select ("IKfake0"+$fitJointIK[$i]+$side);
			joint -n ("IKfake1"+$fitJointIK[$i]+$side);
			joint -n ("IKfake2"+$fitJointIK[$i]+$side);
			joint -n ("IKfake3"+$fitJointIK[$i]+$side);
			asAlign ("IKfake2"+$fitJointIK[$i]+$side) ("IKSp"+$fitJointIKEndJoint[$i]+$side) 1 1 1 0;
			$tempString=`listRelatives -p $tempString[0]`;
			parent ("IKfake1"+$fitJointIK[$i]+$side) $tempString[0];
			setAttr -l 1 ("IKfake1"+$fitJointIK[$i]+$side+".visibility") 0;
			setAttr ("IKfake3"+$fitJointIK[$i]+$side+".tx") `getAttr ("IKfake2"+$fitJointIK[$i]+$side+".tx")`;			
			}

		$startJoint="IKX"+$fitJointIKStartJoint[$i]+$side;
		$endJoint="IKX"+$fitJointIKEndJoint[$i]+$side;
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			$startJoint="IKfake0"+$fitJointIK[$i]+$side;
			$endJoint="IKfake2"+$fitJointIK[$i]+$side;
			if (`objExists ("IKfake2"+$fitJointIK[$i]+$side)`)
				$endJoint="IKfake3"+$fitJointIK[$i]+$side;
			}
		joint -e -setPreferredAngles -children $startJoint;
		if (`objExists ("IKfake1"+$fitJointIK[$i]+$side)` && size($IKJoints)==2)
			{
			$tempString=`listRelatives -p ("IKfake1"+$fitJointIK[$i]+$side)`;
			if ($tempString[0]!="IKfake0"+$fitJointIK[$i]+$side)
				parent ("IKfake1"+$fitJointIK[$i]+$side) ("IKfake0"+$fitJointIK[$i]+$side);
			}
		$tempString=`ikHandle -n ("IK"+$fitJointIK[$i]+"Handle"+$side) -ccv 0 -ns 2 -sol $fitJointIKSolver[$i] -sj $startJoint -ee $endJoint`;
		rename $tempString[1] ("IK"+$fitJointIK[$i]+"Effector"+$side);
		setAttr -l 1 ("IK"+$fitJointIK[$i]+"Handle"+$side+".v") 0;
		setAttr -l 1 ("IK"+$fitJointIK[$i]+"Effector"+$side+".v") 0;
		setAttr ("IK"+$fitJointIK[$i]+"Effector"+$side+".rotateOrder") $fitJointRotOrder[$i];
		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			//controller
			asCreateController "IK" $fitJointIK[$i] $side $fitJoints[$i];		
			if ($fitJointQtoes[$i]!="")
				asAlign ("IKOffset"+$fitJointIK[$i]+$side) ($fitJointQtoes[$i]+$side) 1 0 0 0;
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("IK"+$fitJointIK[$i]+$side);
			//pole
			asCreateController "Pole" $fitJointIK[$i] $side $fitJoints[$i];	
			asLockAttr ("Pole"+$fitJointIK[$i]+$side) 0 1 1 1;
			//place poleVector
//			$tempString=`listRelatives -c -type joint $fitJointIKStartJoint[$i]`;
//			$startJointChildJoint=$tempString[0];
			createNode -n tempPoleVecPlacer1 transform;
			createNode -n tempPoleVecPlacer2 -p tempPoleVecPlacer1 transform;
			createNode -n tempPoleVecPlacer3 -p tempPoleVecPlacer2 transform;
			$tempString=`pointConstraint $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i] tempPoleVecPlacer1`;
			setAttr ($tempString[0]+"."+$fitJointIKStartJoint[$i]+"W0") `getAttr ($fitJointIKEndJoint[$i]+".tx")`;
			setAttr ($tempString[0]+"."+$fitJointIKEndJoint[$i]+"W1") `getAttr ($fitJointIKMiddleJoint[$i]+".tx")`;
			aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject $fitJointIKStartJoint[$i] $fitJointIKMiddleJoint[$i] tempPoleVecPlacer2;
			setAttr tempPoleVecPlacer3.tx $ikLenght[$i];
			$temp=`xform -q -ws -t tempPoleVecPlacer3`;
			delete tempPoleVecPlacer1;
			xform -ws -t ($temp[0]*$b) $temp[1] $temp[2] ("PoleOffset"+$fitJointIK[$i]+$side);
			poleVectorConstraint ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side);
			$tempString[0]=`createNode annotationShape`;
			$tempString=`listRelatives -p $tempString[0]`;
			string $direction=`rename $tempString[0] ("PoleAnnotation"+$fitJointIK[$i]+$side)`;
			setAttr ($direction+"Shape.overrideEnabled") 1;
			setAttr ($direction+"Shape.overrideDisplayType") 2;
			connectAttr Main.arrowVis ($direction+".v");
//			$tempString=`listRelatives -c -type joint $fitJointIKStartJoint[$i]`;
			parent $direction ("IKX"+$fitJointIKMiddleJoint[$i]+$side);
			xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $direction;
			connectAttr ("Pole"+$fitJointIK[$i]+$side+"Shape.worldMatrix[0]") ($direction+"Shape.dagObjectMatrix[0]");
			//orientCnstraint last segment to controller
			createNode -n ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
			createNode -n ("IKFKAligned"+$fitJointIK[$i]+$side) -p ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) transform;
			asAlign ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ($fitJointIKEndJoint[$i]+$side) 0 1 0 0;
			orientConstraint ("IKFKAligned"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKEndJoint[$i]+$side);
			//$ikLocal
			if ($ikLocal[$i] && $ikLocalType[$i]==0)//$ikLocal=addCtrl
				{
				asCreateController "IKLocal" $fitJointIK[$i] $side $fitJoints[$i];
				asAlign ("IKLocalOffset"+$fitJointIK[$i]+$side) ($fitJointIKEndJoint[$i]+$side) 0 1 0 0;
				parent ("IKLocalOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
				asLockAttr ("IKLocal"+$fitJointIK[$i]+$side) 1 0 1 1;
				parent ("IKFKAligned"+$fitJointIK[$i]+$side) ("IKLocal"+$fitJointIK[$i]+$side);
				}
			if ($ikLocal[$i] && $ikLocalType[$i]==1)//$ikLocal=nonZero
				{
				parent -w ("IKFKAlignedOffset"+$fitJointIK[$i]+$side);
//				asAlign ("IK"+$fitJointIK[$i]+$side) $fitJoints[$i] 0 1 0 0;
//				setAttr -type float3 ("IKFKAlignedOffset"+$fitJointIK[$i]+$side+".r") (90*$b) 0 180;
				createNode -n tempXform transform;
				asAlign tempXform ($fitJointIKMiddleJoint[$i]+$side) 1 1 0 0;
				delete `aimConstraint -aimVector (1*$b) 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject tempXform tempXform ("IK"+$fitJointIK[$i]+$side)`;
				if (`gmatch $fitJointLabel[$i] "*Foot*"`)
					delete `aimConstraint -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject tempXform tempXform ("IK"+$fitJointIK[$i]+$side)`;
				delete tempXform;
				parent ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
				asAlign ("AlignIKTo"+$fitJointIKEndJoint[$i]+$side) ("IK"+$fitJointIK[$i]+$side) 0 1 0 0;
				}
			if ($ikLocal[$i] && $ikLocalType[$i]==2)//$ikLocal=localOrient
				{
				parent -w ("IKFKAlignedOffset"+$fitJointIK[$i]+$side);
				asAlign ("IKOffset"+$fitJointIK[$i]+$side) ($fitJoints[$i]+$side) 0 1 0 0;
				parent ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
				setAttr -type float3 ("AlignIKTo"+$fitJointIKEndJoint[$i]+$side+".r") 0 0 0;
				}
			}
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) IKHandle;
			string $crvCmd="curve -n IK"+$fitJointIK[$i]+"Curve"+$side+" -d 3";
			for ($z=0;$z<$fitJointIKNumCtrls[$i]+2;$z++)
				 $crvCmd+=" -p 0 0 0";
			eval ($crvCmd);
			$tempString=`listRelatives -s ("IK"+$fitJointIK[$i]+"Curve"+$side)`;
			rename $tempString[0] ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape");
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.overrideEnabled") 1;
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.overrideDisplayType") 1;
			parent ("IK"+$fitJointIK[$i]+"Curve"+$side) IKCurve;

			$ikControlNr=1;
			for ($z=0;$z<$fitJointIKNumCtrls[$i]+2;$z++)
				{
				spaceLocator -n ("IK"+$fitJointIK[$i]+"Locator"+$z+$side);
				setAttr -l 1 ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+".v") 0;
				connectAttr ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+"Shape.worldPosition[0]") ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.controlPoints["+$z+"]");

				float $posFactor=0;
				if ($z>1)
					$posFactor=($z-1)/($fitJointIKNumCtrls[$i]-1.0);
				if ($z>$fitJointIKNumCtrls[$i]-1)
				    $posFactor=1;
				float $invPosFactor=1-$posFactor;
				$tempString=`pointConstraint -w $invPosFactor ("IKSp"+$fitJointIKStartJoint[$i]+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side)`;
				pointConstraint -w $posFactor ("IKSp"+$fitJointIKEndJoint[$i]+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side);
				delete $tempString[0];

				if ($z!=1 && $z!=$fitJointIKNumCtrls[$i])//Controller for each loc except second and seconLast (they are for stiffness)
					{
					asCreateController "IK" ($fitJointIK[$i]+$ikControlNr) $side $fitJointIKStartJoint[$i];
					parent ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) IKRootConstraint;
					asAlign ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) 1 1 0 1;
					parent ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
					$rot=`xform -q -ws -ro ("IKSp"+$fitJointIKStartJoint[$i]+$side)`;
					xform -s 0.1 1 1 ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");
					xform -ws -ro $rot[0] $rot[1] $rot[2] ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");
					$ikControlNr++;
					}
				}
			//inbetween Ik Controllers to follow start & end (Spine only)
			if (`gmatch $fitJointIK[$i] "*Spine*"`)
				for ($z=2;$z<$fitJointIKNumCtrls[$i];$z++)
					{
					float $weight=(1.0/($fitJointIKNumCtrls[$i]-1))*($z-1);
					parentConstraint -mo -w (1-$weight) ("IK"+$fitJointIK[$i]+"1"+$side) ("IKOffset"+$fitJointIK[$i]+$z+$side);
					parentConstraint -mo -w $weight ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$z+$side);
					}
			//inbetween Ik Controllers: lock rotate
			for ($z=2;$z<$fitJointIKNumCtrls[$i];$z++)
				{
				asLockAttr ("IK"+$fitJointIK[$i]+$z+$side) 0 1 0 1;
				asLockAttr ("IKExtra"+$fitJointIK[$i]+$z+$side) 0 1 0 1;
				}

			parent ("IK"+$fitJointIK[$i]+"Locator1"+$side) ("IK"+$fitJointIK[$i]+"1"+$side);
			parent ("IK"+$fitJointIK[$i]+"Locator"+$fitJointIKNumCtrls[$i]+$side) ("IK"+$fitJointIK[$i]+($ikControlNr-1)+$side);
			connectAttr -f ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace[0]") ("IK"+$fitJointIK[$i]+"Handle"+$side+".inCurve");

			createNode -n ("IKCurveInfo"+$fitJointIK[$i]+$side) curveInfo;
			connectAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.worldSpace[0]") ("IKCurveInfo"+$fitJointIK[$i]+$side+".inputCurve");

			//if 1 Ik control, build 2, but expose 1
			if (`attributeExists ikCtrls $fitJointIKStartJoint[$i]`)
				if(`getAttr ($fitJointIKStartJoint[$i]+".ikCtrls")`==1)
					{
					sets -rm ControlSet ("IK"+$fitJointIK[$i]+"1"+$side) ("IKExtra"+$fitJointIK[$i]+"1"+$side);
					setAttr -l 1 ("IK"+$fitJointIK[$i]+"1"+$side+".v") 0;
					}

			//IK spline stretchy
			addAttr -k 1 -ln stretchy -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			createNode -n ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side) multiplyDivide;
			setAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".operation") 2;
			createNode -n ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side) multiplyDivide;
			setAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".operation") 2;
			connectAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".outputX") ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".input1X");
			connectAttr ("Main.scaleX") ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".input2X");
			connectAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength") ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".input1X");
			setAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".input2X") `getAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength")`;
			createNode -n ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
			setAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".stretchy") ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
			createNode -n ("stretchy"+$fitJointIK[$i]+"Reverse"+$side) reverse;
			connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("stretchy"+$fitJointIK[$i]+"Reverse"+$side+".inputX");
			select `listRelatives -ad -type joint $startJoint`;
			select -d ("IKSp"+$fitJointIKEndJoint[$i]+$side);
			$tempString=`ls -sl`;
			for ($x=0;$x<size($tempString);$x++) 
				{
				createNode -n ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side) multiplyDivide;
				setAttr ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side+".input1X") `getAttr ($tempString[$x]+".translateX")`;
				connectAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".outputX") ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side+".input2X");

				createNode -n ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side) blendTwoAttr;
				connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".attributesBlender");
				setAttr ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".input[0]") `getAttr ($tempString[$x]+".translateX")`;
				connectAttr ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side+".outputX") ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".input[1]");
				connectAttr ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".output") ($tempString[$x]+".translateX");
				}

			//IKFake (ChestOrientationLock)
			$tempString=`spaceLocator -n ("IKFake1UpLoc"+$fitJointIK[$i]+$side)`;
			$loc1=$tempString[0];
			asAlign $loc1 ("IKfake1"+$fitJointIK[$i]+$side) 1 1 0 0;
			parent $loc1 ("IKfake1"+$fitJointIK[$i]+$side);
			setAttr ($loc1+".translateY") 1;
			$tempString=`listRelatives -p ("IKSp"+$fitJointIKEndJoint[$i]+$side)`;
			$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject $loc1 ("IKfake2"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) $tempString[0]`;
			$constraint=$tempString[0];
			$attrs=`listAttr -k -ud $constraint`;
			connectAttr ("stretchy"+$fitJointIK[$i]+"Reverse"+$side+".outputX") ($tempString[0]+"."+$attrs[0]);
			connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($tempString[0]+"."+$attrs[1]);


			createNode -n ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) ("IKSp"+$fitJointIKStartJoint[$i]+$side) 1 1 0 0;
			parent ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) ("IK"+$fitJointIK[$i]+"1"+$side);

			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) transform;
//			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) ("IKfake2"+$fitJointIK[$i]+$side) 1 1 0 0;
			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) ("IKfake2"+$fitJointIK[$i]+$side) 1 1 0 0;
			parent ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);

			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) ("IKfake2"+$fitJointIK[$i]+$side) 1 0 0 0;
			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) ("IKSp"+$fitJointIKStartJoint[$i]+$side) 0 1 0 0;
			parent ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);

			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistTo"+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistTo"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) 1 1 0 0;
			parent ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistTo"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side);

			parentConstraint ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) ("IKSp"+$fitJointIKStartJoint[$i]+$side);

			//IK spline Stiff
			$ikControlNr=1;
			for ($z=0;$z<$fitJointIKNumCtrls[$i]+2;$z++)
				{
				if ($z!=1 && $z!=$fitJointIKNumCtrls[$i])
					continue;
				if ($z==$fitJointIKNumCtrls[$i])
					$ikControlNr=$fitJointIKNumCtrls[$i];
				addAttr -k 1 -ln stiff -at double -min 0 -max 10 -dv 5 ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
				createNode -n ("IKStiff"+$fitJointIK[$i]+$z+$side) setRange;
				setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".minX") 0.01;
				setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".oldMinX") 0;
				setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".oldMaxX") 10;
				connectAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".stiff") ("IKStiff"+$fitJointIK[$i]+$z+$side+".valueX");
				createNode -n ("IKStiffOrient"+$fitJointIK[$i]+$z+$side) transform;
				if ($z==1)
					asAlign ("IKStiffOrient"+$fitJointIK[$i]+$z+$side) ($fitJointIKStartJoint[$i]+$side) 1 0 0 0;
				else
					asAlign ("IKStiffOrient"+$fitJointIK[$i]+$z+$side) ($fitJointIKEndJoint[$i]+$side) 1 0 0 0;
				string $aimAt=$fitJointIKEndJoint[$i]+$side;
				float $aimV[3]={1,0,0};
				if ($z==$fitJointIKNumCtrls[$i])
					$aimAt=$fitJointIKStartJoint[$i]+$side;
				$tempString=`aimConstraint -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ($fitJointIKStartJoint[$i]+$side) $aimAt ("IKStiffOrient"+$fitJointIK[$i]+$z+$side)`;
				delete $tempString[0];
				parent ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) ("IKStiffOrient"+$fitJointIK[$i]+$z+$side);
				parent ("IKStiffOrient"+$fitJointIK[$i]+$z+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
				setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".maxX") ($ikLenght[$i]/2.0);
				//Override for Spline to avoid IK curves self-folding, when having many IK controllers
				if (`gmatch $fitJointIK[$i] "*Spline*"`)
					setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".maxX") (($ikLenght[$i]/($fitJointIKNumCtrls[$i]-1))*1.5);
				connectAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".outValueX") ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+".translateX");
//				if ($fitJointIKNumCtrls[$i]<3)
//					setAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".stiff") 10;
				}

			parentConstraint -mo ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side);
			asCreateUnTwister $fitJoints[$i] $side $fitJointIKStartJoint[$i] $side $fitJointIK[$i] $b 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo");
//			connectAttr ("TwistBalancer"+$fitJoints[$i]+$side+".rotateX") ("IK"+$fitJointIK[$i]+"Handle"+$side+".twist");
			connectAttr ("TwistBalancer"+$fitJoints[$i]+$side+".twist") ("IK"+$fitJointIK[$i]+"Handle"+$side+".twist");

			//IK spline Follow
			if ($fitJointIKSolver[$i]=="ikSplineSolver")
				{
				$ikControlNr=1;
				for ($z=0;$z<$fitJointIKNumCtrls[$i]+2;$z++)
					if ($z!=1 && $z!=$fitJointIKNumCtrls[$i])//Controller for each loc except second and seconLast (they are for stiffness)
						{
						$tempString=`listRelatives -p ($fitJointIKStartJoint[$i]+$side)`;
						string $ikParent=$tempString[0];
						if ($ikParent!="DeformationSystem" && $ikParent!="Root_M")
							{
							if (`gmatch $fitJointIK[$i] "*Spine*"` && $z>1 && $z<$fitJointIKNumCtrls[$i])//not Mid Spine controller
								{$ikControlNr++;continue;}

							asFollow ("IK"+$fitJointIK[$i]+$ikControlNr+$side) ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) $ikParent;
							$ikControlNr++;
							}
						}
				}

			//IK spline Global
			if (`attributeExists "global" $IKJoints[size($IKJoints)-1]`)
				{
				$temp[0]=`getAttr ($IKJoints[size($IKJoints)-1]+".global")`;
				addAttr -k 1 -ln "Global" -at double -min 0 -max 10 -dv $temp[0] ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
				createNode -n ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"SetRange"+$side) setRange;
				setAttr ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"SetRange"+$side+".minY") 1;
				setAttr ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"SetRange"+$side+".maxX") 1;
				setAttr -type float3 ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"SetRange"+$side+".oldMax") 10 10 0;
				connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".Global") ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"SetRange"+$side+".valueX");
				connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".Global") ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"SetRange"+$side+".valueY");
				createNode -n ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) -p ("IKOffset"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) transform;
				duplicate -n ("IKGlobalOn"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
				duplicate -n ("IKGlobalOff"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
				parent ("IKExtra"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
				parent ("IKGlobalOn"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) GlobalSystem;
				orientConstraint ("IKGlobalOn"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKGlobalOff"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
				connectAttr ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"SetRange"+$side+".outValueX") ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+"_orientConstraint1.IKGlobalOn"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+"W0");
				connectAttr ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"SetRange"+$side+".outValueY") ("IKGlobal"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+"_orientConstraint1.IKGlobalOff"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+"W1");
				}

			//Constraint to IKSp jointChain
			for ($y=0;$y<size($IKJoints);$y++)
				{
				createNode -n ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) -p ("IKSp"+$IKJoints[$y]+$side) transform;
				asAlign ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ($IKJoints[$y]+$side) 1 1 0 0;
				if ($IKJoints[$y]==$fitJointIKEndJoint[$i]) //fixedEnd replacement (always fixedEnd)
					{
					$tempString=`pointConstraint ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) ("IKX"+$IKJoints[$y]+$side)`;
					$constraint=$tempString[0];
					$attrs=`listAttr -k -ud $constraint`;
					connectAttr ("stretchy"+$fitJointIK[$i]+"Reverse"+$side+".outputX") ($tempString[0]+"."+$attrs[0]);
					connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($tempString[0]+"."+$attrs[1]); 
//					orientConstraint ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) ("IKX"+$IKJoints[$y]+$side);
					orientConstraint -mo ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKX"+$IKJoints[$y]+$side);
					}
				else
					parentConstraint ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ("IKX"+$IKJoints[$y]+$side);
				}
			}

		$tempString=`listRelatives -p ($fitJointIKStartJoint[$i]+$side)`;
		string $ikParent=$tempString[0];

		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			//PoleAim (PoleLeg avoid flipping in the forward plane)
			if (`gmatch $fitJointIK[$i] "*Leg*"`)
				{
				createNode -n ("PoleAim"+$fitJointIK[$i]+$side) transform;
				asAlign ("PoleAim"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKStartJoint[$i]+$side) 1 0 0 0;
//				if ($msLegAim[$i]!="")
//					asAlign ("PoleAim"+$fitJointIK[$i]+$side) ($msLegAim[$i]+$side) 1 0 0 0;
				$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side) ("PoleAim"+$fitJointIK[$i]+$side)`;
				$constraint=$tempString[0];
				parent ("PoleAim"+$fitJointIK[$i]+$side) ("IKHandle");
//				pointConstraint Root_M ("PoleAim"+$fitJointIK[$i]+$side);
				pointConstraint $ikParent ("PoleAim"+$fitJointIK[$i]+$side);
				}

			//Follow
			if (!`gmatch $fitJointIK[$i] "*Leg*"`)
				{
				asFollow ("IK"+$fitJointIK[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$side) $ikParent;
				}
			if (`gmatch $fitJointIK[$i] "*Leg*"`)
				asFollow ("Pole"+$fitJointIK[$i]+$side) ("PoleOffset"+$fitJointIK[$i]+$side) ("PoleAim"+$fitJointIK[$i]+$side);
			else
				asFollow ("Pole"+$fitJointIK[$i]+$side) ("PoleOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
			}
		}

//Advanced FKIK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKStart[$i])
			continue;

		duplicate -n ("FKIK"+$fitJointIK[$i]+$side) "FKIK_icon";
		xform -ws -t 0 0 0 -ro 0 0 0 ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -type float3 ("FKIK"+$fitJointIK[$i]+$side+".scale") $iconScaleFactor $iconScaleFactor $iconScaleFactor;
		setAttr ("FKIK"+$fitJointIK[$i]+$side+".rotateY") 90;
		makeIdentity -a 1 -t 1 -r 1 -s 1 ("FKIK"+$fitJointIK[$i]+$side);

		createNode -n ("FKIKParentConstraint"+$fitJointIK[$i]+$side) transform;
		$tempString=`listRelatives -p -type joint ($fitJointIKStartJoint[$i]+$side)`;
		string $parent=$tempString[0];
		if ($parent=="Root_M")
			parentConstraint LegLockConstrained ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		else if(`objExists $parent`)
			parentConstraint $parent ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		else
			parentConstraint ($fitJointIKStartJoint[$i]+$side) ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		parent ("FKIKParentConstraint"+$fitJointIK[$i]+$side) ("FKIKSystem");

		$sca=`xform -q -r -s $fitJointIKStartJoint[$i]`;
		$sca[0]*=$scale;$sca[1]*=$scale;$sca[2]*=$scale;
		parent ("FKIK"+$fitJointIK[$i]+$side) ($fitJointIKStartJoint[$i]+$side);
		setAttr -type float3 ("FKIK"+$fitJointIK[$i]+$side+".t") ($iconScaleFactor*$b*5) 0 ($iconScaleFactor*$b*5);
		//`fat` based side-distance
		if (`attributeExists fatZ $fitJoints[$i]`)
			{
			$pos=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side+".cv[0]")`;
			$pos2=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side+".cv[5]")`;
			$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`*$b;
			setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") ((`getAttr ($fitJoints[$i]+".fat")`*`getAttr ($fitJoints[$i]+".fatZ")`*$b)+($dist/2.0));
			}

		//ensure its moved to `outside` direction
		if ($side!="_M")
			{
			$pos=`xform -q -ws -t ($fitJointIKStartJoint[$i]+$side)`;
			$pos2=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side)`;
			if ($side=="_R" && $pos2[0]>$pos[0])
				setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") (`getAttr ("FKIK"+$fitJointIK[$i]+$side+".tz")`*-1);
			if ($side=="_L" && $pos2[0]<$pos[0])
				setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") (`getAttr ("FKIK"+$fitJointIK[$i]+$side+".tz")`*-1);
			}

		parent ("FKIK"+$fitJointIK[$i]+$side) ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		asLockAttr ("FKIK"+$fitJointIK[$i]+$side) 1 1 1 1;

		addAttr -k 1 -ln FKIKBlend -at double -min 0 -max 10 -dv 0 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln autoVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -k 0 -cb 1 ("FKIK"+$fitJointIK[$i]+$side+".autoVis");
		addAttr -k 1 -ln FKVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln IKVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -ln startJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".startJoint") $fitJointIKStartJoint[$i];
		addAttr -ln middleJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".middleJoint") $fitJointIKMiddleJoint[$i];
		addAttr -ln endJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".endJoint") $fitJointIKEndJoint[$i];

		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side) reverse;
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".inputX");

		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side) condition;
		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side) setRange;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".minX") 10;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".oldMaxX") 10;

		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".autoVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".firstTerm");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".IKVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfTrueR");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfTrueG");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".valueX");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfFalseR");
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".outValueX") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfFalseG");


		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKOffset"+$fitJointIK[$i]+$side+".visibility");
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("PoleOffset"+$fitJointIK[$i]+$side+".visibility");
			}
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			for ($z=1;$z<$fitJointIKNumCtrls[$i]+1;$z++)
				connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKOffset"+$fitJointIK[$i]+$z+$side+".visibility");
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IK"+$fitJointIK[$i]+"Curve"+$side+".visibility");
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".overrideEnabled") 1;
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".overrideDisplayType") 1;
			}
		connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR")  ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side+".visibility");
		connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorG")  ("FKOffset"+$fitJointIKStartJoint[$i]+$side+".visibility");
		}


//FKIK connect to constraints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointIK[$i]!="")
			{
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".outputX")       ($fitJoints[$i]+$side+"_parentConstraint1.FKX"+$fitJoints[$i]+$side+"W0");
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($fitJoints[$i]+$side+"_parentConstraint1.IKX"+$fitJoints[$i]+$side+"W1");
			}
	}


//Advanced FootRoll
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!`gmatch $fitJointLabel[$i] "*Foot*"`)
			continue;

		//find $ankle,$heel,$toes,$toesEnd & $footRollJoints
		$ankle=$fitJoints[$i];
		$heel="";$toes="";$toesEnd="";$bigToe="";$pinkyToe="";
		clear $footRollJoints;
		$tempString=`listRelatives -ad -type joint $ankle`;
//		for ($y=0;$y<size($tempString);$y++)
		for ($y=size($tempString)-1;$y>-1;$y--)
			{
			$childLabel=`asLabel $tempString[$y]`;
			if (`gmatch $childLabel "*Heel*"`)
				$heel=$tempString[$y];
			if (`gmatch $childLabel "*Toes*"` && !`gmatch $childLabel "*ToesEnd*"`)
				{
				$toes=$tempString[$y];
				$footRollJoints[size($footRollJoints)]=$tempString[$y];
				}
			if (`gmatch $childLabel "*BigToe*"`)
				$bigToe=$tempString[$y];
			if (`gmatch $childLabel "*PinkyToe*"`)
				$pinkyToe=$tempString[$y];
			if (`gmatch $childLabel "*ToesEnd*"`)
				{
				$toesEnd=$tempString[$y];
				$footRollJoints[size($footRollJoints)]=$tempString[$y];
				}
			//skip joints below Toes (that is not ToesEnd)
			$tempString2=`ls -l $tempString[$y]`;
			if (`gmatch $tempString2[0] ("*|"+$toes+"|*")` && $tempString[$y]!=$toesEnd)
				continue;
			//skip joints that end-up at Toes label $hasChildWithToesLabel (e.g claw attached to Ankle)
			$hasChildWithToesLabel=0;
			$tempString2=`listRelatives -ad -type joint $tempString[$y]`;
			for ($z=0;$z<size($tempString2);$z++)
				{
				$label=`asLabel $tempString2[$z]`;
				if (`gmatch $label "*Toes*"`)
					$hasChildWithToesLabel=1;
				}
			if (!$hasChildWithToesLabel)
				continue;
			if ($childLabel=="")
				$footRollJoints[size($footRollJoints)]=$tempString[$y];
			}
		if ($heel!="")
			$footRollJoints[size($footRollJoints)]=$heel;

		if ($toes=="" || $toesEnd=="")
			continue;

		addAttr -k 1 -ln swivel -at double -dv 0 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln toe -at double ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln roll -at double -min -5 -max 10 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln rollAngle -at double -dv 25 ("IK"+$fitJointIK[$i]+$side);

		connectAttr ("IK"+$fitJointIK[$i]+$side+".swivel") ("PoleAim"+$fitJointIK[$i]+$side+"_aimConstraint1.offset.offsetX");
		$tempString=`listConnections ("PoleAim"+$fitJointIK[$i]+$side+"_aimConstraint1.offset.offsetX")`;
		setAttr ($tempString[0]+".conversionFactor") 0.1;

		createNode -n ("IK"+$fitJointIK[$i]+"FootRoll"+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
		$temp=`xform -q -ws -t ($fitJointIKEndJoint[$i]+$side)`;
		xform -ws -t $temp[0] $temp[1] $temp[2] ("IK"+$fitJointIK[$i]+"FootRoll"+$side);
		setAttr ("IK"+$fitJointIK[$i]+"FootRoll"+$side+".ry") ($footRotX[$i]*$b);

		//$footRollJoints  IK->Heel->ToeEnd->Toes->Hocks
		for ($y=0;$y<size($footRollJoints);$y++)
			{
			asCreateController "Roll" $footRollJoints[$y] $side $footRollJoints[$y];
			setAttr ("RollOffset"+$footRollJoints[$y]+$side+".ry") ($footRotX[$i]*$b);
			if ($y>0)
				parent ("RollOffset"+$footRollJoints[$y-1]+$side) ("Roll"+$footRollJoints[$y]+$side);
			}
		parent ("RollOffset"+$footRollJoints[size($footRollJoints)-1]+$side)  ("IK"+$fitJointIK[$i]+$side);

		//Pinky/index toe side2side rocking
		if (`objExists $toes` && `objExists $bigToe` && `objExists $pinkyToe`)
			{
			addAttr -k 1 -ln rock -at double -dv 0 ("IK"+$fitJointIK[$i]+$side);
			createNode -n ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
//			createNode -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
			setAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rotateOrder") 5;
			asAlign ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("Roll"+$toes+$side) 1 1 0 0;
			$pos=`xform -q -ws -t $toes`;
			if (`objExists $bigToe`)
				$pos=`xform -q -ws -t $bigToe`;
			xform -ws -t ($pos[0]*$b) 0 $pos[2] ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("Roll"+$toes+$side);
			duplicate -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			$pos=`xform -q -ws -t $toes`;
			if (`objExists $pinkyToe`)
				$pos=`xform -q -ws -t $pinkyToe`;
			xform -ws -t ($pos[0]*$b) 0 $pos[2] ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+$side);

			createNode -n ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side) clamp;
			setAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".minR") -200;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".rock") ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".inputR");
			connectAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".outputR") ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rz");
			if ($side=="_L")
				{
				$tempString=`listConnections ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rz")`;
				setAttr ($tempString[0]+".conversionFactor") (`getAttr ($tempString[0]+".conversionFactor")`*-1);
				}
			createNode -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side) clamp;
			setAttr ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".maxR") 200;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".rock") ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".inputR");
			connectAttr ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".outputR") ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side+".rz");
			if ($side=="_L")
				{
				$tempString=`listConnections ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side+".rz")`;
				setAttr ($tempString[0]+".conversionFactor") (`getAttr ($tempString[0]+".conversionFactor")`*-1);
				}
			parent ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			parent ("IKFKAligned"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"FootRoll"+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			parent ("RollOffset"+$footRollJoints[size($footRollJoints)-1]+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
				
			if (`objExists ("IKLocalOffset"+$fitJointIK[$i]+$side)`)
				parent ("IKLocalOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			}

		if ($ikLocal[$i] && $ikLocalType[$i]==0 && $heel!="")//$ikLocal=addCtrl
			{
			createNode -n ("RollOffsetOffset"+$heel+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
			asAlign ("RollOffsetOffset"+$heel+$side) ("RollOffset"+$heel+$side) 1 1 0 0;
			parent ("RollOffset"+$heel+$side) ("RollOffsetOffset"+$heel+$side);
			parent ("RollOffsetOffset"+$heel+$side) ("IKLocal"+$fitJointIK[$i]+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRoll"+$side) ("IKLocal"+$fitJointIK[$i]+$side);
			}

		for ($y=-1;$y<size($footRollJoints)-1;$y++)
			{
			if ($y==-1)
				$startJoint=$ankle;
			else
				$startJoint=$footRollJoints[$y];
			$endJoint=$footRollJoints[$y+1];
			if ($startJoint==$heel || $endJoint==$heel)
				continue;
			$tempString=`ikHandle -n ("IK"+$startJoint+"Handle"+$side) -s "sticky" -sol ikSCsolver -sj ("IKX"+$startJoint+$side) -ee ("IKX"+$footRollJoints[$y+1]+$side)`;
			rename $tempString[1] ("IK"+$startJoint+"Effector"+$side);
			parent ("IK"+$startJoint+"Handle"+$side) ("Roll"+$footRollJoints[$y+1]+$side);
			setAttr -l 1 ("IK"+$startJoint+"Handle"+$side+".v") 0;
			}

		if ($toesEnd!="")
			{
			createNode -n ("IK"+$fitJointIK[$i]+"LiftToe"+$side) -p ("Roll"+$toesEnd+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+"LiftToe"+$side) ($toes+$side) 1 0 0 0;
			parent ("IK"+$toes+"Handle"+$side) ("IK"+$fitJointIK[$i]+"LiftToe"+$side);
			connectAttr ("IK"+$fitJointIK[$i]+$side+".toe") ("IK"+$fitJointIK[$i]+"LiftToe"+$side+".rx");
			}

		//parent LegIKHandle to end of RollHierarchy
		if (`objExists ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side)`)
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side);
		else
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("Roll"+$footRollJoints[0]+$side);

		createNode -n ($fitJointIK[$i]+$side+"AngleReverse") multiplyDivide;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".rollAngle") ($fitJointIK[$i]+$side+"AngleReverse.input1X");
		setAttr ($fitJointIK[$i]+$side+"AngleReverse.input2X") -1;

		createNode -n ("IKRollAngle"+$fitJointIK[$i]+$side) setRange;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollAngle"+$fitJointIK[$i]+$side+".valueX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollAngle"+$fitJointIK[$i]+$side+".valueY");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollAngle"+$fitJointIK[$i]+$side+".valueZ");
		connectAttr ($fitJointIK[$i]+$side+"AngleReverse.output.outputX") ("IKRollAngle"+$fitJointIK[$i]+$side+".minX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".rollAngle") ("IKRollAngle"+$fitJointIK[$i]+$side+".maxY");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".rollAngle") ("IKRollAngle"+$fitJointIK[$i]+$side+".maxZ");
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMinX") -5;
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMaxY") 5;
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMinZ") 5;
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMaxZ") 10;

		for ($y=0;$y<size($footRollJoints);$y++)
			{
			if ($footRollJoints[$y]!=$heel && $footRollJoints[$y]!=$toes && $footRollJoints[$y]!=$toesEnd)
				continue;
			createNode -n ("RollRoller"+$footRollJoints[$y]+$side) -p ("RollOffset"+$footRollJoints[$y]+$side) transform;
			parent ("RollExtra"+$footRollJoints[$y]+$side) ("RollRoller"+$footRollJoints[$y]+$side);
			}

		if ($heel!="")
			connectAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".outValueX") ("RollRoller"+$heel+$side+".rotateX");
		connectAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".outValueY") ("RollRoller"+$toes+$side+".rotateX");
		connectAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".outValueZ") ("RollRoller"+$toesEnd+$side+".rotateX");

		//$qtoes aim
		if ($fitJointQtoes[$i]!="")
			{
			createNode -n ("RollToesAimTargetStatic"+$fitJointIK[$i]+$side) -p ("IKX"+$fitJointIKStartJoint[$i]+$side) transform;
			parent ("RollToesAimTargetStatic"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);

			addAttr -k 1 -ln toesAim -dv 10 -min 0 -max 10 -at double ("IK"+$fitJointIK[$i]+$side);
			createNode -n ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side) unitConversion;
			setAttr ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".conversionFactor") 0.1;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".toesAim") ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".input");
			createNode -n ("IK"+$fitJointIK[$i]+"RollToesAimReverse"+$side) reverse;
			connectAttr ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"RollToesAimReverse"+$side+".inputX");

			createNode -n ("RollToesAim"+$toes+$side) -p ("RollOffset"+$toes+$side) transform;
			$tempString=`listRelatives -p ("RollOffset"+$toes+$side)`;
			parent ("RollToesAim"+$toes+$side) $tempString[0];
			aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object"
				-worldUpObject ("Pole"+$fitJointIK[$i]+$side)
				("RollToesAimTargetStatic"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKStartJoint[$i]+$side) 
				("RollToesAim"+$toes+$side);
			parent ("RollOffset"+$toes+$side) ("RollToesAim"+$toes+$side);
			connectAttr ("IK"+$fitJointIK[$i]+"RollToesAimReverse"+$side+".outputX") ("RollToesAim"+$toes+$side+"_aimConstraint1.RollToesAimTargetStatic"+$fitJointIK[$i]+$side+"W0");
			connectAttr ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".output") ("RollToesAim"+$toes+$side+"_aimConstraint1.IKX"+$fitJointIKStartJoint[$i]+$side+"W1");
			}
		}
	if (`objExists deleteMe`)
		delete deleteMe;

//Advanced LegAim
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKStart[$i])
			continue;
		$tempString=`listRelatives -p $fitJoints[$i]`;
		$scapula=$tempString[0];
		if ($scapula!="")
			{
			$tempString[0]=`asLabel $scapula`;
			if (!`gmatch $tempString[0] "*LegAim*"`)
				continue;
			}

		addAttr -k 1 -ln legAim -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$side);
//		addAttr -k 1 -ln legAimSDK -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$side);
		$tempString=`listRelatives -p ("FKOffset"+$scapula+$side)`;
		$parent=$tempString[0];
		createNode -n ("LegAim"+$scapula+$side) -p $parent transform;
		asAlign ("LegAim"+$scapula+$side) ("FKOffset"+$scapula+$side) 1 1 0 0;
		duplicate -n ("LegAimOn"+$scapula+$side) ("LegAim"+$scapula+$side);
		duplicate -n ("LegAimOff"+$scapula+$side) ("LegAim"+$scapula+$side);

//		aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "object" -worldUpObject ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
		aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject ("LegAimOff"+$scapula+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
//		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("LegAimOff"+$scapula+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
//		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "object" -worldUpObject ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
		asAlign ("LegAimOff"+$scapula+$side) ("LegAimOn"+$scapula+$side) 1 1 0 0;
		orientConstraint ("LegAimOff"+$scapula+$side) ("LegAimOn"+$scapula+$side) ("LegAim"+$scapula+$side);
		parent ("FKOffset"+$scapula+$side) ("LegAim"+$scapula+$side);

		createNode -n ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side) unitConversion;
		setAttr ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".legAim") ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".input");

		createNode -n ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side) multiplyDivide;
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".input1X");
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".input2X");

		createNode -n ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side) reverse;
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".outputX") ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side+".inputX");
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".outputX") ("LegAim"+$scapula+$side+"_orientConstraint1.LegAimOn"+$scapula+$side+"W1");
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side+".outputX") ("LegAim"+$scapula+$side+"_orientConstraint1.LegAimOff"+$scapula+$side+"W0");

		createNode -n ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"_Shape") distanceDimShape;
		$tempString=`listRelatives -p ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"_Shape")`;
		rename $tempString[0] ("IKdistanceForLegAim"+$fitJointIK[$i]+$side);
		parent ("IKdistanceForLegAim"+$fitJointIK[$i]+$side) ("IKMessure");
		setAttr -l 1 ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+".visibility") 0;

		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side);
		setAttr -l 1 ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side+".v") 0;
		parent ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side) IKMessure;
		duplicate -n ("IKmessureLocForLegAim2"+$fitJointIK[$i]+$side) ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side);
		connectAttr ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side+".translate") ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+".startPoint");
		connectAttr ("IKmessureLocForLegAim2"+$fitJointIK[$i]+$side+".translate") ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+".endPoint");
		pointConstraint ("LegAim"+$scapula+$side) ("IKmessureLocForLegAim2"+$fitJointIK[$i]+$side);
		pointConstraint ("IK"+$fitJointIK[$i]+$side) ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side);

		$defaultDistance=`getAttr ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"Shape.distance")`;
		float $defaultAngleDirection=`getAttr ($fitJoints[$i]+$side+".jointOrientZ")`;
		float $defaultAngle=90;
		if ($defaultAngleDirection>0)
			$defaultAngle=-90;
		float $defaultUnstretchedLenght=0;
		$parent=$fitJointIKEndJoint[$i];
		while ($parent!=$fitJointIKStartJoint[$i])
			{
			$defaultUnstretchedLenght+=`getAttr ($parent+".tx")`;
			$tempString=`listRelatives -p $parent`;
			$parent=$tempString[0];
			}
		$defaultUnstretchedLenght+=`getAttr ($parent+".tx")`;

		createNode -n tempSampler -p ("FK"+$scapula+$side) transform;
		parent tempSampler ("LegAim"+$scapula+$side);
		float $defaultOffsetAngle=`getAttr tempSampler.rz`;
		delete tempSampler;
		}

//Advanced Scaling
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

//		if ($fitJointIsEndJoint[$i])
//			continue;

		if ($fitJointIK[$i]!="")
			{
			createNode -n ("ScaleBlend"+$fitJoints[$i]+$side) blendColors;
			setAttr -type float3 ("ScaleBlend"+$fitJoints[$i]+$side+".color1") 1 1 1;
			setAttr -type float3 ("ScaleBlend"+$fitJoints[$i]+$side+".color2") 1 1 1;
			if (`objExists ("FK"+$fitJoints[$i]+$side)`)
				{
				connectAttr ("FK"+$fitJoints[$i]+$side+".sx") ("ScaleBlend"+$fitJoints[$i]+$side+".color2R");
				connectAttr ("FK"+$fitJoints[$i]+$side+".sy") ("ScaleBlend"+$fitJoints[$i]+$side+".color2G");
				connectAttr ("FK"+$fitJoints[$i]+$side+".sz") ("ScaleBlend"+$fitJoints[$i]+$side+".color2B");
				}
			connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".outputR") ($fitJoints[$i]+$side+".scaleX");
			connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".outputG") ($fitJoints[$i]+$side+".scaleY");
			connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".outputB") ($fitJoints[$i]+$side+".scaleZ");
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("ScaleBlend"+$fitJoints[$i]+$side+".blender");
			}
		else if (`objExists ("FK"+$fitJoints[$i]+$side)`)
			connectAttr ("FK"+$fitJoints[$i]+$side+".scale") ($fitJoints[$i]+$side+".scale");
		}

for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJoints[$i]==$fitJointIKEndJoint[$i] && $isIKEnd[$i])
			{
			if ($fitJointIKSolver[$i]=="ikRPsolver")
				{
				connectAttr ("IK"+$fitJointIK[$i]+$side+".sx") ("ScaleBlend"+$fitJoints[$i]+$side+".color1R");
				connectAttr ("IK"+$fitJointIK[$i]+$side+".sy") ("ScaleBlend"+$fitJoints[$i]+$side+".color1G");
				connectAttr ("IK"+$fitJointIK[$i]+$side+".sz") ("ScaleBlend"+$fitJoints[$i]+$side+".color1B");
				connectAttr ("IK"+$fitJointIK[$i]+$side+".scale") ("IKX"+$fitJoints[$i]+$side+".scale");
				}
			if ($fitJointIKSolver[$i]=="ikSplineSolver")
				{
				$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;
				for ($y=0;$y<size($IKJoints);$y++)
					{
					createNode -n ("IKScaler"+$IKJoints[$y]+$side) -p IKHandle transform;
					createNode -n ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side) multiplyDivide;
					connectAttr ("IKScaler"+$IKJoints[$y]+$side+".scale") ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".input1");
					connectAttr ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".outputX") ("ScaleBlend"+$IKJoints[$y]+$side+".color1R");
					connectAttr ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".outputY") ("ScaleBlend"+$IKJoints[$y]+$side+".color1G");
					connectAttr ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".outputZ") ("ScaleBlend"+$IKJoints[$y]+$side+".color1B");
					for ($z=0;$z<$fitJointIKNumCtrls[$i];$z++)
						{
		        float $yy=(1.0/(size($IKJoints)-1))*$y;
		        float $zz=(1.0/($fitJointIKNumCtrls[$i]-1))*$z;
		        $weight=1-(abs($yy-$zz));
		        $weight=` smoothstep 0.5 1 $weight`;
						scaleConstraint -w $weight ("IK"+$fitJointIK[$i]+($z+1)+$side) ("IKScaler"+$IKJoints[$y]+$side);
						}
					float $scalerWeight=((1.0 / (`size($IKJoints)`+1))*($y+1))*2;
					if ($scalerWeight>1)
						$scalerWeight=1-($scalerWeight-1);
					addAttr -k 1 -ln scalerWeight -at double -dv $scalerWeight ("IKScaler"+$IKJoints[$y]+$side);
					}
				}
			}
		}

//Advanced Stretchy (arms/legs)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!$isIKEnd[$i])
			continue;
		if ($isIKBelowIKEnd[$i])
			continue;
		if ($fitJointIKSolver[$i]!="ikRPsolver")
			continue;
		if (`asIsMayaLT`)
			continue;

		addAttr -k 1 -ln stretchy -at double  -min 0 -max 10 -dv 0 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln antiPop -at double  -min 0 -max 10 -dv 0 ("IK"+$fitJointIK[$i]+$side);

		createNode -n ("IKSetRangeStretch"+$fitJointIK[$i]+$side) setRange;
		createNode -n ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side) setRange;
		setAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".maxX") 1;
		setAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".maxX") 1;
		setAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".oldMaxX") 10;
		setAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".oldMaxX") 10;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".stretchy") ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".valueX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".antiPop") ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".valueX");

		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLoc1"+$fitJointIK[$i]+$side);
		setAttr -l 1 ("IKmessureLoc1"+$fitJointIK[$i]+$side+".visibility") 0;
		pointConstraint ("IKX"+$fitJointIKStartJoint[$i]+$side)  ("IKmessureLoc1"+$fitJointIK[$i]+$side);
		parent ("IKmessureLoc1"+$fitJointIK[$i]+$side) ("IKMessure");
		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLoc2"+$fitJointIK[$i]+$side);
		setAttr -l 1 ("IKmessureLoc2"+$fitJointIK[$i]+$side+".visibility") 0;
		asAlign ("IKmessureLoc2"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side) 1 0 0 0;
		parent ("IKmessureLoc2"+$fitJointIK[$i]+$side) ("IKmessureLoc1"+$fitJointIK[$i]+$side);

		createNode -n ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) transform;
		asAlign ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side) 1 1 0 0;
		$tempString=`listRelatives -p ("IK"+$fitJointIK[$i]+"Handle"+$side)`;
		parent ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) $tempString[0];
		pointConstraint ("IKmessureConstrainTo"+$fitJointIK[$i]+$side)  ("IKmessureLoc2"+$fitJointIK[$i]+$side);

		createNode -n ("IKdistance"+$fitJointIK[$i]+$side+"_Shape") distanceDimShape;
		$tempString=`listRelatives -p ("IKdistance"+$fitJointIK[$i]+$side+"_Shape")`;
		rename $tempString[0] ("IKdistance"+$fitJointIK[$i]+$side);
		parent ("IKdistance"+$fitJointIK[$i]+$side) ("IKMessure");
		setAttr -l 1 ("IKdistance"+$fitJointIK[$i]+$side+".visibility") 0;
		connectAttr ("IKmessureLoc2"+$fitJointIK[$i]+$side+".translate") ("IKdistance"+$fitJointIK[$i]+$side+".endPoint");
		createNode -n ("IKmessureDiv"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".operation") 2;
		setAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".input2X") $ikLenght[$i];

		$distance=`getAttr ("IKdistance"+$fitJointIK[$i]+$side+".distance")`;
		createNode -n ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side) blendTwoAttr;
		connectAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".outValueX") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".attributesBlender");
		addAttr -ln antiPop -at double ("IKdistance"+$fitJointIK[$i]+$side+"Shape");
		setDrivenKeyframe -itt "spline" -ott "linear" -v $ikLenght[$i] -dv $ikLenght[$i] -cd ("IKdistance"+$fitJointIK[$i]+$side+".distance") ("IKdistance"+$fitJointIK[$i]+$side+"Shape.antiPop");
		setKeyframe -itt "spline" -ott "spline" -v $ikLenght[$i] -f ($ikLenght[$i]*0.1) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setKeyframe -itt "spline" -ott "spline" -v ($ikLenght[$i]*1.2) -f ($ikLenght[$i]*1.2) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setKeyframe -itt "linear" -ott "spline" -v $ikLenght[$i] -f ($ikLenght[$i]*0.70) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");

		setKeyframe -itt "spline" -ott "spline" -v ($ikLenght[$i]*0.9) -f ($ikLenght[$i]*0.85) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");

		selectKey ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setInfinity -poi linear;
		duplicate -n ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal") ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		cutKey -in 0 -in 1 -in 2 ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal");
		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+".distance") ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal.input");

		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal.output") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".input[0]");
		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop.output") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".input[1]");

		createNode -n ("IKdistanceClamp"+$fitJointIK[$i]+$side) clamp;
		setAttr ("IKdistanceClamp"+$fitJointIK[$i]+$side+".maxR") $ikLenght[$i];
		connectAttr ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".output") ("IKdistanceClamp"+$fitJointIK[$i]+$side+".inputR");
		createNode -n ("IKmessureBlendStretch"+$fitJointIK[$i]+$side) blendTwoAttr;
		connectAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".outValueX") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".attributesBlender");
		connectAttr ("IKdistanceClamp"+$fitJointIK[$i]+$side+".outputR") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".input[0]");
		connectAttr ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".output") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".input[1]");
		connectAttr ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".output") ("IKmessureDiv"+$fitJointIK[$i]+$side+".input1X");

		addAttr -k 1 -ln lock -at double -min 0 -max 10 ("Pole"+$fitJointIK[$i]+$side);
		createNode -n ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("Pole"+$fitJointIK[$i]+$side+".lock") ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".input");

		$tempString[0]=("IKX"+$fitJointIKStartJoint[$i]+$side);
		for ($a=0;$a<99;$a++)
			{
			$tempString=`listRelatives -c -type joint ($tempString[0])`;
			$temp[0]=`getAttr ($tempString[0]+".translateX")`;
			createNode -n ($tempString[0]+"_IKmessureDiv"+$side) multiplyDivide;
			setAttr ($tempString[0]+"_IKmessureDiv"+$side+".input2X") $temp[0];
			connectAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".output.outputX") ($tempString[0]+"_IKmessureDiv"+$side+".input1X");
//			connectAttr ($tempString[0]+"_IKmessureDiv"+$side+".output.outputX") ($tempString[0]+".translateX");
			//IkLengtControl
			addAttr -k 1 -ln ("Lenght"+($a+1)) -at double -dv 1 ("IK"+$fitJointIK[$i]+$side);
			createNode -n ($tempString[0]+"_IKLenght"+$side) multiplyDivide;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".Lenght"+($a+1)) ($tempString[0]+"_IKLenght"+$side+".input1X");
			setAttr ($tempString[0]+"_IKLenght"+$side+".input2X") $temp[0];
			connectAttr ($tempString[0]+"_IKLenght"+$side+".output.outputX") ($tempString[0]+"_IKmessureDiv"+$side+".input2X");

			//pole.lock
			createNode -n ("PoleLockBlender"+$tempString[0]) blendTwoAttr;
			connectAttr ($tempString[0]+"_IKmessureDiv"+$side+".output.outputX") ("PoleLockBlender"+$tempString[0]+".input[0]");
			connectAttr ("PoleLockBlender"+$tempString[0]+".output") ($tempString[0]+".translateX");
			connectAttr ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".output")  ("PoleLockBlender"+$tempString[0]+".attributesBlender");
			createNode -n ($tempString[0]+"Distance") distanceBetween;
			connectAttr ("Pole"+$fitJointIK[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix1");
			if ($a==0)
				connectAttr ("IKMessureFrom"+$fitJointIKStartJoint[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
			else
				connectAttr ("IK"+$fitJointIK[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
			createNode -n ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side) unitConversion;
			setAttr ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".conversionFactor") $b;
//			connectAttr ($tempString[0]+"Distance.distance") ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".input");
			//divide by Main.sy scale
			createNode -n ("PoleLockMainScaler"+$tempString[0]) multiplyDivide;
			setAttr ("PoleLockMainScaler"+$tempString[0]+".operation") 2;
			connectAttr ($tempString[0]+"Distance.distance") ("PoleLockMainScaler"+$tempString[0]+".input1X");
			connectAttr Main.sy ("PoleLockMainScaler"+$tempString[0]+".input2X");
			connectAttr ("PoleLockMainScaler"+$tempString[0]+".outputX") ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".input");

			connectAttr ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".output") ("PoleLockBlender"+$tempString[0]+".input[1]");

			//stretching applies to scaleX as well, unless twistJoints
			$tempString2=`listRelatives -p -type joint $tempString[0]`;
			$tempString2[0]=`substring $tempString2[0] 4 99`;
			$tempString3=`listRelatives -c -type joint $tempString2[0]`;
			if (!`gmatch $tempString3[0] "*Part[0-9]*"`)
				{
				createNode -n ("PoleLockBlenderNormalize"+$tempString[0]) multiplyDivide;
				setAttr ("PoleLockBlenderNormalize"+$tempString[0]+".operation") 2;
				setAttr ("PoleLockBlenderNormalize"+$tempString[0]+".input2X") `getAttr ("PoleLockBlender"+$tempString[0]+".output")`;
				connectAttr ("PoleLockBlender"+$tempString[0]+".output") ("PoleLockBlenderNormalize"+$tempString[0]+".input1X");
				connectAttr ("PoleLockBlenderNormalize"+$tempString[0]+".outputX") ("ScaleBlend"+$tempString2[0]+".color1R");
				}

			if ($tempString[0]==("IKX"+$fitJointIKEndJoint[$i]+$side))
				break;
			}
		}

//HipSwinger
int $buildHipSwinger=`objExists Spine1_M`;
for ($i=0;$i<size($fitJoints);$i++)
	if (`asLabel $fitJoints[$i]`=="Root")
		if (`attributeExists hipSwinger $fitJoints[$i]`)
			if (`getAttr ($fitJoints[$i]+".hipSwinger")`==0)
				$buildHipSwinger=0;
if ($buildHipSwinger)
	{
	asCreateController "HipSwinger" "" "_M" "Spine1";
	if (`objExists FKIKBlendSpineCondition_M`)
		connectAttr FKIKBlendSpineCondition_M.outColorG HipSwingerOffset_M.v;
	asAlign HipSwingerOffset_M Root_M 0 1 0 0;
	parent HipSwinger_M HipSwingerOffset_M;
	delete HipSwingerExtra_M;
	parent HipSwingerOffset_M FKSystem;
	$pos=`xform -q -ws -t Root`;
	delete `pointConstraint Root Spine1 HipSwingerOffset_M`;
	setAttr HipSwingerOffset_M.tx (`getAttr Root.fat`*`getAttr Root.fatZ`*-1.4);
	parent HipSwingerOffset_M FKRoot_M;
	asLockAttr HipSwinger_M 1 0 1 0;

	$inbetweenJoints=0;
	if (`attributeExists inbetweenJoints Root`)
		$inbetweenJoints=`getAttr Root.inbetweenJoints`;

	createNode -n HipSwingerStabilizerTarget transform;
	if ($inbetweenJoints)
		asAlign HipSwingerStabilizerTarget HipSwinger_M 1 1 0 0;
	else
		{
		asAlign HipSwingerStabilizerTarget FKOffsetSpine1_M 1 1 0 0;
		asAlign HipSwingerStabilizerTarget Spine1 0 1 0 0;
		}

	parent HipSwingerStabilizerTarget FKRoot_M;
	createNode -n HipSwingReverse -p FKRoot_M transform;
	asAlign HipSwingReverse Spine1_M 1 0 0 0;

	$parent="HipSwingReverse";
	$inbetweenJoints=0;
	if (`attributeExists inbetweenJoints Root`)
		$inbetweenJoints=`getAttr Root.inbetweenJoints`;
	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		createNode -n ("HipSwingReversePart"+$y) -p $parent transform;
		setAttr ("HipSwingReversePart"+$y+".tx") (`getAttr ("RootPart"+$y+"_M.tx")`*-1);
		duplicate -n ("HipSwingReverseXPart"+$y) ("HipSwingReversePart"+$y);
		if ($y>1)
			parent ("HipSwingReverseXPart"+$y) HipSwingReverse;
		orientConstraint ("HipSwingReversePart"+$y) ("HipSwingReverseXPart"+$y);
		$parent="HipSwingReversePart"+$y;
		}
	createNode -n HipSwingReverseRoot transform;
	asAlign HipSwingReverseRoot Root_M 1 1 0 0;

	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		orientConstraint HipSwingerStabilizerTarget HipSwinger_M ("HipSwingReversePart"+$y);
		setAttr ("HipSwingReversePart"+$y+"_orientConstraint1.HipSwingerStabilizerTargetW0") (1-((1.0/($inbetweenJoints+1))*$y));
		setAttr ("HipSwingReversePart"+$y+"_orientConstraint1.HipSwinger_MW1") ((1.0/($inbetweenJoints+1))*$y);
		setAttr ("HipSwingReversePart"+$y+"_orientConstraint1.interpType") 2;
		}

	//inbetween done by constraint-blend, hipSwing done with constraint-offset
	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		if ($y==$inbetweenJoints)
			connectAttr ("HipSwingReverseXPart"+$y+".r") FKXRoot_M_orientConstraint1.offset;
		else
			connectAttr ("HipSwingReverseXPart"+($inbetweenJoints-$y)+".r") ("FKXRootPart"+$y+"_M_orientConstraint1.offset");
		}

	createNode -n HipSwingerStabilizer transform;
	if ($inbetweenJoints==0)
		{
		parent HipSwingReverseRoot HipSwingReverse;
		orientConstraint HipSwinger_M HipSwingReverse;
		parentConstraint HipSwingReverseRoot FKXRoot_M;

		parent HipSwingerStabilizer FKOffsetSpine1_M;
		xform -os -t 0 0 0 -ro 0 0 0 HipSwingerStabilizer;
		parent FKExtraSpine1_M HipSwingerStabilizer;
		}
	else
		{
		parent HipSwingReverseRoot ("HipSwingReversePart"+$inbetweenJoints);
		orientConstraint HipSwinger_M HipSwingReverseRoot;
		pointConstraint HipSwingReverseRoot FKXRoot_M;

		parent HipSwingerStabilizer ("FKXRootPart"+$inbetweenJoints+"_M");
		xform -os -t 0 0 0 -ro 0 0 0 HipSwingerStabilizer;
		parent FKOffsetSpine1_M HipSwingerStabilizer;
		}

	orientConstraint HipSwingerStabilizerTarget HipSwingerStabilizer;	
	}

//CenterBetweenFeet
string $ikLegs[];
$tempString=`ls "IKLeg*_*"`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im ControlSet $tempString[$i]`)
		$ikLegs[size($ikLegs)]=$tempString[$i];
if (size($ikLegs) && $centerBtwFeet)
	{
	createNode -n RootCenterBtwLegsBlended_M transform;
	asAlign RootCenterBtwLegsBlended_M Root_M 1 0 0 1;
	parent RootCenterBtwLegsBlended_M RootSystem;
	parent RootOffsetX_M RootCenterBtwLegsBlended_M;
	createNode -n RootCenterBtwLegsOffset_M -p RootSystem transform;
	asAlign RootCenterBtwLegsOffset_M Root_M 1 0 0 1;
	duplicate -n RootCenter_M RootCenterBtwLegsOffset_M;
	duplicate -n RootCenterBtwLegs_M RootCenterBtwLegsOffset_M;
	for ($i=0;$i<size($ikLegs);$i++)
		{
		pointConstraint -skip y $ikLegs[$i] RootCenterBtwLegs_M;
		orientConstraint -skip x -skip z $ikLegs[$i] RootCenterBtwLegs_M;
		}
	parent RootCenterBtwLegsOffset_M RootCenterBtwLegs_M;
	parentConstraint RootCenter_M RootCenterBtwLegsOffset_M RootCenterBtwLegsBlended_M;
	createNode -n CenterBtwLegsUnitConversion unitConversion;
	setAttr CenterBtwLegsUnitConversion.conversionFactor 0.1;
	addAttr -k 1 -ln CenterBtwFeet -at double -min 0 -max 10 RootX_M;
	connectAttr RootX_M.CenterBtwFeet CenterBtwLegsUnitConversion.input;
	createNode -n CenterBtwLegsUnitReverse reverse;
	connectAttr CenterBtwLegsUnitConversion.output CenterBtwLegsUnitReverse.inputX;
	connectAttr CenterBtwLegsUnitConversion.output RootCenterBtwLegsBlended_M_parentConstraint1.RootCenterBtwLegsOffset_MW1;
	connectAttr CenterBtwLegsUnitReverse.outputX RootCenterBtwLegsBlended_M_parentConstraint1.RootCenter_MW0;
	createNode -n CenterBtwLegsNodeStateSetRange setRange;
	setAttr CenterBtwLegsNodeStateSetRange.minX 1;
	setAttr CenterBtwLegsNodeStateSetRange.oldMaxX 0.1;
	connectAttr RootX_M.CenterBtwFeet CenterBtwLegsNodeStateSetRange.valueX;
	connectAttr CenterBtwLegsNodeStateSetRange.outValueX RootCenterBtwLegs_M_pointConstraint1.nodeState;
	connectAttr CenterBtwLegsNodeStateSetRange.outValueX RootCenterBtwLegs_M_orientConstraint1.nodeState;
	}

//Locking
asLockAttr RootX_M 0 0 1 0;

//Advanced Twist
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointTwistJoints[$i])
			catchQuiet (`delete ($fitJoints[$i]+$side+"_parentConstraint1")`);
		else if (!$fitJointUpTwistJoints[$i])
			continue;refresh;

		asCreateUnTwister $fitJoints[$i] $side $fitJointParent[$i] $parentSide $fitJointIK[$i] $b 0 "";

		if ($fitJointTwistJoints[$i])
			{
			asConstraintToFKIK "point" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
			parent ($fitJoints[$i]+$side+"_pointConstraint1") ConstraintSystem;	
			}

		int $numTwisters=$fitJointTwistJoints[$i]+1;
		if ($fitJointUpTwistJoints[$i] && !$fitJointTwistJoints[$i])
			$numTwisters=$fitJointUpTwistJoints[$i]+1;
		for ($y=0;$y<$numTwisters;$y++)
			{
			createNode -n ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side) multiplyDivide;
			createNode -n ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side) plusMinusAverage;
			createNode -n ("Twister"+$fitJoints[$i]+$y+$side) -p ("UnTwist"+$fitJoints[$i]+$side) transform;

			if ($fitJointTwistJoints[$i])
				{
				if ($y==0)
					$joint=$fitJoints[$i]+$side;
				else
					$joint=$fitJoints[$i]+"Part"+$y+$side;
				addAttr -k 1 -ln twistAmount -at double -min 0 -max 1 $joint;
				addAttr -k 1 -ln twistAddition -at double $joint;
				setAttr ($joint+".twistAmount") ($y/($fitJointTwistJoints[$i]+1.0));
				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input2X");
				connectAttr ($joint+".twistAddition") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[1]");
				orientConstraint ("Twister"+$fitJoints[$i]+$y+$side) $joint;
				parent ($joint+"_orientConstraint1") ConstraintSystem;
				}

//			connectAttr ("TwistBalancer"+$fitJoints[$i]+$side+".rotateX") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input1X");
			connectAttr ("TwistBalancer"+$fitJoints[$i]+$side+".twist") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input1X");
			connectAttr ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".outputX") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[0]");
			connectAttr ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".output1D") ("Twister"+$fitJoints[$i]+$y+$side+".rotateX");
			}
		}

//Advanced Twist ($fitJointUpTwistJoints)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointUpTwistJoints[$i] && !$fitJointTwistJoints[$i])
			for ($y=0;$y<$fitJointUpTwistJoints[$i]+1;$y++)
				{
				if ($y==0)
					$joint=$fitJointParent[$i]+$parentSide;
				else
					$joint=$fitJointParent[$i]+"Part"+$y+$parentSide;
				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input2X");
				connectAttr ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".outputX") ("twistAddition"+$fitJointParent[$i]+"Part"+$y+$parentSide+".input1D[2]");
//				connectAttr -f ("TwistBalancer"+$fitJoints[$i]+$side+".rotateX") ("twistAmountDivide"+$fitJointParent[$i]+"Part"+$y+$parentSide+".input1X");
				}
		}

//Advanced BendyJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if (!$fitJointBendyJoints[$i])
			continue;

		string $crvCmd="curve -n Bend"+$fitJoints[$i]+"Curve"+$side+" -d 3";
		for ($z=0;$z<5;$z++)
			 $crvCmd+=" -p 0 0 0";
		eval ($crvCmd);
		$tempString=`listRelatives -s ("Bend"+$fitJoints[$i]+"Curve"+$side)`;
		rename $tempString[0] ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape");
		setAttr ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.overrideEnabled") 1;
		setAttr ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.overrideDisplayType") 1;
		parent ("Bend"+$fitJoints[$i]+"Curve"+$side) BendSystem;

		createNode -n ("BendParentConstraint"+$fitJoints[$i]+$side) -p BendSystem transform;
		asConstraintToFKIK "parent" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
		asConstraintToFKIK "scale" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);

		createNode -n ("BendParentConstraintOffset"+$fitJoints[$i]+$side) -p BendSystem transform;
		asAlign ("BendParentConstraintOffset"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side) 1 1 0 0;
		parent ("BendParentConstraint"+$fitJoints[$i]+$side) ("BendParentConstraintOffset"+$fitJoints[$i]+$side);

		$bendControlNr=1;
		for ($z=0;$z<5;$z++)
			{
			spaceLocator -n ("Bend"+$fitJoints[$i]+"Locator"+$z+$side);
			setAttr -l 1 ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+".v") 0;
			connectAttr ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+"Shape.worldPosition[0]") ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.controlPoints["+$z+"]");

			float $posFactor=(1.0/4.0)*$z;

			float $invPosFactor=1-$posFactor;
			$tempString=`pointConstraint -w $invPosFactor ($fitJoints[$i]+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side)`;
			pointConstraint -w $posFactor ($fitJointChild[$i]+$childSide) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side);
			delete $tempString[0];

			if ($z==0)//Start
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
			if ($z==2 || $z==0)//Controllers
				{
				asCreateController "Bend" ($fitJoints[$i]+$bendControlNr) $side $fitJoints[$i];
				parent ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) BendSystem;
				asAlign ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) 1 0 0 0;
				asAlign ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("FK"+$fitJoints[$i]+$side) 0 1 0 0;
				parent ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("Bend"+$fitJoints[$i]+$bendControlNr+$side);
				$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;
				xform -s 0.1 1 1 ("Bend"+$fitJoints[$i]+$bendControlNr+$side+".cv[0:99]");
				$bendControlNr++;
				}
			if ($z==0)//Create BendStiff node
				{
				createNode -n ("BendStiff"+$fitJoints[$i]+$side) setRange;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".minX") 0;setAttr ("BendStiff"+$fitJoints[$i]+$side+".minY") 1;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".maxX") 1;setAttr ("BendStiff"+$fitJoints[$i]+$side+".maxY") 0;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMinX") -10;setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMinY") -10;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMaxX") 10;setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMaxY") 10;
				}
			if ($z==2)//`Bezier handles`(stiffness)
				{
				addAttr -k 1 -ln stiff -at double -min -10 -max 10 -dv 10 ("Bend"+$fitJoints[$i]+"2"+$side);
				connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".stiff") ("BendStiff"+$fitJoints[$i]+$side+".valueX");
				connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".stiff") ("BendStiff"+$fitJoints[$i]+$side+".valueY");
				}

			if ($z==1 || $z==3)//`Bezier handles`(stiffness)
				{
				createNode -n ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) -p ("BendParentConstraint"+$fitJoints[$i]+$side) transform;
				if ($z==1)
					parent ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJoints[$i]+"1"+$side);
				if ($z==3 && `objExists ("Bend"+$fitJointChild[$i]+"1"+$side)`)
					parent ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJointChild[$i]+"1"+$side);

				asAlign ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) 1 1 0 0;
				duplicate -n ("Bend"+$fitJoints[$i]+"BezOn"+$z+$side) ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side);
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
				pointConstraint ("Bend"+$fitJoints[$i]+"BezOn"+$z+$side) ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side);

				connectAttr ("BendStiff"+$fitJoints[$i]+$side+".outValueX") ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+"_pointConstraint1.Bend"+$fitJoints[$i]+"BezOn"+$z+$side+"W0");
				connectAttr ("BendStiff"+$fitJoints[$i]+$side+".outValueY") ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+"_pointConstraint1.Bend"+$fitJoints[$i]+"BezOff"+$z+$side+"W1");

				}
			if ($z==4)
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
			if ($z==3)
				{
				parent ("Bend"+$fitJoints[$i]+"BezOn"+"1"+$side) ("Bend"+$fitJoints[$i]+"2"+$side);
				parent ("Bend"+$fitJoints[$i]+"BezOn"+"3"+$side) ("Bend"+$fitJoints[$i]+"2"+$side);
				}
			}

		//Bend1 adds to orientConstraintOffset
		connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".rotateY") ($fitJoints[$i]+$side+"_orientConstraint1.offsetY");
		connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".rotateZ") ($fitJoints[$i]+$side+"_orientConstraint1.offsetZ");

		//connect to twistJoints
		for ($y=0;$y<($fitJointTwistJoints[$i]+1);$y++)
			{

			if ($y==0)
				$joint=$fitJoints[$i]+$side;
			else
				{
				$joint=$fitJoints[$i]+"Part"+$y+$side;
				delete ($joint+"_orientConstraint1");
				}
			if ($y==0)
				delete (`listConnections -s 1 -d 0 ($fitJoints[$i]+$side+".tx")`);//could be point or parent constraint

			//bend hookup
			if ($y==0)
				{
				pointConstraint ("Bend"+$fitJoints[$i]+"1"+$side) $joint;				
				parent ($joint+"_pointConstraint1") ConstraintSystem;			
				}
			else
				{
				createNode -n ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side) pointOnCurveInfo;
				connectAttr -f ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.worldSpace[0]") ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".inputCurve");
				createNode -p BendSystem -n ($fitJoints[$i]+"PointOnCurveXform"+$y+$side) transform;
				connectAttr -f ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".position") ($fitJoints[$i]+"PointOnCurveXform"+$y+$side+".t");
//				setAttr ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".turnOnPercentage") 1;
				//make tempSurface, so a closestPointOnSurface node can find $parameter
				extrude -n tempSurface -ch true -rn false -po 0 -et 0 -upn 1 -length 1 -rotation 0 -scale 1 -dl 3 ("Bend"+$fitJoints[$i]+"Curve"+$side);
				createNode -n tempClosestPointOnSurface closestPointOnSurface;
				spaceLocator -n tempClosestPointOnSurfaceLoc;
				connectAttr tempSurface.worldSpace[0] tempClosestPointOnSurface.inputSurface;
				connectAttr tempClosestPointOnSurfaceLoc.worldPosition[0] tempClosestPointOnSurface.inPosition;
				pointConstraint ($fitJoints[$i]+$side) ($fitJointChild[$i]+$childSide) tempClosestPointOnSurfaceLoc;
				setAttr ("tempClosestPointOnSurfaceLoc_pointConstraint1."+$fitJoints[$i]+$side+"W0") (1-((1.0/($fitJointTwistJoints[$i]+1.0))*$y));
				setAttr ("tempClosestPointOnSurfaceLoc_pointConstraint1."+$fitJointChild[$i]+$childSide+"W1")((1.0/($fitJointTwistJoints[$i]+1.0))*$y);
				float $parameter=`getAttr tempClosestPointOnSurface.parameterU`;
				delete tempClosestPointOnSurface tempSurface tempClosestPointOnSurfaceLoc;
				setAttr ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".parameter") $parameter;

				pointConstraint ($fitJoints[$i]+"PointOnCurveXform"+$y+$side) $joint;
				parent ($joint+"_pointConstraint1") ConstraintSystem;	
				tangentConstraint -weight 1 -aimVector $b 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ("Twister"+$fitJoints[$i]+$y+$side) ("Bend"+$fitJoints[$i]+"Curve"+$side) $joint;
				parent ($joint+"_tangentConstraint1") ConstraintSystem;
				}
			}
		}

//Advanced BendyJoints (attached to parent)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointUpBendyJoints[$i])
			{
			if (!$fitJointBendyJoints[$i])//e.g. wrist
				asConstraintToFKIK "parent" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("Bend"+$fitJointParent[$i]+"Locator"+"4"+$parentSide);
			if ($fitJointBendyJoints[$i])//e.g. elbow
				parent ("Bend"+$fitJointParent[$i]+"Locator"+"4"+$parentSide) ("Bend"+$fitJoints[$i]+"1"+$side);
			}

		//twisty BendyJoints
		for ($y=0;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			if (!$fitJointBendyJoints[$i])
				continue;
			//startTwister
			createNode -n ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1X");
			setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2X") (1-(1/($fitJointTwistJoints[$i]+0.00))*$y);
			connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputX") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[3]");
			//midTwister
			createNode -n ("BendTwistMult"+$fitJoints[$i]+"2"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1Y");
			float $hf=(1.0/$fitJointTwistJoints[$i])*$y*2;
			if ($y>$fitJointTwistJoints[$i]/2) $hf=2-$hf;
			setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2Y") $hf;
			connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputY") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[4]");
			//endTwister
			if (`objExists ("Bend"+$fitJointChild[$i]+"1"+$childSide+".rx")`)
				{
				connectAttr ("Bend"+$fitJointChild[$i]+"1"+$childSide+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1Z");
				setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2Z") ((1/($fitJointTwistJoints[$i]+0.00))*$y);
				connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputZ") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[5]");
				}
			}
		}

//Advanced distribution of twistJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$fitJointTwistJoints[$i])
			continue;

		//Seem to work.Nope, makes foot unasable with stretchy leg
//		setAttr ($fitJoints[$i]+"Part"+"1"+$side+".segmentScaleCompensate") 0;

		//if there`s no ("FKX"+$fitJointChild[$i]+$childSide), the skip Advanced distribution
		if (!`objExists ("FKX"+$fitJointChild[$i]+$childSide)`)
			continue;

		string $contraintTo="FKX"+$fitJointChild[$i]+$childSide;
		if ($fitJointIK[$i]!="")
			{
			$contraintTo=("FKIKMix"+$fitJointChild[$i]+$childSide);
			createNode -n $contraintTo -p TwistSystem transform;
			if (`objExists $contraintTo`)
				asConstraintToFKIK "point" $fitJointIK[$i] ("FKX"+$fitJointChild[$i]+$childSide) ("IKX"+$fitJointChild[$i]+$childSide) $contraintTo;
			}

		//Above Knee(elbow) to follow Knee(elbow)
		if ($fitJointBendyJoints[$i] && !$fitJointUpBendyJoints[$i] && `objExists ("Bend"+$fitJointChild[$i]+"1"+$side)`)
			$contraintTo="Bend"+$fitJointChild[$i]+"1"+$side;

		if (!$fitJointBendyJoints[$i] && `objExists $contraintTo`)
			{
			for ($y=1;$y<$fitJointTwistJoints[$i]+1;$y++)
				{
				$tempString=`pointConstraint $contraintTo ($fitJoints[$i]+$side) ($fitJoints[$i]+"Part"+$y+$side)`;
				$constraint=$tempString[0];
				parent $constraint ConstraintSystem;
				setAttr ($constraint+"."+$contraintTo+"W0") ($y/($fitJointTwistJoints[$i]+1.0));
				setAttr ($constraint+"."+$fitJoints[$i]+$side+"W1") (1-($y/($fitJointTwistJoints[$i]+1.0)));
				}
			}
		//make bendy compatible with `stretchy`
		if ($fitJointBendyJoints[$i] && `objExists $contraintTo`)
			{
			aimConstraint -offset 0 0 0 -aimVector $b 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($fitJoints[$i]+$side) $contraintTo ("BendOffset"+$fitJoints[$i]+"2"+$side);
			pointConstraint ($fitJoints[$i]+$side) $contraintTo ("BendOffset"+$fitJoints[$i]+"2"+$side);
			//and SX
			createNode -n ($fitJoints[$i]+"Distance"+$side) distanceBetween;
			connectAttr ($fitJoints[$i]+$side+".worldMatrix[0]") ($fitJoints[$i]+"Distance"+$side+".inMatrix1");
			connectAttr ($contraintTo+".worldMatrix[0]") ($fitJoints[$i]+"Distance"+$side+".inMatrix2");
			createNode -n ($fitJoints[$i]+"DistanceNormalizer"+$side) multiplyDivide;
			setAttr ($fitJoints[$i]+"DistanceNormalizer"+$side+".operation") 2;
			connectAttr ($fitJoints[$i]+"Distance"+$side+".distance") ($fitJoints[$i]+"DistanceNormalizer"+$side+".input1X");
			setAttr ($fitJoints[$i]+"DistanceNormalizer"+$side+".input2X") `getAttr ($fitJoints[$i]+"DistanceNormalizer"+$side+".input1X")`;

			createNode -n ($fitJoints[$i]+"DistanceNormalizerScaler"+$side) multiplyDivide;
			setAttr ($fitJoints[$i]+"DistanceNormalizerScaler"+$side+".operation") 2;
			connectAttr ($fitJoints[$i]+"DistanceNormalizer"+$side+".outputX") ($fitJoints[$i]+"DistanceNormalizerScaler"+$side+".input1X");
			connectAttr Main.scaleY ($fitJoints[$i]+"DistanceNormalizerScaler"+$side+".input2X");
			connectAttr ($fitJoints[$i]+"DistanceNormalizerScaler"+$side+".outputX") ("BendOffset"+$fitJoints[$i]+"2"+$side+".sx");
			}
		}

//volume (Squash Scaling) - `IK setup` part
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!$isIKEnd[$i])
			continue;
		if (`asIsMayaLT`)
			continue;

		$ikHandle = ("IK"+$fitJointIK[$i]+$side);
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			$ikHandle = ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
		addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 $ikHandle;
		createNode -n ("volume"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ($ikHandle+".volume") ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
		createNode -n ("multWithStretchy"+$fitJointIK[$i]+$side) multiplyDivide;
		connectAttr ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("multWithStretchy"+$fitJointIK[$i]+$side+".input1X");
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("multWithStretchy"+$fitJointIK[$i]+$side+".input2X");
		createNode -n ("volume1Over"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("volume1Over"+$fitJointIK[$i]+$side+".operation") 2;
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			connectAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".outputX") ("volume1Over"+$fitJointIK[$i]+$side+".input2X");
		else
			connectAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".outputX") ("volume1Over"+$fitJointIK[$i]+$side+".input2X");			
		setAttr ("volume1Over"+$fitJointIK[$i]+$side+".input1X") 1;
		createNode -n ("volumepow"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("volumepow"+$fitJointIK[$i]+$side+".operation") 3;
		connectAttr ("volume1Over"+$fitJointIK[$i]+$side+".outputX") ("volumepow"+$fitJointIK[$i]+$side+".input1X");
		setAttr ("volumepow"+$fitJointIK[$i]+$side+".input2X") 0.5;
		createNode -n ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side) blendTwoAttr;
		connectAttr ("multWithStretchy"+$fitJointIK[$i]+$side+".outputX") ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".attributesBlender");
		setAttr ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".input[0]") 1;
		connectAttr ("volumepow"+$fitJointIK[$i]+$side+".outputX") ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".input[1]");
		}

//volume (Squash Scaling) - `Connect to scale` part
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJoints[$i]=="Root")
			continue;
		if ($isIKEnd[$i] || $isIKBelowIKEnd[$i])
			continue;

		if (`asIsMayaLT`)
			continue;

		string $volumeOutPlug="volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".output";
		if (`objExists ("IKScaler"+$fitJoints[$i]+$side)`)
			{
			createNode -n ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side) plusMinusAverage;
			createNode -n ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side) plusMinusAverage;
			connectAttr ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".output") ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".input1D[0]");
			setAttr ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".input1D[1]") -1;
			setAttr ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".input1D[1]") 1;

			createNode -n ("IKSquashDistributer"+$fitJoints[$i]+$side) multiplyDivide;
			connectAttr ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".output1D") ("IKSquashDistributer"+$fitJoints[$i]+$side+".input1X");
			connectAttr ("IKScaler"+$fitJoints[$i]+$side+".scalerWeight") ("IKSquashDistributer"+$fitJoints[$i]+$side+".input2X");

			connectAttr ("IKSquashDistributer"+$fitJoints[$i]+$side+".outputX") ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".input1D[0]");
			$volumeOutPlug="IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".output1D";
			}

		if (`objExists ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side)`)//splineIkScaling
			{
			connectAttr $volumeOutPlug ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side+".input2Y");
			connectAttr $volumeOutPlug ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side+".input2Z");
			}
		else
			{
			connectAttr $volumeOutPlug ("ScaleBlend"+$fitJoints[$i]+$side+".color1G");
			connectAttr $volumeOutPlug ("ScaleBlend"+$fitJoints[$i]+$side+".color1B");
			}
		}

//Advanced Attach
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointsAttachTo[$i]=="")
			continue;

		if (`gmatch $fitJointsAttachTo[$i] "*_R"`)
			if ($side=="_L")
				{
				$tempString[0]=`substitute "_R" $fitJointsAttachTo[$i] "_L"`;
				if (`objExists $tempString[0]`)
					$fitJointsAttachTo[$i]=$tempString[0];
				}

		if (`objExists closestSampler`)
			delete closestSampler;
		createNode -n closestSampler closestPointOnMesh;
		connectAttr -f ($fitJointsAttachTo[$i]+".outMesh") closestSampler.inMesh;
		float $temp[]=`xform -q -ws -t $fitJoints[$i]`;
		setAttr closestSampler.inPosition ($temp[0]*$b) $temp[1] $temp[2];
		int $closestFaceIndex=`getAttr closestSampler.closestFaceIndex`;
		delete closestSampler;
		$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
		$offsetParent=$tempString[0];
		createNode -n ("FKAttach"+$fitJoints[$i]+$side) transform;
		createNode -n ("Attach"+$fitJoints[$i]+$side) transform;
		createNode -n ("Detach"+$fitJoints[$i]+$side) transform;
		createNode -n ("FKAttachOffset"+$fitJoints[$i]+$side) transform;
		asAlign ("FKAttachOffset"+$fitJoints[$i]+$side) $offsetParent 1 1 0 0;
		select -r ($fitJointsAttachTo[$i]+".f["+$closestFaceIndex+"]");
		select -add ("Attach"+$fitJoints[$i]+$side);
		doCreatePointOnPolyConstraintArgList 1 { "0","0","0","1","","1" };
		$tempString=`listConnections ("Attach"+$fitJoints[$i]+$side+".tx")`;
		if ($fitJointsAttachMode[$i]=="point")
			{
			disconnectAttr ($tempString[0]+".constraintRotate.constraintRotateX") ("Attach"+$fitJoints[$i]+$side+".rx");
			disconnectAttr ($tempString[0]+".constraintRotate.constraintRotateY") ("Attach"+$fitJoints[$i]+$side+".ry");
			disconnectAttr ($tempString[0]+".constraintRotate.constraintRotateZ") ("Attach"+$fitJoints[$i]+$side+".rz");
			}
		if ($fitJointsAttachMode[$i]=="orient")
			{
			disconnectAttr ($tempString[0]+".constraintTranslate.constraintTranslateX") ("Attach"+$fitJoints[$i]+$side+".tx");
			disconnectAttr ($tempString[0]+".constraintTranslate.constraintTranslateY") ("Attach"+$fitJoints[$i]+$side+".ty");
			disconnectAttr ($tempString[0]+".constraintTranslate.constraintTranslateZ") ("Attach"+$fitJoints[$i]+$side+".tz");
			}

		asAlign ("FKAttach"+$fitJoints[$i]+$side) ("Attach"+$fitJoints[$i]+$side) 1 1 0 0;
		asAlign ("Detach"+$fitJoints[$i]+$side) ("Attach"+$fitJoints[$i]+$side) 1 1 0 0;
		parent ("FKAttach"+$fitJoints[$i]+$side) ("Attach"+$fitJoints[$i]+$side)  ("Detach"+$fitJoints[$i]+$side) $offsetParent;

		parent ("FKAttachOffset"+$fitJoints[$i]+$side) ("FKAttach"+$fitJoints[$i]+$side);
		parent ("FKOffset"+$fitJoints[$i]+$side) ("FKAttachOffset"+$fitJoints[$i]+$side);

		parentConstraint ("Attach"+$fitJoints[$i]+$side) ("Detach"+$fitJoints[$i]+$side) ("FKAttach"+$fitJoints[$i]+$side);
		addAttr -k 1 -ln attach -at double -min 0 -max 10 -dv 10 ("FK"+$fitJoints[$i]+$side);
		createNode -n ("FK"+$fitJoints[$i]+$side+"AttachSetRange") setRange;
		setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.minX") 0;setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.minY") 1;
		setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.maxX") 1;setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.maxY") 0;
		setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.oldMinX") 0;setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.oldMinY") 0;
		setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.oldMaxX") 10;setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.oldMaxY") 10;
		connectAttr ("FK"+$fitJoints[$i]+$side+".attach") ("FK"+$fitJoints[$i]+$side+"AttachSetRange.value.valueX");
		connectAttr ("FK"+$fitJoints[$i]+$side+".attach") ("FK"+$fitJoints[$i]+$side+"AttachSetRange.value.valueY");
		connectAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.outValue.outValueX") ("FKAttach"+$fitJoints[$i]+$side+"_parentConstraint1."+"Attach"+$fitJoints[$i]+$side+"W0");
		connectAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.outValue.outValueY") ("FKAttach"+$fitJoints[$i]+$side+"_parentConstraint1."+"Detach"+$fitJoints[$i]+$side+"W1");
		}

//Advanced CurveGuide
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointsCurveGuide[$i]=="")
			continue;

		if (!`objExists CurveGuideSystem`)
			{
			createNode -n CurveGuideSystem -p MotionSystem transform;
			setAttr -l 1 CurveGuideSystem.inheritsTransform 0;
			}
		
		$curveGuide=$fitJointsCurveGuide[$i]+$side;
		if ($fitJointsCurveGuide[$i]=="tailWing_guideEdge")//eagle
			$curveGuide=$fitJointsCurveGuide[$i]+"_M";
//		setAttr ($fitJointsCurveGuide[$i]+".v") 0;
		$tempString=`listRelatives -p $fitJointsCurveGuide[$i]`;
		if ($tempString[0]=="")
			parent $fitJointsCurveGuide[$i] FitSkeleton;
		if (`attributeExists curveGuide $fitJointsCurveGuide[$i]`) deleteAttr ($fitJointsCurveGuide[$i]+".curveGuide");
		if (!`objExists $curveGuide`)
			{
			duplicate -n $curveGuide $fitJointsCurveGuide[$i];
			makeIdentity -a 1 -t 1 -r 1 -s 1 $curveGuide;
			asLockAttr $curveGuide 1 1 1 1;
			sets -add ControlSet $curveGuide;
			setAttr ($curveGuide+"Shape.overrideEnabled") 1;
			setAttr ($curveGuide+"Shape.overrideColor") 17;
//			setAttr ($curveGuide+".v") 1;
			parent $curveGuide CurveGuideSystem;
			if ($side=="_L")
				scale -r -p 0 0 0 -1 1 1 ($curveGuide+".cv[0:999]");
			}

		$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
		$offsetParent=$tempString[0];
		createNode -n ("FKCurveGuide"+$fitJoints[$i]+$side) -p $offsetParent transform;
		asAlign ("FKCurveGuide"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side) 1 1 0 0;
//		rotate -r -os -fo 0 0 -90 ("FKCurveGuide"+$fitJoints[$i]+$side);
//		duplicate -n ("FKCurveGuideUpVec"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);

		createNode -n ("CurveGuideOnCurve"+$fitJoints[$i]+$side) -p ("FK"+$fitJoints[$i]+$side) transform;

		geometryConstraint $curveGuide ("CurveGuideOnCurve"+$fitJoints[$i]+$side);
		$pos=`xform -q -ws -t ("FK"+$fitJoints[$i]+$side)`;
		$pos2=`xform -q -ws -t ("CurveGuideOnCurve"+$fitJoints[$i]+$side)`;
		$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
		delete ("CurveGuideOnCurve"+$fitJoints[$i]+$side+"_geometryConstraint1");
		setAttr -type float3 ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".t") ($dist*$b) 0 0;
		geometryConstraint $curveGuide ("CurveGuideOnCurve"+$fitJoints[$i]+$side);

		for ($y=0;$y<99;$y++)
			{
			setAttr ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".ty") 0;
			setAttr ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".tz") 0;
			}
		delete ("CurveGuideOnCurve"+$fitJoints[$i]+$side+"_geometryConstraint1");
		parent ("CurveGuideOnCurve"+$fitJoints[$i]+$side) CurveGuideSystem;

		extrude -n tempSurface -ch true -rn false -po 0 -et 0 -upn 1 -length 1 -rotation 0 -scale 1 -dl 3 $curveGuide;
		createNode -n tempSampler closestPointOnSurface;
		connectAttr tempSurface.worldSpace[0] tempSampler.inputSurface;
		connectAttr ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".translate") tempSampler.inPosition;

		createNode -n ("CurveGuideInfo"+$fitJoints[$i]+$side) pointOnCurveInfo;
		connectAttr -f ($curveGuide+".worldSpace") ("CurveGuideInfo"+$fitJoints[$i]+$side+".inputCurve");
		setAttr ("CurveGuideInfo"+$fitJoints[$i]+$side+".parameter") `getAttr tempSampler.result.parameterU`;

		connectAttr ("CurveGuideInfo"+$fitJoints[$i]+$side+".position") ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".t");
		tangentConstraint -weight 1 -aimVector (-1*$b) 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $curveGuide ("CurveGuideOnCurve"+$fitJoints[$i]+$side);

		createNode -n ("CurveGuideStaticOffset"+$fitJoints[$i]+$side) transform;
		$tempString=`listRelatives -p ("FKCurveGuide"+$fitJoints[$i]+$side)`;
		parent ("CurveGuideStaticOffset"+$fitJoints[$i]+$side) $tempString[0];
		createNode -n ("CurveGuideStatic"+$fitJoints[$i]+$side) -p ("CurveGuideStaticOffset"+$fitJoints[$i]+$side) transform;
		asAlign ("CurveGuideStatic"+$fitJoints[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) 1 1 0 0;

		delete tempSurface tempSampler;

		asCreateController "IK" $fitJoints[$i] $side $fitJoints[$i];
		if (!`attributeExists guideTargetsVis Main`)
			{
			addAttr -k 1 -ln guideTargetsVis -at bool -dv 0 Main;
			setAttr -k 0 -cb 1 Main.guideTargetsVis;
			}
		connectAttr Main.guideTargetsVis ("IKOffset"+$fitJoints[$i]+$side+".v");
		xform -os -t 0 0 0 ("IKOffset"+$fitJoints[$i]+$side);
		scale -r -p 0 0 0 0.3 0.3 0.3 ("IK"+$fitJoints[$i]+$side+".cv[0:99]");
//		asAlign ("IKOffset"+$fitJoints[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) 1 1 0 0;
		parentConstraint ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("CurveGuideStatic"+$fitJoints[$i]+$side) ("IKOffset"+$fitJoints[$i]+$side);

		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 -1 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("IK"+$fitJoints[$i]+$side) ("IK"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);
//		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 -1 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("CurveGuideStatic"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);
//		aimConstraint -offset 0 0 90 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("FK"+$fitJointParent[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);
//		aimConstraint -offset 0 0 0 -aimVector (1*$b) 0 0 -upVector 1 0 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("FKCurveGuideUpVec"+$fitJoints[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);

		if (!`attributeExists blend $curveGuide`)
			addAttr -k 1 -ln blend -at double -min 0 -max 10 -dv 10 $curveGuide;
		if (!`objExists ($curveGuide+"BlendUnitConversion")`)
			{
			createNode -n ($curveGuide+"BlendUnitConversion") unitConversion;
			setAttr ($curveGuide+"BlendUnitConversion.conversionFactor") 0.1;
			connectAttr ($curveGuide+".blend") ($curveGuide+"BlendUnitConversion.input");
			createNode -n ($curveGuide+"BlendReverse") reverse;
			connectAttr ($curveGuide+"BlendUnitConversion.output") ($curveGuide+"BlendReverse.inputX");
			}
//		connectAttr ($curveGuide+"BlendUnitConversion.output") ("FKCurveGuide"+$fitJoints[$i]+$side+"_aimConstraint1.CurveGuideOnCurve"+$fitJoints[$i]+$side+"W0");
//		connectAttr ($curveGuide+"BlendReverse.outputX") ("FKCurveGuide"+$fitJoints[$i]+$side+"_aimConstraint1.CurveGuideStatic"+$fitJoints[$i]+$side+"W1");
		connectAttr ($curveGuide+"BlendUnitConversion.output") ("IKOffset"+$fitJoints[$i]+$side+"_parentConstraint1.CurveGuideOnCurve"+$fitJoints[$i]+$side+"W0");
		connectAttr ($curveGuide+"BlendReverse.outputX") ("IKOffset"+$fitJoints[$i]+$side+"_parentConstraint1.CurveGuideStatic"+$fitJoints[$i]+$side+"W1");

		parent ("FKOffset"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);

		//CurveGuide controllers
		$spans=`getAttr ($curveGuide+".spans")`;
		$degree=`getAttr ($curveGuide+".degree")`;
		$numCVs=$spans+$degree;
		for ($y=0;$y<$numCVs;$y++)
			{
			$side="_R";
			$pos=`xform -q -ws -t ($curveGuide+".cv["+$y+"]")`;
			if ($pos[0]==0) $side="_M";
			if ($pos[0]>0) $side="_L";
			$ctrl="IK"+$fitJointsCurveGuide[$i]+"Ctrl"+$y+$side;
			if (`objExists $ctrl`)
				continue;

			$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
			rename $tempString[0] $ctrl;
			$tempString=`listRelatives -s $ctrl`;
			rename $tempString[0] ($ctrl+"Shape");
			setAttr ($ctrl+"Shape.overrideEnabled") 1;
			setAttr ($ctrl+"Shape.overrideColor") 17;
			sets -add ControlSet $ctrl;
			scale -r -p 0 0 0 ($scale/2.0) ($scale/2.0) ($scale/2.0) ($ctrl+".cv[0:4]");
			createNode -n ($ctrl+"Offset") -p CurveGuideSystem transform;
			parent $ctrl ($ctrl+"Offset");
			$tempString=`spaceLocator`;
			rename $tempString[0] ($ctrl+"Loc");
			parent ($ctrl+"Loc") $ctrl;
			setAttr -l 1 ($ctrl+"Loc.v") 0;

			$pos=`xform -q -ws -t ($curveGuide+".cv["+$y+"]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($ctrl+"Offset");

			connectAttr -f ($ctrl+"Loc.worldPosition[0]") ($curveGuide+".controlPoints["+$y+"]");

			addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 $ctrl;
			createNode -n ($ctrl+"FollowSetRange") setRange;
			setAttr ($ctrl+"FollowSetRange.minX") 0;setAttr ($ctrl+"FollowSetRange.minY") 1;
			setAttr ($ctrl+"FollowSetRange.maxX") 1;setAttr ($ctrl+"FollowSetRange.maxY") 0;
			setAttr ($ctrl+"FollowSetRange.oldMinX") 0;setAttr ($ctrl+"FollowSetRange.oldMinY") 0;
			setAttr ($ctrl+"FollowSetRange.oldMaxX") 10;setAttr ($ctrl+"FollowSetRange.oldMaxY") 10;
			connectAttr ($ctrl+".follow") ($ctrl+"FollowSetRange.value.valueX");
			connectAttr ($ctrl+".follow") ($ctrl+"FollowSetRange.value.valueY");

			createNode -n ($ctrl+"FollowOn") -p $ctrl transform;
			createNode -n ($ctrl+"FollowOff") -p $ctrl transform;
			parent ($ctrl+"FollowOn") CurveGuideSystem;
			parent ($ctrl+"FollowOff") GlobalSystem;
			parentConstraint -mo `asNearestFeatherParent $ctrl $fitJointsCurveGuide[$i]` ($ctrl+"FollowOn");
			parentConstraint ($ctrl+"FollowOn") ($ctrl+"FollowOff") ($ctrl+"Offset");
			connectAttr ($ctrl+"FollowSetRange.outValue.outValueX") ($ctrl+"Offset_parentConstraint1."+$ctrl+"FollowOnW0");
			connectAttr ($ctrl+"FollowSetRange.outValue.outValueY") ($ctrl+"Offset_parentConstraint1."+$ctrl+"FollowOffW1");
			}
		}

//Advanced Wheel
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$fitJointsWheel[$i])
			continue;

		if (!`objExists WheelSystem`)
			{
			createNode -n WheelSystem -p MotionSystem transform;
			setAttr -l 1 WheelSystem.inheritsTransform 0;
			}

		xform -os -t 0 -0.783612 -0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[0]");
		xform -os -t 0 0 -1.108194 ("FK"+$fitJoints[$i]+$side+"Shape.cv[1]");
		xform -os -t 0 0.783612 -0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[2]");
		xform -os -t 0 1.108194 0  ("FK"+$fitJoints[$i]+$side+"Shape.cv[3]");
		xform -os -t 0 0.783612 0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[4]");
		xform -os -t 0 0 1.108194 ("FK"+$fitJoints[$i]+$side+"Shape.cv[5]");
		xform -os -t 0 -0.783612 0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[6]");
		xform -os -t 0 -1.108194 0 ("FK"+$fitJoints[$i]+$side+"Shape.cv[7]");

		$temp=`xform -q -ws -t $fitJoints[$i]`;
		float $diameter=$temp[1]*2;
//		float $scaleFactor= $diameter * 1.1054;// 1.1054->nurbs
		float $scaleFactor=$diameter/2.0;
		xform -ws -s $scaleFactor $scaleFactor $scaleFactor ("FK"+$fitJoints[$i]+$side+"Shape.cv[0:999]");
		addAttr -k 1 -ln "diameter" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 1 -ln "autoRoll" -at double -smn 0 -hsn 1 -smx 1 -hsx 1 -dv 1 ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosX" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosY" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosZ" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);

		createNode -n ("prevPosOffset"+$fitJoints[$i]+$side) -p WheelSystem transform;
		createNode -n ("prevPos"+$fitJoints[$i]+$side) -p ("prevPosOffset"+$fitJoints[$i]+$side) transform;
		createNode -n ("prevPosAngler"+$fitJoints[$i]+$side) -p ("prevPos"+$fitJoints[$i]+$side) transform;
		createNode -n ("nowPos"+$fitJoints[$i]+$side) -p WheelSystem transform;
		pointConstraint ("FK"+$fitJoints[$i]+$side) ("nowPos"+$fitJoints[$i]+$side);
		asAlign ("prevPosOffset"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side) 1 0 0 0;
		$temp=`xform -q -ws -ro ("FK"+$fitJoints[$i]+$side)`;
		setAttr ("prevPosOffset"+$fitJoints[$i]+$side+".rz") 90;
		setAttr ("prevPosOffset"+$fitJoints[$i]+$side+".rx") $temp[1];
		duplicate -n ("prevPosSteer"+$fitJoints[$i]+$side) ("prevPosAngler"+$fitJoints[$i]+$side);
		parent ("prevPosSteer"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side);
		orientConstraint ("prevPosSteer"+$fitJoints[$i]+$side) ("prevPosAngler"+$fitJoints[$i]+$side);
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "vector" -worldUpVector 0 1 0 ("FK"+$fitJoints[$i]+$side) ("prevPos"+$fitJoints[$i]+$side);


		string $exp="";
		$exp+="float $diameter = FK"+$fitJoints[$i]+$side+".diameter;\n";
		$exp+="float $autoRoll = FK"+$fitJoints[$i]+$side+".autoRoll;\n";
		$exp+="float $sideAngle=prevPosAngler"+$fitJoints[$i]+$side+".rotateX;\n";
		$exp+="float $prevPosX=FK"+$fitJoints[$i]+$side+".prevPosX;\n";
		$exp+="float $prevPosY=FK"+$fitJoints[$i]+$side+".prevPosY;\n";
		$exp+="float $prevPosZ=FK"+$fitJoints[$i]+$side+".prevPosZ;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateX=$prevPosX;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateY=$prevPosY;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateZ=$prevPosZ;\n";
		$exp+="float $nowPosX=nowPos"+$fitJoints[$i]+$side+".translateX;\n";
		$exp+="float $nowPosY=nowPos"+$fitJoints[$i]+$side+".translateY;\n";
		$exp+="float $nowPosZ=nowPos"+$fitJoints[$i]+$side+".translateZ;\n";
		$exp+="float $distance=`mag<<$nowPosX-$prevPosX,$nowPosY-$prevPosY,$nowPosZ-$prevPosZ>>`;\n";
		$exp+="float $curRotX=FKX"+$fitJoints[$i]+$side+".rotateX;\n";
		$exp+="float $piD = 3.14 * $diameter;\n";
		$exp+="FKX"+$fitJoints[$i]+$side+".rotateX=$curRotX+($distance/$piD)*360 * $autoRoll * "+($b*-1)+" * sin(deg_to_rad($sideAngle));\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosX=$nowPosX;\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosY=$nowPosY;\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosZ=$nowPosZ;\n";

		expression -n ($fitJoints[$i]+"WheelExpression"+$side) -s $exp -o ("FKX"+$fitJoints[$i]+$side) -ae 1 -uc all ;

		}

if (`objExists FKOffsetRoot_M`)
	connectAttr -f jointLayer.drawInfo FKOffsetRoot_M.drawOverride;

//Lock FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		if ($fitJointLockTx[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".tx");
		if ($fitJointLockTy[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".ty");
		if ($fitJointLockTz[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".tz");
		if ($fitJointLockRx[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".rx");
		if ($fitJointLockRy[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".ry");
		if ($fitJointLockRz[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".rz");
		if ($fitJointLockSx[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".sx");
		if ($fitJointLockSy[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".sy");
		if ($fitJointLockSz[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".sz");
		}

//Custom controller shapes
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;
		$sca=`xform -q -r -s $fitJoints[$i]`;

		//Head 
		if (`gmatch $fitJoints[$i] "*Head*"` && $fitJointChild[$i]!="")
			{
			$pos2=`xform -q -ws -t $fitJointChild[$i]`;
			xform -r -s 2 2 2 ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
			xform -r -ws -t ($pos2[0]-$pos[0]) ($pos2[1]-$pos[1]) ($pos2[2]-$pos[2]) ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
//			xform -s (1/$sca[0]) (1/$sca[1]) (1/$sca[2]) ("FK"+$fitJoints[$i]+$side+".cv[0:99]");//restore uniform scale first
//			float $frontAxisScale=`getAttr ($fitJoints[$i]+".s"+$U)`;
//			xform -s $frontAxisScale $frontAxisScale $frontAxisScale ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
			}
		//IKLegs
		if (`gmatch $fitJointLabel[$i] "*Foot*"` && `objExists ("IK"+$fitJointIK[$i]+$side)`)
			{
			//First find $toesEnd
			$toesEnd="";
			$tempString=`listRelatives -ad -type joint $fitJoints[$i]`;
			for ($y=0;$y<size($tempString);$y++)
				{
				$childLabel=`asLabel $tempString[$y]`;
				if (`gmatch $childLabel "*ToesEnd*"`)
					$toesEnd=$tempString[$y];
				}
			int $numCVs=`getAttr ("IK"+$fitJointIK[$i]+$side+".spans")`+`getAttr ("IK"+$fitJointIK[$i]+$side+".degree")`;
			if ($toesEnd!="")
				for ($y=0;$y<$numCVs;$y++)
					{
					$temp=`xform -q -ws -t ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]")`;
					$temp2=`xform -q -ws -t ("IKX"+$fitJoints[$i]+$side)`;
					if ($fitJointQtoes[$i]!="")
						$temp2=`xform -q -ws -t ("IKX"+$fitJointQtoes[$i]+$side)`;
					$temp3=`xform -q -ws -t ($toesEnd+$side)`;
					if ($temp[1]<$temp2[1])
						{
						xform -ws -t $temp[0] 0 $temp[2] ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]");
						if ($temp[2]>$temp2[2])
							xform -ws -t $temp[0] 0 $temp3[2] ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]");
						}
					}
			$temp=`xform -q -ws -t ($fitJoints[$i]+$side)`;
			rotate -r -p $temp[0] $temp[1] $temp[2] -ws 0 ($footRotX[$i]*$b) 0 ("IK"+$fitJointIK[$i]+$side+".cv[0:99]");
			}
		}

//Default System values
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKEnd[$i])
			continue;

		if (`gmatch $fitJointLabel[$i] "*Foot*"`)
			{
			//Legs in IK
			setAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") 10;
			//Legs have pole follow
			setAttr ("Pole"+$fitJointIK[$i]+$side+".follow") 10;
			}
		if (`gmatch $fitJointIK[$i] "*Spline*"`)
			{
//			setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".fixedEnd") 0;
			//IK tail stiffness, start = 5 & end= 0, and follow=10 for first
			setAttr ("IK"+$fitJointIK[$i]+"1"+$side+".stiff") 5;
			setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".stiff") 0;
			if (`attributeExists follow ("IK"+$fitJointIK[$i]+"1"+$side)`)
				setAttr ("IK"+$fitJointIK[$i]+"1"+$side+".follow") 10;
			}
		}

delete "iconsGroup";

//Remove endJoints from DeformSet
string $deformJoints[]=`listRelatives -type joint -ad "DeformationSystem"`;
for ($i=0;$i<size($deformJoints);$i++)
	{
	$tempString=`listRelatives -c -type joint $deformJoints[$i]`;
	if ($tempString[0]=="")
		sets -rm DeformSet $deformJoints[$i];
	}

//delete $fitJointNonDef
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointNonDef[$i])
			delete ($fitJoints[$i]+$side);
		}

//Remove tempInbetweeners
for ($i=0;$i<size($fitJoints);$i++)
	if (`attributeExists tempInbetweener $fitJoints[$i]`)
		{
		$tempString=`listRelatives -c $fitJoints[$i]`;
		$tempString2=`listRelatives -p $fitJoints[$i]`;
		parent $tempString[0] $tempString2[0];
		delete $fitJoints[$i];
		}

//buildPose
createNode -n "buildPose" dagPose;
select `sets -q ("ControlSet")`;
string $controlSetMembers[]=`ls -sl`;
string $setAttrCmd;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	int $kT=0;
	int $kR=0;
	int $kS=0;
	if (`getAttr -k ($controlSetMembers[$i]+".tx")`) $kT=1;
	if (`getAttr -k ($controlSetMembers[$i]+".rx")`) $kR=1;
	if (`getAttr -k ($controlSetMembers[$i]+".sx")`) $kS=1;
	if ($kT || $kR || $kS)
		$setAttrCmd+="xform -os ";
	if ($kT)
		{
		$temp=`xform -q -os -t $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-t "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kR)
		{
		$temp=`xform -q -os -ro $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-ro "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kS)
		{
		$temp=`xform -q -r -os -s $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-s "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kT || $kR || $kS)
		$setAttrCmd+=$controlSetMembers[$i]+";";
	$tempString=`listAttr -k -shortNames -ud $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
if (!`attributeExists udAttr buildPose`)
	addAttr -ln udAttr -dt "string"  buildPose;
setAttr -type "string" buildPose.udAttr $setAttrCmd;

//Ensure mirrored controls
//asMirrorControlCurves 0 ControlSet;

//drivingSystems
$userAttrs=`listAttr -ud -s FitSkeleton`;
for ($i=0;$i<size($userAttrs);$i++)
	{
	if (!`gmatch $userAttrs[$i] "drivingSystem_*"`)
		continue;
	string $ds=`substitute "drivingSystem_" $userAttrs[$i] ""`;
	int $numChar=size($ds);
	string $dsObjName=`substring $ds 1 ($numChar-2)`;
	string $dsSide=`substring $ds ($numChar-1) 99`;
	string $sdks[]=`listConnections ("FitSkeleton."+$userAttrs[$i])`;
	string $sdkPlugs[]=`listConnections -p 1 ("FitSkeleton."+$userAttrs[$i])`;

//	$sdks=`sort $sdks`;
//	$sdkPlugs=`sort $sdkPlugs`;

	for ($y=0;$y<size($sdks);$y++)
		{
		tokenize $sdkPlugs[$y] "." $tempString;
		string $dsAttrName=$tempString[1];

		tokenize $sdks[$y] "_" $tempString;
		string $drivenObj=`substring $tempString[0] 5 99`+"_"+$tempString[1];
		if (!`objExists $drivenObj`)
			continue;
		string $drivenAttr=$tempString[2];
		if (`gmatch $drivenAttr "*[0-9]"`)
			{
			$numChar=size($drivenAttr);
			$drivenAttr=`substring $drivenAttr 1 ($numChar-1)`;
			}

		string $controllerName=$dsObjName+$dsSide;
		if (!`objExists $controllerName`)
			asCreateDrivingSystemController $controllerName {$drivenObj};
		string $sdkXform=`asCreateSDKXform $drivenObj`;
		if (`attributeExists $drivenAttr $sdkXform`)
			connectAttr -f ($sdks[$y]+".output") ($sdkXform+"."+$drivenAttr);
		else
			warning ("failed: connectAttr -f "+$sdks[$y]+".output "+$sdkXform+"."+$drivenAttr+";");
		if (!`attributeExists $dsAttrName $ds`)
			{
			string $addAttrCmd="addAttr -k 1 -ln "+$dsAttrName+" -at \"float\"  ";
			if (`addAttr -q -hasMinValue ($sdks[$y]+"."+$dsAttrName)`)
				$addAttrCmd+="-hasMinValue 1 -minValue "+`addAttr -q -min ($sdks[$y]+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasMaxValue ($sdks[$y]+"."+$dsAttrName)`)
				$addAttrCmd+="-hasMaxValue 1 -maxValue "+`addAttr -q -max ($sdks[$y]+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasSoftMinValue ($sdks[$y]+"."+$dsAttrName)`)
				$addAttrCmd+="-hasSoftMinValue 1 -softMinValue "+`addAttr -q -softMinValue ($sdks[$y]+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasSoftMaxValue ($sdks[$y]+"."+$dsAttrName)`)
				$addAttrCmd+="-hasSoftMaxValue 1 -softMaxValue "+`addAttr -q -softMaxValue ($sdks[$y]+"."+$dsAttrName)`+" ";
			$addAttrCmd+=$ds;
			eval ($addAttrCmd);
			setAttr -type "string" buildPose.udAttr (`getAttr buildPose.udAttr`+";setAttr "+$ds+"."+$dsAttrName+" 0;");
			}
		if (`attributeExists $dsAttrName $ds`)
			connectAttr -f ($ds+"."+$dsAttrName) ($sdks[$y]+".input");
		}
	}
asOptimizeDrivingSystemControllers;

//selectionChildHighlighting
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`attributeExists "selectionChildHighlighting" $controlSetMembers[$i]`)
		setAttr ($controlSetMembers[$i]+".selectionChildHighlighting") 0;

//Run
if (`attributeExists "run" FitSkeleton`)
	{
	string $run=`getAttr FitSkeleton.run`;
	catch (`eval ($run)`);
	}

//version
addAttr -ln version -at double Main;
setAttr -l 1 Main.version `asGetScriptVersion`;

//Allset
string $allAfter[]=`ls`;
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $allBefore $myIntersector;
stringArrayIntersector -edit -intersect $allAfter $myIntersector;
string $allSame[]=`stringArrayIntersector -query $myIntersector`;
deleteUI $myIntersector;
select $allAfter;
select -d $allSame;
select -ne -d "Sets" "Geometry";
select -d `ls -type ikSolver -type ikSystem`;
sets -add AllSet `ls -sl`;
select -cl;
sets -rm AllSet `listRelatives -ad FitSkeleton`;
asUpdateButtonEnables;
print "// Build Complete\n";
}
