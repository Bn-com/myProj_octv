/* This file downloaded from Highend3d.com
''  
''  Highend3d.com File Information:
''  
''    Script Name: aks_lightRay
''    Author:  
''    Last Updated: Mar 08, 2008
''    Update/Change this file at:
''    http://Highend3d.com/maya/downloads/mel_scripts/lighting/4517.html
''  
''  Please do not alter any information above this line
''  it is generated dynamically by Highend3d.com and will
''  be changed automatically on any updates.
*/


//                               aks_lightRay v.1.0 for maya v.8.x
//
// Creation Date : 02.03.2007
//
// Author : Andreas Klingert
//
// E-mail : polyCity@lycos.de
//
// Description:

//                Take a look in the Help!!
//
//                If you have problems with this script or if you have questions, comments, 
//                suggestions, requests, bug-reports or something else, please contact me.
//
//                INSTALLATION: 
//                Take a look in the installation.txt file!
//

global proc aks_lightRay()
{
 string $allTrans[] = `ls "aks_LightGrp*"`;

 
 if (`size ($allTrans)` == 0){
	
 if (`window -ex aks_lightRayWin`)
		 deleteUI aks_lightRayWin;	
	
 
 window -title "Light Ray" -wh 406 164 -s false aks_lightRayWin;
 
   columnLayout -adjustableColumn true  mainCol ;
      frameLayout
			-label ""
			-cll false
			-bs "etchedOut"
			-bv true
			-h 160
			curveFrame;

     formLayout lighterForm;
//START of formLayout content----------------------------------------------------------------
	 
	    radioCollection;
		   radioButton -l "Directional Light" -sl rBtn1;
		   radioButton -l "Spot Light"  rBtn2;
	 
	    separator sep1;
   
        attrFieldSliderGrp  -en false -label "Subdivisions Axis" -min 0 -max 10 -pre 0  attrSli1;
        
		attrFieldSliderGrp -en false -label "Subdivisions Height" -min 0 -max 10 -pre 0 -cc "aks_adjustSlider" attrSli2 ;
		
		text -l "Select Verts" -en false txt1;
 
        intSliderGrp -en false -field true -min -29 -max 29 -value 0 -step 1 -cc "aks_selectVerts" -dc "aks_selectVerts" horSli1;
		
		separator sep2;
		
		text -l "Light Type" txt2;
		text -l "Color Type" txt3;
		
		radioCollection coll1;
		   radioButton -l "2D Ramp" -sl -w 80 rBtn3;
		   radioButton -l "2D Image File" rBtn4;
		
//END of formLayout content----------------------------------------------------------------
		
		formLayout -e
			
			
        -attachForm     rBtn1  "top"	0
		-attachForm     rBtn1  "left"	110
		-attachNone     rBtn1  "right"	
		
		-attachForm     rBtn2  "top"	0
		-attachForm     rBtn2  "left"	250
		-attachNone     rBtn2  "right"
		
		-attachForm     sep1  "top"	   22
		-attachForm     sep1 "left"	    4
		-attachForm     sep1  "right"	4
			
		-attachForm      attrSli1  "top"	35
		-attachForm      attrSli1  "left"	0
		-attachNone      attrSli1  "right" 
		
		-attachForm		 attrSli2  "top"   57
		-attachForm      attrSli2  "left"	0
		-attachNone      attrSli2  "right"
	
		-attachForm      txt1   "top"	81
		-attachForm      txt1   "left"  78
		
		-attachForm      horSli1   "top"	81
		-attachForm      horSli1   "right"  16
		
		-attachForm     sep2  "top"	  110
		-attachForm     sep2 "left"	    4
		-attachForm     sep2  "right"	4
		
	    -attachForm     rBtn3  "top"	122
		-attachForm     rBtn3 "left"	110
		-attachNone     rBtn3  "right"	
		
		-attachForm     rBtn4  "top"	122
		-attachForm     rBtn4 "left"	250
		-attachNone     rBtn4  "right"	
		
		
		
		-attachForm      txt2   "top"	0
		-attachForm      txt2   "left"  40
		
		-attachForm      txt3   "top"	122
		-attachForm      txt3   "left"  40
		
		
		lighterForm;
		
		setParent mainCol;
		
	   rowColumnLayout -nc 2  
		               -cw 1 200 
					   -cw 2 200 
					   -cal 1 "left"  
					   -cat 1 "both" 1
				       -cat 2 "both" 1 ;
				
	    separator -style "none" -h 3;
		separator -style "none" -h 3;
	    button -l "Create Sphere" -c "aks_createSphere 1"  btn1;
		button -l "Setup Lights" -c "aks_setupLights" btn2;
		
		window -e -wh 406 211 aks_lightRayWin;

       showWindow aks_lightRayWin;
	   
	   aks_createSphere 0;
   }
   else
	    aks_lightRayUI $allTrans[0] 1;
  

}

///////////////////////////////////////////////////////////////////////////////////////
//selects the vertices on the sphere
///////////////////////////////////////////////////////////////////////////////////////
global proc aks_selectVerts()
{
	
	string	$sel[] = `ls -sl`;
	
	if ((`size($sel)`== 1) && (`match "aks_dome_" $sel[0]`== "aks_dome_")){
	
	       //takes the spherename, if the are some verts selected
	       int $vertsToSelect;
	       string $pSphere[];
	       $numTokens =`tokenize $sel[0] "." $pSphere`;
	
           //gets polySphere node
	       string $getShape[] = `listRelatives -c $pSphere[0]`;
           string $getPolySphere[] = `listConnections -d 0 $getShape[0]`;
	
	       if ((`size $getPolySphere` > 0) && (`nodeType $getPolySphere[0]` == "polySphere")){
	
	             int $valueHorizontal = `intSliderGrp -q -v horSli1`; 
	
	             //gets sphere creation attributes
                 int $subdivisionsAxis = `getAttr ($getPolySphere[0] + ".subdivisionsAxis")`;
	             int $subdivisionsHeight = `getAttr ($getPolySphere[0] + ".subdivisionsHeight")`;
	
	             //gives the total amount of verts
	             int $vertsTotal = ($subdivisionsAxis * ($subdivisionsHeight -1)) + 2;
	
    
	             //select the verts
	             if ($valueHorizontal == 0)
		             select $pSphere[0];
	             else if ($valueHorizontal > 0){
		
		             //selects the vertsrows from below
		             $vertsToSelect = $valueHorizontal * $subdivisionsAxis;
	                 select -r ($pSphere[0] + ".vtx[0:" + ($vertsToSelect - 1) + "]" );
	                 }
	             else if ($valueHorizontal < 0){
		
		             //selects the vertsrows from abows
		             int $counter = abs($valueHorizontal);
	                 int $startVertex = $vertsTotal - 3;
		             $vertsToSelect = $startVertex - ($subdivisionsAxis * $counter);
		             select -r ($pSphere[0] + ".vtx["  + ($vertsToSelect + 1)  + ":" + $startVertex + "]" );
		            }
		   }
	     else{
			 
			   intSliderGrp -e -en false -v 0 horSli1;
		       error "History error, to use the sliders, create a fresh sphere from the aks_lightRay GUI !";
			 
			 
		    }
	}
	else
	 error "Please select the dome sphere !"; 
		
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//creates the polySphere and makes the connections to the GUI
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_createSphere(int $createSphere)
{
	string $lightSphere[];
	
	if ($createSphere == 1)
		     $lightSphere = `polySphere -r 10 -sx 10 -sy 10 -ax 0 1 0 -cuv 2 -ch 1 -n "aks_dome_#"`;
    else
		     $lightSphere = `ls -type "transform" "aks_dome_*"`;
		
	if 	(`size ($lightSphere)` != 0){
		
		string $selectedDome[] = `ls -sl`;
	    if((`size $selectedDome` > 0) && ((`match "aks_dome" $selectedDome[0]` == "aks_dome") && (`nodeType $selectedDome[0]` == "transform"))) 
			 $lightSphere[0] = $selectedDome[0];
        
		string $shapeNode[] = `listRelatives -c  $lightSphere[0]`;
        string $polySphereNode[] = `listConnections -d 0 $shapeNode[0]`;
		
		if ((`size $polySphereNode` > 0) && (`nodeType $polySphereNode[0]` == "polySphere")){

	              int $subDH = `getAttr ($polySphereNode[0] + ".subdivisionsHeight")`;
	
	              attrFieldSliderGrp -e -en true -at ($polySphereNode[0] + ".subdivisionsAxis") -min 0 -max 30 attrSli1; 
	              attrFieldSliderGrp -e -en true -at ($polySphereNode[0] + ".subdivisionsHeight") -min 0 -max 30 attrSli2; 
	              intSliderGrp -e -en true -min (-$subDH)  -max ($subDH -1) horSli1;
	              text -e -en true txt1;
		}
		else
			error "History error, to use the sliders, create a fresh sphere from the aks_lightRay GUI !";
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//creates the lights and the textures
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_setupLights()
{
 string $allLights[], $makeLight, $getLightTransl[], $directLight, $lightID, $finalLight, $dupSurface, $group;
 float $pointTransl[3];
 int $index, $isDome;
 
 string $selPoints[] = `filterExpand -ex true -sm 31`;

 if (`size($selPoints)` > 0){
 
 string $radioCollection = `radioCollection -q -sl coll1`;
 if ($radioCollection == "rBtn3")
		$lightID = "rc_";
 else if ($radioCollection == "rBtn4")
	    $lightID = "fc_";
 
 
 string $lightSurfaceTrans[];
 $numTokens =`tokenize $selPoints[0] "." $lightSurfaceTrans`;

 int $polyInfo[] = `polyEvaluate -v $lightSurfaceTrans[0]` ;
 
 if (($polyInfo[0] -2 > `size ($selPoints)`) && (`match "aks_dome_" $lightSurfaceTrans[0]`== "aks_dome_")){
	 
	     string $lastOrFirstVert;
	     int $sliderVal = `intSliderGrp -q -v horSli1`;
		 
		 //gets polySphere node
	     string $getShape[] = `listRelatives -s $lightSurfaceTrans[0]`;
         string $getPolySphere[] = `listConnections -d 0 $getShape[0]`;
			   
		 if ($sliderVal < 0){
		          $lastOrFirstVert = ($lightSurfaceTrans[0] + ".vtx[" + ($polyInfo[0] - 1) + "]");
		          select -add  $lastOrFirstVert;
		      }        
	     else if ($sliderVal > 0){
			      $lastOrFirstVert = ($lightSurfaceTrans[0] + ".vtx[" + ($polyInfo[0] - 2) + "]");
		          select -add  $lastOrFirstVert;
		      }
		
         InvertSelection;	
         ConvertSelectionToFaces;	
			
         delete `ls -sl`;
		 delete -ch $lightSurfaceTrans[0];
		 
		 $polyInfo = `polyEvaluate -v -f $lightSurfaceTrans[0]`;
		 
		 string $polyProj[] = `polyProjection -ch 1 -type Cylindrical -ibd on -icx 0.5 -icy 0.5 -ra 0 -isu 1 -isv 1 -sf on ($lightSurfaceTrans[0] + ".f[0:" + $polyInfo[1] + "]")` ;
	     
		 select -r ($lightSurfaceTrans[0] + ".vtx[0:" + $polyInfo[0] + "]");
	     select -deselect ($lightSurfaceTrans[0] + ".vtx[" + ($polyInfo[0] - 1) + "]");
		 
		 //renames the surface temporarely , so it goes in the next if and the surface 
		 //will be duplicated as goal object
		 $lightSurfaceTrans[0] = `rename $lightSurfaceTrans[0] "aks_lightGRP_Temp"`;
		 $isDome = 1;
	 }
 
 if  (`match "aks_dome_" $lightSurfaceTrans[0]`!= "aks_dome_"){
	  //renames the selected surface, when they is not the dome sphere
	  //and runs the filterexpand command again, to avoid some naming conflicts
	  if ($isDome == 1)
           $lightSurfaceTrans[0] = `rename $lightSurfaceTrans[0] "aks_dome_#"`;
      else
	       $lightSurfaceTrans[0] = `rename $lightSurfaceTrans[0] "aks_lightSurface_#"`;
	  
	  $selPoints = `filterExpand -ex true -sm 31`;
	  $index = 1;
 }
 
 //divides dome or lightSurfacename for renaming the light properly
 string $lightSurfaceDiv[];
 $numTokens =`tokenize $lightSurfaceTrans[0] "_" $lightSurfaceDiv`;
 
 //creates a locator as a goal for the aimconstraints
 string $loc[] = `spaceLocator -p 0 0 0`;
	
     //creates the lights on the vertex positions,
     //and constraints them to the locator
	 for ($i = 0; $i < `size ($selPoints)`; $i++){
		 
	   float $pointTransl[3] = `xform -q -t -ws $selPoints[$i]`;
	   
	   string $vertexNum[];
	   $numTokens =`tokenize $selPoints[$i] ".,[,]" $vertexNum`;
	   
	   
	   
	    if (`radioButton -q -sl rBtn1`){
      
		    $makeLight = `directionalLight`;
			setAttr ($makeLight + ".useDepthMapShadows") 1;
			//setAttr "directionalLightShape1.useDepthMapShadows" 1;
			
		    $getLightTransl = `listRelatives -p $makeLight`;
			$finalLight = `rename  $getLightTransl[0] ($lightID + "dLight#")`;
			//renames the lights, with which surface they are connected, the first 2 characters are
			//the surface, the last one is the vertex id, is for later use, when lightColor 
			//will be changed or animated, makes my live a lot easier
			$directLight = `rename $finalLight ($finalLight + "_" + $lightSurfaceDiv[1] +
				                    "_" +  $lightSurfaceDiv[2] + "_" + $vertexNum[2])`;
	  }
	   
	   else{
		    $makeLight = `spotLight`;
			setAttr ($makeLight + ".useDepthMapShadows") 1;
			
		    $getLightTransl = `listRelatives -p $makeLight`; 
			$finalLight = `rename  $getLightTransl[0] ($lightID + "sLight#")`;
			$directLight = `rename $finalLight ($finalLight + "_" + $lightSurfaceDiv[1] +
				                    "_" +  $lightSurfaceDiv[2] + "_" + $vertexNum[2])`;
	     }
	   
	    // gets the position data of the cureent vert
		xform -ws  -t  $pointTransl[0] $pointTransl[1] $pointTransl[2]  $directLight;
			 
		if  ($index != 1){
        
		      // constraining them to the center (or locator) and delete them
		      string $aim[] = `aimConstraint -aim 0 0 -1 -u 0 1 0 $loc[0]  $directLight`;
		      delete $aim[0];
		 }
		 else{
			 xform -ws -ro -90 0 0 $directLight;
			 
			 //duplicates the selected object, and makes the light aim object
			 //only in the first execution of the loop
			 if ($i == 0){
				 $dupSurface = `aks_duplicateSurface ($lightSurfaceTrans[0])`;
			 }
			
			 
			 string $cluster[] = `cluster -rel ($dupSurface + ".vtx[" + $vertexNum[2] + "]")`;
			 parent $cluster[1] $dupSurface;
			 aimConstraint -aim 0 0 -1 -u 0 1 0 $cluster[1]  $directLight;
			 
		 }	 
		
	 $allLights[`size($allLights)`] =  $directLight;
		
	  }
	 
	 string $colorTexture;
	
	 string $shader = `shadingNode -asShader surfaceShader -n "aks_lightColor#"`;
	 string $place2dNode = `shadingNode -asUtility place2dTexture`;
     string $sgNode = `sets -r true -nss true -em -n ( $shader + "SG")` ;
	
	 if (`radioCollection -q -sl coll1` == "rBtn3"){
      
	         
		     $colorTexture = `shadingNode -asTexture ramp -n ($lightSurfaceTrans[0] + "_color")`;
		 
	         //sets ramp attributes
	         setAttr ($colorTexture + ".colorEntryList[0].position") 0;
		     setAttr ($colorTexture + ".colorEntryList[0].color") -type double3 0.641 0.469 0.360 ;
		     setAttr ($colorTexture + ".colorEntryList[1].position") 0.49;
	         setAttr ($colorTexture + ".colorEntryList[1].color") -type double3 1.000 0.813 0.625 ;
		     setAttr ($colorTexture + ".colorEntryList[2].position") 0.51;
             setAttr ($colorTexture + ".colorEntryList[2].color") -type double3 0.746 0.895 1.000 ;
		     setAttr ($colorTexture + ".colorEntryList[3].position") 0.8;
             setAttr ($colorTexture + ".colorEntryList[3].color") -type double3 0.909 0.980 1 ;
	   
          

             //makes the shader complete
             connectAttr -f ($shader + ".outColor") ($sgNode + ".surfaceShader");
             connectAttr -f ($colorTexture + ".outColor") ($shader + ".outColor");
             connectAttr -f ($place2dNode + ".outUV") ( $colorTexture + ".uvCoord");
             connectAttr -f ($place2dNode + ".outUvFilterSize") ( $colorTexture + ".uvFilterSize");
	     }
		 
	 else if ($radioCollection == "rBtn4"){
	
	       
	         $colorTexture = `shadingNode -asTexture file -n ($lightSurfaceTrans[0] + "_color")`;
			
			 //makes  the proper connections to build the shading network
	         connectAttr -force ($place2dNode  + ".repeatUV") ($colorTexture + ".repeatUV");
			 connectAttr -f ($colorTexture + ".outColor") ($shader + ".outColor");
			 connectAttr -f ($shader + ".outColor") ($sgNode + ".surfaceShader");
	         
	         string $path=(`workspace -q -rootDirectory` + "sourceimages/");
	         string $fileName = `fileDialog -directoryMask $path`;
	         setAttr ($colorTexture + ".fileTextureName") -type "string" $fileName;
	 }
	 
	 
	    //connecst the shader to the plane
        string $pSphere[];
        $numTokens =`tokenize $selPoints[0] "." $pSphere`;
        
		if ($index != 1){
		    setAttr ($lightSurfaceTrans[0] + ".doubleSided") 0;
            setAttr ($lightSurfaceTrans[0] + ".opposite") 1;
		}
		else{
			setAttr ($lightSurfaceTrans[0] + ".visibleInReflections") 0;
		    setAttr ($lightSurfaceTrans[0] + ".visibleInRefractions") 0;
			
		}
        setAttr ($lightSurfaceTrans[0] + ".castsShadows") 0;
		setAttr ($lightSurfaceTrans[0] + ".primaryVisibility") 0;
		setAttr ($lightSurfaceTrans[0] + ".receiveShadows") 0;
		sets -e -forceElement $sgNode $pSphere[0] ;
	   
	   //assings the lightcolor
       for ($i = 0; $i < `size($selPoints)`; $i++){
	
	          select $selPoints[$i];
	          // ConvertSelectionToUVs;
	          string $convertToUV[] = `polyListComponentConversion -fromVertex -toUV $selPoints[$i]`;
	    
	          //gets uv values
	          float $uv[] = `polyEditUV -query $convertToUV[0]`;
	          //gets the texturcolor based an the uv value
	          vector $lightColor = ` colorAtPoint -o RGB -u $uv[0] -v $uv[1] $colorTexture`;
	   
	          setAttr ( $allLights[$i] + ".color") ($lightColor.x) ($lightColor.y) ($lightColor.z);
	          select -cl;
	       }

   
   //creates the light group node and add intensity attr to the group node
   select $allLights $lightSurfaceTrans[0];
   
   if ($index != 0)
	   select -add $dupSurface;
   
   $group = `group -n "aks_LightGrp#"`;
   addAttr -ln intensity -at "float"  -min 0 -max 50 -dv 0.1 $group;
   aks_connectAttr($group,"intensity");
   addAttr -ln shadowColor -usedAsColor -attributeType "float3";
           addAttr -ln sColorR -at "float" -parent shadowColor;
           addAttr -ln sColorG -at "float" -parent shadowColor;
           addAttr -ln sColorB -at "float" -parent shadowColor;
		   setAttr ($group + ".shadowColor") -type float3 0 0 0;
	       aks_connectAttr($group,"shadowColor");
   addAttr -ln sampling -at "long" -min 1 -max 10 -dv 1 $group;
   addAttr -ln dmapResolution -at "short"  -min 16 -max 4048 -dv 128 $group;
   aks_connectAttr($group,"dmapResolution");
   addAttr -ln dmapFilterSize -at "short"  -min 0 -max 30 -dv 1 $group;
   aks_connectAttr($group,"dmapFilterSize");
   addAttr -ln dmapBias -at "float"  -min 0 -max 1 -dv 0.001 $group;
   aks_connectAttr($group,"dmapBias");
   
 
   
   if (`radioButton -q -sl rBtn2`){
	  
	   addAttr -ln coneAngle -at "float"  -min 0.006 -max 180 -dv 40 $group;
       aks_connectAttr($group,"coneAngle");
	   addAttr -ln penumbraAngle -at "float"  -min -10 -max 10 -dv 0 $group;
       aks_connectAttr($group,"penumbraAngle");
	   addAttr -ln dropoff -at "float"  -min 0 -max 255 -dv 0 $group;
       aks_connectAttr($group,"dropoff");
	   addAttr -ln  dmapFocus -at "float"  -min 0 -max 360 -dv 90 $group;
       aks_connectAttr($group,"dmapFocus");
	   }
	   
   delete $loc[0];
   select -cl;
 }
 else 
  error "This script works only on a polygonal vertex selection, you have to select them !"; 
  
  string $lightGroupsExists[] = `ls "aks_LightGrp*"`;
  int $lightGroupIndex = `size $lightGroupsExists`;
  
  aks_lightRayUI $group $lightGroupIndex; 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//duplicates the lightgroup
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_duplicateLightGroup()
{
	string $selLightGrp = `optionMenu -q -v optMenu1`;
	
	
	if (`objExists $selLightGrp`){
		
		string $surfaces[], $newSurfaces[], $newSurfacesTemp[],$texture, $vertexIDs[], $finalLightGroup[];
		
		string $lightGroupChilds[] = `listRelatives -c $selLightGrp`;
	    int $counter = 0;
	
	    //loops through the selected lightGroup, and gets the ID which
	    //vertex is connected to which light and gets the surfaces to find later the shader
	    for ($each in $lightGroupChilds){
		
		     string $getLightShape[] = `listRelatives -s $each`;

		     if (`nodeType ($getLightShape[0])` != "mesh"){
			 
			       string $origLightNames[];
                   $numTokens =`tokenize $each "_" $origLightNames`;
			       $vertexIDs[`size $vertexIDs`] = $origLightNames[4];
		     }
		     else if ((`match "aks_dome_" $each`== "aks_dome_") || (`match "aks_lightSurface_" $each`== "aks_lightSurface_"))
			       if (`nodeType ($getLightShape[0])` == "mesh")
			            $surfaces[`size $surfaces`] = $getLightShape[0];
		}
	
	   //duplicates the lightGrp and gets the children, it`s not possible to use the upstreamNodes flag
	   //in the duplicate command, because it`s turning off some of the lights, and this to fix is much harder
	   //than recreate the constraints and clusters
	   string $duplicateGrp[] = `duplicate -renameChildren $selLightGrp`;
	   xform -ws -t 0 0 0 $duplicateGrp[0];
	   makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $duplicateGrp[0];
	   string $childsNewGrp[] = `listRelatives -type "transform" $duplicateGrp[0]`;
	   
	   //it`s getting rid of the clusters and constraints
	   for ($node in $childsNewGrp){
	          string $getChildren[] = `listRelatives $node`;
	  
	          for ($child in $getChildren){
		 
		              string $cluster[] = `listRelatives  $child`;
		   
		              if ((`size $cluster` > 0 ) && (`nodeType $cluster[0]` == "clusterHandle"))
		                  delete $child;
	                  else if (`nodeType $child` == "aimConstraint")
	  	                  delete $child;
	               }
	      }
	   
	   //gets number of lightGroups, this number is the light surface ID
	   //in the light name, will be used in the next loop
	   string $lightGroups[] = `ls "aks_LightGrp*"`;
	   string $testString = $lightGroups[(`size ($lightGroups)` -1)];
	   int $numLightGroups = `match "[0-9]+" $testString`;
	
	   //loops through the new lightgroup, and renames the lights, 
	   //so that every light gets his vertexID
	   for ($piece in $childsNewGrp){
		
		    string $oldLightName[];
            $numTokens =`tokenize $piece "_" $oldLightName`;
		
		    string $getLightShape[] = `listRelatives -s $piece`;
		
		    if (`nodeType ($getLightShape[0])` != "mesh"){
			 
			      string $newName = ` rename $piece ($oldLightName[0] + "_" + $oldLightName[1] + "_" + $oldLightName[2] + "_" + $numLightGroups + "_" + $vertexIDs[$counter])`;
			      $counter++;
			   
			      $finalLightGroup[`size ($finalLightGroup)`] = $newName;
			    }
		    else 
			      $finalLightGroup[`size ($finalLightGroup)`] = $piece;
		  }
       
	   //loops through the children of the duplicated group and gets the 
	   //surfaces to assign later the duplicated shadingnetworks
	   for ($child in $finalLightGroup){
		
		          string $getMesh[] = `listRelatives -s $child`;
				  
				  if (`nodeType $getMesh[0]` == "mesh")
					    if  ((`match "aks_dome_" $child`== "aks_dome_") || (`match "aks_lightSurface_" $child`== "aks_lightSurface_"))
		                       $newSurfacesTemp[0] = $child;
					    else if (`match "aks_aim" $child`== "aks_aim")
						       $newSurfacesTemp[1] = $child;
	   } 
	   
	   //makes clusters
	   if (`match "aks_dome_" $newSurfacesTemp[0]`!= "aks_dome_"){
	   
	   for ($each in $finalLightGroup){
		   
		   string $getShapeNode[] = `listRelatives -s $each`;
		 
		   if (`nodeType $getShapeNode[0]` != "mesh"){
			   
			     string $lightName[];
                 $numTokens =`tokenize $each "_" $lightName`;
				 
				 string $vertexID = $lightName[`size $lightName` -1];
				 
				 string $cluster[] = `cluster -rel ($newSurfacesTemp[1] + ".vtx[" + $vertexID + "]")`;
				 parent $cluster[1] $newSurfacesTemp[1];
			     aimConstraint -aim 0 0 -1 -u 0 1 0 $cluster[1] $each;
		       }
		   }
	   }
	   
	   //connects light attributes, connections lost through duplicate command
	   string $attrs[] = `listAttr -ud $duplicateGrp[0]`;
	  
	   	for ($i = 0; $i < size($attrs); $i++){
		if (($attrs[$i] != "attributeAliasList") && (($attrs[$i] != "sampling") && (`match "sColor" $attrs[$i]` != "sColor")))
			         aks_connectAttr($duplicateGrp[0], $attrs[$i]);
		  }
	
	   //renames the surfaces properly
	   for ($surface in $newSurfacesTemp){
		   
		        string $buffer[0];
				$numTokens =`tokenize $surface "_" $buffer`;
				
				string $rename = `rename $surface ($buffer[0] + "_" + $buffer[1] + "_" + $numLightGroups)`;
				$newSurfaces[`size $newSurfaces`] = $rename;
		    }
	   
	   string $connections[] = `listConnections $surfaces[0]`;
	   
	   string $shadindGrp;	
	
	   //gets SGnode for duplicating
	   for ($node in $connections){
			 
			    if (`nodeType ($node)` == "shadingEngine")
				   $shadindGrp = $node;
		 }
	
	   //duplicates the shader
	   string $duplicatedShader[] = `duplicate -upstreamNodes $shadindGrp `;
	
       string $material,$sgNode;
	
	   //finds shadingnodes for renaming
	   for ($each in $duplicatedShader){
		     if ((`match "aks_lightSurface_" $each`== "aks_lightSurface_") || (`match "aks_dome_" $each`== "aks_dome_"))
				     rename $each ($newSurfaces[0] + "_color");
			 else if (`nodeType ($each)` == "surfaceShader")
				    $material = $each;
			 else if (`nodeType ($each)` == "shadingEngine")
				    $sgNode = $each;
		}
	   //renames shadinggroup
       string $newShader = `rename $sgNode ($material + "SG")`;
		 
       sets -e -forceElement $newShader $newSurfaces[0] ;
		 
	   //make sure the aimSurface exist,otherwise it`s a dome
	   if ($newSurfaces[1] != ""){
		   string $mesh[] = `listRelatives -s $newSurfaces[1]`;
	   $newSurfaces[1] = $mesh[0];
	   sets -e -forceElement "aks_aimLambertSG" $newSurfaces[1] ;
	   }
		 
	   select $duplicateGrp[0];
	
	   //querie num of itmes
	   int $numItems = `optionMenu -q -ni optMenu1`;
	   //call window and add the duplicated group to the optionmenu	 
	   aks_lightRayUI ($duplicateGrp[0], ($numItems + 1));
	   }
    else
	    error "The group you want to duplicate doesn`t exists, press \"Refresh\" to update the UI !"; 
		
}		
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//deletes the lightgroup
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_deleteLightGroup()
{
	string $shadingNetwork[];
	string $selLightGrp = `optionMenu -q -v optMenu1`;
	
	//if the lightgroup exists, go on
	if (`objExists $selLightGrp` == 1){
		
		string $surfaces[];
		
		string $lightGroupChilds[] = `listRelatives -c $selLightGrp`;
	    
	    //getting shape of the surface
		for ($each in $lightGroupChilds){
		
		     string $getLightShape[] = `listRelatives -s $each`;

		     if ((`match "aks_dome_" $each`== "aks_dome_") || (`match "aks_lightSurface_" $each`== "aks_lightSurface_"))
			       if (`nodeType ($getLightShape[0])` == "mesh")
			            $surfaces[`size $surfaces`] = $getLightShape[0];
		}
	
	    string $getSGNode[] = `listConnections -d 1 $surfaces[0]`;
	   
		//get every single shadingnode, and put them in a variable 
	    for ($a in $getSGNode){
			
			     if (`nodeType $a` == "shadingEngine"){
			   
			           $shadingNetwork[`size $shadingNetwork`] = $a;
			           string $getMaterial[] = `listConnections $shadingNetwork[0]`;
					   
					   for ($b in $getMaterial){
						   
						        if (`nodeType $b` == "surfaceShader"){
			   
			                          $shadingNetwork[`size $shadingNetwork`] = $b;
			                          string $getTexture[] = `listConnections $shadingNetwork[1]`;
									  
									  for ($c in $getTexture){
										  
										    if ((`nodeType $c` == "ramp") || (`nodeType $c` == "file")){
												
												         $shadingNetwork[`size $shadingNetwork`] = $c;
														 string $getPlace2D[] = `listConnections $shadingNetwork[2]`;
														 
														 for ($d in $getPlace2D){
															 
															    if (`nodeType $d` == "place2dTexture"){
																   $shadingNetwork[`size $shadingNetwork`] = $d;
																   break;
			} }		    } }		        } }	              } }
											  
	    //deletes the whole stuff
		delete $selLightGrp $shadingNetwork;
		
		string $allLightGroups[] = `ls "aks_LightGrp*"`;

		//if another group exists call the window
		//if not don`t call it
		if (`size $allLightGroups` > 0)
	          aks_lightRay;
		else{
		      deleteUI  aks_lightRayWin;
			  
			  if (`objExists "aks_aimLambert"`)
			        delete "aks_aimLambert";
			 }
	   }
    else
	 error  "The group you want to delete doesn`t exists, press \"Refresh\" to update the UI !"; 
		
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//duplicates the lightSurface and makes the aim surface, moves all the verts to 0 in Y
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc string aks_duplicateSurface(string $surface)
{
 string $dupSurface[] = `duplicate -n ("aks_aimSurface_#") $surface`;
 
 setAttr ($dupSurface[0] + ".castsShadows") 0;
 setAttr ($dupSurface[0] + ".primaryVisibility") 0;
 setAttr ($dupSurface[0] + ".receiveShadows") 0;
 setAttr ($dupSurface[0] + ".visibleInReflections") 0;
 setAttr ($dupSurface[0] + ".visibleInRefractions") 0;
  
 //creates a lambert for the aim surface
 string $shader = `shadingNode -asShader lambert -n "aks_aimLambert"`;
 string $sgNode = `sets -r true -nss true -em -n ( $shader + "SG")` ;
 connectAttr -f ($shader + ".outColor") ($sgNode + ".surfaceShader");
 sets -e -forceElement $sgNode $dupSurface[0] ;
 
 int $vertsNum[] = `polyEvaluate -v  $dupSurface[0]`;
				 
		for ($i = 0; $i < $vertsNum[0]; $i++){
			 
			float $getTranslate[] =`xform -q -t -ws ($dupSurface[0] + ".vtx[" + $i + "]")`;
			xform -ws -t $getTranslate[0] 0 $getTranslate[2] ($dupSurface[0] + ".vtx[" + $i + "]");
		 }
 //freeze transform
 makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $dupSurface[0];
 //center pivot
 xform -cp $dupSurface[0];
 
 return $dupSurface[0];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//connect the attributes the the current light group
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_connectAttr(string $lightGroup, string $attribute){
	
	string $light[] = `listRelatives  $lightGroup`;
		
    for ($i = 0; $i < `size ($light)`; $i++){
        string $lightShape[] = `listRelatives -s $light[$i]`;
        string $node = `nodeType $lightShape[0]`;
		
	    if ((`nodeType ($lightShape[0])` == "directionalLight") || (`nodeType ($lightShape[0])` == "spotLight"))
                connectAttr -f ($lightGroup + "." + $attribute)($lightShape[0] + "." + $attribute); 
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//adjusts the "Select Verts" slider, 
//so that the min max value is equal the polySphere subdivisionAxis value
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_adjustSlider()
{
	string $sel[] = `ls -sl`;
	
	if (`size $sel` > 0){
	
	  string $pSphere[];
	  $numTokens =`tokenize $sel[0] "." $pSphere`;
	
      string $getShape[] = `listRelatives -c $pSphere[0]`;
      string $getPolySphere[] = `listConnections -d 0 $getShape[0]`;
	  int $subdivisionsHeight = `getAttr ($getPolySphere[0] + ".subdivisionsHeight")`;
	
	  intSliderGrp -e -min (-$subdivisionsHeight + 1)  -max ($subdivisionsHeight -1) horSli1;
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//change the lightGroup attributes
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_editLightGRP(string $operator, string $attribute, string $radioButtonGrp, string $lightGrp)
{
	
	string $lights[];
	if ($lightGrp == "")
	   $lightGrp = `optionMenu -q -v optMenu1`;
	
	if ($operator != "refreshUI")
	    $lights = `aks_divideLightNode $lightGrp 0`;

	
    switch ($operator){
	     case "openRamp" : 
			            //opens AEWindow for the ramp node
			            string $lightSurface;
	                    string $getChilds[] = `listRelatives  -c $lightGrp`;
						
	                    
						for ($node in $getChilds){
							
						      if  ((`match "aks_dome" $node`== "aks_dome") || (`match "aks_lightSurface" $node`== "aks_lightSurface"))
						      $lightSurface = $node;
							 }
								  
						
	                    select ($lightSurface + "_color");
	                    openAEWindow ;
				        break;
		
	     case "editColor" :
		                //updates the lightcolor, when the ramp color or texturfile has changed
	                    for ($i = 0; $i < `size ($lights)`; $i++){
			
			                    string $fullName[];
								
								//breaks the lightname in different parts
			                    $numTokens = `tokenize $lights[$i] "_" $fullName`;
			                   
								//builds the rampname, uses the broken parts from the commands above
			                    string $rampTextur = ("aks_" + $fullName[2] + "_" + $fullName[3] + "_color");
			                    select -r ("aks_" + $fullName[2] + "_" + $fullName[3] + ".vtx[" + $fullName[4] + "]");
			
			                    string $selPoints[] = `ls -sl`;
			                    // ConvertSelectionToUVs;
	                            string $convertToUV[] = `polyListComponentConversion -fromVertex -toUV $selPoints[0]`;
	                            //gets uv values
	                            float $uv[] = `polyEditUV -query $convertToUV[0]`;
	                            //gets the texturcolor based an the uv value
	                            vector $lightColor = ` colorAtPoint -o RGB -u $uv[0] -v $uv[1] $rampTextur`;
	   
	                            setAttr ( $lights[$i] + ".color") ($lightColor.x) ($lightColor.y) ($lightColor.z);
	                            select -cl;
			               }
	                             
						  break;
						  
	      case "changeAttRbtnGrp" :
			                 //turning boolean attr off/off/ by given arguments, like "lightShape1.emitSpecular"
			                 if(` radioButtonGrp -q -sl $radioButtonGrp` == 2)
	                              for ($light in $lights)
	                                 setAttr ($light + "." + $attribute) 0;
                             else 
	                               for ($light in $lights)
	                                 setAttr ($light + "." + $attribute) 1;
							 break;
							 
	      case "editSampling" :
			                 //turns shadows on based on the sampling value, this means, by a sampling value 
			                 //of 2, every second lights shadow are turned on , and so on
	                         string $shadowLights[];
	                         int $sampling = `getAttr ($lightGrp + ".sampling")`;
	
	                         for ($i = 0; $i < `size ($lights)`; $i++){
		
		                          setAttr ($lights[$i] + ".useDepthMapShadows") 0;
		                          int $mod = fmod($i,$sampling);
		   
		                          if ($mod == 0)
			                      $shadowLights[`size($shadowLights)`] = $lights[$i];
		                         }
	
	                         for ($light in $shadowLights){
	                              string $lightShape[] =`listRelatives -s $light`;
		                          setAttr ($lightShape[0] + ".useDepthMapShadows") 1;
		                      }
							 break;
							 
	      case  "connectTexture" :
			                   //changes the file texture
			                   string $path=(`workspace -q -rootDirectory` + "sourceimages/");
	                           string $fileName = `fileDialog -directoryMask $path`;
	                           string $getTextureInfo[] = `aks_fileTextureInfo`;
							   
							   if ($fileName != ""){
	                                setAttr ($getTextureInfo[1] + "_color" + ".fileTextureName") -type "string" $fileName;
	                                textFieldButtonGrp -e  -tx $fileName btnGrp1;
							   }
			                   break;
							   
	      case "editMiscAttr"  :
			                   for ($light in $lights){
							   string $shape[] = `listRelatives -s $light`;
										 
							   switch ($attribute){
										 
									    case "setDecayRate" :
											         int $decayType = `optionMenu -q -sl optMenu2`;
								                     setAttr ($shape[0] + ".decayRate") ($decayType -1);
													 break;
							              
							            case "useMidDistDmap" : 
								                     int $attr = `getAttr ($light + ".useMidDistDmap")`;
									                 if ($attr == 1)
										                   setAttr ($shape[0] + ".useMidDistDmap") 0;
										             else 
											               setAttr ($shape[0] + ".useMidDistDmap") 1;
												     break;
							               
										case "useDmapAutoFocus" : 
								                     int $attr = `getAttr ($light + ".useDmapAutoFocus")`;
									                 if ($attr == 1)
										                   setAttr ($shape[0] + ".useDmapAutoFocus") 0;
										             else 
											               setAttr ($shape[0] + ".useDmapAutoFocus") 1;
												     break;
							                
									     case "dmapWidthFocus" : 
												     float $autoFocus = `floatField -q -v focusField`;
												     setAttr ($shape[0] + ".dmapWidthFocus") $autoFocus;
													 break;
												 }
												}
									  break;
									  
	      case "reloadTexture"  :
			                    string $getTextureInfo[] = `aks_fileTextureInfo`;
								setAttr ($getTextureInfo[1] + "_color" + ".fileTextureName") -type "string" $getTextureInfo[0];
	                            textFieldButtonGrp -e  -tx $getTextureInfo[0] btnGrp1;
							    break;
									
	      case "openImageApp"   :
			                    string $getTextureInfo[] = `aks_fileTextureInfo`;
								string $fileTexture = ($getTextureInfo[1] + "_color" + ".fileTextureName");
			  
			                    AEfileTextureEditCmd $fileTexture;
                                optionVar -q EditImageDir;
								break;
								
	      case "refreshUI"      :
			                    string $lGroups[] = `ls "aks_LightGrp*" `;
	
	                            if (`size $lGroups` > 0)
		                              aks_lightRayUI $lGroups[0] 1;
		                        else 
								    error "No lightgroups exists, can`t refresh the UI !"; 

	} 
	
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//returns, based on the index num, the lights or the surface in the dome group node
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc string[] aks_divideLightNode(string $lightGrp, int $index)
{
	string $divideLightNode[];
	
	string $childs[] = `listRelatives  $lightGrp`;
		
	     
	            for ($i = 0; $i < `size ($childs)`; $i++){
		 
		             string $shape[] = `listRelatives -s $childs[$i]`;
					 
				     if ($index == 0){
		                 if ((`nodeType ($shape[0])` == "directionalLight") || (`nodeType ($shape[0])` == "spotLight"))
			                   $divideLightNode[`size ($divideLightNode)`] = $childs[$i];
				              }
				     else if ($index == 1){
				          if ((`nodeType ($shape[0])` == "mesh") && (`match "aks_aim" $shape[0]`!= "aks_aim"))
					           $divideLightNode[`size ($divideLightNode)`] = $childs[$i];
			    }
               }
		   
	return $divideLightNode;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//returns the file texture path 
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc string[] aks_fileTextureInfo()
{
	string $path[];
	string $getLightGrp = `optionMenu -q -v optMenu1`;
    string $getSurface[] = aks_divideLightNode($getLightGrp, 1 );
    $path[0] = `getAttr ($getSurface[0] + "_color" + ".fileTextureName")`; 
	$path[1] = $getSurface[0]; 
	return $path;
	
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//enables controls in the Light Effects frameLayout, and connects attributes from one lightFog or 
//opticalFX node to all the other ones
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_connectFXNodes(string $nodeType, int $index)
{
   int $bingo;
   string $attribute;
   string $getLightGrp = `optionMenu -q -v optMenu1`;
   string $getLights[] = `listRelatives -c $getLightGrp`;
   
   //enables the controls and adds the first lightFog or opticalFX as a 
   //masternode to attrNControlGrp, is called everytime you open up the GUI
   for ($light in $getLights){
	   
	     string $lightShape[] = `listRelatives -s $light`;
		 string $connections[] = `listConnections -sh 1  $lightShape[0]`;
		 
		 
		 for ($con in $connections){
			 
			 if ($nodeType == "lightGlow"){
		  
		            if (`nodeType $con` == "opticalFX"){
						
				         $attribute = ($lightShape[0] + "." + $nodeType);
				         attrNavigationControlGrp -e -en 1 -at $attribute lightGlowCtrlGrp;
						 $bingo = on ;
			             break;
			        }
			     }
			else 
				 {
					
					 if (`nodeType $con` == "renderCone"){
						 
				         $attribute = ($lightShape[0] + "." + $nodeType);
				         attrNavigationControlGrp -e -en 1 -at $attribute lightFogCtrlGrp;
				         attrFieldSliderGrp -e -en 1 -at ($lightShape[0] + ".fogSpread") attrSlGrp10;
				         attrFieldSliderGrp -e -en 1 -at ($lightShape[0] + ".fogIntensity") attrSlGrp11;
						 $bingo = on;
			             break;
			           }
					}
		      }
		 if ($bingo == on)
			 break;
	   }
	 
    //is called if you hit the "Connect to..." button, 
	//connects all the attributes to one masternode
	if($index == 1){
		
	      if ($nodeType == "fogGeometry"){
			  
			  string $outputNode, $inputNode;
			  string $lShape[];
              $numTokens =`tokenize $attribute "." $lShape`;
			  
			  for ($light in $getLights){
					   
					string $lightShape[] = `listRelatives -s $light`;
		            string $connections[] = `listConnections -sh 1 $lightShape[0]`;
					   
					for ($con in $connections){
						
						 //gets lightFog outputNode trough the first iretation of the loop
						 if ((`nodeType $con` == "renderCone") && ($lightShape[0] == $lShape[0])){
							  
							   string $connectionsOut[] = `listConnections $con`;
	
	                           for ($node in $connectionsOut){
		
	                           if (`nodeType $node` == "shadingEngine"){
			   
			                         string $getFogNode[] = `listConnections $node`;
				
				                     for ($each in $getFogNode)
					                       if (`nodeType $each` == "lightFog")
					                       $outputNode = $each;
						            }
                                }
							 }
						   
						  if ((`nodeType $con` == "renderCone") && ($lightShape[0] != $lShape[0])){
								
							     //checks is the connection already made
								 string $connectInfo = `connectionInfo -sourceFromDestination ($lightShape[0] + ".fogSpread")`;
								 string $objectAttr = ($lShape[0] + ".fogSpread");
								 
								 //if there is no connection, do the job, otherwise, don`t do anything
								 if ($connectInfo != $objectAttr){
								
									    connectAttr -force ($lShape[0]  + ".fogSpread") ($lightShape[0] + ".fogSpread");
								        connectAttr -force ($lShape[0]  + ".fogIntensity") ($lightShape[0] + ".fogIntensity");
										
										
										 //gets lightFog inputNode
										 string $connections[] = `listConnections $con`;
	
	                                     for ($node in $connections){
		
	                                     if (`nodeType $node` == "shadingEngine"){
			   
			                                  string $getFogNode[] = `listConnections $node`;
				
				                              for ($each in $getFogNode)
					 
					                               if (`nodeType $each` == "lightFog")
					                                     $inputNode = $each;
						                               
			                                       }
                                               }
										  connectAttr -force ($outputNode + ".color") ($inputNode + ".color");
										  connectAttr -force ($outputNode + ".density") ($inputNode + ".density");
										  connectAttr -force ($outputNode + ".colorBasedTransparency") ($inputNode + ".colorBasedTransparency");
										  connectAttr -force ($outputNode + ".fastDropOff") ($inputNode + ".fastDropOff");
								          break;
			          }   }   }   }   } 
	     else
		     {
              string $fxInput, $fxOutput;
              string $lShape[];
              $numTokens =`tokenize $attribute "." $lShape`;
			  
			  for ($light in $getLights){
					 
					string $lightShape[] = `listRelatives -s $light`;
		            string $connections[] = `listConnections -sh 1 $lightShape[0]`;
						
				    for ($con in $connections){
						
						//gets opticalFX outputNode trough the first iretation of the loop
						if ((`nodeType $con` == "opticalFX") && ($lightShape[0] == $lShape[0]))
							    $fxOutput = $con;
							  
					    if ((`nodeType $con` == "opticalFX") && ($lightShape[0] != $lShape[0])){
							    
							    $fxInput = $con;
								
								//if there is no connection, do the job, otherwise, don`t do anything
								string $connectInfo = `connectionInfo -sourceFromDestination ($fxInput + ".active")`;
								string $objectAttr = ($fxOutput + ".active");
								 
								if ($connectInfo != $objectAttr){ 
									
							         connectAttr -force ($fxOutput + ".active") ($fxInput + ".active");
								     connectAttr -force ($fxOutput + ".lensFlare") ($fxInput + ".lensFlare");
								     connectAttr -force ($fxOutput + ".glowType") ($fxInput + ".glowType");
								     connectAttr -force ($fxOutput + ".haloType") ($fxInput + ".haloType");
								     connectAttr -force ($fxOutput + ".radialFrequency") ($fxInput + ".radialFrequency");
								     connectAttr -force ($fxOutput + ".starPoints") ($fxInput + ".starPoints");
								     connectAttr -force ($fxOutput + ".rotation") ($fxInput + ".rotation");
								     connectAttr -force ($fxOutput + ".ignoreLight") ($fxInput + ".ignoreLight");
								     connectAttr -force ($fxOutput + ".glowColor") ($fxInput + ".glowColor");
								     connectAttr -force ($fxOutput + ".glowIntensity") ($fxInput + ".glowIntensity");
								     connectAttr -force ($fxOutput + ".glowSpread") ($fxInput + ".glowSpread");
								     connectAttr -force ($fxOutput + ".glowNoise") ($fxInput + ".glowNoise");
								     connectAttr -force ($fxOutput + ".glowRadialNoise") ($fxInput + ".glowRadialNoise");
								     connectAttr -force ($fxOutput + ".glowStarLevel") ($fxInput + ".glowStarLevel");
								     connectAttr -force ($fxOutput + ".glowOpacity") ($fxInput + ".glowOpacity");
								     connectAttr -force ($fxOutput + ".haloColor") ($fxInput + ".haloColor");
								     connectAttr -force ($fxOutput + ".haloIntensity") ($fxInput + ".haloIntensity");
								     connectAttr -force ($fxOutput + ".haloSpread") ($fxInput + ".haloSpread");
								     connectAttr -force ($fxOutput + ".flareColor") ($fxInput + ".flareColor");
								     connectAttr -force ($fxOutput + ".flareIntensity") ($fxInput + ".flareIntensity");
								     connectAttr -force ($fxOutput + ".flareNumCircles") ($fxInput + ".flareNumCircles");
								     connectAttr -force ($fxOutput + ".flareMinSize") ($fxInput + ".flareMinSize");
								     connectAttr -force ($fxOutput + ".flareMaxSize") ($fxInput + ".flareMaxSize");
								     connectAttr -force ($fxOutput + ".hexagonFlare") ($fxInput + ".hexagonFlare");
								     connectAttr -force ($fxOutput + ".flareColSpread") ($fxInput + ".flareColSpread");
								     connectAttr -force ($fxOutput + ".flareFocus") ($fxInput + ".flareFocus");
								     connectAttr -force ($fxOutput + ".flareVertical") ($fxInput + ".flareVertical");
								     connectAttr -force ($fxOutput + ".flareHorizontal") ($fxInput + ".flareHorizontal");
								     connectAttr -force ($fxOutput + ".flareLength") ($fxInput + ".flareLength");
								     connectAttr -force ($fxOutput + ".noiseUscale") ($fxInput + ".noiseUscale");
								     connectAttr -force ($fxOutput + ".noiseVscale") ($fxInput + ".noiseVscale");
								     connectAttr -force ($fxOutput + ".noiseUoffset") ($fxInput + ".noiseUoffset");
								     connectAttr -force ($fxOutput + ".noiseVoffset") ($fxInput + ".noiseVoffset");
								     connectAttr -force ($fxOutput + ".noiseThreshold") ($fxInput + ".noiseThreshold");
								     break;
					}   }  }  }  }  }
		 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//creates the window for connecting the opticalFX and the lightFog node
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_lightFxUI(string $attribute)
{
	
	if (`window -ex aks_lightFxWin`)
		 deleteUI aks_lightFxWin;	
	
    window -title "Light FX " -mxb 0 -s 0 aks_lightFxWin;
	 
	columnLayout -adjustableColumn true  mainCol ;
    frameLayout-labelVisible false
			-h 230
			-cll false
			-mh 3
			-bs "etchedOut"
			-bv true
			-lw 120
		fxFrame;

    formLayout mainForm;

//START of formLayout content----------------------------------------------------------------
	text -l "Lights :" txt1; 
	
	string $selectCmd = ("aks_changeNavigationCtrlGrp " +  $attribute);
	textScrollList -h 150 -ams false -sc $selectCmd tslLights;
	attrNavigationControlGrp -l "Light Glow" 
					         -cw3 53 150 25
						     -cat 1 "left" 0
						     -cat 2 "both" 3
						     -cat 3 "right" 1 
							 lightGlowGrp;
	
	text -l " : Press the map button to made connection :" txt2;

//END of formLayout content----------------------------------------------------------------
	 
	formLayout -e
			
		-attachForm     txt1  "top"	   4
		-attachForm     txt1  "left"   4	
		
		-attachForm     tslLights  "top"	20
		-attachForm     tslLights  "left"	4
		-attachForm     tslLights  "right"  4
		
		-attachForm     lightGlowGrp  "top"	  180
		-attachForm     lightGlowGrp  "left"  6
		
		-attachForm     txt2  "top"	  205
		-attachForm     txt2  "left"  10
		mainForm;
	
	setParent mainCol;
	separator -style "none";
	columnLayout -cw 245 -cat "both" 3;
	
	button -l "Close" -c "deleteUI aks_lightFxWin" fxBtn1;
	
	window -e -wh 250 281 aks_lightFxWin;
	showWindow aks_lightFxWin;
	 
	 aks_populateTSL $attribute;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//populates the textScrollList in the window above
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_populateTSL(string $attribute)
{
	
	 string $selLights[] = `ls -sl`;
	 
	 //if nothing selected, append all lights to the textScrollList
	 if (`size $selLights` == 0 ){
		 
		  string $lightGrp = `optionMenu -q -v optMenu1`;
		  $selLights = `aks_divideLightNode $lightGrp 0`;
		  
		  for ($light in $selLights)
			       textScrollList -e -a $light tslLights;
			  
		 }
	  else{
		  //appends the selected Lights to the textScrollList
		  for ($light in $selLights){
			  
			   string $shape[] = `listRelatives -s $light`;
				
			   if ((`nodeType $shape[0]` == "spotLight") || (`nodeType $shape[0]` == "directionalLight"))
			        textScrollList -e -a $light tslLights;
			   else
			        error "Wrong selection, select at least 1 light !"; 
		      }
		  }
	      //first item in the list is the selected item
		  textScrollList -e -si $selLights[0] tslLights;
		  //connect attribute (lightFog or opticalfx) to the attrNavigationControlGrp
		  attrNavigationControlGrp -e -at ($selLights[0] + "." + $attribute) lightGlowGrp;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//is called when a new item in the textScrollList is selected
//connects the attribute (lightFog or opticalfx) to the attrNavigationControlGrp
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_changeNavigationCtrlGrp (string $attribute)
{
	string $selectItem[] = `textScrollList -q -si tslLights`;
	attrNavigationControlGrp -e -at ($selectItem[0] + "." + $attribute) lightGlowGrp;
	
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//adjusting UI 
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_adjustUI(string $operator)
{
     switch ($operator){
		 
       case "shadow" :
	              int $enable;
 
                  if (`radioButtonGrp -q -sl radioBtnGrp2` == "1")
			      $enable = 1;
			
	              attrColorSliderGrp -e -en $enable attrSlGrp5;
		          attrFieldSliderGrp -e -en $enable samplingGrp1;
		          attrFieldSliderGrp -e -en $enable attrSlGrp6;
		          checkBox -e -en $enable chBox1;
		          checkBox -e -en $enable chBox2;
	              attrFieldSliderGrp -e -en $enable attrSlGrp8;
		          attrFieldSliderGrp -e -en $enable attrSlGrp9;
		 
					 //if the shadow/off button is selected, turn off a the focus field
					 if (`radioButtonGrp -q -sl radioBtnGrp2` == "2")
					            rowColumnLayout -e -en false shadowColumn3;
				       
		             else{
						   //if the shadow/on button is selected, turn on or off a the focus field
						   //based on the auto focus attribute
						   if (`checkBox -q -v chBox2`)
						      
							    rowColumnLayout -e -en false shadowColumn3;
						     
						   else
						        rowColumnLayout -e -en true shadowColumn3;
					     }
			          break;
		
	   case "focus" :
		        
				  int $onOff = 1;
				  if (`checkBox -q -v chBox2`)
                      $onOff = 0;
        
		          if (`radioButtonGrp -q -sl radioBtnGrp2` == "1")
		                  rowColumnLayout -e -en $onOff shadowColumn3;
		            
				  break;
		
	 }
		
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//opens the help in yout webbrowser
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_lightRayHelp()
{
	//gets the scripts directory of your current maya version
    string $scriptDir = fromNativePath(`internalVar -userScriptDir`);
   
    //if the help dir exists, open it in your webbrowser,
	//otherwise you get an error
	if (`filetest -d ($scriptDir + "aks_lightRay/aks_lightRayHelp")`){
		
		   string $fullPath  =(" file:///" + $scriptDir + "aks_lightRay/aks_lightRayHelp/aks_lightRayHelp.htm");
		   system("load" + $fullPath);
		}
     else
	       error "Help file doesen`t exists, take a look in the installation notes !"; 
	
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//is called when the menuItem has changed, is calling the window with the settings 
//of the current lightGroup
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc aks_updateWin()
{
	string $lightGroup = `optionMenu -q -v optMenu1`;
	int $itemIndex = `optionMenu -q -sl optMenu1`;
	
	aks_lightRayUI ($lightGroup, $itemIndex);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//creates the control GUI, called when the item in the optionMenu has been changed
/////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc  aks_lightRayUI(string $lightGrp, int $menuIndex)
{
  
  string $lightTypeID[];
  int $colorFrameHeight;
  
  //gets all the lights in the group and extracts the first two 
  //characters, to identify, thats the lightgroup gets the color 
  //from a filetextur or a ramp
  string $getLightNames[] =`listRelatives $lightGrp`;
  
  $numTokens =`tokenize $getLightNames[0] "_" $lightTypeID`;
  
  //gets the shapeNode for the first light in the list, so 
  //the script can check is it a spotLight or not
  string $getlightShape[] =`listRelatives -s $getLightNames[0]`;
  string $nodeType = `nodeType $getlightShape[0]`;
 
//~~~~~~~~~~~~~~~~~~~~~~~~ Window creation starts here ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 
  if (`window -ex aks_lightRayWin`)
		 deleteUI aks_lightRayWin;	
 
  string $allLightGrp[] = `ls "aks_LightGrp*"`;
  window -title "Light Ray" -s false aks_lightRayWin;
  
   menuBarLayout;
       menu -l "Help";
           menuItem -l "Help" -c "aks_lightRayHelp";
             setParent -menu..;
  
   columnLayout -adjustableColumn true  mainCol ;
        columnLayout -cal "center" -cat "left" 140 ;
              separator -style "none" -h 10;
              
			  optionMenu -cc "aks_updateWin" optMenu1;
 		  		for ($group in $allLightGrp){
					
					if (`nodeType $group` == "transform")
                         menuItem -l $group;
				}
			  optionMenu -e -sl $menuIndex optMenu1;
			  separator -style "none" -h 10;
				   setParent mainCol;
	   
		columnLayout -adj true;				   
 				   
            scrollLayout  -horizontalScrollBarThickness  0  mainScroll;
             columnLayout -adj true mainFrame;	

///////// -----------------------------  Content of scrollLayout  ---------------------------  //////////// 


			 
//Start of Frame 1 //
			 
	//determins the height for the first frameLayout/colorFrame
    //based on the lighttype and texturtype
    if ($nodeType == "directionalLight")
		  
		   if ($lightTypeID[0] == "rc")
		      $colorFrameHeight = 165;
	       else
		      $colorFrameHeight = 225;
	else 
		  if ($lightTypeID[0] == "rc")
		      $colorFrameHeight = 260;
	      else
		      $colorFrameHeight = 320;
			 
	
   frameLayout -label "Color"
			    -lw 100
			    -cll 1
			    -cl 0
			    -bs "etchedOut"
			    -bv true
			    -h $colorFrameHeight
			    colorFrame;
	  
   columnLayout;
	   
	   //gets the surface of the lightgroup
	   string $getSurface[] = aks_divideLightNode($lightGrp, 1 );
	  

//------- content of frameLayout1 if the texturType is a ramp ---------------------------
       
		if ($lightTypeID[0] == "rc"){

           rowColumnLayout -nc 3
	                       -cw 1 50 
				           -cw 2 170
		                   -cat 1 "left" 0
	                       -cat 2 "left" 116;
		   
		       text -l "  Texture Sample";
		       swatchDisplayPort -wh 48 48 -rs 48 -sn ($getSurface[0] + "_color") ;
			   separator -style "none" -h 10;
			   separator -style "none" -h 10;
			  
			  
			  setParent..;
			  rowColumnLayout -nc 3
	                       -cw 1 50 
				           -cw 2 170
		                   -cat 1 "left" 0
	                       -cat 2 "left" 51;
     
	          text -l "                  Color";
              button -l "Edit Ramp" -w 115 -c "aks_editLightGRP openRamp 0 0 \"\" "  ;
		      button -l "Update Color" -w 115 -c "aks_editLightGRP editColor 0 0 \"\" " -h 25;
			}
	  

//------- content of frameLayout1 if the texturType is a fileTexture -------------------------		 
		
		else if ($lightTypeID[0] == "fc"){
		
		   string $path[] = `aks_fileTextureInfo`;
		  
		   rowColumnLayout -nc 3
	                       -cw 1 50 
				           -cw 2 170
		                   -cat 1 "left" 0
	                       -cat 2 "left" 120;
		   
		      text -l "  Texture Sample";
		      swatchDisplayPort -wh 48 48 -rs 48 -sn ($getSurface[0] + "_color") ;
			  
			  setParent..;
		      
			  columnLayout;
			  
			  separator -style "none" -h 10;
			  textFieldButtonGrp -label "        File Name"
	                             -fileName  $path[0]
	                             -buttonLabel "Browse" 
	                             -bc "aks_editLightGRP connectTexture 0 0 \"\" "
				                 -cw3 70 250 20
						         -cat 1 "left" 5
					             -cat 2 "both" 30
			                     -cat 3 "right" 1
	                             btnGrp1;
			  separator -st "none" -h 5;
			  
			                setParent..;
			  
			   rowColumnLayout -nc 3
	                       -cw 1 50 
				           -cw 2 170
		                   -cat 1 "left" 103
	                       -cat 2 "left" 150;
			   
			     button -l "Reload" -w 90 -c "aks_editLightGRP reloadTexture 0 0 \"\" "  ;
		         button -l "Edit" -w 90 -c "aks_editLightGRP openImageApp 0 0 \"\" " -h 25;
				 
				 
				 setParent..;
	                }
//---------- end of textur dependend content ----------------------------------------------- 


//---------- frameLayout1 content for both texturetypes (intensity a.s.o.) ------------------------------------

           columnLayout ;
			   separator -style "none" -h 10 ;
	     
		       attrFieldSliderGrp -l "            Intensity"
			                      -at ($lightGrp + ".intensity")
			                      -min 0 -max 20 
		                          -cw3 30 100 200 
	     		                  -cat 1 "left" 1
						          -cat 2 "right" 60
						          -cat 3 "right" 55 attrSlGrp1;
	    
		       separator -style "none" -h 5;
         
		       radioButtonGrp -l "        Specular" 
				              -sl 1 
							  -nrb 2 
			                  -labelArray2 "On" "Off"
					          -cc "aks_editLightGRP changeAttRbtnGrp emitSpecular radioBtnGrp1 \"\" "
			                  -cw3 50 100 200 
		   		              -cat 1 "left" 11 
						      -cat 2 "right" 10
					          -cat 3 "right" 80 radioBtnGrp1;
			   		   
//--------- if it a spotlightgroup, the spotlightShape attribute own stuff will be added
		  
			if (`nodeType ($getlightShape[0])` == "spotLight"){
						  
				     separator -h 5 -style "none";
						
					 int $decayRate = `getAttr ($getlightShape[0] + ".decayRate")`;
					 
					 optionMenu -l "          Dec. Rate      " 
							    -cc "aks_editLightGRP editMiscAttr setDecayRate 0 \"\" "  optMenu2;
 		  		                    menuItem -l "No Decay";
									menuItem -l "Linear";
								    menuItem -l "Quadratic";
								    menuItem -l "Cubic";
					 optionMenu -e -sl ($decayRate + 1) optMenu2;
									
					 attrFieldSliderGrp -l "       Cone Angle"
			                            -at ($lightGrp + ".coneAngle")
			                            -min 0.006 -max 180
		                                -cw3 30 100 200 
						                -cat 1 "left" 1
						                -cat 2 "right" 60
						                -cat 3 "right" 55 attrSlGrp2;
					 attrFieldSliderGrp -l "        Pen. Angle "
			                            -at ($lightGrp + ".penumbraAngle")
			                            -min -10 -max 10 
		                                -cw3 30 100 200 
						                -cat 1 "left" 1
						                -cat 2 "right" 60
						                -cat 3 "right" 55 attrSlGrp3;
					 attrFieldSliderGrp -l "              Dropoff"
			                            -at ($lightGrp + ".dropoff")
			                            -min 0 -max 255
		                                -cw3 30 100 200 
						                -cat 1 "left" 1
						                -cat 2 "right" 60
						                -cat 3 "right" 55 attrSlGrp4;
					 
					}
//------- content of frameLayout1, if the texturType is a fileTexture,---------------------
//------- for the purpose of the layoutdesign, have to be here ----------------------------						
			   
			  if ($lightTypeID[0] == "fc"){
					
			           columnLayout -cat "left" 102;
				    
				          separator -style "none" -h 8;
						  button -l "Update Color" -w 190 -c "aks_editLightGRP editColor 0 0 \"\" " -h 25;
						 
				           setParent..;
			   }
			  setParent mainFrame;

//End of Frame 1 //	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////									  
//Start of Frame 2 //
	 
	   string $expandCmd = "frameLayout -e -h 40 colorUpdateFrame";
			  
	  frameLayout -label "Update Color over Animation"
			      -lw 200
				  -ec $expandCmd
			      -cll 1
			      -cl 1
			      -bs "etchedOut"
			      -bv true
				  -w 385
		         colorUpdateFrame;
	  
	     columnLayout -h 100;
		 
		 string $currentGrp = `optionMenu -q -v optMenu1`;
		 
		 string $doJobsOn = ("aks_doScriptJobs 1 " + $lightGrp);
		 string $doJobsOff = ("aks_doScriptJobs 0 " + $lightGrp);
		 
		 int $rButtonNum;
		 
		 if (`objExists ( "scriptNode_" + $lightGrp)`)
			  $rButtonNum = 1;
		 else
			  $rButtonNum = 2;
		 
		 
		 radioButtonGrp -l " Update Color" -sl $rButtonNum -nrb 2 
			                  -labelArray2 "On" "Off"
					          -on1 $doJobsOn
							  -of1 $doJobsOff
			                  -cw3 50 100 200 
		   		              -cat 1 "left" 11 
						      -cat 2 "right" 10
					          -cat 3 "right" 80 radioBtnGrpCol;
	  
	  setParent mainFrame;
	  
//End of Frame 2 //	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////									  
//Start of Frame 3 //
	  
	  
	  frameLayout -label "Shadow"
			      -lw 100
			      -cll 1
			      -cl 0
			      -bs "etchedOut"
			      -bv true
			      -h 228
				  -w 385
		          shadowFrame;
	      
	   columnLayout;
	    columnLayout shadowColumn1;
		  
		separator -style "none" -h 5;
		
         
	    radioButtonGrp -l "         Shadow" 
						-nrb 2 
			            -labelArray2 "On" "Off"
						-cc "aks_editLightGRP changeAttRbtnGrp useDepthMapShadows radioBtnGrp2 \"\" ; aks_adjustUI shadow"
			            -cw3 50 100 200 
						-cat 1 "left" 11 
						-cat 2 "right" 10
						-cat 3 "right" 80 radioBtnGrp2; 
		
		separator -style "none" -h 10;
		
		
		
		float $shadowColor[3] = `getAttr ($lightGrp + ".shadowColor")`;
		attrColorSliderGrp -label "  Shadow Color" 
			               -at ($lightGrp + ".shadowColor")
			               -rgb $shadowColor[0] $shadowColor[1] $shadowColor[2]
						   -h 25
						   -cw4 93 74 99 10
					       -cat 1 "left" 8 
					       -cat 2 "both" 9
					       -cat 3 "left" 0
						   -cat 4 "left" 70 attrSlGrp5;
		
	    attrFieldSliderGrp -l "           Sampling" 
			         -at ($lightGrp + ".sampling")
			         -cc "aks_editLightGRP editSampling 0 0 \"\" "
				     -min 1
				     -max 20
				     -h 23
					 -cw3 30 100 200 
					 -cat 1 "left" 1
				     -cat 2 "right" 60
					 -cat 3 "right" 53 samplingGrp1;
		
		 attrFieldSliderGrp -l "         Resolution"
			                -at ($lightGrp + ".dmapResolution")
			                -min 16 -max 4048
		                    -cw3 30 100 200 
						    -cat 1 "left" 1
						    -cat 2 "right" 60
						    -cat 3 "right" 53 attrSlGrp6;
		 
		 setParent..;
		 
		columnLayout -cw 150 -cat "left" 101 shadowColumn2;
		
	    //getting attribute values for the checkboxes
		int $val1 = `getAttr ($getlightShape[0] + ".useMidDistDmap")`;
		int $val2 = `getAttr ($getlightShape[0] + ".useDmapAutoFocus")`;
		
		checkBox -label "Use Mid Dist"  -v $val1 -align "left" -cc "aks_editLightGRP editMiscAttr useMidDistDmap 0  \"\" " chBox1;
		checkBox -label "Use Auto Focus" -v $val2 -align "left" -cc "aks_editLightGRP editMiscAttr useDmapAutoFocus 0 \"\"; aks_adjustUI focus " chBox2;
		setParent..;
		
		
		int $boxOn = 1;
		if (`checkBox -q -v chBox2`)
				 $boxOn = 0;
			
		 //this column contains different controls based on the lighttype
	      rowColumnLayout -nc 2
		                  -cw 1 50 
					      -cw 2 170
		                  -cat 1 "left" 0
	                      -cat 2 "left" 51 shadowColumn3;
		            
				 if ($nodeType == "directionalLight"){
 	           
			              text -l "       Width Focus" -en false txt1;
		                  int $val3 = `getAttr ($getlightShape[0] + ".dmapWidthFocus")`;
			              floatField -v $val3 -cc "aks_editLightGRP editMiscAttr dmapWidthFocus 0 \"\" " -en false focusField;
			              setParent..;
		               }
		         else if ($nodeType == "spotLight"){
			
			              attrFieldSliderGrp -l "                Focus"
			                                  -at ($lightGrp + ".dmapFocus")
									          -en false
			                                  -min 16 -max 4048
		                                      -cw3 30 100 200 
						                      -cat 1 "left" 1
						                      -cat 2 "right" 60
						                      -cat 3 "right" 53 attrSlGrp7;
				           setParent..;
			
		                } 
			   //have to be a extra line, otherwise it doesen`t work
			   rowColumnLayout -e -en $boxOn shadowColumn3;
			  
				   
		  columnLayout shadowColumn4;
			       attrFieldSliderGrp -l "           Filter Size"
			                          -at ($lightGrp + ".dmapFilterSize")
			                          -min 0 -max 30
		                              -cw3 30 100 200 
						              -cat 1 "left" 1
						              -cat 2 "right" 60
						              -cat 3 "right" 53 attrSlGrp8;
				   
				   attrFieldSliderGrp -l "                   Bias"
			                          -at ($lightGrp + ".dmapBias")
			                          -min 0 -max 1
		                              -cw3 30 100 200 
						              -cat 1 "left" 1
						              -cat 2 "right" 60
						              -cat 3 "right" 53 attrSlGrp9;
				   setParent..;
	         setParent mainFrame;
						   
//End of Frame 3 //	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////	
//Start Frame 4
			 
           if (`nodeType ($getlightShape[0])` == "spotLight"){
			 
			     string $expandHeightCmd = "frameLayout -e -h 225 lightEffectsFrame";
			   
                 frameLayout -label "Light Effects"
			                 -lw 100
							 -ec $expandHeightCmd 
			                 -cll 1
			                 -cl 1
			                 -bs "etchedOut"
			                 -bv true
				             -w 385
		                     lightEffectsFrame;
				 
				 columnLayout lightMain;
				 columnLayout -cw 400;
		              attrNavigationControlGrp -l " Light Fog" 
						                       -en false
					                           -at ($getLightNames[0] + ".fogGeometry")
					                           -cw3 86 250 25
						                       -cat 1 "left" 35
						                       -cat 2 "both" 13
						                       -cat 3 "right" 1 lightFogCtrlGrp;
				 
				       attrFieldSliderGrp -l "      Fog Spread"
			                              -en false
			                              -min 0.006 -max 180
										  -hmb 0
		                                  -h 22
						                  -cw4 93 74 99 10
					                      -cat 1 "left" 8 
					                      -cat 2 "both" 6
					                      -cat 3 "left" 0
						                  -cat 4 "left" 71 attrSlGrp10;
				
				        attrFieldSliderGrp -l "     Fog Intensity"
			                               -en false
			                               -min 0.006 -max 180
										   -hmb 0
		                                    -h 27
						                    -cw4 93 74 99 10
					                        -cat 1 "left" 8 
					                        -cat 2 "both" 6
					                        -cat 3 "left" 0
						                    -cat 4 "left" 71 attrSlGrp11;
				        setParent lightMain;
					  
			     rowColumnLayout  -cat 1 "left" 100;
				 
				        button -l "Create Light Fog Nodes" -w 225 -c "aks_lightFxUI fogGeometry" ;
						button -l "Connect all to 1 Light Fog Node" -w 225 -c "aks_connectFXNodes \"fogGeometry\" 1";
				         setParent lightMain;
				  
				 columnLayout;
		   
				        separator -style "none" -h 4;
                        separator -w 400;
				        separator -style "none" -h 4;
				 
				        attrNavigationControlGrp -l "Light Glow" 
                                                 -en false
					                             -cw3 86 250 25
						                         -cat 1 "left" 35
						                         -cat 2 "both" 13
						                         -cat 3 "right" 1 lightGlowCtrlGrp;
				 
				        separator -style "none" -h 4;
				         setParent lightMain;
				  
				  columnLayout -cat "left" 100;
				 
				        button -l "Create Light Glow Nodes" -w 225 -c "aks_lightFxUI lightGlow"  ;
						button -l "Connect all to 1 Light Glow Node" -w 225 -c "aks_connectFXNodes \"lightGlow\" 1" ;
 
      }
	  setParent mainFrame;
			 
//End of Frame 4 //	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////	
//Start Frame 5	

	   string $lightEffectsFrameCmd = "frameLayout -e -h 210 newGroupFrame";
			   
       frameLayout -label "Create New Lightgroup"
		           -mh 6
			       -lw 130
				   -ec $lightEffectsFrameCmd
			       -cll 1
			       -cl 1
			       -bs "etchedOut"
			       -bv true
				   -w 385
		           newGroupFrame;
				 
	   
	    formLayout lighterForm;
//START of formLayout content----------------------------------------------------------------
	 
	    radioCollection;
		   radioButton -l "Directional Light" -sl rBtn1;
		   radioButton -l "Spot Light"  rBtn2;
	 
	    separator sep1;
   
        attrFieldSliderGrp  -en false 
			                -label "          SubD Axis" 
							-min 0 
							-max 10 
							-pre 0
							-cw3 30 100 200 
						    -cat 1 "left" 1
						    -cat 2 "right" 60
						    -cat 3 "right" 53 attrSli1;
         
		attrFieldSliderGrp -en false 
			               -label "      SubD Height" 
						   -min 0 -max 10 
						   -pre 0 
						   -cc "aks_adjustSlider"
						   -cw3 30 100 200 
						   -cat 1 "left" 1
						   -cat 2 "right" 60
						   -cat 3 "right" 53 attrSli2 ;
		
		text -l "Select Verts" -en false txt1;
 
        intSliderGrp -en false 
			         -field true 
					 -min -29 
					 -max 29 
					 -value 0 
					 -step 1 
					 -cc "aks_selectVerts" 
					 -dc "aks_selectVerts" 
					 -cw2 69 186
					 -cat 1 "both" 4
				     -cat 2 "left" 4
                     horSli1;
		
		separator sep2;
		
		radioCollection coll1;
		   radioButton -l "2D Ramp" -sl -w 80 rBtn3;
		   radioButton -l "2D Image File" rBtn4;
		   
		button -l "Create Sphere" -c "aks_createSphere 1" -w 150 -h 25 btn1;
		button -l "Setup Lights" -c "aks_setupLights" -w 150 -h 25 btn2;
		
//END of formLayout content----------------------------------------------------------------
		
		formLayout -e
			
		-attachForm     rBtn1  "top"	0
		-attachForm     rBtn1  "left"	98
		-attachNone     rBtn1  "right"	
		
		-attachForm     rBtn2  "top"	0
		-attachForm     rBtn2  "left"	226
		-attachNone     rBtn2  "right"
		
		-attachForm     sep1  "top"	   22
		-attachForm     sep1 "left"	    4
		-attachForm     sep1  "right"	4
			
		-attachForm      attrSli1  "top"	35
		-attachForm      attrSli1  "left"	0
		-attachNone      attrSli1  "right" 
		
		-attachForm		 attrSli2  "top"   57
		-attachForm      attrSli2  "left"	0
		-attachNone      attrSli2  "right"
	
		-attachForm      txt1   "top"	81
		-attachForm      txt1   "left"  26
		
		-attachForm      horSli1   "top"	79
		-attachForm      horSli1   "right"  52

		-attachForm     sep2  "top"	  110
		-attachForm     sep2 "left"	    4
		-attachForm     sep2  "right"	4
		
	    -attachForm     rBtn3  "top"	122
		-attachForm     rBtn3 "left"	98
		-attachNone     rBtn3  "right"	
		
		-attachForm     rBtn4  "top"	122
		-attachForm     rBtn4 "left"	226
		-attachNone     rBtn4  "right"	
		
		-attachForm     btn1  "top"	   150
		-attachForm     btn1  "left"	45
		-attachNone     btn1  "right"	
		
		-attachForm     btn2  "top"	   150
		-attachForm     btn2  "left"   200
		-attachNone     btn2  "right"	
		lighterForm;
		
		setParent mainFrame;

//End of Frame 5 //	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////	

	    //checks that the shadows and emit specular are on or not, if not, turns the shadow frame off
		//have to be here, so that the slider in the shadowFrame exists
        if(`getAttr ($getlightShape[0] + ".emitSpecular")` == 1)
			 radioButtonGrp -e -sl 1 radioBtnGrp1;
		else
			radioButtonGrp -e -sl 2 radioBtnGrp1;
			
		if(`getAttr ($getlightShape[0] + ".useDepthMapShadows")` == 1)
			 radioButtonGrp -e -sl 1 radioBtnGrp2;
		else{
			radioButtonGrp -e -sl 2 radioBtnGrp2;
			aks_adjustUI shadow;
		}
		
		

//--------   back to the mainCol, and creates the buttons outside of the scrollLayout   -----------------------	

	setParent mainCol;
	
    separator -style "none";
                   
	rowColumnLayout -nc 4
		            -cw 1 102
					-cw 2 103
					-cw 3 103
					-cw 4 102
					-cat 1 "both" 1
	                -cat 2 "both" 1
					-cat 3 "both" 1
					-cat 4 "both" 1;
	    
		button -l "Copy" -h 28 -c "aks_duplicateLightGroup" ;
        button -l "Delete"  -h 28 -c "aks_deleteLightGroup";	
		button -l "Refresh" -h 28 -c "aks_editLightGRP refreshUI 0 0 \"\" " ;
	    button -l "Close"  -h 28 -c "deleteUI aks_lightRayWin";	
		
		
	// this is wonderful -- Thanks to Chris Kniffen for the help --	
	scrollLayout -e -rc "scrollLayout -e -w 200 -h 400 mainScroll" mainScroll;
	window -e -wh 416 520 aks_lightRayWin;
	aks_connectFXNodes "fogGeometry" 0;
	aks_connectFXNodes "lightGlow" 0;
	showWindow aks_lightRayWin;
}

